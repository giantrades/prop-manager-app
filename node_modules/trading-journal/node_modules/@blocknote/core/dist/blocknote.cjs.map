{"version":3,"file":"blocknote.cjs","sources":["../src/schema/inlineContent/createSpec.ts","../src/api/blockManipulation/commands/insertBlocks/insertBlocks.ts","../src/api/blockManipulation/commands/replaceBlocks/replaceBlocks.ts","../src/api/exporters/html/util/serializeBlocksExternalHTML.ts","../src/api/exporters/html/externalHTMLExporter.ts","../src/api/exporters/html/util/serializeBlocksInternalHTML.ts","../src/api/exporters/html/internalHTMLSerializer.ts","../src/api/getBlocksChangedByTransaction.ts","../src/api/clipboard/fromClipboard/acceptedMIMETypes.ts","../src/api/clipboard/fromClipboard/handleFileInsertion.ts","../src/api/clipboard/fromClipboard/fileDropExtension.ts","../src/api/parsers/markdown/detectMarkdown.ts","../src/api/clipboard/fromClipboard/handleVSCodePaste.ts","../src/api/clipboard/fromClipboard/pasteExtension.ts","../src/api/exporters/markdown/util/removeUnderlinesRehypePlugin.ts","../src/api/exporters/markdown/util/addSpacesToCheckboxesRehypePlugin.ts","../src/api/exporters/markdown/util/convertVideoToMarkdownRehypePlugin.ts","../src/api/exporters/markdown/markdownExporter.ts","../src/api/nodeConversions/fragmentToBlocks.ts","../src/api/clipboard/toClipboard/copyExtension.ts","../src/extensions/BackgroundColor/BackgroundColorExtension.ts","../src/extensions/BlockChange/BlockChangePlugin.ts","../src/extensions/Collaboration/CursorPlugin.ts","../src/extensions/Collaboration/SyncPlugin.ts","../src/extensions/Collaboration/UndoPlugin.ts","../src/extensions/Collaboration/ForkYDocPlugin.ts","../src/extensions/Collaboration/schemaMigration/migrationRules/moveColorAttributes.ts","../src/extensions/Collaboration/schemaMigration/migrationRules/index.ts","../src/extensions/Collaboration/schemaMigration/SchemaMigrationPlugin.ts","../src/extensions/Comments/CommentMark.ts","../src/extensions/Comments/userstore/UserStore.ts","../src/extensions/Comments/CommentsPlugin.ts","../src/extensions/FilePanel/FilePanelPlugin.ts","../src/extensions/FormattingToolbar/FormattingToolbarPlugin.ts","../src/extensions/HardBreak/HardBreak.ts","../src/api/blockManipulation/commands/mergeBlocks/mergeBlocks.ts","../src/api/blockManipulation/commands/nestBlock/nestBlock.ts","../src/extensions/KeyboardShortcuts/KeyboardShortcutsExtension.ts","../src/extensions/LinkToolbar/LinkToolbarPlugin.ts","../src/extensions/LinkToolbar/protocols.ts","../src/extensions/NodeSelectionKeyboard/NodeSelectionKeyboardPlugin.ts","../src/extensions/Placeholder/PlaceholderPlugin.ts","../src/extensions/PreviousBlockType/PreviousBlockTypePlugin.ts","../src/extensions/ShowSelection/ShowSelectionPlugin.ts","../src/extensions/getDraggableBlockFromElement.ts","../src/extensions/SideMenu/MultipleNodeSelection.ts","../src/extensions/SideMenu/dragging.ts","../src/extensions/SideMenu/SideMenuPlugin.ts","../src/api/positionMapping.ts","../src/extensions/SuggestionMenu/SuggestionPlugin.ts","../src/extensions/Suggestions/SuggestionMarks.ts","../src/extensions/TableHandles/TableHandlesPlugin.ts","../src/extensions/TextAlignment/TextAlignmentExtension.ts","../src/extensions/TextColor/TextColorExtension.ts","../src/extensions/TrailingNode/TrailingNodeExtension.ts","../src/pm-nodes/BlockContainer.ts","../src/pm-nodes/BlockGroup.ts","../src/pm-nodes/Doc.ts","../src/editor/BlockNoteExtensions.ts","../src/api/blockManipulation/commands/moveBlocks/moveBlocks.ts","../src/api/blockManipulation/getBlock/getBlock.ts","../src/editor/managers/BlockManager.ts","../src/editor/managers/CollaborationManager.ts","../src/editor/managers/EventManager.ts","../src/api/parsers/html/util/nestedLists.ts","../src/api/parsers/html/parseHTML.ts","../src/api/parsers/markdown/parseMarkdown.ts","../src/editor/managers/ExportManager.ts","../src/editor/managers/ExtensionManager.ts","../src/api/blockManipulation/selections/selection.ts","../src/api/blockManipulation/selections/textCursorPosition.ts","../src/editor/managers/SelectionManager.ts","../src/editor/managers/StateManager.ts","../src/api/blockManipulation/insertContentAt.ts","../src/editor/managers/StyleManager.ts","../src/editor/transformPasted.ts","../src/editor/BlockNoteEditor.ts","../src/exporter/Exporter.ts","../src/exporter/mapping.ts","../src/extensions/SuggestionMenu/getDefaultEmojiPickerItems.ts","../src/util/combineByGroup.ts"],"sourcesContent":["import { Node } from \"@tiptap/core\";\n\nimport { TagParseRule } from \"@tiptap/pm/model\";\nimport { inlineContentToNodes } from \"../../api/nodeConversions/blockToNode.js\";\nimport { nodeToCustomInlineContent } from \"../../api/nodeConversions/nodeToBlock.js\";\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport { propsToAttributes } from \"../blocks/internal.js\";\nimport { Props } from \"../propTypes.js\";\nimport { StyleSchema } from \"../styles/types.js\";\nimport {\n  addInlineContentAttributes,\n  addInlineContentKeyboardShortcuts,\n  createInlineContentSpecFromTipTapNode,\n} from \"./internal.js\";\nimport {\n  CustomInlineContentConfig,\n  InlineContentFromConfig,\n  InlineContentSpec,\n  PartialCustomInlineContentFromConfig,\n} from \"./types.js\";\n\nexport type CustomInlineContentImplementation<\n  T extends CustomInlineContentConfig,\n  S extends StyleSchema,\n> = {\n  meta?: {\n    draggable?: boolean;\n  };\n\n  /**\n   * Parses an external HTML element into a inline content of this type when it returns the block props object, otherwise undefined\n   */\n  parse?: (el: HTMLElement) => Partial<Props<T[\"propSchema\"]>> | undefined;\n\n  /**\n   * Renders an inline content to DOM elements\n   */\n  render: (\n    /**\n     * The custom inline content to render\n     */\n    inlineContent: InlineContentFromConfig<T, S>,\n    /**\n     * A callback that allows overriding the inline content element\n     */\n    updateInlineContent: (\n      update: PartialCustomInlineContentFromConfig<T, S>,\n    ) => void,\n    /**\n     * The BlockNote editor instance\n     * This is typed generically. If you want an editor with your custom schema, you need to\n     * cast it manually, e.g.: `const e = editor as BlockNoteEditor<typeof mySchema>;`\n     */\n    editor: BlockNoteEditor<any, any, S>,\n    // (note) if we want to fix the manual cast, we need to prevent circular references and separate block definition and render implementations\n    // or allow manually passing <BSchema>, but that's not possible without passing the other generics because Typescript doesn't support partial inferred generics\n  ) => {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n    destroy?: () => void;\n  };\n\n  /**\n   * Renders an inline content to external HTML elements for use outside the editor\n   * If not provided, falls back to the render method\n   */\n  toExternalHTML?: (\n    /**\n     * The custom inline content to render\n     */\n    inlineContent: InlineContentFromConfig<T, S>,\n    /**\n     * The BlockNote editor instance\n     * This is typed generically. If you want an editor with your custom schema, you need to\n     * cast it manually, e.g.: `const e = editor as BlockNoteEditor<typeof mySchema>;`\n     */\n    editor: BlockNoteEditor<any, any, S>,\n  ) =>\n    | {\n        dom: HTMLElement | DocumentFragment;\n        contentDOM?: HTMLElement;\n      }\n    | undefined;\n};\n\nexport function getInlineContentParseRules<C extends CustomInlineContentConfig>(\n  config: C,\n  customParseFunction?: CustomInlineContentImplementation<C, any>[\"parse\"],\n) {\n  const rules: TagParseRule[] = [\n    {\n      tag: `[data-inline-content-type=\"${config.type}\"]`,\n      contentElement: (element) => {\n        const htmlElement = element as HTMLElement;\n\n        if (htmlElement.matches(\"[data-editable]\")) {\n          return htmlElement;\n        }\n\n        return htmlElement.querySelector(\"[data-editable]\") || htmlElement;\n      },\n    },\n  ];\n\n  if (customParseFunction) {\n    rules.push({\n      tag: \"*\",\n      getAttrs(node: string | HTMLElement) {\n        if (typeof node === \"string\") {\n          return false;\n        }\n\n        const props = customParseFunction?.(node);\n\n        if (props === undefined) {\n          return false;\n        }\n\n        return props;\n      },\n    });\n  }\n  return rules;\n}\n\nexport function createInlineContentSpec<\n  T extends CustomInlineContentConfig,\n  S extends StyleSchema,\n>(\n  inlineContentConfig: T,\n  inlineContentImplementation: CustomInlineContentImplementation<T, S>,\n): InlineContentSpec<T> {\n  const node = Node.create({\n    name: inlineContentConfig.type,\n    inline: true,\n    group: \"inline\",\n    draggable: inlineContentImplementation.meta?.draggable,\n    selectable: inlineContentConfig.content === \"styled\",\n    atom: inlineContentConfig.content === \"none\",\n    content: inlineContentConfig.content === \"styled\" ? \"inline*\" : \"\",\n\n    addAttributes() {\n      return propsToAttributes(inlineContentConfig.propSchema);\n    },\n\n    addKeyboardShortcuts() {\n      return addInlineContentKeyboardShortcuts(inlineContentConfig);\n    },\n\n    parseHTML() {\n      return getInlineContentParseRules(\n        inlineContentConfig,\n        inlineContentImplementation.parse,\n      );\n    },\n\n    renderHTML({ node }) {\n      const editor = this.options.editor;\n\n      const output = inlineContentImplementation.render.call(\n        { renderType: \"dom\", props: undefined },\n        nodeToCustomInlineContent(\n          node,\n          editor.schema.inlineContentSchema,\n          editor.schema.styleSchema,\n        ) as any as InlineContentFromConfig<T, S>, // TODO: fix cast\n        () => {\n          // No-op\n        },\n        editor,\n      );\n\n      return addInlineContentAttributes(\n        output,\n        inlineContentConfig.type,\n        node.attrs as Props<T[\"propSchema\"]>,\n        inlineContentConfig.propSchema,\n      );\n    },\n\n    addNodeView() {\n      return (props) => {\n        const { node, getPos } = props;\n        const editor = this.options.editor as BlockNoteEditor<any, any, S>;\n\n        const output = inlineContentImplementation.render.call(\n          { renderType: \"nodeView\", props },\n          nodeToCustomInlineContent(\n            node,\n            editor.schema.inlineContentSchema,\n            editor.schema.styleSchema,\n          ) as any as InlineContentFromConfig<T, S>, // TODO: fix cast\n          (update) => {\n            const content = inlineContentToNodes([update], editor.pmSchema);\n\n            const pos = getPos();\n\n            if (!pos) {\n              return;\n            }\n\n            editor.transact((tr) =>\n              tr.replaceWith(pos, pos + node.nodeSize, content),\n            );\n          },\n          editor,\n        );\n\n        return addInlineContentAttributes(\n          output,\n          inlineContentConfig.type,\n          node.attrs as Props<T[\"propSchema\"]>,\n          inlineContentConfig.propSchema,\n        );\n      };\n    },\n  });\n\n  return createInlineContentSpecFromTipTapNode(\n    node,\n    inlineContentConfig.propSchema,\n    {\n      toExternalHTML: inlineContentImplementation.toExternalHTML,\n      render(inlineContent, updateInlineContent, editor) {\n        const output = inlineContentImplementation.render(\n          inlineContent,\n          updateInlineContent,\n          editor,\n        );\n\n        return addInlineContentAttributes(\n          output,\n          inlineContentConfig.type,\n          inlineContent.props,\n          inlineContentConfig.propSchema,\n        );\n      },\n    },\n  ) as InlineContentSpec<T>;\n}\n","import { Fragment, Slice } from \"prosemirror-model\";\nimport type { Transaction } from \"prosemirror-state\";\nimport { ReplaceStep } from \"prosemirror-transform\";\nimport { Block, PartialBlock } from \"../../../../blocks/defaultBlocks.js\";\nimport {\n  BlockIdentifier,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../../schema/index.js\";\nimport { blockToNode } from \"../../../nodeConversions/blockToNode.js\";\nimport { nodeToBlock } from \"../../../nodeConversions/nodeToBlock.js\";\nimport { getNodeById } from \"../../../nodeUtil.js\";\nimport { getPmSchema } from \"../../../pmUtil.js\";\n\nexport function insertBlocks<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  tr: Transaction,\n  blocksToInsert: PartialBlock<BSchema, I, S>[],\n  referenceBlock: BlockIdentifier,\n  placement: \"before\" | \"after\" = \"before\",\n): Block<BSchema, I, S>[] {\n  const id =\n    typeof referenceBlock === \"string\" ? referenceBlock : referenceBlock.id;\n  const pmSchema = getPmSchema(tr);\n  const nodesToInsert = blocksToInsert.map((block) =>\n    blockToNode(block, pmSchema),\n  );\n\n  const posInfo = getNodeById(id, tr.doc);\n  if (!posInfo) {\n    throw new Error(`Block with ID ${id} not found`);\n  }\n\n  let pos = posInfo.posBeforeNode;\n  if (placement === \"after\") {\n    pos += posInfo.node.nodeSize;\n  }\n\n  tr.step(\n    new ReplaceStep(pos, pos, new Slice(Fragment.from(nodesToInsert), 0, 0)),\n  );\n\n  // Now that the `PartialBlock`s have been converted to nodes, we can\n  // re-convert them into full `Block`s.\n  const insertedBlocks = nodesToInsert.map((node) =>\n    nodeToBlock(node, pmSchema),\n  ) as Block<BSchema, I, S>[];\n\n  return insertedBlocks;\n}\n","import type { Node } from \"prosemirror-model\";\nimport type { Transaction } from \"prosemirror-state\";\nimport type { Block, PartialBlock } from \"../../../../blocks/defaultBlocks.js\";\nimport type {\n  BlockIdentifier,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../../schema/index.js\";\nimport { blockToNode } from \"../../../nodeConversions/blockToNode.js\";\nimport { nodeToBlock } from \"../../../nodeConversions/nodeToBlock.js\";\nimport { getPmSchema } from \"../../../pmUtil.js\";\n\nexport function removeAndInsertBlocks<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  tr: Transaction,\n  blocksToRemove: BlockIdentifier[],\n  blocksToInsert: PartialBlock<BSchema, I, S>[],\n): {\n  insertedBlocks: Block<BSchema, I, S>[];\n  removedBlocks: Block<BSchema, I, S>[];\n} {\n  const pmSchema = getPmSchema(tr);\n  // Converts the `PartialBlock`s to ProseMirror nodes to insert them into the\n  // document.\n  const nodesToInsert: Node[] = blocksToInsert.map((block) =>\n    blockToNode(block, pmSchema),\n  );\n\n  const idsOfBlocksToRemove = new Set<string>(\n    blocksToRemove.map((block) =>\n      typeof block === \"string\" ? block : block.id,\n    ),\n  );\n  const removedBlocks: Block<BSchema, I, S>[] = [];\n\n  const idOfFirstBlock =\n    typeof blocksToRemove[0] === \"string\"\n      ? blocksToRemove[0]\n      : blocksToRemove[0].id;\n  let removedSize = 0;\n\n  tr.doc.descendants((node, pos) => {\n    // Skips traversing nodes after all target blocks have been removed.\n    if (idsOfBlocksToRemove.size === 0) {\n      return false;\n    }\n\n    // Keeps traversing nodes if block with target ID has not been found.\n    if (\n      !node.type.isInGroup(\"bnBlock\") ||\n      !idsOfBlocksToRemove.has(node.attrs.id)\n    ) {\n      return true;\n    }\n\n    // Saves the block that is being deleted.\n    removedBlocks.push(nodeToBlock(node, pmSchema));\n    idsOfBlocksToRemove.delete(node.attrs.id);\n\n    if (blocksToInsert.length > 0 && node.attrs.id === idOfFirstBlock) {\n      const oldDocSize = tr.doc.nodeSize;\n      tr.insert(pos, nodesToInsert);\n      const newDocSize = tr.doc.nodeSize;\n\n      removedSize += oldDocSize - newDocSize;\n    }\n\n    const oldDocSize = tr.doc.nodeSize;\n    // Checks if the block is the only child of its parent. In this case, we\n    // need to delete the parent `blockGroup` node instead of just the\n    // `blockContainer`.\n    const $pos = tr.doc.resolve(pos - removedSize);\n    if (\n      $pos.node().type.name === \"blockGroup\" &&\n      $pos.node($pos.depth - 1).type.name !== \"doc\" &&\n      $pos.node().childCount === 1\n    ) {\n      tr.delete($pos.before(), $pos.after());\n    } else {\n      tr.delete(pos - removedSize, pos - removedSize + node.nodeSize);\n    }\n    const newDocSize = tr.doc.nodeSize;\n    removedSize += oldDocSize - newDocSize;\n\n    return false;\n  });\n\n  // Throws an error if now all blocks could be found.\n  if (idsOfBlocksToRemove.size > 0) {\n    const notFoundIds = [...idsOfBlocksToRemove].join(\"\\n\");\n\n    throw Error(\n      \"Blocks with the following IDs could not be found in the editor: \" +\n        notFoundIds,\n    );\n  }\n\n  // Converts the nodes created from `blocksToInsert` into full `Block`s.\n  const insertedBlocks = nodesToInsert.map((node) =>\n    nodeToBlock(node, pmSchema),\n  ) as Block<BSchema, I, S>[];\n\n  return { insertedBlocks, removedBlocks };\n}\n","import { DOMSerializer, Fragment, Node } from \"prosemirror-model\";\n\nimport { PartialBlock } from \"../../../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../../../editor/BlockNoteEditor.js\";\nimport {\n  BlockImplementation,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../../schema/index.js\";\nimport { UnreachableCaseError } from \"../../../../util/typescript.js\";\nimport {\n  inlineContentToNodes,\n  tableContentToNodes,\n} from \"../../../nodeConversions/blockToNode.js\";\nimport { nodeToCustomInlineContent } from \"../../../nodeConversions/nodeToBlock.js\";\n\nfunction addAttributesAndRemoveClasses(element: HTMLElement) {\n  // Removes all BlockNote specific class names.\n  const className =\n    Array.from(element.classList).filter(\n      (className) => !className.startsWith(\"bn-\"),\n    ) || [];\n\n  if (className.length > 0) {\n    element.className = className.join(\" \");\n  } else {\n    element.removeAttribute(\"class\");\n  }\n}\n\nexport function serializeInlineContentExternalHTML<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<any, I, S>,\n  blockContent: PartialBlock<BSchema, I, S>[\"content\"],\n  serializer: DOMSerializer,\n  options?: { document?: Document },\n) {\n  let nodes: Node[];\n\n  // TODO: reuse function from nodeconversions?\n  if (!blockContent) {\n    throw new Error(\"blockContent is required\");\n  } else if (typeof blockContent === \"string\") {\n    nodes = inlineContentToNodes([blockContent], editor.pmSchema);\n  } else if (Array.isArray(blockContent)) {\n    nodes = inlineContentToNodes(blockContent, editor.pmSchema);\n  } else if (blockContent.type === \"tableContent\") {\n    nodes = tableContentToNodes(blockContent, editor.pmSchema);\n  } else {\n    throw new UnreachableCaseError(blockContent.type);\n  }\n\n  // Check if any of the nodes are custom inline content with toExternalHTML\n  const doc = options?.document ?? document;\n  const fragment = doc.createDocumentFragment();\n\n  for (const node of nodes) {\n    // Check if this is a custom inline content node with toExternalHTML\n    if (\n      node.type.name !== \"text\" &&\n      editor.schema.inlineContentSchema[node.type.name]\n    ) {\n      const inlineContentImplementation =\n        editor.schema.inlineContentSpecs[node.type.name].implementation;\n\n      if (inlineContentImplementation) {\n        // Convert the node to inline content format\n        const inlineContent = nodeToCustomInlineContent(\n          node,\n          editor.schema.inlineContentSchema,\n          editor.schema.styleSchema,\n        );\n\n        // Use the custom toExternalHTML method or fallback to `render`\n        const output = inlineContentImplementation.toExternalHTML\n          ? inlineContentImplementation.toExternalHTML(\n              inlineContent as any,\n              editor as any,\n            )\n          : inlineContentImplementation.render.call(\n              {\n                renderType: \"dom\",\n                props: undefined,\n              },\n              inlineContent as any,\n              () => {\n                // No-op\n              },\n              editor as any,\n            );\n\n        if (output) {\n          fragment.appendChild(output.dom);\n\n          // If contentDOM exists, render the inline content into it\n          if (output.contentDOM) {\n            const contentFragment = serializer.serializeFragment(\n              node.content,\n              options,\n            );\n            output.contentDOM.dataset.editable = \"\";\n            output.contentDOM.appendChild(contentFragment);\n          }\n          continue;\n        }\n      }\n    } else if (node.type.name === \"text\") {\n      // We serialize text nodes manually as we need to serialize the styles/\n      // marks using `styleSpec.implementation.render`. When left up to\n      // ProseMirror, it'll use `toDOM` which is incorrect.\n      let dom: globalThis.Node | Text = document.createTextNode(\n        node.textContent,\n      );\n      // Reverse the order of marks to maintain the correct priority.\n      for (const mark of node.marks.toReversed()) {\n        if (mark.type.name in editor.schema.styleSpecs) {\n          const newDom = (\n            editor.schema.styleSpecs[mark.type.name].implementation\n              .toExternalHTML ??\n            editor.schema.styleSpecs[mark.type.name].implementation.render\n          )(mark.attrs[\"stringValue\"], editor);\n          newDom.contentDOM!.appendChild(dom);\n          dom = newDom.dom;\n        } else {\n          const domOutputSpec = mark.type.spec.toDOM!(mark, true);\n          const newDom = DOMSerializer.renderSpec(document, domOutputSpec);\n          newDom.contentDOM!.appendChild(dom);\n          dom = newDom.dom;\n        }\n      }\n\n      fragment.appendChild(dom);\n    } else {\n      // Fall back to default serialization for this node\n      const nodeFragment = serializer.serializeFragment(\n        Fragment.from([node]),\n        options,\n      );\n      fragment.appendChild(nodeFragment);\n    }\n  }\n\n  if (\n    fragment.childNodes.length === 1 &&\n    fragment.firstChild?.nodeType === 1 /* Node.ELEMENT_NODE */\n  ) {\n    addAttributesAndRemoveClasses(fragment.firstChild as HTMLElement);\n  }\n\n  return fragment;\n}\n\n/**\n * TODO: there's still quite some logic that handles getting and filtering properties,\n * we should make sure the `toExternalHTML` methods of default blocks actually handle this,\n * instead of the serializer.\n */\nfunction serializeBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  fragment: DocumentFragment,\n  editor: BlockNoteEditor<BSchema, I, S>,\n  block: PartialBlock<BSchema, I, S>,\n  serializer: DOMSerializer,\n  orderedListItemBlockTypes: Set<string>,\n  unorderedListItemBlockTypes: Set<string>,\n  options?: { document?: Document },\n) {\n  const doc = options?.document ?? document;\n  const BC_NODE = editor.pmSchema.nodes[\"blockContainer\"];\n\n  // set default props in case we were passed a partial block\n  const props = block.props || {};\n  for (const [name, spec] of Object.entries(\n    editor.schema.blockSchema[block.type as any].propSchema,\n  )) {\n    if (!(name in props) && spec.default !== undefined) {\n      (props as any)[name] = spec.default;\n    }\n  }\n\n  const bc = BC_NODE.spec?.toDOM?.(\n    BC_NODE.create({\n      id: block.id,\n      ...props,\n    }),\n  ) as {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n  };\n\n  // the container node is just used as a workaround to get some block-level attributes.\n  // we should change toExternalHTML so that this is not necessary\n  const attrs = Array.from(bc.dom.attributes);\n\n  const blockImplementation = editor.blockImplementations[block.type as any]\n    .implementation as BlockImplementation;\n  const ret =\n    blockImplementation.toExternalHTML?.call(\n      {},\n      { ...block, props } as any,\n      editor as any,\n    ) ||\n    blockImplementation.render.call(\n      {},\n      { ...block, props } as any,\n      editor as any,\n    );\n\n  const elementFragment = doc.createDocumentFragment();\n\n  if ((ret.dom as HTMLElement).classList.contains(\"bn-block-content\")) {\n    const blockContentDataAttributes = [\n      ...attrs,\n      ...Array.from((ret.dom as HTMLElement).attributes),\n    ].filter(\n      (attr) =>\n        attr.name.startsWith(\"data\") &&\n        attr.name !== \"data-content-type\" &&\n        attr.name !== \"data-file-block\" &&\n        attr.name !== \"data-node-view-wrapper\" &&\n        attr.name !== \"data-node-type\" &&\n        attr.name !== \"data-id\" &&\n        attr.name !== \"data-editable\",\n    );\n\n    // ret.dom = ret.dom.firstChild! as any;\n    for (const attr of blockContentDataAttributes) {\n      (ret.dom.firstChild! as HTMLElement).setAttribute(attr.name, attr.value);\n    }\n\n    addAttributesAndRemoveClasses(ret.dom.firstChild! as HTMLElement);\n    elementFragment.append(...Array.from(ret.dom.childNodes));\n  } else {\n    elementFragment.append(ret.dom);\n  }\n\n  if (ret.contentDOM && block.content) {\n    const ic = serializeInlineContentExternalHTML(\n      editor,\n      block.content as any, // TODO\n      serializer,\n      options,\n    );\n\n    ret.contentDOM.appendChild(ic);\n  }\n\n  let listType = undefined;\n  if (orderedListItemBlockTypes.has(block.type!)) {\n    listType = \"OL\";\n  } else if (unorderedListItemBlockTypes.has(block.type!)) {\n    listType = \"UL\";\n  }\n\n  if (listType) {\n    if (fragment.lastChild?.nodeName !== listType) {\n      const list = doc.createElement(listType);\n\n      if (\n        listType === \"OL\" &&\n        \"start\" in props &&\n        props.start &&\n        props?.start !== 1\n      ) {\n        list.setAttribute(\"start\", props.start + \"\");\n      }\n      fragment.append(list);\n    }\n    fragment.lastChild!.appendChild(elementFragment);\n  } else {\n    fragment.append(elementFragment);\n  }\n\n  if (block.children && block.children.length > 0) {\n    const childFragment = doc.createDocumentFragment();\n    serializeBlocksToFragment(\n      childFragment,\n      editor,\n      block.children,\n      serializer,\n      orderedListItemBlockTypes,\n      unorderedListItemBlockTypes,\n      options,\n    );\n    if (\n      fragment.lastChild?.nodeName === \"UL\" ||\n      fragment.lastChild?.nodeName === \"OL\"\n    ) {\n      // add nested lists to the last list item\n      while (\n        childFragment.firstChild?.nodeName === \"UL\" ||\n        childFragment.firstChild?.nodeName === \"OL\"\n      ) {\n        fragment.lastChild!.lastChild!.appendChild(childFragment.firstChild!);\n      }\n    }\n\n    if (editor.pmSchema.nodes[block.type as any].isInGroup(\"blockContent\")) {\n      // default \"blockContainer\" style blocks are flattened (no \"nested block\" support) for externalHTML, so append the child fragment to the outer fragment\n      fragment.append(childFragment);\n    } else {\n      // for columns / column lists, do use nesting\n      ret.contentDOM?.append(childFragment);\n    }\n  }\n}\n\nconst serializeBlocksToFragment = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  fragment: DocumentFragment,\n  editor: BlockNoteEditor<BSchema, I, S>,\n  blocks: PartialBlock<BSchema, I, S>[],\n  serializer: DOMSerializer,\n  orderedListItemBlockTypes: Set<string>,\n  unorderedListItemBlockTypes: Set<string>,\n  options?: { document?: Document },\n) => {\n  for (const block of blocks) {\n    serializeBlock(\n      fragment,\n      editor,\n      block,\n      serializer,\n      orderedListItemBlockTypes,\n      unorderedListItemBlockTypes,\n      options,\n    );\n  }\n};\n\nexport const serializeBlocksExternalHTML = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n  blocks: PartialBlock<BSchema, I, S>[],\n  serializer: DOMSerializer,\n  orderedListItemBlockTypes: Set<string>,\n  unorderedListItemBlockTypes: Set<string>,\n  options?: { document?: Document },\n) => {\n  const doc = options?.document ?? document;\n  const fragment = doc.createDocumentFragment();\n\n  serializeBlocksToFragment(\n    fragment,\n    editor,\n    blocks,\n    serializer,\n    orderedListItemBlockTypes,\n    unorderedListItemBlockTypes,\n    options,\n  );\n  return fragment;\n};\n","import { DOMSerializer, Schema } from \"prosemirror-model\";\n\nimport { PartialBlock } from \"../../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../../editor/BlockNoteEditor.js\";\nimport {\n  BlockSchema,\n  InlineContent,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport {\n  serializeBlocksExternalHTML,\n  serializeInlineContentExternalHTML,\n} from \"./util/serializeBlocksExternalHTML.js\";\n\n// Used to export BlockNote blocks and ProseMirror nodes to HTML for use outside\n// the editor. Blocks are exported using the `toExternalHTML` method in their\n// `blockSpec`, or `toInternalHTML` if `toExternalHTML` is not defined.\n//\n// The HTML created by this serializer is different to what's rendered by the\n// editor to the DOM. This also means that data is likely to be lost when\n// converting back to original blocks. The differences in the output HTML are:\n// 1. It doesn't include the `blockGroup` and `blockContainer` wrappers meaning\n// that nesting is not preserved for non-list-item blocks.\n// 2. `li` items in the output HTML are wrapped in `ul` or `ol` elements.\n// 3. While nesting for list items is preserved, other types of blocks nested\n// inside a list are un-nested and a new list is created after them.\n// 4. The HTML is wrapped in a single `div` element.\n\n// Needs to be sync because it's used in drag handler event (SideMenuPlugin)\nexport const createExternalHTMLExporter = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  schema: Schema,\n  editor: BlockNoteEditor<BSchema, I, S>,\n) => {\n  const serializer = DOMSerializer.fromSchema(schema);\n\n  return {\n    exportBlocks: (\n      blocks: PartialBlock<BSchema, I, S>[],\n      options: { document?: Document },\n    ) => {\n      const html = serializeBlocksExternalHTML(\n        editor,\n        blocks,\n        serializer,\n        new Set<string>([\"numberedListItem\"]),\n        new Set<string>([\"bulletListItem\", \"checkListItem\", \"toggleListItem\"]),\n        options,\n      );\n      const div = document.createElement(\"div\");\n      div.append(html);\n      return div.innerHTML;\n    },\n\n    exportInlineContent: (\n      inlineContent: InlineContent<I, S>[],\n      options: { document?: Document },\n    ) => {\n      const domFragment = serializeInlineContentExternalHTML(\n        editor,\n        inlineContent as any,\n        serializer,\n        options,\n      );\n\n      const parent = document.createElement(\"div\");\n      parent.append(domFragment.cloneNode(true));\n\n      return parent.innerHTML;\n    },\n  };\n};\n","import { DOMSerializer, Fragment, Node } from \"prosemirror-model\";\n\nimport { PartialBlock } from \"../../../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../../../editor/BlockNoteEditor.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../../schema/index.js\";\nimport { UnreachableCaseError } from \"../../../../util/typescript.js\";\nimport {\n  inlineContentToNodes,\n  tableContentToNodes,\n} from \"../../../nodeConversions/blockToNode.js\";\n\nimport { nodeToCustomInlineContent } from \"../../../nodeConversions/nodeToBlock.js\";\nexport function serializeInlineContentInternalHTML<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<any, I, S>,\n  blockContent: PartialBlock<BSchema, I, S>[\"content\"],\n  serializer: DOMSerializer,\n  blockType?: string,\n  options?: { document?: Document },\n) {\n  let nodes: Node[];\n\n  // TODO: reuse function from nodeconversions?\n  if (!blockContent) {\n    throw new Error(\"blockContent is required\");\n  } else if (typeof blockContent === \"string\") {\n    nodes = inlineContentToNodes([blockContent], editor.pmSchema, blockType);\n  } else if (Array.isArray(blockContent)) {\n    nodes = inlineContentToNodes(blockContent, editor.pmSchema, blockType);\n  } else if (blockContent.type === \"tableContent\") {\n    nodes = tableContentToNodes(blockContent, editor.pmSchema);\n  } else {\n    throw new UnreachableCaseError(blockContent.type);\n  }\n\n  // Check if any of the nodes are custom inline content with toExternalHTML\n  const doc = options?.document ?? document;\n  const fragment = doc.createDocumentFragment();\n\n  for (const node of nodes) {\n    // Check if this is a custom inline content node with toExternalHTML\n    if (\n      node.type.name !== \"text\" &&\n      editor.schema.inlineContentSchema[node.type.name]\n    ) {\n      const inlineContentImplementation =\n        editor.schema.inlineContentSpecs[node.type.name].implementation;\n\n      if (inlineContentImplementation) {\n        // Convert the node to inline content format\n        const inlineContent = nodeToCustomInlineContent(\n          node,\n          editor.schema.inlineContentSchema,\n          editor.schema.styleSchema,\n        );\n\n        // Use the custom toExternalHTML method\n        const output = inlineContentImplementation.render.call(\n          {\n            renderType: \"dom\",\n            props: undefined,\n          },\n          inlineContent as any,\n          () => {\n            // No-op\n          },\n          editor as any,\n        );\n\n        if (output) {\n          fragment.appendChild(output.dom);\n\n          // If contentDOM exists, render the inline content into it\n          if (output.contentDOM) {\n            const contentFragment = serializer.serializeFragment(\n              node.content,\n              options,\n            );\n            output.contentDOM.dataset.editable = \"\";\n            output.contentDOM.appendChild(contentFragment);\n          }\n          continue;\n        }\n      }\n    } else if (node.type.name === \"text\") {\n      // We serialize text nodes manually as we need to serialize the styles/\n      // marks using `styleSpec.implementation.render`. When left up to\n      // ProseMirror, it'll use `toDOM` which is incorrect.\n      let dom: globalThis.Node | Text = document.createTextNode(\n        node.textContent,\n      );\n      // Reverse the order of marks to maintain the correct priority.\n      for (const mark of node.marks.toReversed()) {\n        if (mark.type.name in editor.schema.styleSpecs) {\n          const newDom = editor.schema.styleSpecs[\n            mark.type.name\n          ].implementation.render(mark.attrs[\"stringValue\"], editor);\n          newDom.contentDOM!.appendChild(dom);\n          dom = newDom.dom;\n        } else {\n          const domOutputSpec = mark.type.spec.toDOM!(mark, true);\n          const newDom = DOMSerializer.renderSpec(document, domOutputSpec);\n          newDom.contentDOM!.appendChild(dom);\n          dom = newDom.dom;\n        }\n      }\n\n      fragment.appendChild(dom);\n    } else {\n      // Fall back to default serialization for this node\n      const nodeFragment = serializer.serializeFragment(\n        Fragment.from([node]),\n        options,\n      );\n      fragment.appendChild(nodeFragment);\n    }\n  }\n\n  return fragment;\n}\n\nfunction serializeBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n  block: PartialBlock<BSchema, I, S>,\n  serializer: DOMSerializer,\n  options?: { document?: Document },\n) {\n  const BC_NODE = editor.pmSchema.nodes[\"blockContainer\"];\n\n  // set default props in case we were passed a partial block\n  const props = block.props || {};\n  for (const [name, spec] of Object.entries(\n    editor.schema.blockSchema[block.type as any].propSchema,\n  )) {\n    if (!(name in props) && spec.default !== undefined) {\n      (props as any)[name] = spec.default;\n    }\n  }\n  const children = block.children || [];\n\n  const impl = editor.blockImplementations[block.type as any].implementation;\n  const ret = impl.render.call(\n    {\n      renderType: \"dom\",\n      props: undefined,\n    },\n    { ...block, props, children } as any,\n    editor as any,\n  );\n\n  if (ret.contentDOM && block.content) {\n    const ic = serializeInlineContentInternalHTML(\n      editor,\n      block.content as any, // TODO\n      serializer,\n      block.type,\n      options,\n    );\n    ret.contentDOM.appendChild(ic);\n  }\n\n  const pmType = editor.pmSchema.nodes[block.type as any];\n\n  if (pmType.isInGroup(\"bnBlock\")) {\n    if (block.children && block.children.length > 0) {\n      const fragment = serializeBlocks(\n        editor,\n        block.children,\n        serializer,\n        options,\n      );\n\n      ret.contentDOM?.append(fragment);\n    }\n    return ret.dom;\n  }\n\n  // wrap the block in a blockContainer\n  const bc = BC_NODE.spec?.toDOM?.(\n    BC_NODE.create({\n      id: block.id,\n      ...props,\n    }),\n  ) as {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n  };\n\n  bc.contentDOM?.appendChild(ret.dom);\n\n  if (block.children && block.children.length > 0) {\n    bc.contentDOM?.appendChild(\n      serializeBlocksInternalHTML(editor, block.children, serializer, options),\n    );\n  }\n  return bc.dom;\n}\n\nfunction serializeBlocks<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n  blocks: PartialBlock<BSchema, I, S>[],\n  serializer: DOMSerializer,\n  options?: { document?: Document },\n) {\n  const doc = options?.document ?? document;\n  const fragment = doc.createDocumentFragment();\n\n  for (const block of blocks) {\n    const blockDOM = serializeBlock(editor, block, serializer, options);\n    fragment.appendChild(blockDOM);\n  }\n\n  return fragment;\n}\n\nexport const serializeBlocksInternalHTML = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n  blocks: PartialBlock<BSchema, I, S>[],\n  serializer: DOMSerializer,\n  options?: { document?: Document },\n) => {\n  const BG_NODE = editor.pmSchema.nodes[\"blockGroup\"];\n\n  const bg = BG_NODE.spec!.toDOM!(BG_NODE.create({})) as {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n  };\n\n  const fragment = serializeBlocks(editor, blocks, serializer, options);\n\n  bg.contentDOM?.appendChild(fragment);\n\n  return bg.dom;\n};\n","import { DOMSerializer, Schema } from \"prosemirror-model\";\nimport { PartialBlock } from \"../../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../../editor/BlockNoteEditor.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { serializeBlocksInternalHTML } from \"./util/serializeBlocksInternalHTML.js\";\n// Used to serialize BlockNote blocks and ProseMirror nodes to HTML without\n// losing data. Blocks are exported using the `toInternalHTML` method in their\n// `blockSpec`.\n//\n// The HTML created by this serializer is the same as what's rendered by the\n// editor to the DOM. This means that it retains the same structure as the\n// editor, including the `blockGroup` and `blockContainer` wrappers. This also\n// means that it can be converted back to the original blocks without any data\n// loss.\nexport const createInternalHTMLSerializer = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  schema: Schema,\n  editor: BlockNoteEditor<BSchema, I, S>,\n) => {\n  const serializer = DOMSerializer.fromSchema(schema);\n\n  return {\n    serializeBlocks: (\n      blocks: PartialBlock<BSchema, I, S>[],\n      options: { document?: Document },\n    ) => {\n      return serializeBlocksInternalHTML(editor, blocks, serializer, options)\n        .outerHTML;\n    },\n  };\n};\n","import { combineTransactionSteps } from \"@tiptap/core\";\nimport deepEqual from \"fast-deep-equal\";\nimport type { Node } from \"prosemirror-model\";\nimport type { Transaction } from \"prosemirror-state\";\nimport {\n  Block,\n  DefaultBlockSchema,\n  DefaultInlineContentSchema,\n  DefaultStyleSchema,\n} from \"../blocks/defaultBlocks.js\";\nimport type { BlockSchema } from \"../schema/index.js\";\nimport type { InlineContentSchema } from \"../schema/inlineContent/types.js\";\nimport type { StyleSchema } from \"../schema/styles/types.js\";\nimport { nodeToBlock } from \"./nodeConversions/nodeToBlock.js\";\nimport { isNodeBlock } from \"./nodeUtil.js\";\nimport { getPmSchema } from \"./pmUtil.js\";\n\n/**\n * Change detection utilities for BlockNote.\n *\n * High-level algorithm used by getBlocksChangedByTransaction:\n * 1) Merge appended transactions into one document change.\n * 2) Collect a snapshot of blocks before and after (flat map by id, and per-parent child order).\n * 3) Emit inserts and deletes by diffing ids between snapshots.\n * 4) For ids present in both snapshots:\n *    - If parentId changed, emit a move\n *    - Else if block changed (ignoring children), emit an update\n * 5) Finally, detect same-parent sibling reorders by comparing child order per parent.\n *    We use an inlined O(n log n) LIS inside detectReorderedChildren to keep a\n *    longest already-ordered subsequence and mark only the remaining items as moved.\n */\n/**\n * Gets the parent block of a node, if it has one.\n */\nfunction getParentBlockId(doc: Node, pos: number): string | undefined {\n  if (pos === 0) {\n    return undefined;\n  }\n  const resolvedPos = doc.resolve(pos);\n  for (let i = resolvedPos.depth; i > 0; i--) {\n    const parent = resolvedPos.node(i);\n    if (isNodeBlock(parent)) {\n      return parent.attrs.id;\n    }\n  }\n  return undefined;\n}\n\n/**\n * This attributes the changes to a specific source.\n */\nexport type BlockChangeSource =\n  | { type: \"local\" }\n  | { type: \"paste\" }\n  | { type: \"drop\" }\n  | { type: \"undo\" | \"redo\" | \"undo-redo\" }\n  | { type: \"yjs-remote\" };\n\nexport type BlocksChanged<\n  BSchema extends BlockSchema = DefaultBlockSchema,\n  ISchema extends InlineContentSchema = DefaultInlineContentSchema,\n  SSchema extends StyleSchema = DefaultStyleSchema,\n> = Array<\n  {\n    /**\n     * The affected block.\n     */\n    block: Block<BSchema, ISchema, SSchema>;\n    /**\n     * The source of the change.\n     */\n    source: BlockChangeSource;\n  } & (\n    | {\n        type: \"insert\" | \"delete\";\n        /**\n         * Insert and delete changes don't have a previous block.\n         */\n        prevBlock: undefined;\n      }\n    | {\n        type: \"update\";\n        /**\n         * The previous block.\n         */\n        prevBlock: Block<BSchema, ISchema, SSchema>;\n      }\n    | {\n        type: \"move\";\n        /**\n         * The affected block.\n         */\n        block: Block<BSchema, ISchema, SSchema>;\n        /**\n         * The block before the move.\n         */\n        prevBlock: Block<BSchema, ISchema, SSchema>;\n        /**\n         * The previous parent block (if it existed).\n         */\n        prevParent?: Block<BSchema, ISchema, SSchema>;\n        /**\n         * The current parent block (if it exists).\n         */\n        currentParent?: Block<BSchema, ISchema, SSchema>;\n      }\n  )\n>;\n\nfunction determineChangeSource(transaction: Transaction): BlockChangeSource {\n  if (transaction.getMeta(\"paste\")) {\n    return { type: \"paste\" };\n  }\n  if (transaction.getMeta(\"uiEvent\") === \"drop\") {\n    return { type: \"drop\" };\n  }\n  if (transaction.getMeta(\"history$\")) {\n    return {\n      type: transaction.getMeta(\"history$\").redo ? \"redo\" : \"undo\",\n    };\n  }\n  if (transaction.getMeta(\"y-sync$\")) {\n    if (transaction.getMeta(\"y-sync$\").isUndoRedoOperation) {\n      return { type: \"undo-redo\" };\n    }\n    return { type: \"yjs-remote\" };\n  }\n  return { type: \"local\" };\n}\n\ntype BlockSnapshot<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema,\n> = {\n  byId: Record<\n    string,\n    {\n      block: Block<BSchema, ISchema, SSchema>;\n      parentId: string | undefined;\n    }\n  >;\n  childrenByParent: Record<string, string[]>;\n};\n\n/**\n * Collects a snapshot of blocks and per-parent child order in a single traversal.\n * Uses \"__root__\" to represent the root level where parentId is undefined.\n */\nfunction collectSnapshot<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema,\n>(doc: Node): BlockSnapshot<BSchema, ISchema, SSchema> {\n  const ROOT_KEY = \"__root__\";\n  const byId: Record<\n    string,\n    {\n      block: Block<BSchema, ISchema, SSchema>;\n      parentId: string | undefined;\n    }\n  > = {};\n  const childrenByParent: Record<string, string[]> = {};\n  const pmSchema = getPmSchema(doc);\n  doc.descendants((node, pos) => {\n    if (!isNodeBlock(node)) {\n      return true;\n    }\n    const parentId = getParentBlockId(doc, pos);\n    const key = parentId ?? ROOT_KEY;\n    if (!childrenByParent[key]) {\n      childrenByParent[key] = [];\n    }\n    const block = nodeToBlock(node, pmSchema);\n    byId[node.attrs.id] = { block, parentId };\n    childrenByParent[key].push(node.attrs.id);\n    return true;\n  });\n  return { byId, childrenByParent };\n}\n\n/**\n * Determines which child ids have been reordered (moved) within the same parent.\n * Uses LIS to keep the longest ordered subsequence and marks the rest as moved.\n */\nfunction detectReorderedChildren(\n  prevOrder: string[] | undefined,\n  nextOrder: string[] | undefined,\n): Set<string> {\n  const moved = new Set<string>();\n  if (!prevOrder || !nextOrder) {\n    return moved;\n  }\n  // Consider only ids present in both orders (ignore inserts/deletes handled elsewhere)\n  const prevIds = new Set(prevOrder);\n  const commonNext: string[] = nextOrder.filter((id) => prevIds.has(id));\n  const commonPrev: string[] = prevOrder.filter((id) =>\n    commonNext.includes(id),\n  );\n\n  if (commonPrev.length <= 1 || commonNext.length <= 1) {\n    return moved;\n  }\n\n  // Map ids to their index in previous order\n  const indexInPrev: Record<string, number> = {};\n  for (let i = 0; i < commonPrev.length; i++) {\n    indexInPrev[commonPrev[i]] = i;\n  }\n\n  // Build sequence of indices representing next order in terms of previous indices\n  const sequence: number[] = commonNext.map((id) => indexInPrev[id]);\n\n  // Inline O(n log n) LIS with reconstruction.\n  // Why LIS? We want the smallest set of siblings to label as \"moved\".\n  // Keeping the longest subsequence that is already in order achieves this,\n  // so only items outside the LIS are reported as moves.\n  const n = sequence.length;\n  const tailsValues: number[] = [];\n  const tailsEndsAtIndex: number[] = [];\n  const previousIndexInLis: number[] = new Array(n).fill(-1);\n\n  const lowerBound = (arr: number[], target: number): number => {\n    let lo = 0;\n    let hi = arr.length;\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1;\n      if (arr[mid] < target) {\n        lo = mid + 1;\n      } else {\n        hi = mid;\n      }\n    }\n    return lo;\n  };\n\n  for (let i = 0; i < n; i++) {\n    const value = sequence[i];\n    const pos = lowerBound(tailsValues, value);\n    if (pos > 0) {\n      previousIndexInLis[i] = tailsEndsAtIndex[pos - 1];\n    }\n    if (pos === tailsValues.length) {\n      tailsValues.push(value);\n      tailsEndsAtIndex.push(i);\n    } else {\n      tailsValues[pos] = value;\n      tailsEndsAtIndex[pos] = i;\n    }\n  }\n\n  const lisIndexSet = new Set<number>();\n  let k = tailsEndsAtIndex[tailsEndsAtIndex.length - 1] ?? -1;\n  while (k !== -1) {\n    lisIndexSet.add(k);\n    k = previousIndexInLis[k];\n  }\n\n  // Items not part of LIS are considered moved\n  for (let i = 0; i < commonNext.length; i++) {\n    if (!lisIndexSet.has(i)) {\n      moved.add(commonNext[i]);\n    }\n  }\n  return moved;\n}\n\n/**\n * Get the blocks that were changed by a transaction.\n */\nexport function getBlocksChangedByTransaction<\n  BSchema extends BlockSchema = DefaultBlockSchema,\n  ISchema extends InlineContentSchema = DefaultInlineContentSchema,\n  SSchema extends StyleSchema = DefaultStyleSchema,\n>(\n  transaction: Transaction,\n  appendedTransactions: Transaction[] = [],\n): BlocksChanged<BSchema, ISchema, SSchema> {\n  const source = determineChangeSource(transaction);\n  const combinedTransaction = combineTransactionSteps(transaction.before, [\n    transaction,\n    ...appendedTransactions,\n  ]);\n\n  const prevSnap = collectSnapshot<BSchema, ISchema, SSchema>(\n    combinedTransaction.before,\n  );\n  const nextSnap = collectSnapshot<BSchema, ISchema, SSchema>(\n    combinedTransaction.doc,\n  );\n\n  const changes: BlocksChanged<BSchema, ISchema, SSchema> = [];\n  const changedIds = new Set<string>();\n\n  // Handle inserted blocks\n  Object.keys(nextSnap.byId)\n    .filter((id) => !(id in prevSnap.byId))\n    .forEach((id) => {\n      changes.push({\n        type: \"insert\",\n        block: nextSnap.byId[id].block,\n        source,\n        prevBlock: undefined,\n      });\n      changedIds.add(id);\n    });\n\n  // Handle deleted blocks\n  Object.keys(prevSnap.byId)\n    .filter((id) => !(id in nextSnap.byId))\n    .forEach((id) => {\n      changes.push({\n        type: \"delete\",\n        block: prevSnap.byId[id].block,\n        source,\n        prevBlock: undefined,\n      });\n      changedIds.add(id);\n    });\n\n  // Handle updated, moved to different parent, indented, outdented blocks\n  Object.keys(nextSnap.byId)\n    .filter((id) => id in prevSnap.byId)\n    .forEach((id) => {\n      const prev = prevSnap.byId[id];\n      const next = nextSnap.byId[id];\n      const isParentDifferent = prev.parentId !== next.parentId;\n\n      if (isParentDifferent) {\n        changes.push({\n          type: \"move\",\n          block: next.block,\n          prevBlock: prev.block,\n          source,\n          prevParent: prev.parentId\n            ? prevSnap.byId[prev.parentId]?.block\n            : undefined,\n          currentParent: next.parentId\n            ? nextSnap.byId[next.parentId]?.block\n            : undefined,\n        });\n        changedIds.add(id);\n      } else if (\n        // Compare blocks while ignoring children to avoid reporting a parent\n        // update when only descendants changed.\n        !deepEqual(\n          { ...prev.block, children: undefined } as any,\n          { ...next.block, children: undefined } as any,\n        )\n      ) {\n        changes.push({\n          type: \"update\",\n          block: next.block,\n          prevBlock: prev.block,\n          source,\n        });\n        changedIds.add(id);\n      }\n    });\n\n  // Handle sibling reorders (parent unchanged but relative order changed)\n  const prevOrderByParent = prevSnap.childrenByParent;\n  const nextOrderByParent = nextSnap.childrenByParent;\n\n  // Use a special key for root-level siblings\n  const ROOT_KEY = \"__root__\";\n  const parents = new Set<string>([\n    ...Object.keys(prevOrderByParent),\n    ...Object.keys(nextOrderByParent),\n  ]);\n\n  const addedMoveForId = new Set<string>();\n\n  parents.forEach((parentKey) => {\n    const movedWithinParent = detectReorderedChildren(\n      prevOrderByParent[parentKey],\n      nextOrderByParent[parentKey],\n    );\n    if (movedWithinParent.size === 0) {\n      return;\n    }\n    movedWithinParent.forEach((id) => {\n      // Only consider ids that exist in both snapshots and whose parent truly did not change\n      const prev = prevSnap.byId[id];\n      const next = nextSnap.byId[id];\n      if (!prev || !next) {\n        return;\n      }\n      if (prev.parentId !== next.parentId) {\n        return;\n      }\n      // Skip if already accounted for by insert/delete/update/parent move\n      if (changedIds.has(id)) {\n        return;\n      }\n      // Verify we're addressing the right parent bucket\n      const bucketKey = prev.parentId ?? ROOT_KEY;\n      if (bucketKey !== parentKey) {\n        return;\n      }\n      if (addedMoveForId.has(id)) {\n        return;\n      }\n      addedMoveForId.add(id);\n      changes.push({\n        type: \"move\",\n        block: next.block,\n        prevBlock: prev.block,\n        source,\n        prevParent: prev.parentId\n          ? prevSnap.byId[prev.parentId]?.block\n          : undefined,\n        currentParent: next.parentId\n          ? nextSnap.byId[next.parentId]?.block\n          : undefined,\n      });\n      changedIds.add(id);\n    });\n  });\n\n  return changes;\n}\n","export const acceptedMIMETypes = [\n  \"vscode-editor-data\",\n  \"blocknote/html\",\n  \"text/markdown\",\n  \"text/html\",\n  \"text/plain\",\n  \"Files\",\n] as const;\n","import { Block, PartialBlock } from \"../../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../../editor/BlockNoteEditor\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { getNearestBlockPos } from \"../../getBlockInfoFromPos.js\";\nimport { acceptedMIMETypes } from \"./acceptedMIMETypes.js\";\n\nfunction checkFileExtensionsMatch(\n  fileExtension1: string,\n  fileExtension2: string,\n) {\n  if (!fileExtension1.startsWith(\".\") || !fileExtension2.startsWith(\".\")) {\n    throw new Error(`The strings provided are not valid file extensions.`);\n  }\n\n  return fileExtension1 === fileExtension2;\n}\n\nfunction checkMIMETypesMatch(mimeType1: string, mimeType2: string) {\n  const types1 = mimeType1.split(\"/\");\n  const types2 = mimeType2.split(\"/\");\n\n  if (types1.length !== 2) {\n    throw new Error(`The string ${mimeType1} is not a valid MIME type.`);\n  }\n  if (types2.length !== 2) {\n    throw new Error(`The string ${mimeType2} is not a valid MIME type.`);\n  }\n\n  if (types1[1] === \"*\" || types2[1] === \"*\") {\n    return types1[0] === types2[0];\n  }\n  if (types1[0] === \"*\" || types2[0] === \"*\") {\n    return types1[1] === types2[1];\n  }\n\n  return types1[0] === types2[0] && types1[1] === types2[1];\n}\n\nfunction insertOrUpdateBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n  referenceBlock: Block<BSchema, I, S>,\n  newBlock: PartialBlock<BSchema, I, S>,\n  placement: \"before\" | \"after\" = \"after\",\n) {\n  let insertedBlockId: string | undefined;\n\n  if (\n    Array.isArray(referenceBlock.content) &&\n    referenceBlock.content.length === 0\n  ) {\n    insertedBlockId = editor.updateBlock(referenceBlock, newBlock).id;\n  } else {\n    insertedBlockId = editor.insertBlocks(\n      [newBlock],\n      referenceBlock,\n      placement,\n    )[0].id;\n  }\n\n  return insertedBlockId;\n}\n\nexport async function handleFileInsertion<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(event: DragEvent | ClipboardEvent, editor: BlockNoteEditor<BSchema, I, S>) {\n  if (!editor.uploadFile) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      \"Attempted ot insert file, but uploadFile is not set in the BlockNote editor options\",\n    );\n    return;\n  }\n\n  const dataTransfer =\n    \"dataTransfer\" in event ? event.dataTransfer : event.clipboardData;\n  if (dataTransfer === null) {\n    return;\n  }\n\n  let format: (typeof acceptedMIMETypes)[number] | null = null;\n  for (const mimeType of acceptedMIMETypes) {\n    if (dataTransfer.types.includes(mimeType)) {\n      format = mimeType;\n      break;\n    }\n  }\n  if (format !== \"Files\") {\n    return;\n  }\n\n  const items = dataTransfer.items;\n  if (!items) {\n    return;\n  }\n\n  event.preventDefault();\n\n  for (let i = 0; i < items.length; i++) {\n    // Gets file block corresponding to MIME type.\n    let fileBlockType = \"file\";\n    for (const blockSpec of Object.values(editor.schema.blockSpecs)) {\n      for (const mimeType of blockSpec.implementation.meta?.fileBlockAccept ||\n        []) {\n        const isFileExtension = mimeType.startsWith(\".\");\n        const file = items[i].getAsFile();\n\n        if (file) {\n          if (\n            (!isFileExtension &&\n              file.type &&\n              checkMIMETypesMatch(items[i].type, mimeType)) ||\n            (isFileExtension &&\n              checkFileExtensionsMatch(\n                \".\" + file.name.split(\".\").pop(),\n                mimeType,\n              ))\n          ) {\n            fileBlockType = blockSpec.config.type;\n            break;\n          }\n        }\n      }\n    }\n\n    const file = items[i].getAsFile();\n    if (file) {\n      const fileBlock = {\n        type: fileBlockType,\n        props: {\n          name: file.name,\n        },\n      } as PartialBlock<BSchema, I, S>;\n\n      let insertedBlockId: string | undefined = undefined;\n\n      if (event.type === \"paste\") {\n        const currentBlock = editor.getTextCursorPosition().block;\n        insertedBlockId = insertOrUpdateBlock(editor, currentBlock, fileBlock);\n      } else if (event.type === \"drop\") {\n        const coords = {\n          left: (event as DragEvent).clientX,\n          top: (event as DragEvent).clientY,\n        };\n\n        const pos = editor.prosemirrorView.posAtCoords(coords);\n\n        if (!pos) {\n          return;\n        }\n\n        insertedBlockId = editor.transact((tr) => {\n          const posInfo = getNearestBlockPos(tr.doc, pos.pos);\n          const blockElement = editor.prosemirrorView.dom.querySelector(\n            `[data-id=\"${posInfo.node.attrs.id}\"]`,\n          );\n\n          const blockRect = blockElement?.getBoundingClientRect();\n\n          return insertOrUpdateBlock(\n            editor,\n            editor.getBlock(posInfo.node.attrs.id)!,\n            fileBlock,\n            blockRect && (blockRect.top + blockRect.bottom) / 2 > coords.top\n              ? \"before\"\n              : \"after\",\n          );\n        });\n      } else {\n        return;\n      }\n\n      const updateData = await editor.uploadFile(file, insertedBlockId);\n\n      const updatedFileBlock =\n        typeof updateData === \"string\"\n          ? ({\n              props: {\n                url: updateData,\n              },\n            } as PartialBlock<BSchema, I, S>)\n          : { ...updateData };\n\n      editor.updateBlock(insertedBlockId, updatedFileBlock);\n    }\n  }\n}\n","import { Extension } from \"@tiptap/core\";\nimport { Plugin } from \"prosemirror-state\";\n\nimport type { BlockNoteEditor } from \"../../../editor/BlockNoteEditor.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { acceptedMIMETypes } from \"./acceptedMIMETypes.js\";\nimport { handleFileInsertion } from \"./handleFileInsertion.js\";\n\nexport const createDropFileExtension = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n) =>\n  Extension.create<{ editor: BlockNoteEditor<BSchema, I, S> }, undefined>({\n    name: \"dropFile\",\n    addProseMirrorPlugins() {\n      return [\n        new Plugin({\n          props: {\n            handleDOMEvents: {\n              drop(_view, event) {\n                if (!editor.isEditable) {\n                  return;\n                }\n\n                let format: (typeof acceptedMIMETypes)[number] | null = null;\n                for (const mimeType of acceptedMIMETypes) {\n                  if (event.dataTransfer!.types.includes(mimeType)) {\n                    format = mimeType;\n                    break;\n                  }\n                }\n                if (format === null) {\n                  return true;\n                }\n\n                if (format === \"Files\") {\n                  handleFileInsertion(event, editor);\n                  return true;\n                }\n\n                return false;\n              },\n            },\n          },\n        }),\n      ];\n    },\n  });\n","// Headings H1-H6.\nconst h1 = /(^|\\n) {0,3}#{1,6} {1,8}[^\\n]{1,64}\\r?\\n\\r?\\n\\s{0,32}\\S/;\n\n// Bold, italic, underline, strikethrough, highlight.\nconst bold =\n  /(_|__|\\*|\\*\\*|~~|==|\\+\\+)(?!\\s)(?:[^\\s](?:.{0,62}[^\\s])?|\\S)(?=\\1)/;\n\n// Basic inline link (also captures images).\nconst link = /\\[[^\\]]{1,128}\\]\\(https?:\\/\\/\\S{1,999}\\)/;\n\n// Inline code.\nconst code = /(?:\\s|^)`(?!\\s)(?:[^\\s`](?:[^`]{0,46}[^\\s`])?|[^\\s`])`([^\\w]|$)/;\n\n// Unordered list.\nconst ul = /(?:^|\\n)\\s{0,5}-\\s{1}[^\\n]+\\n\\s{0,15}-\\s/;\n\n// Ordered list.\nconst ol = /(?:^|\\n)\\s{0,5}\\d+\\.\\s{1}[^\\n]+\\n\\s{0,15}\\d+\\.\\s/;\n\n// Horizontal rule.\nconst hr = /\\n{2} {0,3}-{2,48}\\n{2}/;\n\n// Fenced code block.\nconst fences =\n  /(?:\\n|^)(```|~~~|\\$\\$)(?!`|~)[^\\s]{0,64} {0,64}[^\\n]{0,64}\\n[\\s\\S]{0,9999}?\\s*\\1 {0,64}(?:\\n+|$)/;\n\n// Classical underlined H1 and H2 headings.\nconst title = /(?:\\n|^)(?!\\s)\\w[^\\n]{0,64}\\r?\\n(-|=)\\1{0,64}\\n\\n\\s{0,64}(\\w|$)/;\n\n// Blockquote.\nconst blockquote =\n  /(?:^|(\\r?\\n\\r?\\n))( {0,3}>[^\\n]{1,333}\\n){1,999}($|(\\r?\\n))/;\n\n// Table Header\nconst tableHeader = /^\\s*\\|(.+\\|)+\\s*$/m;\n\n// Table Divider\nconst tableDivider = /^\\s*\\|(\\s*[-:]+[-:]\\s*\\|)+\\s*$/m;\n\n// Table Row\nconst tableRow = /^\\s*\\|(.+\\|)+\\s*$/m;\n\n/**\n * Returns `true` if the source text might be a markdown document.\n *\n * @param src Source text to analyze.\n */\nexport const isMarkdown = (src: string): boolean =>\n  h1.test(src) ||\n  bold.test(src) ||\n  link.test(src) ||\n  code.test(src) ||\n  ul.test(src) ||\n  ol.test(src) ||\n  hr.test(src) ||\n  fences.test(src) ||\n  title.test(src) ||\n  blockquote.test(src) ||\n  tableHeader.test(src) ||\n  tableDivider.test(src) ||\n  tableRow.test(src);\n","import { EditorView } from \"prosemirror-view\";\n\nexport async function handleVSCodePaste(\n  event: ClipboardEvent,\n  view: EditorView,\n) {\n  const { schema } = view.state;\n\n  if (!event.clipboardData) {\n    return false;\n  }\n\n  const text = event.clipboardData!.getData(\"text/plain\");\n\n  if (!text) {\n    return false;\n  }\n\n  if (!schema.nodes.codeBlock) {\n    view.pasteText(text);\n    return true;\n  }\n\n  const vscode = event.clipboardData!.getData(\"vscode-editor-data\");\n  const vscodeData = vscode ? JSON.parse(vscode) : undefined;\n  const language = vscodeData?.mode;\n\n  if (!language) {\n    return false;\n  }\n\n  // strip carriage return chars from text pasted as code\n  // see: https://github.com/ProseMirror/prosemirror-view/commit/a50a6bcceb4ce52ac8fcc6162488d8875613aacd\n  view.pasteHTML(\n    `<pre><code class=\"language-${language}\">${text.replace(\n      /\\r\\n?/g,\n      \"\\n\",\n    )}</code></pre>`,\n  );\n\n  return true;\n}\n","import { Extension } from \"@tiptap/core\";\nimport { Plugin } from \"prosemirror-state\";\n\nimport type {\n  BlockNoteEditor,\n  BlockNoteEditorOptions,\n} from \"../../../editor/BlockNoteEditor\";\nimport { isMarkdown } from \"../../parsers/markdown/detectMarkdown.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { acceptedMIMETypes } from \"./acceptedMIMETypes.js\";\nimport { handleFileInsertion } from \"./handleFileInsertion.js\";\nimport { handleVSCodePaste } from \"./handleVSCodePaste.js\";\n\nfunction defaultPasteHandler({\n  event,\n  editor,\n  prioritizeMarkdownOverHTML,\n  plainTextAsMarkdown,\n}: {\n  event: ClipboardEvent;\n  editor: BlockNoteEditor<any, any, any>;\n  prioritizeMarkdownOverHTML: boolean;\n  plainTextAsMarkdown: boolean;\n}) {\n  // Special case for code blocks, as they do not support any rich text\n  // formatting, so we force pasting plain text.\n  const isInCodeBlock = editor.transact(\n    (tr) =>\n      tr.selection.$from.parent.type.spec.code &&\n      tr.selection.$to.parent.type.spec.code,\n  );\n\n  if (isInCodeBlock) {\n    const data = event.clipboardData?.getData(\"text/plain\");\n\n    if (data) {\n      editor.pasteText(data);\n\n      return true;\n    }\n  }\n\n  let format: (typeof acceptedMIMETypes)[number] | undefined;\n  for (const mimeType of acceptedMIMETypes) {\n    if (event.clipboardData!.types.includes(mimeType)) {\n      format = mimeType;\n      break;\n    }\n  }\n\n  if (!format) {\n    return true;\n  }\n\n  if (format === \"vscode-editor-data\") {\n    handleVSCodePaste(event, editor.prosemirrorView);\n    return true;\n  }\n\n  if (format === \"Files\") {\n    handleFileInsertion(event, editor);\n    return true;\n  }\n\n  const data = event.clipboardData!.getData(format);\n\n  if (format === \"blocknote/html\") {\n    // Is blocknote/html, so no need to convert it\n    editor.pasteHTML(data, true);\n    return true;\n  }\n\n  if (format === \"text/markdown\") {\n    editor.pasteMarkdown(data);\n    return true;\n  }\n\n  if (prioritizeMarkdownOverHTML) {\n    // Use plain text instead of HTML if it looks like Markdown\n    const plainText = event.clipboardData!.getData(\"text/plain\");\n\n    if (isMarkdown(plainText)) {\n      editor.pasteMarkdown(plainText);\n      return true;\n    }\n  }\n\n  if (format === \"text/html\") {\n    editor.pasteHTML(data);\n    return true;\n  }\n\n  if (plainTextAsMarkdown) {\n    editor.pasteMarkdown(data);\n    return true;\n  }\n\n  editor.pasteText(data);\n  return true;\n}\n\nexport const createPasteFromClipboardExtension = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n  pasteHandler: Exclude<\n    BlockNoteEditorOptions<any, any, any>[\"pasteHandler\"],\n    undefined\n  >,\n) =>\n  Extension.create({\n    name: \"pasteFromClipboard\",\n    addProseMirrorPlugins() {\n      return [\n        new Plugin({\n          props: {\n            handleDOMEvents: {\n              paste(_view, event) {\n                event.preventDefault();\n\n                if (!editor.isEditable) {\n                  return;\n                }\n\n                return pasteHandler({\n                  event,\n                  editor,\n                  defaultPasteHandler: ({\n                    prioritizeMarkdownOverHTML = true,\n                    plainTextAsMarkdown = true,\n                  } = {}) => {\n                    return defaultPasteHandler({\n                      event,\n                      editor,\n                      prioritizeMarkdownOverHTML,\n                      plainTextAsMarkdown,\n                    });\n                  },\n                });\n              },\n            },\n          },\n        }),\n      ];\n    },\n  });\n","import { Element as HASTElement, Parent as HASTParent } from \"hast\";\n\n/**\n * Rehype plugin which removes <u> tags. Used to remove underlines before converting HTML to markdown, as Markdown\n * doesn't support underlines.\n */\nexport function removeUnderlines() {\n  const removeUnderlinesHelper = (tree: HASTParent) => {\n    let numChildElements = tree.children.length;\n\n    for (let i = 0; i < numChildElements; i++) {\n      const node = tree.children[i];\n\n      if (node.type === \"element\") {\n        // Recursively removes underlines from child elements.\n        removeUnderlinesHelper(node);\n\n        if ((node as HASTElement).tagName === \"u\") {\n          // Lifts child nodes outside underline element, deletes the underline element, and updates current index &\n          // the number of child elements.\n          if (node.children.length > 0) {\n            tree.children.splice(i, 1, ...node.children);\n\n            const numElementsAdded = node.children.length - 1;\n            numChildElements += numElementsAdded;\n            i += numElementsAdded;\n          } else {\n            tree.children.splice(i, 1);\n\n            numChildElements--;\n            i--;\n          }\n        }\n      }\n    }\n  };\n\n  return removeUnderlinesHelper;\n}\n","import { Element as HASTElement, Parent as HASTParent } from \"hast\";\nimport { fromDom } from \"hast-util-from-dom\";\n\n/**\n * Rehype plugin which adds a space after each checkbox input element. This is\n * because remark doesn't add any spaces between the checkbox input and the text\n * itself, but these are needed for correct Markdown syntax.\n */\nexport function addSpacesToCheckboxes() {\n  const helper = (tree: HASTParent) => {\n    if (tree.children && \"length\" in tree.children && tree.children.length) {\n      for (let i = tree.children.length - 1; i >= 0; i--) {\n        const child = tree.children[i];\n        const nextChild =\n          i + 1 < tree.children.length ? tree.children[i + 1] : undefined;\n\n        // Checks for paragraph element after checkbox input element.\n        if (\n          child.type === \"element\" &&\n          child.tagName === \"input\" &&\n          child.properties?.type === \"checkbox\" &&\n          nextChild?.type === \"element\" &&\n          nextChild.tagName === \"p\"\n        ) {\n          // Converts paragraph to span, otherwise remark will think it needs to\n          // be on a new line.\n          nextChild.tagName = \"span\";\n          // Adds a space after the checkbox input element.\n          nextChild.children.splice(\n            0,\n            0,\n            fromDom(document.createTextNode(\" \")) as HASTElement,\n          );\n        } else {\n          helper(child as HASTParent);\n        }\n      }\n    }\n  };\n\n  return helper;\n}\n","import { Parent as HASTParent } from \"hast\";\nimport { visit } from \"unist-util-visit\";\n\n// Originally, rehypeParse parses videos as links, which is incorrect.\nexport function convertVideoToMarkdown() {\n  return (tree: HASTParent) => {\n    visit(tree, \"element\", (node, index, parent) => {\n      if (parent && node.tagName === \"video\") {\n        const src = node.properties?.src || node.properties?.[\"data-url\"] || \"\";\n        const name =\n          node.properties?.title || node.properties?.[\"data-name\"] || \"\";\n        parent.children[index!] = {\n          type: \"text\",\n          value: `![${name}](${src})`,\n        };\n      }\n    });\n  };\n}\n","import { Schema } from \"prosemirror-model\";\nimport rehypeParse from \"rehype-parse\";\nimport rehypeRemark from \"rehype-remark\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkStringify from \"remark-stringify\";\nimport { unified } from \"unified\";\n\nimport { PartialBlock } from \"../../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../../editor/BlockNoteEditor.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { createExternalHTMLExporter } from \"../html/externalHTMLExporter.js\";\nimport { removeUnderlines } from \"./util/removeUnderlinesRehypePlugin.js\";\nimport { addSpacesToCheckboxes } from \"./util/addSpacesToCheckboxesRehypePlugin.js\";\nimport { convertVideoToMarkdown } from \"./util/convertVideoToMarkdownRehypePlugin.js\";\n\n// Needs to be sync because it's used in drag handler event (SideMenuPlugin)\nexport function cleanHTMLToMarkdown(cleanHTMLString: string) {\n  const markdownString = unified()\n    .use(rehypeParse, { fragment: true })\n    .use(convertVideoToMarkdown)\n    .use(removeUnderlines)\n    .use(addSpacesToCheckboxes)\n    .use(rehypeRemark)\n    .use(remarkGfm)\n    .use(remarkStringify, {\n      handlers: { text: (node) => node.value },\n    })\n    .processSync(cleanHTMLString);\n\n  return markdownString.value as string;\n}\n\nexport function blocksToMarkdown<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  blocks: PartialBlock<BSchema, I, S>[],\n  schema: Schema,\n  editor: BlockNoteEditor<BSchema, I, S>,\n  options: { document?: Document },\n): string {\n  const exporter = createExternalHTMLExporter(schema, editor);\n  const externalHTML = exporter.exportBlocks(blocks, options);\n\n  return cleanHTMLToMarkdown(externalHTML);\n}\n","import { Fragment } from \"@tiptap/pm/model\";\nimport {\n  BlockNoDefaults,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\nimport { getPmSchema } from \"../pmUtil.js\";\nimport { nodeToBlock } from \"./nodeToBlock.js\";\n\n/**\n * Converts all Blocks within a fragment to BlockNote blocks.\n */\nexport function fragmentToBlocks<\n  B extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(fragment: Fragment) {\n  // first convert selection to blocknote-style blocks, and then\n  // pass these to the exporter\n  const blocks: BlockNoDefaults<B, I, S>[] = [];\n  fragment.descendants((node) => {\n    const pmSchema = getPmSchema(node);\n    if (node.type.name === \"blockContainer\") {\n      if (node.firstChild?.type.name === \"blockGroup\") {\n        // selection started within a block group\n        // in this case the fragment starts with:\n        // <blockContainer>\n        //   <blockGroup>\n        //     <blockContainer ... />\n        //     <blockContainer ... />\n        //   </blockGroup>\n        // </blockContainer>\n        //\n        // instead of:\n        // <blockContainer>\n        //   <blockContent ... />\n        //   <blockGroup>\n        //     <blockContainer ... />\n        //     <blockContainer ... />\n        //   </blockGroup>\n        // </blockContainer>\n        //\n        // so we don't need to serialize this block, just descend into the children of the blockGroup\n        return true;\n      }\n    }\n\n    if (node.type.name === \"columnList\" && node.childCount === 1) {\n      // column lists with a single column should be flattened (not the entire column list has been selected)\n      node.firstChild?.forEach((child) => {\n        blocks.push(nodeToBlock(child, pmSchema));\n      });\n      return false;\n    }\n\n    if (node.type.isInGroup(\"bnBlock\")) {\n      blocks.push(nodeToBlock(node, pmSchema));\n      // don't descend into children, as they're already included in the block returned by nodeToBlock\n      return false;\n    }\n    return true;\n  });\n  return blocks;\n}\n","import { Extension } from \"@tiptap/core\";\nimport { Fragment, Node } from \"prosemirror-model\";\nimport { NodeSelection, Plugin } from \"prosemirror-state\";\nimport { CellSelection } from \"prosemirror-tables\";\nimport type { EditorView } from \"prosemirror-view\";\n\nimport type { BlockNoteEditor } from \"../../../editor/BlockNoteEditor.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { createExternalHTMLExporter } from \"../../exporters/html/externalHTMLExporter.js\";\nimport { cleanHTMLToMarkdown } from \"../../exporters/markdown/markdownExporter.js\";\nimport { fragmentToBlocks } from \"../../nodeConversions/fragmentToBlocks.js\";\nimport {\n  contentNodeToInlineContent,\n  contentNodeToTableContent,\n} from \"../../nodeConversions/nodeToBlock.js\";\n\nfunction fragmentToExternalHTML<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  view: EditorView,\n  selectedFragment: Fragment,\n  editor: BlockNoteEditor<BSchema, I, S>,\n) {\n  let isWithinBlockContent = false;\n  const isWithinTable = view.state.selection instanceof CellSelection;\n\n  if (!isWithinTable) {\n    // Checks whether block ancestry should be included when creating external\n    // HTML. If the selection is within a block content node, the block ancestry\n    // is excluded as we only care about the inline content.\n    const fragmentWithoutParents = view.state.doc.slice(\n      view.state.selection.from,\n      view.state.selection.to,\n      false,\n    ).content;\n\n    const children = [];\n    for (let i = 0; i < fragmentWithoutParents.childCount; i++) {\n      children.push(fragmentWithoutParents.child(i));\n    }\n\n    isWithinBlockContent =\n      children.find(\n        (child) =>\n          child.type.isInGroup(\"bnBlock\") ||\n          child.type.name === \"blockGroup\" ||\n          child.type.spec.group === \"blockContent\",\n      ) === undefined;\n    if (isWithinBlockContent) {\n      selectedFragment = fragmentWithoutParents;\n    }\n  }\n\n  let externalHTML: string;\n\n  const externalHTMLExporter = createExternalHTMLExporter(\n    view.state.schema,\n    editor,\n  );\n\n  if (isWithinTable) {\n    if (selectedFragment.firstChild?.type.name === \"table\") {\n      // contentNodeToTableContent expects the fragment of the content of a table, not the table node itself\n      // but cellselection.content() returns the table node itself if all cells and columns are selected\n      selectedFragment = selectedFragment.firstChild.content;\n    }\n\n    // first convert selection to blocknote-style table content, and then\n    // pass this to the exporter\n    const ic = contentNodeToTableContent(\n      selectedFragment as any,\n      editor.schema.inlineContentSchema,\n      editor.schema.styleSchema,\n    );\n\n    // Wrap in table to ensure correct parsing by spreadsheet applications\n    externalHTML = `<table>${externalHTMLExporter.exportInlineContent(\n      ic as any,\n      {},\n    )}</table>`;\n  } else if (isWithinBlockContent) {\n    // first convert selection to blocknote-style inline content, and then\n    // pass this to the exporter\n    const ic = contentNodeToInlineContent(\n      selectedFragment as any,\n      editor.schema.inlineContentSchema,\n      editor.schema.styleSchema,\n    );\n    externalHTML = externalHTMLExporter.exportInlineContent(ic, {});\n  } else {\n    const blocks = fragmentToBlocks<BSchema, I, S>(selectedFragment);\n    externalHTML = externalHTMLExporter.exportBlocks(blocks, {});\n  }\n  return externalHTML;\n}\n\nexport function selectedFragmentToHTML<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  view: EditorView,\n  editor: BlockNoteEditor<BSchema, I, S>,\n): {\n  clipboardHTML: string;\n  externalHTML: string;\n  markdown: string;\n} {\n  // Checks if a `blockContent` node is being copied and expands\n  // the selection to the parent `blockContainer` node. This is\n  // for the use-case in which only a block without content is\n  // selected, e.g. an image block.\n  if (\n    \"node\" in view.state.selection &&\n    (view.state.selection.node as Node).type.spec.group === \"blockContent\"\n  ) {\n    editor.transact((tr) =>\n      tr.setSelection(\n        new NodeSelection(tr.doc.resolve(view.state.selection.from - 1)),\n      ),\n    );\n  }\n\n  // Uses default ProseMirror clipboard serialization.\n  const clipboardHTML: string = view.serializeForClipboard(\n    view.state.selection.content(),\n  ).dom.innerHTML;\n\n  const selectedFragment = view.state.selection.content().content;\n\n  const externalHTML = fragmentToExternalHTML<BSchema, I, S>(\n    view,\n    selectedFragment,\n    editor,\n  );\n\n  const markdown = cleanHTMLToMarkdown(externalHTML);\n\n  return { clipboardHTML, externalHTML, markdown };\n}\n\nconst checkIfSelectionInNonEditableBlock = () => {\n  // Let browser handle event if selection is empty (nothing\n  // happens).\n  const selection = window.getSelection();\n  if (!selection || selection.isCollapsed) {\n    return true;\n  }\n\n  // Let browser handle event if it's within a non-editable\n  // \"island\". This means it's in selectable content within a\n  // non-editable block. We only need to check one node as it's\n  // not possible for the browser selection to start in an\n  // editable block and end in a non-editable one.\n  let node = selection.focusNode;\n  while (node) {\n    if (\n      node instanceof HTMLElement &&\n      node.getAttribute(\"contenteditable\") === \"false\"\n    ) {\n      return true;\n    }\n\n    node = node.parentElement;\n  }\n\n  return false;\n};\n\nconst copyToClipboard = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n  view: EditorView,\n  event: ClipboardEvent,\n) => {\n  // Stops the default browser copy behaviour.\n  event.preventDefault();\n  event.clipboardData!.clearData();\n\n  const { clipboardHTML, externalHTML, markdown } = selectedFragmentToHTML(\n    view,\n    editor,\n  );\n\n  // TODO: Writing to other MIME types not working in Safari for\n  //  some reason.\n  event.clipboardData!.setData(\"blocknote/html\", clipboardHTML);\n  event.clipboardData!.setData(\"text/html\", externalHTML);\n  event.clipboardData!.setData(\"text/plain\", markdown);\n};\n\nexport const createCopyToClipboardExtension = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n) =>\n  Extension.create<{ editor: BlockNoteEditor<BSchema, I, S> }, undefined>({\n    name: \"copyToClipboard\",\n    addProseMirrorPlugins() {\n      return [\n        new Plugin({\n          props: {\n            handleDOMEvents: {\n              copy(view, event) {\n                if (checkIfSelectionInNonEditableBlock()) {\n                  return true;\n                }\n\n                copyToClipboard(editor, view, event);\n                // Prevent default PM handler to be called\n                return true;\n              },\n              cut(view, event) {\n                if (checkIfSelectionInNonEditableBlock()) {\n                  return true;\n                }\n\n                copyToClipboard(editor, view, event);\n                if (view.editable) {\n                  view.dispatch(view.state.tr.deleteSelection());\n                }\n                // Prevent default PM handler to be called\n                return true;\n              },\n              // This is for the use-case in which only a block without content\n              // is selected, e.g. an image block, and dragged (not using the\n              // drag handle).\n              dragstart(view, event) {\n                // Checks if a `NodeSelection` is active.\n                if (!(\"node\" in view.state.selection)) {\n                  return;\n                }\n\n                // Checks if a `blockContent` node is being dragged.\n                if (\n                  (view.state.selection.node as Node).type.spec.group !==\n                  \"blockContent\"\n                ) {\n                  return;\n                }\n\n                // Expands the selection to the parent `blockContainer` node.\n                editor.transact((tr) =>\n                  tr.setSelection(\n                    new NodeSelection(\n                      tr.doc.resolve(view.state.selection.from - 1),\n                    ),\n                  ),\n                );\n\n                // Stops the default browser drag start behaviour.\n                event.preventDefault();\n                event.dataTransfer!.clearData();\n\n                const { clipboardHTML, externalHTML, markdown } =\n                  selectedFragmentToHTML(view, editor);\n\n                // TODO: Writing to other MIME types not working in Safari for\n                //  some reason.\n                event.dataTransfer!.setData(\"blocknote/html\", clipboardHTML);\n                event.dataTransfer!.setData(\"text/html\", externalHTML);\n                event.dataTransfer!.setData(\"text/plain\", markdown);\n\n                // Prevent default PM handler to be called\n                return true;\n              },\n            },\n          },\n        }),\n      ];\n    },\n  });\n","import { Extension } from \"@tiptap/core\";\nimport { getBackgroundColorAttribute } from \"../../blocks/defaultProps.js\";\n\nexport const BackgroundColorExtension = Extension.create({\n  name: \"blockBackgroundColor\",\n\n  addGlobalAttributes() {\n    return [\n      {\n        types: [\"tableCell\", \"tableHeader\"],\n        attributes: {\n          backgroundColor: getBackgroundColorAttribute(),\n        },\n      },\n    ];\n  },\n});\n","import { Plugin, PluginKey, Transaction } from \"prosemirror-state\";\nimport {\n  BlocksChanged,\n  getBlocksChangedByTransaction,\n} from \"../../api/getBlocksChangedByTransaction.js\";\nimport { BlockNoteExtension } from \"../../editor/BlockNoteExtension.js\";\n\n/**\n * This plugin can filter transactions before they are applied to the editor, but with a higher-level API than `filterTransaction` from prosemirror.\n */\nexport class BlockChangePlugin extends BlockNoteExtension {\n  public static key() {\n    return \"blockChange\";\n  }\n\n  private beforeChangeCallbacks: ((context: {\n    getChanges: () => BlocksChanged<any, any, any>;\n    tr: Transaction;\n  }) => boolean | void)[] = [];\n\n  constructor() {\n    super();\n\n    this.addProsemirrorPlugin(\n      new Plugin({\n        key: new PluginKey(\"blockChange\"),\n        filterTransaction: (tr) => {\n          let changes:\n            | ReturnType<typeof getBlocksChangedByTransaction>\n            | undefined = undefined;\n\n          return this.beforeChangeCallbacks.reduce((acc, cb) => {\n            if (acc === false) {\n              // We only care that we hit a `false` result, so we can stop iterating.\n              return acc;\n            }\n            return (\n              cb({\n                getChanges() {\n                  if (changes) {\n                    return changes;\n                  }\n                  changes = getBlocksChangedByTransaction(tr);\n                  return changes;\n                },\n                tr,\n              }) !== false\n            );\n          }, true);\n        },\n      }),\n    );\n  }\n\n  public subscribe(\n    callback: (context: {\n      getChanges: () => BlocksChanged<any, any, any>;\n      tr: Transaction;\n    }) => boolean | void,\n  ) {\n    this.beforeChangeCallbacks.push(callback);\n\n    return () => {\n      this.beforeChangeCallbacks = this.beforeChangeCallbacks.filter(\n        (cb) => cb !== callback,\n      );\n    };\n  }\n}\n","import { defaultSelectionBuilder, yCursorPlugin } from \"y-prosemirror\";\nimport { Awareness } from \"y-protocols/awareness.js\";\nimport * as Y from \"yjs\";\nimport { BlockNoteExtension } from \"../../editor/BlockNoteExtension.js\";\n\nexport type CollaborationUser = {\n  name: string;\n  color: string;\n  [key: string]: string;\n};\n\nexport class CursorPlugin extends BlockNoteExtension {\n  public static key() {\n    return \"yCursorPlugin\";\n  }\n\n  private provider: { awareness: Awareness };\n  private recentlyUpdatedCursors: Map<\n    number,\n    { element: HTMLElement; hideTimeout: NodeJS.Timeout | undefined }\n  >;\n  constructor(\n    private collaboration: {\n      fragment: Y.XmlFragment;\n      user: CollaborationUser;\n      provider: { awareness: Awareness };\n      renderCursor?: (user: CollaborationUser) => HTMLElement;\n      showCursorLabels?: \"always\" | \"activity\";\n    },\n  ) {\n    super();\n    this.provider = collaboration.provider;\n    this.recentlyUpdatedCursors = new Map();\n\n    this.provider.awareness.setLocalStateField(\"user\", collaboration.user);\n\n    if (collaboration.showCursorLabels !== \"always\") {\n      this.provider.awareness.on(\n        \"change\",\n        ({\n          updated,\n        }: {\n          added: Array<number>;\n          updated: Array<number>;\n          removed: Array<number>;\n        }) => {\n          for (const clientID of updated) {\n            const cursor = this.recentlyUpdatedCursors.get(clientID);\n\n            if (cursor) {\n              cursor.element.setAttribute(\"data-active\", \"\");\n\n              if (cursor.hideTimeout) {\n                clearTimeout(cursor.hideTimeout);\n              }\n\n              this.recentlyUpdatedCursors.set(clientID, {\n                element: cursor.element,\n                hideTimeout: setTimeout(() => {\n                  cursor.element.removeAttribute(\"data-active\");\n                }, 2000),\n              });\n            }\n          }\n        },\n      );\n    }\n\n    this.addProsemirrorPlugin(\n      yCursorPlugin(this.provider.awareness, {\n        selectionBuilder: defaultSelectionBuilder,\n        cursorBuilder: this.renderCursor,\n      }),\n    );\n  }\n\n  public get priority() {\n    return 999;\n  }\n\n  private renderCursor = (user: CollaborationUser, clientID: number) => {\n    let cursorData = this.recentlyUpdatedCursors.get(clientID);\n\n    if (!cursorData) {\n      const cursorElement = (\n        this.collaboration.renderCursor ?? CursorPlugin.defaultCursorRender\n      )(user);\n\n      if (this.collaboration.showCursorLabels !== \"always\") {\n        cursorElement.addEventListener(\"mouseenter\", () => {\n          const cursor = this.recentlyUpdatedCursors.get(clientID)!;\n          cursor.element.setAttribute(\"data-active\", \"\");\n\n          if (cursor.hideTimeout) {\n            clearTimeout(cursor.hideTimeout);\n            this.recentlyUpdatedCursors.set(clientID, {\n              element: cursor.element,\n              hideTimeout: undefined,\n            });\n          }\n        });\n\n        cursorElement.addEventListener(\"mouseleave\", () => {\n          const cursor = this.recentlyUpdatedCursors.get(clientID)!;\n\n          this.recentlyUpdatedCursors.set(clientID, {\n            element: cursor.element,\n            hideTimeout: setTimeout(() => {\n              cursor.element.removeAttribute(\"data-active\");\n            }, 2000),\n          });\n        });\n      }\n\n      cursorData = {\n        element: cursorElement,\n        hideTimeout: undefined,\n      };\n\n      this.recentlyUpdatedCursors.set(clientID, cursorData);\n    }\n\n    return cursorData.element;\n  };\n\n  public updateUser = (user: {\n    name: string;\n    color: string;\n    [key: string]: string;\n  }) => {\n    this.provider.awareness.setLocalStateField(\"user\", user);\n  };\n\n  /**\n   * Determine whether the foreground color should be white or black based on a provided background color\n   * Inspired by: https://stackoverflow.com/a/3943023\n   *\n   */\n  public static isDarkColor(bgColor: string): boolean {\n    const color = bgColor.charAt(0) === \"#\" ? bgColor.substring(1, 7) : bgColor;\n    const r = parseInt(color.substring(0, 2), 16); // hexToR\n    const g = parseInt(color.substring(2, 4), 16); // hexToG\n    const b = parseInt(color.substring(4, 6), 16); // hexToB\n    const uicolors = [r / 255, g / 255, b / 255];\n    const c = uicolors.map((col) => {\n      if (col <= 0.03928) {\n        return col / 12.92;\n      }\n      return Math.pow((col + 0.055) / 1.055, 2.4);\n    });\n    const L = 0.2126 * c[0] + 0.7152 * c[1] + 0.0722 * c[2];\n    return L <= 0.179;\n  }\n\n  public static defaultCursorRender = (user: CollaborationUser) => {\n    const cursorElement = document.createElement(\"span\");\n\n    cursorElement.classList.add(\"bn-collaboration-cursor__base\");\n\n    const caretElement = document.createElement(\"span\");\n    caretElement.setAttribute(\"contentedEditable\", \"false\");\n    caretElement.classList.add(\"bn-collaboration-cursor__caret\");\n    caretElement.setAttribute(\n      \"style\",\n      `background-color: ${user.color}; color: ${\n        CursorPlugin.isDarkColor(user.color) ? \"white\" : \"black\"\n      }`,\n    );\n\n    const labelElement = document.createElement(\"span\");\n\n    labelElement.classList.add(\"bn-collaboration-cursor__label\");\n    labelElement.setAttribute(\n      \"style\",\n      `background-color: ${user.color}; color: ${\n        CursorPlugin.isDarkColor(user.color) ? \"white\" : \"black\"\n      }`,\n    );\n    labelElement.insertBefore(document.createTextNode(user.name), null);\n\n    caretElement.insertBefore(labelElement, null);\n\n    cursorElement.insertBefore(document.createTextNode(\"\\u2060\"), null); // Non-breaking space\n    cursorElement.insertBefore(caretElement, null);\n    cursorElement.insertBefore(document.createTextNode(\"\\u2060\"), null); // Non-breaking space\n\n    return cursorElement;\n  };\n}\n","import { ySyncPlugin } from \"y-prosemirror\";\nimport type * as Y from \"yjs\";\nimport { BlockNoteExtension } from \"../../editor/BlockNoteExtension.js\";\n\nexport class SyncPlugin extends BlockNoteExtension {\n  public static key() {\n    return \"ySyncPlugin\";\n  }\n\n  constructor(fragment: Y.XmlFragment) {\n    super();\n    this.addProsemirrorPlugin(ySyncPlugin(fragment));\n  }\n\n  public get priority() {\n    return 1001;\n  }\n}\n","import { yUndoPlugin } from \"y-prosemirror\";\nimport { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport { BlockNoteExtension } from \"../../editor/BlockNoteExtension.js\";\n\nexport class UndoPlugin extends BlockNoteExtension {\n  public static key() {\n    return \"yUndoPlugin\";\n  }\n\n  constructor({ editor }: { editor: BlockNoteEditor<any, any, any> }) {\n    super();\n    this.addProsemirrorPlugin(yUndoPlugin({ trackedOrigins: [editor] }));\n  }\n\n  public get priority() {\n    return 1000;\n  }\n}\n","import * as Y from \"yjs\";\n\nimport {\n  yCursorPluginKey,\n  ySyncPluginKey,\n  yUndoPluginKey,\n} from \"y-prosemirror\";\nimport { CursorPlugin } from \"./CursorPlugin.js\";\nimport { SyncPlugin } from \"./SyncPlugin.js\";\nimport { UndoPlugin } from \"./UndoPlugin.js\";\n\nimport {\n  BlockNoteEditor,\n  BlockNoteEditorOptions,\n} from \"../../editor/BlockNoteEditor.js\";\nimport { BlockNoteExtension } from \"../../editor/BlockNoteExtension.js\";\n\nexport class ForkYDocPlugin extends BlockNoteExtension<{\n  forked: boolean;\n}> {\n  public static key() {\n    return \"ForkYDocPlugin\";\n  }\n\n  private editor: BlockNoteEditor<any, any, any>;\n  private collaboration: BlockNoteEditorOptions<any, any, any>[\"collaboration\"];\n\n  constructor({\n    editor,\n    collaboration,\n  }: {\n    editor: BlockNoteEditor<any, any, any>;\n    collaboration: BlockNoteEditorOptions<any, any, any>[\"collaboration\"];\n  }) {\n    super(editor);\n    this.editor = editor;\n    this.collaboration = collaboration;\n  }\n\n  /**\n   * To find a fragment in another ydoc, we need to search for it.\n   */\n  private findTypeInOtherYdoc<T extends Y.AbstractType<any>>(\n    ytype: T,\n    otherYdoc: Y.Doc,\n  ): T {\n    const ydoc = ytype.doc!;\n    if (ytype._item === null) {\n      /**\n       * If is a root type, we need to find the root key in the original ydoc\n       * and use it to get the type in the other ydoc.\n       */\n      const rootKey = Array.from(ydoc.share.keys()).find(\n        (key) => ydoc.share.get(key) === ytype,\n      );\n      if (rootKey == null) {\n        throw new Error(\"type does not exist in other ydoc\");\n      }\n      return otherYdoc.get(rootKey, ytype.constructor as new () => T) as T;\n    } else {\n      /**\n       * If it is a sub type, we use the item id to find the history type.\n       */\n      const ytypeItem = ytype._item;\n      const otherStructs =\n        otherYdoc.store.clients.get(ytypeItem.id.client) ?? [];\n      const itemIndex = Y.findIndexSS(otherStructs, ytypeItem.id.clock);\n      const otherItem = otherStructs[itemIndex] as Y.Item;\n      const otherContent = otherItem.content as Y.ContentType;\n      return otherContent.type as T;\n    }\n  }\n\n  /**\n   * Whether the editor is editing a forked document,\n   * preserving a reference to the original document and the forked document.\n   */\n  public get isForkedFromRemote() {\n    return this.forkedState !== undefined;\n  }\n\n  /**\n   * Stores whether the editor is editing a forked document,\n   * preserving a reference to the original document and the forked document.\n   */\n  private forkedState:\n    | {\n        originalFragment: Y.XmlFragment;\n        undoStack: Y.UndoManager[\"undoStack\"];\n        forkedFragment: Y.XmlFragment;\n      }\n    | undefined;\n\n  /**\n   * Fork the Y.js document from syncing to the remote,\n   * allowing modifications to the document without affecting the remote.\n   * These changes can later be rolled back or applied to the remote.\n   */\n  public fork() {\n    if (this.isForkedFromRemote) {\n      return;\n    }\n\n    const originalFragment = this.collaboration?.fragment;\n\n    if (!originalFragment) {\n      throw new Error(\"No fragment to fork from\");\n    }\n\n    const doc = new Y.Doc();\n    // Copy the original document to a new Yjs document\n    Y.applyUpdate(doc, Y.encodeStateAsUpdate(originalFragment.doc!));\n\n    // Find the forked fragment in the new Yjs document\n    const forkedFragment = this.findTypeInOtherYdoc(originalFragment, doc);\n\n    this.forkedState = {\n      undoStack: yUndoPluginKey.getState(this.editor.prosemirrorState)!\n        .undoManager.undoStack,\n      originalFragment,\n      forkedFragment,\n    };\n\n    // Need to reset all the yjs plugins\n    this.editor._tiptapEditor.unregisterPlugin([\n      yCursorPluginKey,\n      yUndoPluginKey,\n      ySyncPluginKey,\n    ]);\n    // Register them again, based on the new forked fragment\n    this.editor._tiptapEditor.registerPlugin(\n      new SyncPlugin(forkedFragment).plugins[0],\n    );\n    this.editor._tiptapEditor.registerPlugin(\n      new UndoPlugin({ editor: this.editor }).plugins[0],\n    );\n    // No need to register the cursor plugin again, it's a local fork\n    this.emit(\"forked\", true);\n  }\n\n  /**\n   * Resume syncing the Y.js document to the remote\n   * If `keepChanges` is true, any changes that have been made to the forked document will be applied to the original document.\n   * Otherwise, the original document will be restored and the changes will be discarded.\n   */\n  public merge({ keepChanges }: { keepChanges: boolean }) {\n    if (!this.forkedState) {\n      return;\n    }\n    // Remove the forked fragment's plugins\n    this.editor._tiptapEditor.unregisterPlugin(ySyncPluginKey);\n    this.editor._tiptapEditor.unregisterPlugin(yUndoPluginKey);\n\n    const { originalFragment, forkedFragment, undoStack } = this.forkedState;\n    this.editor.extensions[\"ySyncPlugin\"] = new SyncPlugin(originalFragment);\n    this.editor.extensions[\"yCursorPlugin\"] = new CursorPlugin(\n      this.collaboration!,\n    );\n    this.editor.extensions[\"yUndoPlugin\"] = new UndoPlugin({\n      editor: this.editor,\n    });\n\n    // Register the plugins again, based on the original fragment\n    this.editor._tiptapEditor.registerPlugin(\n      this.editor.extensions[\"ySyncPlugin\"].plugins[0],\n    );\n    this.editor._tiptapEditor.registerPlugin(\n      this.editor.extensions[\"yCursorPlugin\"].plugins[0],\n    );\n    this.editor._tiptapEditor.registerPlugin(\n      this.editor.extensions[\"yUndoPlugin\"].plugins[0],\n    );\n\n    // Reset the undo stack to the original undo stack\n    yUndoPluginKey.getState(\n      this.editor.prosemirrorState,\n    )!.undoManager.undoStack = undoStack;\n\n    if (keepChanges) {\n      // Apply any changes that have been made to the fork, onto the original doc\n      const update = Y.encodeStateAsUpdate(\n        forkedFragment.doc!,\n        Y.encodeStateVector(originalFragment.doc!),\n      );\n      // Applying this change will add to the undo stack, allowing it to be undone normally\n      Y.applyUpdate(originalFragment.doc!, update, this.editor);\n    }\n    // Reset the forked state\n    this.forkedState = undefined;\n    this.emit(\"forked\", false);\n  }\n}\n","import * as Y from \"yjs\";\n\nimport { MigrationRule } from \"./migrationRule.js\";\nimport { defaultProps } from \"../../../../blocks/defaultProps.js\";\n\n// Helper function to recursively traverse a `Y.XMLElement` and its descendant\n// elements.\nconst traverseElement = (\n  rootElement: Y.XmlElement,\n  cb: (element: Y.XmlElement) => void,\n) => {\n  cb(rootElement);\n  rootElement.forEach((element) => {\n    if (element instanceof Y.XmlElement) {\n      traverseElement(element, cb);\n    }\n  });\n};\n\n// Moves `textColor` and `backgroundColor` attributes from `blockContainer`\n// nodes to their child `blockContent` nodes. This is due to a schema change\n// introduced in PR #TODO.\nexport const moveColorAttributes: MigrationRule = (fragment, tr) => {\n  // Stores necessary info for all `blockContainer` nodes which still have\n  // `textColor` or `backgroundColor` attributes that need to be moved.\n  const targetBlockContainers: Record<\n    string,\n    {\n      textColor?: string;\n      backgroundColor?: string;\n    }\n  > = {};\n\n  // Finds all elements which still have `textColor` or `backgroundColor`\n  // attributes in the current Yjs fragment.\n  fragment.forEach((element) => {\n    if (element instanceof Y.XmlElement) {\n      traverseElement(element, (element) => {\n        if (\n          element.nodeName === \"blockContainer\" &&\n          element.hasAttribute(\"id\")\n        ) {\n          const colors = {\n            textColor: element.getAttribute(\"textColor\"),\n            backgroundColor: element.getAttribute(\"backgroundColor\"),\n          };\n\n          if (colors.textColor === defaultProps.textColor.default) {\n            colors.textColor = undefined;\n          }\n          if (colors.backgroundColor === defaultProps.backgroundColor.default) {\n            colors.backgroundColor = undefined;\n          }\n\n          if (colors.textColor || colors.backgroundColor) {\n            targetBlockContainers[element.getAttribute(\"id\")!] = colors;\n          }\n        }\n      });\n    }\n  });\n\n  // Appends transactions to add the `textColor` and `backgroundColor`\n  // attributes found on each `blockContainer` node to move them to the child\n  // `blockContent` node.\n  tr.doc.descendants((node, pos) => {\n    if (\n      node.type.name === \"blockContainer\" &&\n      targetBlockContainers[node.attrs.id]\n    ) {\n      tr = tr.setNodeMarkup(\n        pos + 1,\n        undefined,\n        targetBlockContainers[node.attrs.id],\n      );\n    }\n  });\n};\n","import { MigrationRule } from \"./migrationRule.js\";\nimport { moveColorAttributes } from \"./moveColorAttributes.js\";\n\nexport default [moveColorAttributes] as MigrationRule[];\n","import { Plugin, PluginKey } from \"@tiptap/pm/state\";\nimport { ySyncPluginKey } from \"y-prosemirror\";\nimport * as Y from \"yjs\";\n\nimport { BlockNoteExtension } from \"../../../editor/BlockNoteExtension.js\";\nimport migrationRules from \"./migrationRules/index.js\";\n\n// This plugin allows us to update collaboration YDocs whenever BlockNote's\n// underlying ProseMirror schema changes. The plugin reads the current Yjs\n// fragment and dispatches additional transactions to the ProseMirror state, in\n// case things are found in the fragment that don't adhere to the editor schema\n// and need to be fixed. These fixes are defined as `MigrationRule`s within the\n// `migrationRules` directory.\nexport class SchemaMigrationPlugin extends BlockNoteExtension {\n  private migrationDone = false;\n\n  public static key() {\n    return \"schemaMigrationPlugin\";\n  }\n\n  constructor(fragment: Y.XmlFragment) {\n    const pluginKey = new PluginKey(SchemaMigrationPlugin.key());\n\n    super();\n    this.addProsemirrorPlugin(\n      new Plugin({\n        key: pluginKey,\n        appendTransaction: (transactions, _oldState, newState) => {\n          if (this.migrationDone) {\n            return undefined;\n          }\n\n          if (\n            transactions.length !== 1 ||\n            !transactions[0].getMeta(ySyncPluginKey)\n          ) {\n            return undefined;\n          }\n\n          const tr = newState.tr;\n          for (const migrationRule of migrationRules) {\n            migrationRule(fragment, tr);\n          }\n\n          this.migrationDone = true;\n\n          return tr;\n        },\n      }),\n    );\n  }\n}\n","import { Mark, mergeAttributes } from \"@tiptap/core\";\n\nexport const CommentMark = Mark.create({\n  name: \"comment\",\n  excludes: \"\",\n  inclusive: false,\n  keepOnSplit: true,\n\n  addAttributes() {\n    // Return an object with attribute configuration\n    return {\n      // orphans are marks that currently don't have an active thread. It could be\n      // that users have resolved the thread. Resolved threads by default are not shown in the document,\n      // but we need to keep the mark (positioning) data so we can still \"revive\" it when the thread is unresolved\n      // or we enter a \"comments\" view that includes resolved threads.\n      orphan: {\n        parseHTML: (element) => !!element.getAttribute(\"data-orphan\"),\n        renderHTML: (attributes) => {\n          return (attributes as { orphan: boolean }).orphan\n            ? {\n                \"data-orphan\": \"true\",\n              }\n            : {};\n        },\n        default: false,\n      },\n      threadId: {\n        parseHTML: (element) => element.getAttribute(\"data-bn-thread-id\"),\n        renderHTML: (attributes) => {\n          return {\n            \"data-bn-thread-id\": (attributes as { threadId: string }).threadId,\n          };\n        },\n        default: \"\",\n      },\n    };\n  },\n\n  renderHTML({ HTMLAttributes }: { HTMLAttributes: Record<string, any> }) {\n    return [\n      \"span\",\n      mergeAttributes(HTMLAttributes, {\n        class: \"bn-thread-mark\",\n      }),\n    ];\n  },\n\n  parseHTML() {\n    return [{ tag: \"span.bn-thread-mark\" }];\n  },\n\n  extendMarkSchema(extension) {\n    if (extension.name === \"comment\") {\n      return {\n        blocknoteIgnore: true,\n      };\n    }\n    return {};\n  },\n});\n","import type { User } from \"../../../comments/index.js\";\nimport { EventEmitter } from \"../../../util/EventEmitter.js\";\n\n/**\n * The `UserStore` is used to retrieve and cache information about users.\n *\n * It does this by calling `resolveUsers` (which is user-defined in the Editor Options)\n * for users that are not yet cached.\n */\nexport class UserStore<U extends User> extends EventEmitter<any> {\n  private userCache: Map<string, U> = new Map();\n\n  // avoid duplicate loads\n  private loadingUsers = new Set<string>();\n\n  public constructor(\n    private readonly resolveUsers: (userIds: string[]) => Promise<U[]>,\n  ) {\n    super();\n  }\n\n  /**\n   * Load information about users based on an array of user ids.\n   */\n  public async loadUsers(userIds: string[]) {\n    const missingUsers = userIds.filter(\n      (id) => !this.userCache.has(id) && !this.loadingUsers.has(id),\n    );\n\n    if (missingUsers.length === 0) {\n      return;\n    }\n\n    for (const id of missingUsers) {\n      this.loadingUsers.add(id);\n    }\n\n    try {\n      const users = await this.resolveUsers(missingUsers);\n      for (const user of users) {\n        this.userCache.set(user.id, user);\n      }\n      this.emit(\"update\", this.userCache);\n    } finally {\n      for (const id of missingUsers) {\n        // delete the users from the loading set\n        // on a next call to `loadUsers` we will either\n        // return the cached user or retry loading the user if the request failed failed\n        this.loadingUsers.delete(id);\n      }\n    }\n  }\n\n  /**\n   * Retrieve information about a user based on their id, if cached.\n   *\n   * The user will have to be loaded via `loadUsers` first\n   */\n  public getUser(userId: string): U | undefined {\n    return this.userCache.get(userId);\n  }\n\n  /**\n   * Subscribe to changes in the user store.\n   *\n   * @param cb - The callback to call when the user store changes.\n   * @returns A function to unsubscribe from the user store.\n   */\n  public subscribe(cb: (users: Map<string, U>) => void): () => void {\n    return this.on(\"update\", cb);\n  }\n}\n","import { Node } from \"prosemirror-model\";\nimport { Plugin, PluginKey } from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\nimport { getRelativeSelection, ySyncPluginKey } from \"y-prosemirror\";\nimport type {\n  CommentBody,\n  ThreadData,\n  ThreadStore,\n  User,\n} from \"../../comments/index.js\";\nimport { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport { BlockNoteExtension } from \"../../editor/BlockNoteExtension.js\";\nimport { CustomBlockNoteSchema } from \"../../schema/schema.js\";\nimport { UserStore } from \"./userstore/UserStore.js\";\n\nconst PLUGIN_KEY = new PluginKey(`blocknote-comments`);\nconst SET_SELECTED_THREAD_ID = \"SET_SELECTED_THREAD_ID\";\n\ntype CommentsPluginState = {\n  /**\n   * Decorations to be rendered, specifically to indicate the selected thread\n   */\n  decorations: DecorationSet;\n};\n\n/**\n * Calculate the thread positions from the current document state\n */\nfunction getUpdatedThreadPositions(doc: Node, markType: string) {\n  const threadPositions = new Map<string, { from: number; to: number }>();\n\n  // find all thread marks and store their position + create decoration for selected thread\n  doc.descendants((node, pos) => {\n    node.marks.forEach((mark) => {\n      if (mark.type.name === markType) {\n        const thisThreadId = (mark.attrs as { threadId: string | undefined })\n          .threadId;\n        if (!thisThreadId) {\n          return;\n        }\n        const from = pos;\n        const to = from + node.nodeSize;\n\n        // FloatingThreads component uses \"to\" as the position, so always store the largest \"to\" found\n        // AnchoredThreads component uses \"from\" as the position, so always store the smallest \"from\" found\n        const currentPosition = threadPositions.get(thisThreadId) ?? {\n          from: Infinity,\n          to: 0,\n        };\n        threadPositions.set(thisThreadId, {\n          from: Math.min(from, currentPosition.from),\n          to: Math.max(to, currentPosition.to),\n        });\n      }\n    });\n  });\n  return threadPositions;\n}\n\nexport class CommentsPlugin extends BlockNoteExtension {\n  public static key() {\n    return \"comments\";\n  }\n\n  public readonly userStore: UserStore<User>;\n\n  /**\n   * Whether a comment is currently being composed\n   */\n  private pendingComment = false;\n\n  /**\n   * The currently selected thread id\n   */\n  private selectedThreadId: string | undefined;\n\n  /**\n   * Store the positions of all threads in the document.\n   * this can be used later to implement a floating sidebar\n   */\n  private threadPositions: Map<string, { from: number; to: number }> =\n    new Map();\n\n  private emitStateUpdate() {\n    this.emit(\"update\", {\n      selectedThreadId: this.selectedThreadId,\n      pendingComment: this.pendingComment,\n      threadPositions: this.threadPositions,\n    });\n  }\n\n  /**\n   * when a thread is resolved or deleted, we need to update the marks to reflect the new state\n   */\n  private updateMarksFromThreads = (threads: Map<string, ThreadData>) => {\n    this.editor.transact((tr) => {\n      tr.doc.descendants((node, pos) => {\n        node.marks.forEach((mark) => {\n          if (mark.type.name === this.markType) {\n            const markType = mark.type;\n            const markThreadId = mark.attrs.threadId;\n            const thread = threads.get(markThreadId);\n            const isOrphan = !!(!thread || thread.resolved || thread.deletedAt);\n\n            if (isOrphan !== mark.attrs.orphan) {\n              const trimmedFrom = Math.max(pos, 0);\n              const trimmedTo = Math.min(\n                pos + node.nodeSize,\n                tr.doc.content.size - 1,\n                tr.doc.content.size - 1,\n              );\n              tr.removeMark(trimmedFrom, trimmedTo, mark);\n              tr.addMark(\n                trimmedFrom,\n                trimmedTo,\n                markType.create({\n                  ...mark.attrs,\n                  orphan: isOrphan,\n                }),\n              );\n\n              if (isOrphan && this.selectedThreadId === markThreadId) {\n                // unselect\n                this.selectedThreadId = undefined;\n                this.emitStateUpdate();\n              }\n            }\n          }\n        });\n      });\n    });\n  };\n\n  constructor(\n    private readonly editor: BlockNoteEditor<any, any, any>,\n    public readonly threadStore: ThreadStore,\n    private readonly markType: string,\n    public readonly resolveUsers:\n      | undefined\n      | ((userIds: string[]) => Promise<User[]>),\n    public readonly commentEditorSchema?: CustomBlockNoteSchema<any, any, any>,\n  ) {\n    super();\n\n    if (!resolveUsers) {\n      throw new Error(\"resolveUsers is required for comments\");\n    }\n    this.userStore = new UserStore<User>(resolveUsers);\n\n    // Note: Plugins are currently not destroyed when the editor is destroyed.\n    // We should unsubscribe from the threadStore when the editor is destroyed.\n    this.threadStore.subscribe(this.updateMarksFromThreads);\n\n    editor.onCreate(() => {\n      // Need to wait for TipTap editor state to be initialized\n      this.updateMarksFromThreads(this.threadStore.getThreads());\n      editor.onSelectionChange(() => {\n        if (this.pendingComment) {\n          this.pendingComment = false;\n          this.emitStateUpdate();\n        }\n      });\n    });\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n\n    this.addProsemirrorPlugin(\n      new Plugin<CommentsPluginState>({\n        key: PLUGIN_KEY,\n        state: {\n          init() {\n            return {\n              decorations: DecorationSet.empty,\n            };\n          },\n          apply(tr, state) {\n            const action = tr.getMeta(PLUGIN_KEY);\n\n            if (!tr.docChanged && !action) {\n              return state;\n            }\n\n            // only update threadPositions if the doc changed\n            const threadPositions = tr.docChanged\n              ? getUpdatedThreadPositions(tr.doc, self.markType)\n              : self.threadPositions;\n\n            if (threadPositions.size > 0 || self.threadPositions.size > 0) {\n              // small optimization; don't emit event if threadPositions before / after were both empty\n              self.threadPositions = threadPositions;\n              self.emitStateUpdate();\n            }\n\n            // update decorations if doc or selected thread changed\n            const decorations = [];\n\n            if (self.selectedThreadId) {\n              const selectedThreadPosition = threadPositions.get(\n                self.selectedThreadId,\n              );\n\n              if (selectedThreadPosition) {\n                decorations.push(\n                  Decoration.inline(\n                    selectedThreadPosition.from,\n                    selectedThreadPosition.to,\n                    {\n                      class: \"bn-thread-mark-selected\",\n                    },\n                  ),\n                );\n              }\n            }\n\n            return {\n              decorations: DecorationSet.create(tr.doc, decorations),\n            };\n          },\n        },\n        props: {\n          decorations(state) {\n            return (\n              PLUGIN_KEY.getState(state)?.decorations ?? DecorationSet.empty\n            );\n          },\n          /**\n           * Handle click on a thread mark and mark it as selected\n           */\n          handleClick: (view, pos, event) => {\n            if (event.button !== 0) {\n              return;\n            }\n\n            const node = view.state.doc.nodeAt(pos);\n\n            if (!node) {\n              self.selectThread(undefined);\n              return;\n            }\n\n            const commentMark = node.marks.find(\n              (mark) =>\n                mark.type.name === markType && mark.attrs.orphan !== true,\n            );\n\n            const threadId = commentMark?.attrs.threadId as string | undefined;\n            self.selectThread(threadId, false);\n          },\n        },\n      }),\n    );\n  }\n\n  /**\n   * Subscribe to state updates\n   */\n  public onUpdate(\n    callback: (state: {\n      pendingComment: boolean;\n      selectedThreadId: string | undefined;\n      threadPositions: Map<string, { from: number; to: number }>;\n    }) => void,\n  ) {\n    return this.on(\"update\", callback);\n  }\n\n  /**\n   * Set the selected thread\n   */\n  public selectThread(threadId: string | undefined, scrollToThread = true) {\n    if (this.selectedThreadId === threadId) {\n      return;\n    }\n    this.selectedThreadId = threadId;\n    this.emitStateUpdate();\n    this.editor.transact((tr) =>\n      tr.setMeta(PLUGIN_KEY, {\n        name: SET_SELECTED_THREAD_ID,\n      }),\n    );\n\n    if (threadId && scrollToThread) {\n      const selectedThreadPosition = this.threadPositions.get(threadId);\n\n      if (!selectedThreadPosition) {\n        return;\n      }\n\n      // When a new thread is selected, scrolls the page to its reference text in\n      // the editor.\n      (\n        this.editor.prosemirrorView?.domAtPos(selectedThreadPosition.from)\n          .node as Element | undefined\n      )?.scrollIntoView({\n        behavior: \"smooth\",\n        block: \"center\",\n      });\n    }\n  }\n\n  /**\n   * Start a pending comment (e.g.: when clicking the \"Add comment\" button)\n   */\n  public startPendingComment() {\n    this.pendingComment = true;\n    this.emitStateUpdate();\n  }\n\n  /**\n   * Stop a pending comment (e.g.: user closes the comment composer)\n   */\n  public stopPendingComment() {\n    this.pendingComment = false;\n    this.emitStateUpdate();\n  }\n\n  /**\n   * Create a thread at the current selection\n   */\n  public async createThread(options: {\n    initialComment: {\n      body: CommentBody;\n      metadata?: any;\n    };\n    metadata?: any;\n  }) {\n    const thread = await this.threadStore.createThread(options);\n\n    if (this.threadStore.addThreadToDocument) {\n      // creating the mark is handled by the store\n      // this is useful if we don't have write-access to the document.\n      // We can then offload the responsibility of creating the mark to the server.\n      // (e.g.: RESTYjsThreadStore)\n      const view = this.editor.prosemirrorView!;\n      const pmSelection = view.state.selection;\n\n      const ystate = ySyncPluginKey.getState(view.state);\n\n      const selection = {\n        prosemirror: {\n          head: pmSelection.head,\n          anchor: pmSelection.anchor,\n        },\n        yjs: ystate\n          ? getRelativeSelection(ystate.binding, view.state)\n          : undefined, // if we're not using yjs\n      };\n\n      await this.threadStore.addThreadToDocument({\n        threadId: thread.id,\n        selection,\n      });\n    } else {\n      // we create the mark directly in the document\n      this.editor._tiptapEditor.commands.setMark(this.markType, {\n        orphan: false,\n        threadId: thread.id,\n      });\n    }\n  }\n}\n","import { EditorState, Plugin, PluginKey, PluginView } from \"prosemirror-state\";\nimport { EditorView } from \"prosemirror-view\";\n\nimport { ySyncPluginKey } from \"y-prosemirror\";\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport { BlockNoteExtension } from \"../../editor/BlockNoteExtension.js\";\nimport { UiElementPosition } from \"../../extensions-shared/UiElementPosition.js\";\nimport type {\n  BlockFromConfig,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\n\nexport type FilePanelState<\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n> = UiElementPosition & {\n  // TODO: This typing is not quite right (children should be from BSchema)\n  block: BlockFromConfig<any, I, S>;\n};\n\nexport class FilePanelView<I extends InlineContentSchema, S extends StyleSchema>\n  implements PluginView\n{\n  public state?: FilePanelState<I, S>;\n  public emitUpdate: () => void;\n\n  constructor(\n    private readonly editor: BlockNoteEditor<Record<string, any>, I, S>,\n    private readonly pluginKey: PluginKey<FilePanelState<I, S>>,\n    private readonly pmView: EditorView,\n    emitUpdate: (state: FilePanelState<I, S>) => void,\n  ) {\n    this.emitUpdate = () => {\n      if (!this.state) {\n        throw new Error(\"Attempting to update uninitialized file panel\");\n      }\n\n      emitUpdate(this.state);\n    };\n\n    pmView.dom.addEventListener(\"mousedown\", this.mouseDownHandler);\n    pmView.dom.addEventListener(\"dragstart\", this.dragstartHandler);\n\n    // Setting capture=true ensures that any parent container of the editor that\n    // gets scrolled will trigger the scroll event. Scroll events do not bubble\n    // and so won't propagate to the document by default.\n    pmView.root.addEventListener(\"scroll\", this.scrollHandler, true);\n  }\n\n  mouseDownHandler = () => {\n    if (this.state?.show) {\n      this.state.show = false;\n      this.emitUpdate();\n    }\n  };\n\n  // For dragging the whole editor.\n  dragstartHandler = () => {\n    if (this.state?.show) {\n      this.state.show = false;\n      this.emitUpdate();\n    }\n  };\n\n  scrollHandler = () => {\n    if (this.state?.show) {\n      const blockElement = this.pmView.root.querySelector(\n        `[data-node-type=\"blockContainer\"][data-id=\"${this.state.block.id}\"]`,\n      );\n      if (!blockElement) {\n        return;\n      }\n      this.state.referencePos = blockElement.getBoundingClientRect();\n      this.emitUpdate();\n    }\n  };\n\n  update(view: EditorView, prevState: EditorState) {\n    const pluginState = this.pluginKey.getState(view.state);\n    const prevPluginState = this.pluginKey.getState(prevState);\n\n    if (!this.state?.show && pluginState?.block && this.editor.isEditable) {\n      const blockElement = this.pmView.root.querySelector(\n        `[data-node-type=\"blockContainer\"][data-id=\"${pluginState.block.id}\"]`,\n      );\n      if (!blockElement) {\n        return;\n      }\n      this.state = {\n        show: true,\n        referencePos: blockElement.getBoundingClientRect(),\n        block: pluginState.block,\n      };\n\n      this.emitUpdate();\n\n      return;\n    }\n\n    const isOpening = pluginState?.block && !prevPluginState?.block;\n    const isClosing = !pluginState?.block && prevPluginState?.block;\n    if (isOpening && this.state && !this.state.show) {\n      this.state.show = true;\n      this.emitUpdate();\n    }\n    if (isClosing && this.state?.show) {\n      this.state.show = false;\n      this.emitUpdate();\n    }\n  }\n\n  closeMenu = () => {\n    if (this.state?.show) {\n      this.state.show = false;\n      this.emitUpdate();\n    }\n  };\n\n  destroy() {\n    this.pmView.dom.removeEventListener(\"mousedown\", this.mouseDownHandler);\n\n    this.pmView.dom.removeEventListener(\"dragstart\", this.dragstartHandler);\n\n    this.pmView.root.removeEventListener(\"scroll\", this.scrollHandler, true);\n  }\n}\n\nconst filePanelPluginKey = new PluginKey<FilePanelState<any, any>>(\n  \"FilePanelPlugin\",\n);\n\nexport class FilePanelProsemirrorPlugin<\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n> extends BlockNoteExtension {\n  public static key() {\n    return \"filePanel\";\n  }\n\n  private view: FilePanelView<I, S> | undefined;\n\n  constructor(editor: BlockNoteEditor<Record<string, any>, I, S>) {\n    super();\n    this.addProsemirrorPlugin(\n      new Plugin<{\n        block: BlockFromConfig<any, I, S> | undefined;\n      }>({\n        key: filePanelPluginKey,\n        view: (editorView) => {\n          this.view = new FilePanelView<I, S>(\n            editor,\n            filePanelPluginKey as any,\n            editorView,\n            (state) => {\n              this.emit(\"update\", state);\n            },\n          );\n          return this.view;\n        },\n        props: {\n          handleKeyDown: (_view, event: KeyboardEvent) => {\n            if (event.key === \"Escape\" && this.shown) {\n              this.view?.closeMenu();\n              return true;\n            }\n            return false;\n          },\n        },\n        state: {\n          init: () => {\n            return {\n              block: undefined,\n            };\n          },\n          apply: (transaction, prev) => {\n            const state: FilePanelState<I, S> | undefined =\n              transaction.getMeta(filePanelPluginKey);\n\n            if (state) {\n              return state;\n            }\n\n            if (\n              !transaction.getMeta(ySyncPluginKey) &&\n              (transaction.selectionSet || transaction.docChanged)\n            ) {\n              return { block: undefined };\n            }\n            return prev;\n          },\n        },\n      }),\n    );\n  }\n\n  public get shown() {\n    return this.view?.state?.show || false;\n  }\n\n  public onUpdate(callback: (state: FilePanelState<I, S>) => void) {\n    return this.on(\"update\", callback);\n  }\n\n  public closeMenu = () => this.view?.closeMenu();\n}\n","import { isNodeSelection, isTextSelection, posToDOMRect } from \"@tiptap/core\";\nimport {\n  EditorState,\n  Plugin,\n  PluginKey,\n  PluginView,\n  TextSelection,\n} from \"prosemirror-state\";\nimport { EditorView } from \"prosemirror-view\";\n\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport { BlockNoteExtension } from \"../../editor/BlockNoteExtension.js\";\nimport { UiElementPosition } from \"../../extensions-shared/UiElementPosition.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\n\nexport type FormattingToolbarState = UiElementPosition;\n\nexport class FormattingToolbarView implements PluginView {\n  public state?: FormattingToolbarState;\n  public emitUpdate: () => void;\n\n  public preventHide = false;\n  public preventShow = false;\n\n  public shouldShow: (props: {\n    view: EditorView;\n    state: EditorState;\n    from: number;\n    to: number;\n  }) => boolean = ({ view, state, from, to }) => {\n    const { doc, selection } = state;\n    const { empty } = selection;\n\n    // Sometime check for `empty` is not enough.\n    // Doubleclick an empty paragraph returns a node size of 2.\n    // So we check also for an empty text size.\n    const isEmptyTextBlock =\n      !doc.textBetween(from, to).length && isTextSelection(state.selection);\n\n    // Don't show toolbar inside code blocks\n    if (\n      selection.$from.parent.type.spec.code ||\n      (isNodeSelection(selection) && selection.node.type.spec.code)\n    ) {\n      return false;\n    }\n\n    if (empty || isEmptyTextBlock) {\n      return false;\n    }\n\n    const focusedElement = document.activeElement;\n    if (!this.isElementWithinEditorWrapper(focusedElement) && view.editable) {\n      // editable editors must have focus for the toolbar to show\n      return false;\n    }\n    return true;\n  };\n\n  constructor(\n    private readonly editor: BlockNoteEditor<\n      BlockSchema,\n      InlineContentSchema,\n      StyleSchema\n    >,\n    private readonly pmView: EditorView,\n    emitUpdate: (state: FormattingToolbarState) => void,\n  ) {\n    this.emitUpdate = () => {\n      if (!this.state) {\n        throw new Error(\n          \"Attempting to update uninitialized formatting toolbar\",\n        );\n      }\n\n      emitUpdate(this.state);\n    };\n\n    pmView.dom.addEventListener(\"mousedown\", this.viewMousedownHandler);\n    pmView.root.addEventListener(\"mouseup\", this.mouseupHandler);\n    pmView.dom.addEventListener(\"dragstart\", this.dragHandler);\n    pmView.dom.addEventListener(\"dragover\", this.dragHandler);\n    pmView.dom.addEventListener(\"blur\", this.blurHandler);\n\n    // Setting capture=true ensures that any parent container of the editor that\n    // gets scrolled will trigger the scroll event. Scroll events do not bubble\n    // and so won't propagate to the document by default.\n    pmView.root.addEventListener(\"scroll\", this.scrollHandler, true);\n  }\n\n  blurHandler = (event: FocusEvent) => {\n    if (this.preventHide) {\n      this.preventHide = false;\n\n      return;\n    }\n\n    const editorWrapper = this.pmView.dom.parentElement!;\n\n    // Checks if the focus is moving to an element outside the editor. If it is,\n    // the toolbar is hidden.\n    if (\n      // An element is clicked.\n      event &&\n      event.relatedTarget &&\n      // Element is inside the editor.\n      (editorWrapper === (event.relatedTarget as Node) ||\n        editorWrapper.contains(event.relatedTarget as Node) ||\n        (event.relatedTarget as HTMLElement).matches(\n          \".bn-ui-container, .bn-ui-container *\",\n        ))\n    ) {\n      return;\n    }\n\n    if (this.state?.show) {\n      this.state.show = false;\n      this.emitUpdate();\n    }\n  };\n\n  isElementWithinEditorWrapper = (element: Node | null) => {\n    if (!element) {\n      return false;\n    }\n    const editorWrapper = this.pmView.dom.parentElement!;\n    if (!editorWrapper) {\n      return false;\n    }\n\n    return editorWrapper.contains(element);\n  };\n\n  viewMousedownHandler = (e: MouseEvent) => {\n    if (\n      !this.isElementWithinEditorWrapper(e.target as Node) ||\n      e.button === 0\n    ) {\n      this.preventShow = true;\n    }\n  };\n\n  mouseupHandler = () => {\n    if (this.preventShow) {\n      this.preventShow = false;\n      setTimeout(() => this.update(this.pmView));\n    }\n  };\n\n  // For dragging the whole editor.\n  dragHandler = () => {\n    if (this.state?.show) {\n      this.state.show = false;\n      this.emitUpdate();\n    }\n  };\n\n  scrollHandler = () => {\n    if (this.state?.show) {\n      this.state.referencePos = this.getSelectionBoundingBox();\n      this.emitUpdate();\n    }\n  };\n\n  update(view: EditorView, oldState?: EditorState) {\n    // Delays the update to handle edge case with drag and drop, where the view\n    // is blurred asynchronously and happens only after the state update.\n    // Wrapping in a setTimeout gives enough time to wait for the blur event to\n    // occur before updating the toolbar.\n    const { state, composing } = view;\n    const { doc, selection } = state;\n    const isSame =\n      oldState && oldState.doc.eq(doc) && oldState.selection.eq(selection);\n\n    if (composing || isSame) {\n      return;\n    }\n\n    // support for CellSelections\n    const { ranges } = selection;\n    const from = Math.min(...ranges.map((range) => range.$from.pos));\n    const to = Math.max(...ranges.map((range) => range.$to.pos));\n\n    const shouldShow = this.shouldShow({\n      view,\n      state,\n      from,\n      to,\n    });\n\n    // in jsdom, Range.prototype.getClientRects is not implemented,\n    // this would cause `getSelectionBoundingBox` to fail\n    // we can just ignore jsdom for now and not show the toolbar\n    const jsdom = typeof Range.prototype.getClientRects === \"undefined\";\n\n    // Checks if menu should be shown/updated.\n    if (!this.preventShow && (shouldShow || this.preventHide) && !jsdom) {\n      // Unlike other UI elements, we don't prevent the formatting toolbar from\n      // showing when the editor is not editable. This is because some buttons,\n      // e.g. the download file button, should still be accessible. Therefore,\n      // logic for hiding when the editor is non-editable is handled\n      // individually in each button.\n      const newReferencePos = this.getSelectionBoundingBox();\n\n      // Workaround to ensure the correct reference position when rendering\n      // React components. Without this, e.g. updating styles on React inline\n      // content causes the formatting toolbar to be in the wrong place. We\n      // know the component has not yet rendered if the reference position has\n      // zero dimensions.\n      if (newReferencePos.height === 0 && newReferencePos.width === 0) {\n        // Updates the reference position again following the render.\n        queueMicrotask(() => {\n          const nextState = {\n            show: true,\n            referencePos: this.getSelectionBoundingBox(),\n          };\n\n          this.state = nextState;\n          this.emitUpdate();\n\n          // For some reason, while the selection doesn't actually change and\n          // remains correct, it visually appears to be collapsed. This forces\n          // a ProseMirror view update, which fixes the issue.\n          view.dispatch(\n            view.state.tr.setSelection(\n              TextSelection.create(\n                view.state.doc,\n                view.state.selection.from + 1,\n                view.state.selection.to,\n              ),\n            ),\n          );\n          // 2 separate `dispatch` calls are needed, else ProseMirror realizes\n          // that the transaction is a no-op and doesn't update the view.\n          view.dispatch(\n            view.state.tr.setSelection(\n              TextSelection.create(\n                view.state.doc,\n                view.state.selection.from - 1,\n                view.state.selection.to,\n              ),\n            ),\n          );\n        });\n\n        return;\n      }\n\n      const nextState = {\n        show: true,\n        referencePos: this.getSelectionBoundingBox(),\n      };\n\n      if (\n        nextState.show !== this.state?.show ||\n        nextState.referencePos.toJSON() !== this.state?.referencePos.toJSON()\n      ) {\n        this.state = nextState;\n        this.emitUpdate();\n      }\n\n      return;\n    }\n\n    // Checks if menu should be hidden.\n    if (\n      this.state?.show &&\n      !this.preventHide &&\n      (!shouldShow || this.preventShow || !this.editor.isEditable)\n    ) {\n      this.state.show = false;\n      this.emitUpdate();\n\n      return;\n    }\n  }\n\n  destroy() {\n    this.pmView.dom.removeEventListener(\"mousedown\", this.viewMousedownHandler);\n    this.pmView.root.removeEventListener(\"mouseup\", this.mouseupHandler);\n    this.pmView.dom.removeEventListener(\"dragstart\", this.dragHandler);\n    this.pmView.dom.removeEventListener(\"dragover\", this.dragHandler);\n    this.pmView.dom.removeEventListener(\"blur\", this.blurHandler);\n\n    this.pmView.root.removeEventListener(\"scroll\", this.scrollHandler, true);\n  }\n\n  closeMenu = () => {\n    if (this.state?.show) {\n      this.state.show = false;\n      this.emitUpdate();\n    }\n  };\n\n  getSelectionBoundingBox() {\n    const { state } = this.pmView;\n    const { selection } = state;\n\n    // support for CellSelections\n    const { ranges } = selection;\n    const from = Math.min(...ranges.map((range) => range.$from.pos));\n    const to = Math.max(...ranges.map((range) => range.$to.pos));\n\n    if (isNodeSelection(selection)) {\n      const node = this.pmView.nodeDOM(from) as HTMLElement;\n      if (node) {\n        return node.getBoundingClientRect();\n      }\n    }\n\n    return posToDOMRect(this.pmView, from, to);\n  }\n}\n\nexport const formattingToolbarPluginKey = new PluginKey(\n  \"FormattingToolbarPlugin\",\n);\n\nexport class FormattingToolbarProsemirrorPlugin extends BlockNoteExtension {\n  public static key() {\n    return \"formattingToolbar\";\n  }\n\n  private view: FormattingToolbarView | undefined;\n\n  constructor(editor: BlockNoteEditor<any, any, any>) {\n    super();\n    this.addProsemirrorPlugin(\n      new Plugin({\n        key: formattingToolbarPluginKey,\n        view: (editorView) => {\n          this.view = new FormattingToolbarView(editor, editorView, (state) => {\n            this.emit(\"update\", state);\n          });\n          return this.view;\n        },\n        props: {\n          handleKeyDown: (_view, event: KeyboardEvent) => {\n            if (event.key === \"Escape\" && this.shown) {\n              this.view!.closeMenu();\n              return true;\n            }\n            return false;\n          },\n        },\n      }),\n    );\n  }\n\n  public get shown() {\n    return this.view?.state?.show || false;\n  }\n\n  public onUpdate(callback: (state: FormattingToolbarState) => void) {\n    return this.on(\"update\", callback);\n  }\n\n  public closeMenu = () => this.view!.closeMenu();\n}\n","// Stripped down version of the TipTap HardBreak extension:\n// https://github.com/ueberdosis/tiptap/blob/f3258d9ee5fb7979102fe63434f6ea4120507311/packages/extension-hard-break/src/hard-break.ts#L80\n// Changes:\n// - Removed options\n// - Removed keyboard shortcuts & moved them to the `KeyboardShortcutsExtension`\n// - Removed `setHardBreak` command (added a simpler version in the Shift+Enter\n// handler in `KeyboardShortcutsExtension`).\n// - Added priority\nimport { mergeAttributes, Node } from \"@tiptap/core\";\n\nexport const HardBreak = Node.create({\n  name: \"hardBreak\",\n\n  inline: true,\n\n  group: \"inline\",\n\n  selectable: false,\n\n  linebreakReplacement: true,\n\n  priority: 10,\n\n  parseHTML() {\n    return [{ tag: \"br\" }];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\"br\", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];\n  },\n\n  renderText() {\n    return \"\\n\";\n  },\n});\n","import { Node } from \"prosemirror-model\";\nimport { EditorState } from \"prosemirror-state\";\n\nimport {\n  BlockInfo,\n  getBlockInfoFromResolvedPos,\n} from \"../../../getBlockInfoFromPos.js\";\n\n/**\n * Returns the block info from the parent block\n * or undefined if we're at the root\n */\nexport const getParentBlockInfo = (doc: Node, beforePos: number) => {\n  const $pos = doc.resolve(beforePos);\n\n  if ($pos.depth <= 1) {\n    return undefined;\n  }\n\n  // get start pos of parent\n  const parentBeforePos = $pos.posAtIndex(\n    $pos.index($pos.depth - 1),\n    $pos.depth - 1,\n  );\n\n  const parentBlockInfo = getBlockInfoFromResolvedPos(\n    doc.resolve(parentBeforePos),\n  );\n  return parentBlockInfo;\n};\n\n/**\n * Returns the block info from the sibling block before (above) the given block,\n * or undefined if the given block is the first sibling.\n */\nexport const getPrevBlockInfo = (doc: Node, beforePos: number) => {\n  const $pos = doc.resolve(beforePos);\n\n  const indexInParent = $pos.index();\n\n  if (indexInParent === 0) {\n    return undefined;\n  }\n\n  const prevBlockBeforePos = $pos.posAtIndex(indexInParent - 1);\n\n  const prevBlockInfo = getBlockInfoFromResolvedPos(\n    doc.resolve(prevBlockBeforePos),\n  );\n  return prevBlockInfo;\n};\n\n/**\n * If a block has children like this:\n * A\n * - B\n * - C\n * -- D\n *\n * Then the bottom nested block returned is D.\n */\nexport const getBottomNestedBlockInfo = (doc: Node, blockInfo: BlockInfo) => {\n  while (blockInfo.childContainer) {\n    const group = blockInfo.childContainer.node;\n\n    const newPos = doc\n      .resolve(blockInfo.childContainer.beforePos + 1)\n      .posAtIndex(group.childCount - 1);\n    blockInfo = getBlockInfoFromResolvedPos(doc.resolve(newPos));\n  }\n\n  return blockInfo;\n};\n\nconst canMerge = (prevBlockInfo: BlockInfo, nextBlockInfo: BlockInfo) => {\n  return (\n    prevBlockInfo.isBlockContainer &&\n    prevBlockInfo.blockContent.node.type.spec.content === \"inline*\" &&\n    prevBlockInfo.blockContent.node.childCount > 0 &&\n    nextBlockInfo.isBlockContainer &&\n    nextBlockInfo.blockContent.node.type.spec.content === \"inline*\"\n  );\n};\n\nconst mergeBlocks = (\n  state: EditorState,\n  dispatch: ((args?: any) => any) | undefined,\n  prevBlockInfo: BlockInfo,\n  nextBlockInfo: BlockInfo,\n) => {\n  // Un-nests all children of the next block.\n  if (!nextBlockInfo.isBlockContainer) {\n    throw new Error(\n      `Attempted to merge block at position ${nextBlockInfo.bnBlock.beforePos} into previous block at position ${prevBlockInfo.bnBlock.beforePos}, but next block is not a block container`,\n    );\n  }\n\n  // Removes a level of nesting all children of the next block by 1 level, if it contains both content and block\n  // group nodes.\n  if (nextBlockInfo.childContainer) {\n    const childBlocksStart = state.doc.resolve(\n      nextBlockInfo.childContainer.beforePos + 1,\n    );\n    const childBlocksEnd = state.doc.resolve(\n      nextBlockInfo.childContainer.afterPos - 1,\n    );\n    const childBlocksRange = childBlocksStart.blockRange(childBlocksEnd);\n\n    if (dispatch) {\n      const pos = state.doc.resolve(nextBlockInfo.bnBlock.beforePos);\n      state.tr.lift(childBlocksRange!, pos.depth);\n    }\n  }\n\n  // Deletes the boundary between the two blocks. Can be thought of as\n  // removing the closing tags of the first block and the opening tags of the\n  // second one to stitch them together.\n  if (dispatch) {\n    if (!prevBlockInfo.isBlockContainer) {\n      throw new Error(\n        `Attempted to merge block at position ${nextBlockInfo.bnBlock.beforePos} into previous block at position ${prevBlockInfo.bnBlock.beforePos}, but previous block is not a block container`,\n      );\n    }\n\n    // TODO: test merging between a columnList and paragraph, between two columnLists, and v.v.\n    dispatch(\n      state.tr.delete(\n        prevBlockInfo.blockContent.afterPos - 1,\n        nextBlockInfo.blockContent.beforePos + 1,\n      ),\n    );\n  }\n\n  return true;\n};\n\nexport const mergeBlocksCommand =\n  (posBetweenBlocks: number) =>\n  ({\n    state,\n    dispatch,\n  }: {\n    state: EditorState;\n    dispatch: ((args?: any) => any) | undefined;\n  }) => {\n    const $pos = state.doc.resolve(posBetweenBlocks);\n    const nextBlockInfo = getBlockInfoFromResolvedPos($pos);\n\n    const prevBlockInfo = getPrevBlockInfo(\n      state.doc,\n      nextBlockInfo.bnBlock.beforePos,\n    );\n\n    if (!prevBlockInfo) {\n      return false;\n    }\n\n    const bottomNestedBlockInfo = getBottomNestedBlockInfo(\n      state.doc,\n      prevBlockInfo,\n    );\n\n    if (!canMerge(bottomNestedBlockInfo, nextBlockInfo)) {\n      return false;\n    }\n\n    return mergeBlocks(state, dispatch, bottomNestedBlockInfo, nextBlockInfo);\n  };\n","import { Fragment, NodeType, Slice } from \"prosemirror-model\";\nimport { Transaction } from \"prosemirror-state\";\nimport { ReplaceAroundStep } from \"prosemirror-transform\";\n\nimport { BlockNoteEditor } from \"../../../../editor/BlockNoteEditor.js\";\nimport { getBlockInfoFromTransaction } from \"../../../getBlockInfoFromPos.js\";\n\n// TODO: Unit tests\n/**\n * This is a modified version of https://github.com/ProseMirror/prosemirror-schema-list/blob/569c2770cbb8092d8f11ea53ecf78cb7a4e8f15a/src/schema-list.ts#L232\n *\n * The original function derives too many information from the parentnode and itemtype\n */\nfunction sinkListItem(\n  tr: Transaction,\n  itemType: NodeType,\n  groupType: NodeType,\n) {\n  const { $from, $to } = tr.selection;\n  const range = $from.blockRange(\n    $to,\n    (node) =>\n      node.childCount > 0 &&\n      (node.type.name === \"blockGroup\" || node.type.name === \"column\"), // change necessary to not look at first item child type\n  );\n  if (!range) {\n    return false;\n  }\n  const startIndex = range.startIndex;\n  if (startIndex === 0) {\n    return false;\n  }\n  const parent = range.parent;\n  const nodeBefore = parent.child(startIndex - 1);\n  if (nodeBefore.type !== itemType) {\n    return false;\n  }\n  const nestedBefore =\n    nodeBefore.lastChild && nodeBefore.lastChild.type === groupType; // change necessary to check groupType instead of parent.type\n  const inner = Fragment.from(nestedBefore ? itemType.create() : null);\n  const slice = new Slice(\n    Fragment.from(\n      itemType.create(null, Fragment.from(groupType.create(null, inner))), // change necessary to create \"groupType\" instead of parent.type\n    ),\n    nestedBefore ? 3 : 1,\n    0,\n  );\n\n  const before = range.start;\n  const after = range.end;\n\n  tr.step(\n    new ReplaceAroundStep(\n      before - (nestedBefore ? 3 : 1),\n      after,\n      before,\n      after,\n      slice,\n      1,\n      true,\n    ),\n  ).scrollIntoView();\n\n  return true;\n}\n\nexport function nestBlock(editor: BlockNoteEditor<any, any, any>) {\n  return editor.transact((tr) => {\n    return sinkListItem(\n      tr,\n      editor.pmSchema.nodes[\"blockContainer\"],\n      editor.pmSchema.nodes[\"blockGroup\"],\n    );\n  });\n}\n\nexport function unnestBlock(editor: BlockNoteEditor<any, any, any>) {\n  editor._tiptapEditor.commands.liftListItem(\"blockContainer\");\n}\n\nexport function canNestBlock(editor: BlockNoteEditor<any, any, any>) {\n  return editor.transact((tr) => {\n    const { bnBlock: blockContainer } = getBlockInfoFromTransaction(tr);\n\n    return tr.doc.resolve(blockContainer.beforePos).nodeBefore !== null;\n  });\n}\n\nexport function canUnnestBlock(editor: BlockNoteEditor<any, any, any>) {\n  return editor.transact((tr) => {\n    const { bnBlock: blockContainer } = getBlockInfoFromTransaction(tr);\n\n    return tr.doc.resolve(blockContainer.beforePos).depth > 1;\n  });\n}\n","import { Extension } from \"@tiptap/core\";\n\nimport { TextSelection } from \"prosemirror-state\";\nimport { ReplaceAroundStep } from \"prosemirror-transform\";\nimport {\n  getBottomNestedBlockInfo,\n  getParentBlockInfo,\n  getPrevBlockInfo,\n  mergeBlocksCommand,\n} from \"../../api/blockManipulation/commands/mergeBlocks/mergeBlocks.js\";\nimport { nestBlock } from \"../../api/blockManipulation/commands/nestBlock/nestBlock.js\";\nimport { splitBlockCommand } from \"../../api/blockManipulation/commands/splitBlock/splitBlock.js\";\nimport { updateBlockCommand } from \"../../api/blockManipulation/commands/updateBlock/updateBlock.js\";\nimport { getBlockInfoFromSelection } from \"../../api/getBlockInfoFromPos.js\";\nimport { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\n\nexport const KeyboardShortcutsExtension = Extension.create<{\n  editor: BlockNoteEditor<any, any, any>;\n  tabBehavior: \"prefer-navigate-ui\" | \"prefer-indent\";\n}>({\n  priority: 50,\n\n  // TODO: The shortcuts need a refactor. Do we want to use a command priority\n  //  design as there is now, or clump the logic into a single function?\n  addKeyboardShortcuts() {\n    // handleBackspace is partially adapted from https://github.com/ueberdosis/tiptap/blob/ed56337470efb4fd277128ab7ef792b37cfae992/packages/core/src/extensions/keymap.ts\n    const handleBackspace = () =>\n      this.editor.commands.first(({ chain, commands }) => [\n        // Deletes the selection if it's not empty.\n        () => commands.deleteSelection(),\n        // Undoes an input rule if one was triggered in the last editor state change.\n        () => commands.undoInputRule(),\n        // Reverts block content type to a paragraph if the selection is at the start of the block.\n        () =>\n          commands.command(({ state }) => {\n            const blockInfo = getBlockInfoFromSelection(state);\n            if (!blockInfo.isBlockContainer) {\n              return false;\n            }\n\n            const selectionAtBlockStart =\n              state.selection.from === blockInfo.blockContent.beforePos + 1;\n            const isParagraph =\n              blockInfo.blockContent.node.type.name === \"paragraph\";\n\n            if (selectionAtBlockStart && !isParagraph) {\n              return commands.command(\n                updateBlockCommand(blockInfo.bnBlock.beforePos, {\n                  type: \"paragraph\",\n                  props: {},\n                }),\n              );\n            }\n\n            return false;\n          }),\n        // Removes a level of nesting if the block is indented if the selection is at the start of the block.\n        () =>\n          commands.command(({ state }) => {\n            const blockInfo = getBlockInfoFromSelection(state);\n            if (!blockInfo.isBlockContainer) {\n              return false;\n            }\n            const { blockContent } = blockInfo;\n\n            const selectionAtBlockStart =\n              state.selection.from === blockContent.beforePos + 1;\n\n            if (selectionAtBlockStart) {\n              return commands.liftListItem(\"blockContainer\");\n            }\n\n            return false;\n          }),\n        // Merges block with the previous one if it isn't indented, and the selection is at the start of the\n        // block. The target block for merging must contain inline content.\n        () =>\n          commands.command(({ state }) => {\n            const blockInfo = getBlockInfoFromSelection(state);\n            if (!blockInfo.isBlockContainer) {\n              return false;\n            }\n            const { bnBlock: blockContainer, blockContent } = blockInfo;\n\n            const selectionAtBlockStart =\n              state.selection.from === blockContent.beforePos + 1;\n            const selectionEmpty = state.selection.empty;\n\n            const posBetweenBlocks = blockContainer.beforePos;\n\n            if (selectionAtBlockStart && selectionEmpty) {\n              return chain()\n                .command(mergeBlocksCommand(posBetweenBlocks))\n                .scrollIntoView()\n                .run();\n            }\n\n            return false;\n          }),\n        () =>\n          commands.command(({ state, dispatch }) => {\n            // when at the start of a first block in a column\n            const blockInfo = getBlockInfoFromSelection(state);\n            if (!blockInfo.isBlockContainer) {\n              return false;\n            }\n\n            const selectionAtBlockStart =\n              state.selection.from === blockInfo.blockContent.beforePos + 1;\n\n            if (!selectionAtBlockStart) {\n              return false;\n            }\n\n            const prevBlockInfo = getPrevBlockInfo(\n              state.doc,\n              blockInfo.bnBlock.beforePos,\n            );\n\n            if (prevBlockInfo) {\n              // should be no previous block\n              return false;\n            }\n\n            const parentBlockInfo = getParentBlockInfo(\n              state.doc,\n              blockInfo.bnBlock.beforePos,\n            );\n\n            if (parentBlockInfo?.blockNoteType !== \"column\") {\n              return false;\n            }\n\n            const column = parentBlockInfo;\n\n            const columnList = getParentBlockInfo(\n              state.doc,\n              column.bnBlock.beforePos,\n            );\n            if (columnList?.blockNoteType !== \"columnList\") {\n              throw new Error(\"parent of column is not a column list\");\n            }\n\n            const shouldRemoveColumn =\n              column.childContainer!.node.childCount === 1;\n\n            const shouldRemoveColumnList =\n              shouldRemoveColumn &&\n              columnList.childContainer!.node.childCount === 2;\n\n            const isFirstColumn =\n              columnList.childContainer!.node.firstChild ===\n              column.bnBlock.node;\n\n            if (dispatch) {\n              const blockToMove = state.doc.slice(\n                blockInfo.bnBlock.beforePos,\n                blockInfo.bnBlock.afterPos,\n                false,\n              );\n\n              /*\n              There are 3 different cases:\n              a) remove entire column list (if no columns would be remaining)\n              b) remove just a column (if no blocks inside a column would be remaining)\n              c) keep columns (if there are blocks remaining inside a column)\n\n              Each of these 3 cases has 2 sub-cases, depending on whether the backspace happens at the start of the first (most-left) column,\n              or at the start of a non-first column.\n              */\n              if (shouldRemoveColumnList) {\n                if (isFirstColumn) {\n                  state.tr.step(\n                    new ReplaceAroundStep(\n                      // replace entire column list\n                      columnList.bnBlock.beforePos,\n                      columnList.bnBlock.afterPos,\n                      // select content of remaining column:\n                      column.bnBlock.afterPos + 1,\n                      columnList.bnBlock.afterPos - 2,\n                      blockToMove,\n                      blockToMove.size, // append existing content to blockToMove\n                      false,\n                    ),\n                  );\n                  const pos = state.tr.doc.resolve(column.bnBlock.beforePos);\n                  state.tr.setSelection(TextSelection.between(pos, pos));\n                } else {\n                  // replaces the column list with the blockToMove slice, prepended with the content of the remaining column\n                  state.tr.step(\n                    new ReplaceAroundStep(\n                      // replace entire column list\n                      columnList.bnBlock.beforePos,\n                      columnList.bnBlock.afterPos,\n                      // select content of existing column:\n                      columnList.bnBlock.beforePos + 2,\n                      column.bnBlock.beforePos - 1,\n                      blockToMove,\n                      0, // prepend existing content to blockToMove\n                      false,\n                    ),\n                  );\n                  const pos = state.tr.doc.resolve(\n                    state.tr.mapping.map(column.bnBlock.beforePos - 1),\n                  );\n                  state.tr.setSelection(TextSelection.between(pos, pos));\n                }\n              } else if (shouldRemoveColumn) {\n                if (isFirstColumn) {\n                  // delete column\n                  state.tr.delete(\n                    column.bnBlock.beforePos,\n                    column.bnBlock.afterPos,\n                  );\n\n                  // move before columnlist\n                  state.tr.insert(\n                    columnList.bnBlock.beforePos,\n                    blockToMove.content,\n                  );\n\n                  const pos = state.tr.doc.resolve(\n                    columnList.bnBlock.beforePos,\n                  );\n                  state.tr.setSelection(TextSelection.between(pos, pos));\n                } else {\n                  // just delete the </column><column> closing and opening tags to merge the columns\n                  state.tr.delete(\n                    column.bnBlock.beforePos - 1,\n                    column.bnBlock.beforePos + 1,\n                  );\n                }\n              } else {\n                // delete block\n                state.tr.delete(\n                  blockInfo.bnBlock.beforePos,\n                  blockInfo.bnBlock.afterPos,\n                );\n                if (isFirstColumn) {\n                  // move before columnlist\n                  state.tr.insert(\n                    columnList.bnBlock.beforePos - 1,\n                    blockToMove.content,\n                  );\n                } else {\n                  // append block to previous column\n                  state.tr.insert(\n                    column.bnBlock.beforePos - 1,\n                    blockToMove.content,\n                  );\n                }\n                const pos = state.tr.doc.resolve(column.bnBlock.beforePos - 1);\n                state.tr.setSelection(TextSelection.between(pos, pos));\n              }\n            }\n\n            return true;\n          }),\n        // Deletes the current block if it's an empty block with inline content,\n        // and moves the selection to the previous block.\n        () =>\n          commands.command(({ state }) => {\n            const blockInfo = getBlockInfoFromSelection(state);\n            if (!blockInfo.isBlockContainer) {\n              return false;\n            }\n\n            const blockEmpty =\n              blockInfo.blockContent.node.childCount === 0 &&\n              blockInfo.blockContent.node.type.spec.content === \"inline*\";\n\n            if (blockEmpty) {\n              const prevBlockInfo = getPrevBlockInfo(\n                state.doc,\n                blockInfo.bnBlock.beforePos,\n              );\n              if (!prevBlockInfo || !prevBlockInfo.isBlockContainer) {\n                return false;\n              }\n\n              let chainedCommands = chain();\n\n              if (\n                prevBlockInfo.blockContent.node.type.spec.content ===\n                \"tableRow+\"\n              ) {\n                const tableBlockEndPos = blockInfo.bnBlock.beforePos - 1;\n                const tableBlockContentEndPos = tableBlockEndPos - 1;\n                const lastRowEndPos = tableBlockContentEndPos - 1;\n                const lastCellEndPos = lastRowEndPos - 1;\n                const lastCellParagraphEndPos = lastCellEndPos - 1;\n\n                chainedCommands = chainedCommands.setTextSelection(\n                  lastCellParagraphEndPos,\n                );\n              } else if (\n                prevBlockInfo.blockContent.node.type.spec.content === \"\"\n              ) {\n                const nonEditableBlockContentStartPos =\n                  prevBlockInfo.blockContent.afterPos -\n                  prevBlockInfo.blockContent.node.nodeSize;\n\n                chainedCommands = chainedCommands.setNodeSelection(\n                  nonEditableBlockContentStartPos,\n                );\n              } else {\n                const blockContentStartPos =\n                  prevBlockInfo.blockContent.afterPos -\n                  prevBlockInfo.blockContent.node.nodeSize;\n\n                chainedCommands =\n                  chainedCommands.setTextSelection(blockContentStartPos);\n              }\n\n              return chainedCommands\n                .deleteRange({\n                  from: blockInfo.bnBlock.beforePos,\n                  to: blockInfo.bnBlock.afterPos,\n                })\n                .scrollIntoView()\n                .run();\n            }\n\n            return false;\n          }),\n        // Deletes previous block if it contains no content and isn't a table,\n        // when the selection is empty and at the start of the block. Moves the\n        // current block into the deleted block's place.\n        () =>\n          commands.command(({ state }) => {\n            const blockInfo = getBlockInfoFromSelection(state);\n\n            if (!blockInfo.isBlockContainer) {\n              // TODO\n              throw new Error(`todo`);\n            }\n\n            const selectionAtBlockStart =\n              state.selection.from === blockInfo.blockContent.beforePos + 1;\n            const selectionEmpty = state.selection.empty;\n\n            const prevBlockInfo = getPrevBlockInfo(\n              state.doc,\n              blockInfo.bnBlock.beforePos,\n            );\n\n            if (prevBlockInfo && selectionAtBlockStart && selectionEmpty) {\n              const bottomBlock = getBottomNestedBlockInfo(\n                state.doc,\n                prevBlockInfo,\n              );\n\n              if (!bottomBlock.isBlockContainer) {\n                // TODO\n                throw new Error(`todo`);\n              }\n\n              const prevBlockNotTableAndNoContent =\n                bottomBlock.blockContent.node.type.spec.content === \"\" ||\n                (bottomBlock.blockContent.node.type.spec.content ===\n                  \"inline*\" &&\n                  bottomBlock.blockContent.node.childCount === 0);\n\n              if (prevBlockNotTableAndNoContent) {\n                return chain()\n                  .cut(\n                    {\n                      from: blockInfo.bnBlock.beforePos,\n                      to: blockInfo.bnBlock.afterPos,\n                    },\n                    bottomBlock.bnBlock.afterPos,\n                  )\n                  .deleteRange({\n                    from: bottomBlock.bnBlock.beforePos,\n                    to: bottomBlock.bnBlock.afterPos,\n                  })\n                  .run();\n              }\n            }\n\n            return false;\n          }),\n      ]);\n\n    const handleDelete = () =>\n      this.editor.commands.first(({ commands }) => [\n        // Deletes the selection if it's not empty.\n        () => commands.deleteSelection(),\n        // Merges block with the next one (at the same nesting level or lower),\n        // if one exists, the block has no children, and the selection is at the\n        // end of the block.\n        () =>\n          commands.command(({ state }) => {\n            // TODO: Change this to not rely on offsets & schema assumptions\n            const blockInfo = getBlockInfoFromSelection(state);\n            if (!blockInfo.isBlockContainer) {\n              return false;\n            }\n            const {\n              bnBlock: blockContainer,\n              blockContent,\n              childContainer,\n            } = blockInfo;\n\n            const { depth } = state.doc.resolve(blockContainer.beforePos);\n            const blockAtDocEnd =\n              blockContainer.afterPos === state.doc.nodeSize - 3;\n            const selectionAtBlockEnd =\n              state.selection.from === blockContent.afterPos - 1;\n            const selectionEmpty = state.selection.empty;\n            const hasChildBlocks = childContainer !== undefined;\n\n            if (\n              !blockAtDocEnd &&\n              selectionAtBlockEnd &&\n              selectionEmpty &&\n              !hasChildBlocks\n            ) {\n              let oldDepth = depth;\n              let newPos = blockContainer.afterPos + 1;\n              let newDepth = state.doc.resolve(newPos).depth;\n\n              while (newDepth < oldDepth) {\n                oldDepth = newDepth;\n                newPos += 2;\n                newDepth = state.doc.resolve(newPos).depth;\n              }\n\n              return commands.command(mergeBlocksCommand(newPos - 1));\n            }\n\n            return false;\n          }),\n      ]);\n\n    const handleEnter = (withShift = false) => {\n      return this.editor.commands.first(({ commands, tr }) => [\n        // Removes a level of nesting if the block is empty & indented, while the selection is also empty & at the start\n        // of the block.\n        () =>\n          commands.command(({ state }) => {\n            const blockInfo = getBlockInfoFromSelection(state);\n            if (!blockInfo.isBlockContainer) {\n              return false;\n            }\n            const { bnBlock: blockContainer, blockContent } = blockInfo;\n\n            const { depth } = state.doc.resolve(blockContainer.beforePos);\n\n            const selectionAtBlockStart =\n              state.selection.$anchor.parentOffset === 0;\n            const selectionEmpty =\n              state.selection.anchor === state.selection.head;\n            const blockEmpty = blockContent.node.childCount === 0;\n            const blockIndented = depth > 1;\n\n            if (\n              selectionAtBlockStart &&\n              selectionEmpty &&\n              blockEmpty &&\n              blockIndented\n            ) {\n              return commands.liftListItem(\"blockContainer\");\n            }\n\n            return false;\n          }),\n        // Creates a hard break if block is configured to do so.\n        () =>\n          commands.command(({ state }) => {\n            const blockInfo = getBlockInfoFromSelection(state);\n\n            const blockHardBreakShortcut =\n              this.options.editor.schema.blockSchema[\n                blockInfo.blockNoteType as keyof typeof this.options.editor.schema.blockSchema\n              ].meta?.hardBreakShortcut ?? \"shift+enter\";\n\n            if (blockHardBreakShortcut === \"none\") {\n              return false;\n            }\n\n            if (\n              // If shortcut is not configured, or is configured as \"shift+enter\",\n              // create a hard break for shift+enter, but not for enter.\n              (blockHardBreakShortcut === \"shift+enter\" && withShift) ||\n              // If shortcut is configured as \"enter\", create a hard break for\n              // both enter and shift+enter.\n              blockHardBreakShortcut === \"enter\"\n            ) {\n              const marks =\n                tr.storedMarks ||\n                tr.selection.$head\n                  .marks()\n                  .filter((m) =>\n                    this.editor.extensionManager.splittableMarks.includes(\n                      m.type.name,\n                    ),\n                  );\n\n              tr.insert(\n                tr.selection.head,\n                tr.doc.type.schema.nodes.hardBreak.create(),\n              ).ensureMarks(marks);\n              return true;\n            }\n\n            return false;\n          }),\n        // Creates a new block and moves the selection to it if the current one is empty, while the selection is also\n        // empty & at the start of the block.\n        () =>\n          commands.command(({ state, dispatch }) => {\n            const blockInfo = getBlockInfoFromSelection(state);\n            if (!blockInfo.isBlockContainer) {\n              return false;\n            }\n            const { bnBlock: blockContainer, blockContent } = blockInfo;\n\n            const selectionAtBlockStart =\n              state.selection.$anchor.parentOffset === 0;\n            const selectionEmpty =\n              state.selection.anchor === state.selection.head;\n            const blockEmpty = blockContent.node.childCount === 0;\n\n            if (selectionAtBlockStart && selectionEmpty && blockEmpty) {\n              const newBlockInsertionPos = blockContainer.afterPos;\n              const newBlockContentPos = newBlockInsertionPos + 2;\n\n              if (dispatch) {\n                const newBlock =\n                  state.schema.nodes[\"blockContainer\"].createAndFill()!;\n\n                state.tr\n                  .insert(newBlockInsertionPos, newBlock)\n                  .scrollIntoView();\n                state.tr.setSelection(\n                  new TextSelection(state.doc.resolve(newBlockContentPos)),\n                );\n              }\n\n              return true;\n            }\n\n            return false;\n          }),\n        // Splits the current block, moving content inside that's after the cursor to a new text block below. Also\n        // deletes the selection beforehand, if it's not empty.\n        () =>\n          commands.command(({ state, chain }) => {\n            const blockInfo = getBlockInfoFromSelection(state);\n            if (!blockInfo.isBlockContainer) {\n              return false;\n            }\n            const { blockContent } = blockInfo;\n\n            const selectionAtBlockStart =\n              state.selection.$anchor.parentOffset === 0;\n            const blockEmpty = blockContent.node.childCount === 0;\n\n            if (!blockEmpty) {\n              chain()\n                .deleteSelection()\n                .command(\n                  splitBlockCommand(\n                    state.selection.from,\n                    selectionAtBlockStart,\n                    selectionAtBlockStart,\n                  ),\n                )\n                .run();\n\n              return true;\n            }\n\n            return false;\n          }),\n      ]);\n    };\n\n    return {\n      Backspace: handleBackspace,\n      Delete: handleDelete,\n      Enter: () => handleEnter(),\n      \"Shift-Enter\": () => handleEnter(true),\n      // Always returning true for tab key presses ensures they're not captured by the browser. Otherwise, they blur the\n      // editor since the browser will try to use tab for keyboard navigation.\n      Tab: () => {\n        if (\n          this.options.tabBehavior !== \"prefer-indent\" &&\n          (this.options.editor.formattingToolbar?.shown ||\n            this.options.editor.linkToolbar?.shown ||\n            this.options.editor.filePanel?.shown)\n        ) {\n          // don't handle tabs if a toolbar is shown, so we can tab into / out of it\n          return false;\n        }\n        return nestBlock(this.options.editor);\n        // return true;\n      },\n      \"Shift-Tab\": () => {\n        if (\n          this.options.tabBehavior !== \"prefer-indent\" &&\n          (this.options.editor.formattingToolbar?.shown ||\n            this.options.editor.linkToolbar?.shown ||\n            this.options.editor.filePanel?.shown)\n        ) {\n          // don't handle tabs if a toolbar is shown, so we can tab into / out of it\n          return false;\n        }\n        this.editor.commands.liftListItem(\"blockContainer\");\n        return true;\n      },\n      \"Shift-Mod-ArrowUp\": () => {\n        this.options.editor.moveBlocksUp();\n        return true;\n      },\n      \"Shift-Mod-ArrowDown\": () => {\n        this.options.editor.moveBlocksDown();\n        return true;\n      },\n      \"Mod-z\": () => this.options.editor.undo(),\n      \"Mod-y\": () => this.options.editor.redo(),\n      \"Shift-Mod-z\": () => this.options.editor.redo(),\n    };\n  },\n});\n","import { getMarkRange, posToDOMRect, Range } from \"@tiptap/core\";\n\nimport { EditorView } from \"@tiptap/pm/view\";\nimport { Mark } from \"prosemirror-model\";\nimport { EditorState, Plugin, PluginKey, PluginView } from \"prosemirror-state\";\n\nimport { getPmSchema } from \"../../api/pmUtil.js\";\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport { BlockNoteExtension } from \"../../editor/BlockNoteExtension.js\";\nimport { UiElementPosition } from \"../../extensions-shared/UiElementPosition.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\n\nexport type LinkToolbarState = UiElementPosition & {\n  // The hovered link's URL, and the text it's displayed with in the\n  // editor.\n  url: string;\n  text: string;\n};\n\nclass LinkToolbarView implements PluginView {\n  public state?: LinkToolbarState;\n  public emitUpdate: () => void;\n\n  menuUpdateTimer: ReturnType<typeof setTimeout> | undefined;\n  startMenuUpdateTimer: () => void;\n  stopMenuUpdateTimer: () => void;\n\n  mouseHoveredLinkMark: Mark | undefined;\n  mouseHoveredLinkMarkRange: Range | undefined;\n\n  keyboardHoveredLinkMark: Mark | undefined;\n  keyboardHoveredLinkMarkRange: Range | undefined;\n\n  linkMark: Mark | undefined;\n  linkMarkRange: Range | undefined;\n\n  constructor(\n    private readonly editor: BlockNoteEditor<any, any, any>,\n    private readonly pmView: EditorView,\n    emitUpdate: (state: LinkToolbarState) => void,\n  ) {\n    this.emitUpdate = () => {\n      if (!this.state) {\n        throw new Error(\"Attempting to update uninitialized link toolbar\");\n      }\n\n      emitUpdate(this.state);\n    };\n\n    this.startMenuUpdateTimer = () => {\n      this.menuUpdateTimer = setTimeout(() => {\n        this.update(this.pmView, undefined, true);\n      }, 250);\n    };\n\n    this.stopMenuUpdateTimer = () => {\n      if (this.menuUpdateTimer) {\n        clearTimeout(this.menuUpdateTimer);\n        this.menuUpdateTimer = undefined;\n      }\n\n      return false;\n    };\n\n    this.pmView.dom.addEventListener(\"mouseover\", this.mouseOverHandler);\n    this.pmView.root.addEventListener(\n      \"click\",\n      this.clickHandler as EventListener,\n      true,\n    );\n\n    // Setting capture=true ensures that any parent container of the editor that\n    // gets scrolled will trigger the scroll event. Scroll events do not bubble\n    // and so won't propagate to the document by default.\n    this.pmView.root.addEventListener(\"scroll\", this.scrollHandler, true);\n  }\n\n  mouseOverHandler = (event: MouseEvent) => {\n    // Resets the link mark currently hovered by the mouse cursor.\n    this.mouseHoveredLinkMark = undefined;\n    this.mouseHoveredLinkMarkRange = undefined;\n\n    this.stopMenuUpdateTimer();\n\n    if (\n      event.target instanceof HTMLAnchorElement &&\n      event.target.nodeName === \"A\"\n    ) {\n      // Finds link mark at the hovered element's position to update mouseHoveredLinkMark and\n      // mouseHoveredLinkMarkRange.\n      const hoveredLinkElement = event.target;\n      const posInHoveredLinkMark =\n        this.pmView.posAtDOM(hoveredLinkElement, 0) + 1;\n      const resolvedPosInHoveredLinkMark =\n        this.pmView.state.doc.resolve(posInHoveredLinkMark);\n      const marksAtPos = resolvedPosInHoveredLinkMark.marks();\n\n      for (const mark of marksAtPos) {\n        if (\n          mark.type.name === this.pmView.state.schema.mark(\"link\").type.name\n        ) {\n          this.mouseHoveredLinkMark = mark;\n          this.mouseHoveredLinkMarkRange =\n            getMarkRange(resolvedPosInHoveredLinkMark, mark.type, mark.attrs) ||\n            undefined;\n\n          break;\n        }\n      }\n    }\n\n    this.startMenuUpdateTimer();\n\n    return false;\n  };\n\n  clickHandler = (event: MouseEvent) => {\n    const editorWrapper = this.pmView.dom.parentElement!;\n\n    if (\n      // Toolbar is open.\n      this.linkMark &&\n      // An element is clicked.\n      event &&\n      event.target &&\n      // The clicked element is not the editor.\n      !(\n        editorWrapper === (event.target as Node) ||\n        editorWrapper.contains(event.target as Node)\n      )\n    ) {\n      if (this.state?.show) {\n        this.state.show = false;\n        this.emitUpdate();\n      }\n    }\n  };\n\n  scrollHandler = () => {\n    if (this.linkMark !== undefined) {\n      if (this.state?.show) {\n        this.state.referencePos = posToDOMRect(\n          this.pmView,\n          this.linkMarkRange!.from,\n          this.linkMarkRange!.to,\n        );\n        this.emitUpdate();\n      }\n    }\n  };\n\n  editLink(url: string, text: string) {\n    this.editor.transact((tr) => {\n      const pmSchema = getPmSchema(tr);\n      tr.insertText(text, this.linkMarkRange!.from, this.linkMarkRange!.to);\n      tr.addMark(\n        this.linkMarkRange!.from,\n        this.linkMarkRange!.from + text.length,\n        pmSchema.mark(\"link\", { href: url }),\n      );\n    });\n    this.pmView.focus();\n\n    if (this.state?.show) {\n      this.state.show = false;\n      this.emitUpdate();\n    }\n  }\n\n  deleteLink() {\n    this.editor.transact((tr) =>\n      tr\n        .removeMark(\n          this.linkMarkRange!.from,\n          this.linkMarkRange!.to,\n          this.linkMark!.type,\n        )\n        .setMeta(\"preventAutolink\", true),\n    );\n    this.pmView.focus();\n\n    if (this.state?.show) {\n      this.state.show = false;\n      this.emitUpdate();\n    }\n  }\n\n  update(view: EditorView, oldState?: EditorState, fromMouseOver = false) {\n    const { state } = view;\n\n    const isSame =\n      oldState &&\n      oldState.selection.from === state.selection.from &&\n      oldState.selection.to === state.selection.to;\n\n    if (isSame || !this.pmView.hasFocus()) {\n      return;\n    }\n\n    // Saves the currently hovered link mark before it's updated.\n    const prevLinkMark = this.linkMark;\n\n    // Resets the currently hovered link mark.\n    this.linkMark = undefined;\n    this.linkMarkRange = undefined;\n\n    // Resets the link mark currently hovered by the keyboard cursor.\n    this.keyboardHoveredLinkMark = undefined;\n    this.keyboardHoveredLinkMarkRange = undefined;\n\n    // Finds link mark at the editor selection's position to update keyboardHoveredLinkMark and\n    // keyboardHoveredLinkMarkRange.\n    if (this.pmView.state.selection.empty) {\n      const marksAtPos = this.pmView.state.selection.$from.marks();\n\n      for (const mark of marksAtPos) {\n        if (\n          mark.type.name === this.pmView.state.schema.mark(\"link\").type.name\n        ) {\n          this.keyboardHoveredLinkMark = mark;\n          this.keyboardHoveredLinkMarkRange =\n            getMarkRange(\n              this.pmView.state.selection.$from,\n              mark.type,\n              mark.attrs,\n            ) || undefined;\n\n          break;\n        }\n      }\n    }\n\n    if (this.mouseHoveredLinkMark && fromMouseOver) {\n      this.linkMark = this.mouseHoveredLinkMark;\n      this.linkMarkRange = this.mouseHoveredLinkMarkRange;\n    }\n\n    // Keyboard cursor position takes precedence over mouse hovered link.\n    if (this.keyboardHoveredLinkMark) {\n      this.linkMark = this.keyboardHoveredLinkMark;\n      this.linkMarkRange = this.keyboardHoveredLinkMarkRange;\n    }\n\n    if (this.linkMark && this.editor.isEditable) {\n      this.state = {\n        show: true,\n        referencePos: posToDOMRect(\n          this.pmView,\n          this.linkMarkRange!.from,\n          this.linkMarkRange!.to,\n        ),\n        url: this.linkMark!.attrs.href,\n        text: this.pmView.state.doc.textBetween(\n          this.linkMarkRange!.from,\n          this.linkMarkRange!.to,\n        ),\n      };\n      this.emitUpdate();\n\n      return;\n    }\n\n    // Hides menu.\n    if (\n      this.state?.show &&\n      prevLinkMark &&\n      (!this.linkMark || !this.editor.isEditable)\n    ) {\n      this.state.show = false;\n      this.emitUpdate();\n\n      return;\n    }\n  }\n\n  closeMenu = () => {\n    if (this.state?.show) {\n      this.state.show = false;\n      this.emitUpdate();\n    }\n  };\n\n  destroy() {\n    this.pmView.dom.removeEventListener(\"mouseover\", this.mouseOverHandler);\n    this.pmView.root.removeEventListener(\"scroll\", this.scrollHandler, true);\n    this.pmView.root.removeEventListener(\n      \"click\",\n      this.clickHandler as EventListener,\n      true,\n    );\n  }\n}\n\nexport const linkToolbarPluginKey = new PluginKey(\"LinkToolbarPlugin\");\n\nexport class LinkToolbarProsemirrorPlugin<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n> extends BlockNoteExtension {\n  public static key() {\n    return \"linkToolbar\";\n  }\n\n  private view: LinkToolbarView | undefined;\n\n  constructor(editor: BlockNoteEditor<BSchema, I, S>) {\n    super();\n    this.addProsemirrorPlugin(\n      new Plugin({\n        key: linkToolbarPluginKey,\n        view: (editorView) => {\n          this.view = new LinkToolbarView(editor, editorView, (state) => {\n            this.emit(\"update\", state);\n          });\n          return this.view;\n        },\n        props: {\n          handleKeyDown: (_view, event: KeyboardEvent) => {\n            if (event.key === \"Escape\" && this.shown) {\n              this.view!.closeMenu();\n              return true;\n            }\n            return false;\n          },\n        },\n      }),\n    );\n  }\n\n  public onUpdate(callback: (state: LinkToolbarState) => void) {\n    return this.on(\"update\", callback);\n  }\n\n  /**\n   * Edit the currently hovered link.\n   */\n  public editLink = (url: string, text: string) => {\n    this.view!.editLink(url, text);\n  };\n\n  /**\n   * Delete the currently hovered link.\n   */\n  public deleteLink = () => {\n    this.view!.deleteLink();\n  };\n\n  /**\n   * When hovering on/off links using the mouse cursor, the link toolbar will\n   * open & close with a delay.\n   *\n   * This function starts the delay timer, and should be used for when the mouse\n   * cursor enters the link toolbar.\n   */\n  public startHideTimer = () => {\n    this.view!.startMenuUpdateTimer();\n  };\n\n  /**\n   * When hovering on/off links using the mouse cursor, the link toolbar will\n   * open & close with a delay.\n   *\n   * This function stops the delay timer, and should be used for when the mouse\n   * cursor exits the link toolbar.\n   */\n  public stopHideTimer = () => {\n    this.view!.stopMenuUpdateTimer();\n  };\n\n  public get shown() {\n    return this.view?.state?.show || false;\n  }\n\n  public closeMenu = () => this.view!.closeMenu();\n}\n","export const VALID_LINK_PROTOCOLS = [\n  \"http\",\n  \"https\",\n  \"ftp\",\n  \"ftps\",\n  \"mailto\",\n  \"tel\",\n  \"callto\",\n  \"sms\",\n  \"cid\",\n  \"xmpp\",\n];\nexport const DEFAULT_LINK_PROTOCOL = \"https\";\n","import { Plugin, PluginKey, TextSelection } from \"prosemirror-state\";\nimport { BlockNoteExtension } from \"../../editor/BlockNoteExtension.js\";\n\nconst PLUGIN_KEY = new PluginKey(\"node-selection-keyboard\");\n// By default, typing with a node selection active will cause ProseMirror to\n// replace the node with one that contains editable content. This plugin blocks\n// this behaviour without also blocking things like keyboard shortcuts:\n//\n// - Lets through key presses that do not include alphanumeric characters. This\n// includes things like backspace/delete/home/end/etc.\n// - Lets through any key presses that include ctrl/meta keys. These will be\n// shortcuts of some kind like ctrl+C/mod+C.\n// - Special case for Enter key which creates a new paragraph block below and\n// sets the selection to it. This is just to bring the UX closer to Notion\n//\n// While a more elegant solution would probably process transactions instead of\n// keystrokes, this brings us most of the way to Notion's UX without much added\n// complexity.\nexport class NodeSelectionKeyboardPlugin extends BlockNoteExtension {\n  public static key() {\n    return \"nodeSelectionKeyboard\";\n  }\n\n  constructor() {\n    super();\n    this.addProsemirrorPlugin(\n      new Plugin({\n        key: PLUGIN_KEY,\n        props: {\n          handleKeyDown: (view, event) => {\n            // Checks for node selection\n            if (\"node\" in view.state.selection) {\n              // Checks if key press uses ctrl/meta modifier\n              if (event.ctrlKey || event.metaKey) {\n                return false;\n              }\n              // Checks if key press is alphanumeric\n              if (event.key.length === 1) {\n                event.preventDefault();\n\n                return true;\n              }\n              // Checks if key press is Enter\n              if (\n                event.key === \"Enter\" &&\n                !event.shiftKey &&\n                !event.altKey &&\n                !event.ctrlKey &&\n                !event.metaKey\n              ) {\n                const tr = view.state.tr;\n                view.dispatch(\n                  tr\n                    .insert(\n                      view.state.tr.selection.$to.after(),\n                      view.state.schema.nodes[\"paragraph\"].createChecked(),\n                    )\n                    .setSelection(\n                      new TextSelection(\n                        tr.doc.resolve(view.state.tr.selection.$to.after() + 1),\n                      ),\n                    ),\n                );\n\n                return true;\n              }\n            }\n\n            return false;\n          },\n        },\n      }),\n    );\n  }\n}\n","import { Plugin, PluginKey } from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\nimport { v4 } from \"uuid\";\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport { BlockNoteExtension } from \"../../editor/BlockNoteExtension.js\";\n\nconst PLUGIN_KEY = new PluginKey(`blocknote-placeholder`);\n\nexport class PlaceholderPlugin extends BlockNoteExtension {\n  public static key() {\n    return \"placeholder\";\n  }\n\n  constructor(\n    editor: BlockNoteEditor<any, any, any>,\n    placeholders: Record<\n      string | \"default\" | \"emptyDocument\",\n      string | undefined\n    >,\n  ) {\n    super();\n    this.addProsemirrorPlugin(\n      new Plugin({\n        key: PLUGIN_KEY,\n        view: (view) => {\n          const uniqueEditorSelector = `placeholder-selector-${v4()}`;\n          view.dom.classList.add(uniqueEditorSelector);\n          const styleEl = document.createElement(\"style\");\n\n          const nonce = editor._tiptapEditor.options.injectNonce;\n          if (nonce) {\n            styleEl.setAttribute(\"nonce\", nonce);\n          }\n\n          if (view.root instanceof window.ShadowRoot) {\n            view.root.append(styleEl);\n          } else {\n            view.root.head.appendChild(styleEl);\n          }\n\n          const styleSheet = styleEl.sheet!;\n\n          const getSelector = (additionalSelectors = \"\") =>\n            `.${uniqueEditorSelector} .bn-block-content${additionalSelectors} .bn-inline-content:has(> .ProseMirror-trailingBreak:only-child):before`;\n\n          try {\n            // FIXME: the names \"default\" and \"emptyDocument\" are hardcoded\n            const {\n              default: defaultPlaceholder,\n              emptyDocument: emptyPlaceholder,\n              ...rest\n            } = placeholders;\n\n            // add block specific placeholders\n            for (const [blockType, placeholder] of Object.entries(rest)) {\n              const blockTypeSelector = `[data-content-type=\"${blockType}\"]`;\n\n              styleSheet.insertRule(\n                `${getSelector(blockTypeSelector)} { content: ${JSON.stringify(\n                  placeholder,\n                )}; }`,\n              );\n            }\n\n            const onlyBlockSelector = `[data-is-only-empty-block]`;\n            const mustBeFocusedSelector = `[data-is-empty-and-focused]`;\n\n            // placeholder for when there's only one empty block\n            styleSheet.insertRule(\n              `${getSelector(onlyBlockSelector)} { content: ${JSON.stringify(\n                emptyPlaceholder,\n              )}; }`,\n            );\n\n            // placeholder for default blocks, only when the cursor is in the block (mustBeFocused)\n            styleSheet.insertRule(\n              `${getSelector(mustBeFocusedSelector)} { content: ${JSON.stringify(\n                defaultPlaceholder,\n              )}; }`,\n            );\n          } catch (e) {\n            // eslint-disable-next-line no-console\n            console.warn(\n              `Failed to insert placeholder CSS rule - this is likely due to the browser not supporting certain CSS pseudo-element selectors (:has, :only-child:, or :before)`,\n              e,\n            );\n          }\n\n          return {\n            destroy: () => {\n              if (view.root instanceof window.ShadowRoot) {\n                view.root.removeChild(styleEl);\n              } else {\n                view.root.head.removeChild(styleEl);\n              }\n            },\n          };\n        },\n        props: {\n          decorations: (state) => {\n            const { doc, selection } = state;\n\n            if (!editor.isEditable) {\n              return;\n            }\n\n            if (!selection.empty) {\n              return;\n            }\n\n            // Don't show placeholder when the cursor is inside a code block\n            if (selection.$from.parent.type.spec.code) {\n              return;\n            }\n\n            const decs = [];\n\n            // decoration for when there's only one empty block\n            // positions are hardcoded for now\n            if (state.doc.content.size === 6) {\n              decs.push(\n                Decoration.node(2, 4, {\n                  \"data-is-only-empty-block\": \"true\",\n                }),\n              );\n            }\n\n            const $pos = selection.$anchor;\n            const node = $pos.parent;\n\n            if (node.content.size === 0) {\n              const before = $pos.before();\n\n              decs.push(\n                Decoration.node(before, before + node.nodeSize, {\n                  \"data-is-empty-and-focused\": \"true\",\n                }),\n              );\n            }\n\n            return DecorationSet.create(doc, decs);\n          },\n        },\n      }),\n    );\n  }\n}\n","import { findChildren } from \"@tiptap/core\";\nimport { Plugin, PluginKey } from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\nimport { BlockNoteExtension } from \"../../editor/BlockNoteExtension.js\";\n\nconst PLUGIN_KEY = new PluginKey(`previous-blocks`);\n\nconst nodeAttributes: Record<string, string> = {\n  // Numbered List Items\n  index: \"index\",\n  // Headings\n  level: \"level\",\n  // All Blocks\n  type: \"type\",\n  depth: \"depth\",\n  \"depth-change\": \"depth-change\",\n};\n\n/**\n * This plugin tracks transformation of Block node attributes, so we can support CSS transitions.\n *\n * Problem it solves: ProseMirror recreates the DOM when transactions happen. So when a transaction changes a Node attribute,\n * it results in a completely new DOM element. This means CSS transitions don't work.\n *\n * Solution: When attributes change on a node, this plugin sets a data-* attribute with the \"previous\" value. This way we can still use CSS transitions. (See block.module.css)\n */\nexport class PreviousBlockTypePlugin extends BlockNoteExtension {\n  public static key() {\n    return \"previousBlockType\";\n  }\n\n  constructor() {\n    super();\n    let timeout: ReturnType<typeof setTimeout>;\n    this.addProsemirrorPlugin(\n      new Plugin({\n        key: PLUGIN_KEY,\n        view(_editorView) {\n          return {\n            update: async (view, _prevState) => {\n              if (this.key?.getState(view.state).updatedBlocks.size > 0) {\n                // use setTimeout 0 to clear the decorations so that at least\n                // for one DOM-render the decorations have been applied\n                timeout = setTimeout(() => {\n                  view.dispatch(\n                    view.state.tr.setMeta(PLUGIN_KEY, { clearUpdate: true }),\n                  );\n                }, 0);\n              }\n            },\n            destroy: () => {\n              if (timeout) {\n                clearTimeout(timeout);\n              }\n            },\n          };\n        },\n        state: {\n          init() {\n            return {\n              // Block attributes, by block ID, from just before the previous transaction.\n              prevTransactionOldBlockAttrs: {} as any,\n              // Block attributes, by block ID, from just before the current transaction.\n              currentTransactionOldBlockAttrs: {} as any,\n              // Set of IDs of blocks whose attributes changed from the current transaction.\n              updatedBlocks: new Set<string>(),\n            };\n          },\n\n          apply(transaction, prev, oldState, newState) {\n            prev.currentTransactionOldBlockAttrs = {};\n            prev.updatedBlocks.clear();\n\n            if (!transaction.docChanged || oldState.doc.eq(newState.doc)) {\n              return prev;\n            }\n\n            // TODO: Instead of iterating through the entire document, only check nodes affected by the transactions. Will\n            //  also probably require checking nodes affected by the previous transaction too.\n            // We didn't get this to work yet:\n            // const transform = combineTransactionSteps(oldState.doc, [transaction]);\n            // // const { mapping } = transform;\n            // const changes = getChangedRanges(transform);\n            //\n            // changes.forEach(({ oldRange, newRange }) => {\n            // const oldNodes = findChildrenInRange(\n            //   oldState.doc,\n            //   oldRange,\n            //   (node) => node.attrs.id\n            // );\n            //\n            // const newNodes = findChildrenInRange(\n            //   newState.doc,\n            //   newRange,\n            //   (node) => node.attrs.id\n            // );\n\n            const currentTransactionOriginalOldBlockAttrs = {} as any;\n\n            const oldNodes = findChildren(\n              oldState.doc,\n              (node) => node.attrs.id,\n            );\n            const oldNodesById = new Map(\n              oldNodes.map((node) => [node.node.attrs.id, node]),\n            );\n            const newNodes = findChildren(\n              newState.doc,\n              (node) => node.attrs.id,\n            );\n\n            // Traverses all block containers in the new editor state.\n            for (const node of newNodes) {\n              const oldNode = oldNodesById.get(node.node.attrs.id);\n\n              const oldContentNode = oldNode?.node.firstChild;\n              const newContentNode = node.node.firstChild;\n\n              if (oldNode && oldContentNode && newContentNode) {\n                const newAttrs = {\n                  index: newContentNode.attrs.index,\n                  level: newContentNode.attrs.level,\n                  type: newContentNode.type.name,\n                  depth: newState.doc.resolve(node.pos).depth,\n                };\n\n                const oldAttrs = {\n                  index: oldContentNode.attrs.index,\n                  level: oldContentNode.attrs.level,\n                  type: oldContentNode.type.name,\n                  depth: oldState.doc.resolve(oldNode.pos).depth,\n                };\n\n                currentTransactionOriginalOldBlockAttrs[node.node.attrs.id] =\n                  oldAttrs;\n\n                prev.currentTransactionOldBlockAttrs[node.node.attrs.id] =\n                  oldAttrs;\n\n                // TODO: faster deep equal?\n                if (JSON.stringify(oldAttrs) !== JSON.stringify(newAttrs)) {\n                  (oldAttrs as any)[\"depth-change\"] =\n                    oldAttrs.depth - newAttrs.depth;\n\n                  // for debugging:\n                  // console.log(\n                  //   \"id:\",\n                  //   node.node.attrs.id,\n                  //   \"previousBlockTypePlugin changes detected, oldAttrs\",\n                  //   oldAttrs,\n                  //   \"new\",\n                  //   newAttrs\n                  // );\n\n                  prev.updatedBlocks.add(node.node.attrs.id);\n                }\n              }\n            }\n\n            prev.prevTransactionOldBlockAttrs =\n              currentTransactionOriginalOldBlockAttrs;\n\n            return prev;\n          },\n        },\n        props: {\n          decorations(state) {\n            const pluginState = (this as Plugin).getState(state);\n            if (pluginState.updatedBlocks.size === 0) {\n              return undefined;\n            }\n\n            const decorations: Decoration[] = [];\n\n            state.doc.descendants((node, pos) => {\n              if (!node.attrs.id) {\n                return;\n              }\n\n              if (!pluginState.updatedBlocks.has(node.attrs.id)) {\n                return;\n              }\n\n              const prevAttrs =\n                pluginState.currentTransactionOldBlockAttrs[node.attrs.id];\n              const decorationAttrs: any = {};\n\n              for (const [nodeAttr, val] of Object.entries(prevAttrs)) {\n                decorationAttrs[\"data-prev-\" + nodeAttributes[nodeAttr]] =\n                  val || \"none\";\n              }\n\n              // for debugging:\n              // console.log(\n              //   \"previousBlockTypePlugin committing decorations\",\n              //   decorationAttrs\n              // );\n\n              const decoration = Decoration.node(pos, pos + node.nodeSize, {\n                ...decorationAttrs,\n              });\n\n              decorations.push(decoration);\n            });\n\n            return DecorationSet.create(state.doc, decorations);\n          },\n        },\n      }),\n    );\n  }\n}\n","import { Plugin, PluginKey } from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\nimport { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport { BlockNoteExtension } from \"../../editor/BlockNoteExtension.js\";\n\nconst PLUGIN_KEY = new PluginKey(`blocknote-show-selection`);\n\n/**\n * Plugin that shows adds a decoration around the current selection\n * This can be used to highlight the current selection in the UI even when the\n * text editor is not focused.\n */\nexport class ShowSelectionPlugin extends BlockNoteExtension {\n  public static key() {\n    return \"showSelection\";\n  }\n\n  private enabled = false;\n\n  public constructor(private readonly editor: BlockNoteEditor<any, any, any>) {\n    super();\n    this.addProsemirrorPlugin(\n      new Plugin({\n        key: PLUGIN_KEY,\n        props: {\n          decorations: (state) => {\n            const { doc, selection } = state;\n\n            if (!this.enabled) {\n              return DecorationSet.empty;\n            }\n\n            const dec = Decoration.inline(selection.from, selection.to, {\n              \"data-show-selection\": \"true\",\n            });\n\n            return DecorationSet.create(doc, [dec]);\n          },\n        },\n      }),\n    );\n  }\n\n  public setEnabled(enabled: boolean) {\n    if (this.enabled === enabled) {\n      return;\n    }\n\n    this.enabled = enabled;\n\n    this.editor.transact((tr) => tr.setMeta(PLUGIN_KEY, {}));\n  }\n\n  public getEnabled() {\n    return this.enabled;\n  }\n}\n","import { EditorView } from \"prosemirror-view\";\n\nexport function getDraggableBlockFromElement(\n  element: Element,\n  view: EditorView,\n) {\n  while (\n    element &&\n    element.parentElement &&\n    element.parentElement !== view.dom &&\n    element.getAttribute?.(\"data-node-type\") !== \"blockContainer\"\n  ) {\n    element = element.parentElement;\n  }\n  if (element.getAttribute?.(\"data-node-type\") !== \"blockContainer\") {\n    return undefined;\n  }\n  return { node: element as HTMLElement, id: element.getAttribute(\"data-id\")! };\n}\n","import { Fragment, Node, ResolvedPos, Slice } from \"prosemirror-model\";\nimport { Selection } from \"prosemirror-state\";\nimport { Mappable } from \"prosemirror-transform\";\n\n/**\n * This class represents an editor selection which spans multiple nodes/blocks. It's currently only used to allow users\n * to drag multiple blocks at the same time. Expects the selection anchor and head to be between nodes, i.e. just before\n * the first target node and just after the last, and that anchor and head are at the same nesting level.\n *\n * Partially based on ProseMirror's NodeSelection implementation:\n * (https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.ts)\n * MultipleNodeSelection differs from NodeSelection in the following ways:\n * 1. Stores which nodes are included in the selection instead of just a single node.\n * 2. Already expects the selection to start just before the first target node and ends just after the last, while a\n * NodeSelection automatically sets both anchor and head to just before the single target node.\n */\nexport class MultipleNodeSelection extends Selection {\n  nodes: Array<Node>;\n\n  constructor($anchor: ResolvedPos, $head: ResolvedPos) {\n    super($anchor, $head);\n\n    // Parent is at the same nesting level as anchor/head since they are just before/ just after target nodes.\n    const parentNode = $anchor.node();\n\n    this.nodes = [];\n    $anchor.doc.nodesBetween($anchor.pos, $head.pos, (node, _pos, parent) => {\n      if (parent !== null && parent.eq(parentNode)) {\n        this.nodes.push(node);\n        return false;\n      }\n      return;\n    });\n  }\n\n  static create(doc: Node, from: number, to = from): MultipleNodeSelection {\n    return new MultipleNodeSelection(doc.resolve(from), doc.resolve(to));\n  }\n\n  content(): Slice {\n    return new Slice(Fragment.from(this.nodes), 0, 0);\n  }\n\n  eq(selection: Selection): boolean {\n    if (!(selection instanceof MultipleNodeSelection)) {\n      return false;\n    }\n\n    if (this.nodes.length !== selection.nodes.length) {\n      return false;\n    }\n\n    if (this.from !== selection.from || this.to !== selection.to) {\n      return false;\n    }\n\n    for (let i = 0; i < this.nodes.length; i++) {\n      if (!this.nodes[i].eq(selection.nodes[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  map(doc: Node, mapping: Mappable): Selection {\n    const fromResult = mapping.mapResult(this.from);\n    const toResult = mapping.mapResult(this.to);\n\n    if (toResult.deleted) {\n      return Selection.near(doc.resolve(fromResult.pos));\n    }\n\n    if (fromResult.deleted) {\n      return Selection.near(doc.resolve(toResult.pos));\n    }\n\n    return new MultipleNodeSelection(\n      doc.resolve(fromResult.pos),\n      doc.resolve(toResult.pos),\n    );\n  }\n\n  toJSON(): any {\n    return { type: \"multiple-node\", anchor: this.anchor, head: this.head };\n  }\n}\n\nSelection.jsonID(\"multiple-node\", MultipleNodeSelection);\n","import { Node } from \"prosemirror-model\";\nimport { NodeSelection, Selection } from \"prosemirror-state\";\nimport { EditorView } from \"prosemirror-view\";\n\nimport { createExternalHTMLExporter } from \"../../api/exporters/html/externalHTMLExporter.js\";\nimport { cleanHTMLToMarkdown } from \"../../api/exporters/markdown/markdownExporter.js\";\nimport { fragmentToBlocks } from \"../../api/nodeConversions/fragmentToBlocks.js\";\nimport { getNodeById } from \"../../api/nodeUtil.js\";\nimport { Block } from \"../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport { UiElementPosition } from \"../../extensions-shared/UiElementPosition.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\nimport { MultipleNodeSelection } from \"./MultipleNodeSelection.js\";\n\nlet dragImageElement: Element | undefined;\n\nexport type SideMenuState<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n> = UiElementPosition & {\n  // The block that the side menu is attached to.\n  block: Block<BSchema, I, S>;\n};\n\nfunction blockPositionsFromSelection(selection: Selection, doc: Node) {\n  // Absolute positions just before the first block spanned by the selection, and just after the last block. Having the\n  // selection start and end just before and just after the target blocks ensures no whitespace/line breaks are left\n  // behind after dragging & dropping them.\n  let beforeFirstBlockPos: number;\n  let afterLastBlockPos: number;\n\n  // Even the user starts dragging blocks but drops them in the same place, the selection will still be moved just\n  // before & just after the blocks spanned by the selection, and therefore doesn't need to change if they try to drag\n  // the same blocks again. If this happens, the anchor & head move out of the block content node they were originally\n  // in. If the anchor should update but the head shouldn't and vice versa, it means the user selection is outside a\n  // block content node, which should never happen.\n  const selectionStartInBlockContent =\n    doc.resolve(selection.from).node().type.spec.group === \"blockContent\";\n  const selectionEndInBlockContent =\n    doc.resolve(selection.to).node().type.spec.group === \"blockContent\";\n\n  // Ensures that entire outermost nodes are selected if the selection spans multiple nesting levels.\n  const minDepth = Math.min(selection.$anchor.depth, selection.$head.depth);\n\n  if (selectionStartInBlockContent && selectionEndInBlockContent) {\n    // Absolute positions at the start of the first block in the selection and at the end of the last block. User\n    // selections will always start and end in block content nodes, but we want the start and end positions of their\n    // parent block nodes, which is why minDepth - 1 is used.\n    const startFirstBlockPos = selection.$from.start(minDepth - 1);\n    const endLastBlockPos = selection.$to.end(minDepth - 1);\n\n    // Shifting start and end positions by one moves them just outside the first and last selected blocks.\n    beforeFirstBlockPos = doc.resolve(startFirstBlockPos - 1).pos;\n    afterLastBlockPos = doc.resolve(endLastBlockPos + 1).pos;\n  } else {\n    beforeFirstBlockPos = selection.from;\n    afterLastBlockPos = selection.to;\n  }\n\n  return { from: beforeFirstBlockPos, to: afterLastBlockPos };\n}\n\nfunction setDragImage(view: EditorView, from: number, to = from) {\n  if (from === to) {\n    // Moves to position to be just after the first (and only) selected block.\n    to += view.state.doc.resolve(from + 1).node().nodeSize;\n  }\n\n  // Parent element is cloned to remove all unselected children without affecting the editor content.\n  const parentClone = view.domAtPos(from).node.cloneNode(true) as Element;\n  const parent = view.domAtPos(from).node as Element;\n\n  const getElementIndex = (parentElement: Element, targetElement: Element) =>\n    Array.prototype.indexOf.call(parentElement.children, targetElement);\n\n  const firstSelectedBlockIndex = getElementIndex(\n    parent,\n    // Expects from position to be just before the first selected block.\n    view.domAtPos(from + 1).node.parentElement!,\n  );\n  const lastSelectedBlockIndex = getElementIndex(\n    parent,\n    // Expects to position to be just after the last selected block.\n    view.domAtPos(to - 1).node.parentElement!,\n  );\n\n  for (let i = parent.childElementCount - 1; i >= 0; i--) {\n    if (i > lastSelectedBlockIndex || i < firstSelectedBlockIndex) {\n      parentClone.removeChild(parentClone.children[i]);\n    }\n  }\n\n  // dataTransfer.setDragImage(element) only works if element is attached to the DOM.\n  unsetDragImage(view.root);\n  dragImageElement = parentClone;\n\n  // Browsers may have CORS policies which prevents iframes from being\n  // manipulated, so better to stay on the safe side and remove them from the\n  // drag preview. The drag preview doesn't work with iframes anyway.\n  const iframes = dragImageElement.getElementsByTagName(\"iframe\");\n  for (let i = 0; i < iframes.length; i++) {\n    const iframe = iframes[i];\n    const parent = iframe.parentElement;\n\n    if (parent) {\n      parent.removeChild(iframe);\n    }\n  }\n\n  // TODO: This is hacky, need a better way of assigning classes to the editor so that they can also be applied to the\n  //  drag preview.\n  const classes = view.dom.className.split(\" \");\n  const inheritedClasses = classes\n    .filter(\n      (className) =>\n        className !== \"ProseMirror\" &&\n        className !== \"bn-root\" &&\n        className !== \"bn-editor\",\n    )\n    .join(\" \");\n\n  dragImageElement.className =\n    dragImageElement.className + \" bn-drag-preview \" + inheritedClasses;\n\n  if (view.root instanceof ShadowRoot) {\n    view.root.appendChild(dragImageElement);\n  } else {\n    view.root.body.appendChild(dragImageElement);\n  }\n}\n\nexport function unsetDragImage(rootEl: Document | ShadowRoot) {\n  if (dragImageElement !== undefined) {\n    if (rootEl instanceof ShadowRoot) {\n      rootEl.removeChild(dragImageElement);\n    } else {\n      rootEl.body.removeChild(dragImageElement);\n    }\n\n    dragImageElement = undefined;\n  }\n}\n\nexport function dragStart<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  e: { dataTransfer: DataTransfer | null; clientY: number },\n  block: Block<BSchema, I, S>,\n  editor: BlockNoteEditor<BSchema, I, S>,\n) {\n  if (!e.dataTransfer) {\n    return;\n  }\n\n  if (editor.headless) {\n    return;\n  }\n  const view = editor.prosemirrorView;\n\n  const posInfo = getNodeById(block.id, view.state.doc);\n  if (!posInfo) {\n    throw new Error(`Block with ID ${block.id} not found`);\n  }\n  const pos = posInfo.posBeforeNode;\n\n  if (pos != null) {\n    const selection = view.state.selection;\n    const doc = view.state.doc;\n\n    const { from, to } = blockPositionsFromSelection(selection, doc);\n\n    const draggedBlockInSelection = from <= pos && pos < to;\n    const multipleBlocksSelected =\n      selection.$anchor.node() !== selection.$head.node() ||\n      selection instanceof MultipleNodeSelection;\n\n    if (draggedBlockInSelection && multipleBlocksSelected) {\n      view.dispatch(\n        view.state.tr.setSelection(MultipleNodeSelection.create(doc, from, to)),\n      );\n      setDragImage(view, from, to);\n    } else {\n      view.dispatch(\n        view.state.tr.setSelection(NodeSelection.create(view.state.doc, pos)),\n      );\n      setDragImage(view, pos);\n    }\n\n    const selectedSlice = view.state.selection.content();\n    const schema = editor.pmSchema;\n\n    const clipboardHTML =\n      view.serializeForClipboard(selectedSlice).dom.innerHTML;\n\n    const externalHTMLExporter = createExternalHTMLExporter(schema, editor);\n\n    const blocks = fragmentToBlocks(selectedSlice.content);\n    const externalHTML = externalHTMLExporter.exportBlocks(blocks, {});\n\n    const plainText = cleanHTMLToMarkdown(externalHTML);\n\n    e.dataTransfer.clearData();\n    e.dataTransfer.setData(\"blocknote/html\", clipboardHTML);\n    e.dataTransfer.setData(\"text/html\", externalHTML);\n    e.dataTransfer.setData(\"text/plain\", plainText);\n    e.dataTransfer.effectAllowed = \"move\";\n    e.dataTransfer.setDragImage(dragImageElement!, 0, 0);\n  }\n}\n","import { DOMParser, Slice } from \"@tiptap/pm/model\";\nimport {\n  EditorState,\n  Plugin,\n  PluginKey,\n  PluginView,\n  TextSelection,\n} from \"@tiptap/pm/state\";\nimport { EditorView } from \"@tiptap/pm/view\";\n\nimport { Block } from \"../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport { BlockNoteExtension } from \"../../editor/BlockNoteExtension.js\";\nimport { UiElementPosition } from \"../../extensions-shared/UiElementPosition.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\nimport { getDraggableBlockFromElement } from \"../getDraggableBlockFromElement.js\";\nimport { dragStart, unsetDragImage } from \"./dragging.js\";\n\nexport type SideMenuState<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n> = UiElementPosition & {\n  // The block that the side menu is attached to.\n  block: Block<BSchema, I, S>;\n};\n\nconst DISTANCE_TO_CONSIDER_EDITOR_BOUNDS = 250;\n\nfunction getBlockFromCoords(\n  view: EditorView,\n  coords: { left: number; top: number },\n  adjustForColumns = true,\n) {\n  const elements = view.root.elementsFromPoint(coords.left, coords.top);\n\n  for (const element of elements) {\n    if (!view.dom.contains(element)) {\n      // probably a ui overlay like formatting toolbar etc\n      continue;\n    }\n    if (adjustForColumns) {\n      const column = element.closest(\"[data-node-type=columnList]\");\n      if (column) {\n        return getBlockFromCoords(\n          view,\n          {\n            // TODO can we do better than this?\n            left: coords.left + 50, // bit hacky, but if we're inside a column, offset x position to right to account for the width of sidemenu itself\n            top: coords.top,\n          },\n          false,\n        );\n      }\n    }\n    return getDraggableBlockFromElement(element, view);\n  }\n  return undefined;\n}\n\nfunction getBlockFromMousePos(\n  mousePos: {\n    x: number;\n    y: number;\n  },\n  view: EditorView,\n): { node: HTMLElement; id: string } | undefined {\n  // Editor itself may have padding or other styling which affects\n  // size/position, so we get the boundingRect of the first child (i.e. the\n  // blockGroup that wraps all blocks in the editor) for more accurate side\n  // menu placement.\n  if (!view.dom.firstChild) {\n    return;\n  }\n\n  const editorBoundingBox = (\n    view.dom.firstChild as HTMLElement\n  ).getBoundingClientRect();\n\n  // Gets block at mouse cursor's position.\n  const coords = {\n    // Clamps the x position to the editor's bounding box.\n    left: Math.min(\n      Math.max(editorBoundingBox.left + 10, mousePos.x),\n      editorBoundingBox.right - 10,\n    ),\n    top: mousePos.y,\n  };\n\n  const referenceBlock = getBlockFromCoords(view, coords);\n\n  if (!referenceBlock) {\n    // could not find the reference block\n    return undefined;\n  }\n\n  /**\n   * Because blocks may be nested, we need to check the right edge of the parent block:\n   * ```\n   * | BlockA        |\n   * x | BlockB     y|\n   * ```\n   * Hovering at position x (left edge of BlockB) would return BlockA.\n   * Instead, we check at position y (right edge of BlockA) to correctly identify BlockB.\n   */\n  const referenceBlocksBoundingBox =\n    referenceBlock.node.getBoundingClientRect();\n  return getBlockFromCoords(\n    view,\n    {\n      left: referenceBlocksBoundingBox.right - 10,\n      top: mousePos.y,\n    },\n    false,\n  );\n}\n\n/**\n * With the sidemenu plugin we can position a menu next to a hovered block.\n */\nexport class SideMenuView<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n> implements PluginView\n{\n  public state?: SideMenuState<BSchema, I, S>;\n  public readonly emitUpdate: (state: SideMenuState<BSchema, I, S>) => void;\n\n  private mousePos: { x: number; y: number } | undefined;\n\n  private hoveredBlock: HTMLElement | undefined;\n\n  public menuFrozen = false;\n\n  public isDragOrigin = false;\n\n  constructor(\n    private readonly editor: BlockNoteEditor<BSchema, I, S>,\n    private readonly pmView: EditorView,\n    emitUpdate: (state: SideMenuState<BSchema, I, S>) => void,\n  ) {\n    this.emitUpdate = () => {\n      if (!this.state) {\n        throw new Error(\"Attempting to update uninitialized side menu\");\n      }\n\n      emitUpdate(this.state);\n    };\n\n    this.pmView.root.addEventListener(\n      \"dragstart\",\n      this.onDragStart as EventListener,\n    );\n    this.pmView.root.addEventListener(\n      \"dragover\",\n      this.onDragOver as EventListener,\n    );\n    this.pmView.root.addEventListener(\n      \"drop\",\n      this.onDrop as EventListener,\n      true,\n    );\n    this.pmView.root.addEventListener(\n      \"dragend\",\n      this.onDragEnd as EventListener,\n      true,\n    );\n\n    // Shows or updates menu position whenever the cursor moves, if the menu isn't frozen.\n    this.pmView.root.addEventListener(\n      \"mousemove\",\n      this.onMouseMove as EventListener,\n      true,\n    );\n\n    // Hides and unfreezes the menu whenever the user presses a key.\n    this.pmView.root.addEventListener(\n      \"keydown\",\n      this.onKeyDown as EventListener,\n      true,\n    );\n\n    // Setting capture=true ensures that any parent container of the editor that\n    // gets scrolled will trigger the scroll event. Scroll events do not bubble\n    // and so won't propagate to the document by default.\n    pmView.root.addEventListener(\"scroll\", this.onScroll, true);\n  }\n\n  updateState = (state: SideMenuState<BSchema, I, S>) => {\n    this.state = state;\n    this.emitUpdate(this.state);\n  };\n\n  updateStateFromMousePos = () => {\n    if (this.menuFrozen || !this.mousePos) {\n      return;\n    }\n\n    const closestEditor = this.findClosestEditorElement({\n      clientX: this.mousePos.x,\n      clientY: this.mousePos.y,\n    });\n\n    if (\n      closestEditor?.element !== this.pmView.dom ||\n      closestEditor.distance > DISTANCE_TO_CONSIDER_EDITOR_BOUNDS\n    ) {\n      if (this.state?.show) {\n        this.state.show = false;\n        this.updateState(this.state);\n      }\n      return;\n    }\n\n    const block = getBlockFromMousePos(this.mousePos, this.pmView);\n\n    // Closes the menu if the mouse cursor is beyond the editor vertically.\n    if (!block || !this.editor.isEditable) {\n      if (this.state?.show) {\n        this.state.show = false;\n        this.updateState(this.state);\n      }\n\n      return;\n    }\n\n    // Doesn't update if the menu is already open and the mouse cursor is still hovering the same block.\n    if (\n      this.state?.show &&\n      this.hoveredBlock?.hasAttribute(\"data-id\") &&\n      this.hoveredBlock?.getAttribute(\"data-id\") === block.id\n    ) {\n      return;\n    }\n\n    this.hoveredBlock = block.node;\n\n    // Shows or updates elements.\n    if (this.editor.isEditable) {\n      const blockContentBoundingBox = block.node.getBoundingClientRect();\n      const column = block.node.closest(\"[data-node-type=column]\");\n      this.state = {\n        show: true,\n        referencePos: new DOMRect(\n          column\n            ? // We take the first child as column elements have some default\n              // padding. This is a little weird since this child element will\n              // be the first block, but since it's always non-nested and we\n              // only take the x coordinate, it's ok.\n              column.firstElementChild!.getBoundingClientRect().x\n            : (\n                this.pmView.dom.firstChild as HTMLElement\n              ).getBoundingClientRect().x,\n          blockContentBoundingBox.y,\n          blockContentBoundingBox.width,\n          blockContentBoundingBox.height,\n        ),\n        block: this.editor.getBlock(\n          this.hoveredBlock!.getAttribute(\"data-id\")!,\n        )!,\n      };\n      this.updateState(this.state);\n    }\n  };\n\n  /**\n   * If a block is being dragged, ProseMirror usually gets the context of what's\n   * being dragged from `view.dragging`, which is automatically set when a\n   * `dragstart` event fires in the editor. However, if the user tries to drag\n   * and drop blocks between multiple editors, only the one in which the drag\n   * began has that context, so we need to set it on the others manually. This\n   * ensures that PM always drops the blocks in between other blocks, and not\n   * inside them.\n   *\n   * After the `dragstart` event fires on the drag handle, it sets\n   * `blocknote/html` data on the clipboard. This handler fires right after,\n   * parsing the `blocknote/html` data into nodes and setting them on\n   * `view.dragging`.\n   *\n   * Note: Setting `view.dragging` on `dragover` would be better as the user\n   * could then drag between editors in different windows, but you can only\n   * access `dataTransfer` contents on `dragstart` and `drop` events.\n   */\n  onDragStart = (event: DragEvent) => {\n    const html = event.dataTransfer?.getData(\"blocknote/html\");\n    if (!html) {\n      return;\n    }\n\n    if (this.pmView.dragging) {\n      // already dragging, so no-op\n      return;\n    }\n\n    const element = document.createElement(\"div\");\n    element.innerHTML = html;\n\n    const parser = DOMParser.fromSchema(this.pmView.state.schema);\n    const node = parser.parse(element, {\n      topNode: this.pmView.state.schema.nodes[\"blockGroup\"].create(),\n    });\n\n    this.pmView.dragging = {\n      slice: new Slice(node.content, 0, 0),\n      move: true,\n    };\n  };\n\n  /**\n   * Finds the closest editor visually to the given coordinates\n   */\n  private findClosestEditorElement = (coords: {\n    clientX: number;\n    clientY: number;\n  }) => {\n    // Get all editor elements in the document\n    const editors = Array.from(this.pmView.root.querySelectorAll(\".bn-editor\"));\n\n    if (editors.length === 0) {\n      return null;\n    }\n\n    // Find the editor with the smallest distance to the coordinates\n    let closestEditor = editors[0];\n    let minDistance = Number.MAX_VALUE;\n\n    editors.forEach((editor) => {\n      const rect = editor\n        .querySelector(\".bn-block-group\")!\n        .getBoundingClientRect();\n\n      const distanceX =\n        coords.clientX < rect.left\n          ? rect.left - coords.clientX\n          : coords.clientX > rect.right\n            ? coords.clientX - rect.right\n            : 0;\n\n      const distanceY =\n        coords.clientY < rect.top\n          ? rect.top - coords.clientY\n          : coords.clientY > rect.bottom\n            ? coords.clientY - rect.bottom\n            : 0;\n\n      const distance = Math.sqrt(\n        Math.pow(distanceX, 2) + Math.pow(distanceY, 2),\n      );\n\n      if (distance < minDistance) {\n        minDistance = distance;\n        closestEditor = editor;\n      }\n    });\n\n    return {\n      element: closestEditor,\n      distance: minDistance,\n    };\n  };\n\n  /**\n   * This dragover event handler listens at the document level,\n   * and is trying to handle dragover events for all editors.\n   *\n   * It specifically is trying to handle the following cases:\n   *  - If the dragover event is within the bounds of any editor, then it does nothing\n   *  - If the dragover event is outside the bounds of any editor, but close enough (within DISTANCE_TO_CONSIDER_EDITOR_BOUNDS) to the closest editor,\n   *    then it dispatches a synthetic dragover event to the closest editor (which will trigger the drop-cursor to be shown on that editor)\n   *  - If the dragover event is outside the bounds of the current editor, then it will dispatch a synthetic dragleave event to the current editor\n   *    (which will trigger the drop-cursor to be removed from the current editor)\n   *\n   * The synthetic event is a necessary evil because we do not control prosemirror-dropcursor to be able to show the drop-cursor within the range we want\n   */\n  onDragOver = (event: DragEvent) => {\n    if ((event as any).synthetic) {\n      return;\n    }\n\n    const dragEventContext = this.getDragEventContext(event);\n\n    if (!dragEventContext || !dragEventContext.isDropPoint) {\n      // This is not a drag event that we are interested in\n      // so, we close the drop-cursor\n      this.closeDropCursor();\n      return;\n    }\n\n    if (\n      dragEventContext.isDropPoint &&\n      !dragEventContext.isDropWithinEditorBounds\n    ) {\n      // we are the drop point, but the drag over event is not within the bounds of this editor instance\n      // so, we need to dispatch an event that is in the bounds of this editor instance\n      this.dispatchSyntheticEvent(event);\n    }\n  };\n\n  /**\n   * Closes the drop-cursor for the current editor\n   */\n  private closeDropCursor = () => {\n    const evt = new Event(\"dragleave\", { bubbles: false });\n    // It needs to be synthetic, so we don't accidentally think it is a real dragend event\n    (evt as any).synthetic = true;\n    // We dispatch the event to the current editor, so that the drop-cursor is removed for it\n    this.pmView.dom.dispatchEvent(evt);\n  };\n\n  /**\n   * It is surprisingly difficult to determine the information we need to know about a drag event\n   *\n   * This function is trying to determine the following:\n   *  - Whether the current editor instance is the drop point\n   *  - Whether the current editor instance is the drag origin\n   *  - Whether the drop event is within the bounds of the current editor instance\n   */\n  getDragEventContext = (event: DragEvent) => {\n    // We need to check if there is text content that is being dragged (select some text & just drag it)\n    const textContentIsBeingDragged =\n      !event.dataTransfer?.types.includes(\"blocknote/html\") &&\n      !!this.pmView.dragging;\n    // This is the side menu drag from this plugin\n    const sideMenuIsBeingDragged = !!this.isDragOrigin;\n    // Tells us that the current editor instance has a drag ongoing (either text or side menu)\n    const isDragOrigin = textContentIsBeingDragged || sideMenuIsBeingDragged;\n\n    // Tells us which editor instance is the closest to the drag event (whether or not it is actually reasonably close)\n    const closestEditor = this.findClosestEditorElement(event);\n\n    // We arbitrarily decide how far is \"too far\" from the closest editor to be considered a drop point\n    if (\n      !closestEditor ||\n      closestEditor.distance > DISTANCE_TO_CONSIDER_EDITOR_BOUNDS\n    ) {\n      // we are too far from the closest editor, or no editor was found\n      return undefined;\n    }\n\n    // We check if the closest editor is the same as the current editor instance (which is the drop point)\n    const isDropPoint = closestEditor.element === this.pmView.dom;\n    // We check if the current editor instance is the same as the editor instance that the drag event is happening within\n    const isDropWithinEditorBounds =\n      isDropPoint && closestEditor.distance === 0;\n\n    // We never want to handle drop events that are not related to us\n    if (!isDropPoint && !isDragOrigin) {\n      // we are not the drop point or drag origin, so not relevant to us\n      return undefined;\n    }\n\n    return {\n      isDropPoint,\n      isDropWithinEditorBounds,\n      isDragOrigin,\n    };\n  };\n\n  /**\n   * The drop event handler listens at the document level,\n   * and handles drop events for all editors.\n   *\n   * It specifically handles the following cases:\n   *  - If we are both the drag origin and drop point:\n   *    - Let normal drop handling take over\n   *  - If we are the drop point but not the drag origin:\n   *    - Collapse selection to prevent PM from deleting unrelated content\n   *    - If drop event is outside our editor bounds, dispatch synthetic drop event to our editor\n   *  - If we are the drag origin but not the drop point:\n   *    - Delete the dragged content from our editor after a delay\n   */\n  onDrop = (event: DragEvent) => {\n    if ((event as any).synthetic) {\n      return;\n    }\n\n    const context = this.getDragEventContext(event);\n    if (!context) {\n      this.closeDropCursor();\n      // This is not a drag event that we are interested in\n      return;\n    }\n    const { isDropPoint, isDropWithinEditorBounds, isDragOrigin } = context;\n\n    if (!isDropWithinEditorBounds && isDropPoint) {\n      // Any time that the drop event is outside of the editor bounds (but still close to an editor instance)\n      // We dispatch a synthetic event that is in the bounds of the editor instance, to have the correct drop point\n      this.dispatchSyntheticEvent(event);\n    }\n\n    if (isDropPoint) {\n      // The current instance is the drop point\n\n      if (this.pmView.dragging) {\n        // Do not collapse selection when text content is being dragged\n        return;\n      }\n      // Because the editor selection is unrelated to the dragged content, we\n      // don't want PM to delete its content. Therefore, we collapse the\n      // selection.\n      this.pmView.dispatch(\n        this.pmView.state.tr.setSelection(\n          TextSelection.create(\n            this.pmView.state.tr.doc,\n            this.pmView.state.tr.selection.anchor,\n          ),\n        ),\n      );\n      return;\n    } else if (isDragOrigin) {\n      // The current instance is the drag origin, but not the drop point\n      // our content got dropped somewhere else\n\n      // Because the editor from which the block originates doesn't get a drop\n      // event on it, PM doesn't delete its selected content. Therefore, we\n      // need to do so manually.\n      //\n      // Note: Deleting the selected content from the editor from which the\n      // block originates, may change its height. This can cause the position of\n      // the editor in which the block is being dropping to shift, before it\n      // can handle the drop event. That in turn can cause the drop to happen\n      // somewhere other than the user intended. To get around this, we delay\n      // deleting the selected content until all editors have had the chance to\n      // handle the event.\n      setTimeout(\n        () => this.pmView.dispatch(this.pmView.state.tr.deleteSelection()),\n        0,\n      );\n      return;\n    }\n  };\n\n  onDragEnd = (event: DragEvent) => {\n    if ((event as any).synthetic) {\n      return;\n    }\n    // When the user starts dragging a block, `view.dragging` is set on all\n    // BlockNote editors. However, when the drag ends, only the editor that the\n    // drag originated in automatically clears `view.dragging`. Therefore, we\n    // have to manually clear it on all editors.\n    this.pmView.dragging = null;\n  };\n\n  onKeyDown = (_event: KeyboardEvent) => {\n    if (this.state?.show && this.editor.isFocused()) {\n      // Typing in editor should hide side menu\n      this.state.show = false;\n      this.emitUpdate(this.state);\n    }\n  };\n\n  onMouseMove = (event: MouseEvent) => {\n    if (this.menuFrozen) {\n      return;\n    }\n\n    this.mousePos = { x: event.clientX, y: event.clientY };\n\n    // We want the full area of the editor to check if the cursor is hovering\n    // above it though.\n    const editorOuterBoundingBox = this.pmView.dom.getBoundingClientRect();\n    const cursorWithinEditor =\n      this.mousePos.x > editorOuterBoundingBox.left &&\n      this.mousePos.x < editorOuterBoundingBox.right &&\n      this.mousePos.y > editorOuterBoundingBox.top &&\n      this.mousePos.y < editorOuterBoundingBox.bottom;\n\n    // TODO: remove parentElement, but then we need to remove padding from boundingbox or find a different solution\n    const editorWrapper = this.pmView.dom!.parentElement!;\n\n    // Doesn't update if the mouse hovers an element that's over the editor but\n    // isn't a part of it or the side menu.\n    if (\n      // Cursor is within the editor area\n      cursorWithinEditor &&\n      // An element is hovered\n      event &&\n      event.target &&\n      // Element is outside the editor\n      !(\n        editorWrapper === event.target ||\n        editorWrapper.contains(event.target as HTMLElement)\n      )\n    ) {\n      if (this.state?.show) {\n        this.state.show = false;\n        this.emitUpdate(this.state);\n      }\n\n      return;\n    }\n\n    this.updateStateFromMousePos();\n  };\n\n  private dispatchSyntheticEvent(event: DragEvent) {\n    const evt = new Event(event.type as \"dragover\", event) as any;\n    const dropPointBoundingBox = (\n      this.pmView.dom.firstChild as HTMLElement\n    ).getBoundingClientRect();\n    evt.clientX = event.clientX;\n    evt.clientY = event.clientY;\n\n    evt.clientX = Math.min(\n      Math.max(event.clientX, dropPointBoundingBox.left),\n      dropPointBoundingBox.left + dropPointBoundingBox.width,\n    );\n    evt.clientY = Math.min(\n      Math.max(event.clientY, dropPointBoundingBox.top),\n      dropPointBoundingBox.top + dropPointBoundingBox.height,\n    );\n\n    evt.dataTransfer = event.dataTransfer;\n    evt.preventDefault = () => event.preventDefault();\n    evt.synthetic = true; // prevent recursion\n    this.pmView.dom.dispatchEvent(evt);\n  }\n\n  onScroll = () => {\n    if (this.state?.show) {\n      this.state.referencePos = this.hoveredBlock!.getBoundingClientRect();\n      this.emitUpdate(this.state);\n    }\n    this.updateStateFromMousePos();\n  };\n\n  // Needed in cases where the editor state updates without the mouse cursor\n  // moving, as some state updates can require a side menu update. For example,\n  // adding a button to the side menu which removes the block can cause the\n  // block below to jump up into the place of the removed block when clicked,\n  // allowing the user to click the button again without moving the cursor. This\n  // would otherwise not update the side menu, and so clicking the button again\n  // would attempt to remove the same block again, causing an error.\n  update(_view: EditorView, prevState: EditorState) {\n    const docChanged = !prevState.doc.eq(this.pmView.state.doc);\n    if (docChanged && this.state?.show) {\n      this.updateStateFromMousePos();\n    }\n  }\n\n  destroy() {\n    if (this.state?.show) {\n      this.state.show = false;\n      this.emitUpdate(this.state);\n    }\n    this.pmView.root.removeEventListener(\n      \"mousemove\",\n      this.onMouseMove as EventListener,\n      true,\n    );\n    this.pmView.root.removeEventListener(\n      \"dragstart\",\n      this.onDragStart as EventListener,\n    );\n    this.pmView.root.removeEventListener(\n      \"dragover\",\n      this.onDragOver as EventListener,\n    );\n    this.pmView.root.removeEventListener(\n      \"drop\",\n      this.onDrop as EventListener,\n      true,\n    );\n    this.pmView.root.removeEventListener(\n      \"dragend\",\n      this.onDragEnd as EventListener,\n      true,\n    );\n    this.pmView.root.removeEventListener(\n      \"keydown\",\n      this.onKeyDown as EventListener,\n      true,\n    );\n    this.pmView.root.removeEventListener(\"scroll\", this.onScroll, true);\n  }\n}\n\nexport const sideMenuPluginKey = new PluginKey(\"SideMenuPlugin\");\n\nexport class SideMenuProsemirrorPlugin<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n> extends BlockNoteExtension {\n  public static key() {\n    return \"sideMenu\";\n  }\n\n  public view: SideMenuView<BSchema, I, S> | undefined;\n\n  constructor(private readonly editor: BlockNoteEditor<BSchema, I, S>) {\n    super();\n    this.addProsemirrorPlugin(\n      new Plugin({\n        key: sideMenuPluginKey,\n        view: (editorView) => {\n          this.view = new SideMenuView(editor, editorView, (state) => {\n            this.emit(\"update\", state);\n          });\n          return this.view;\n        },\n      }),\n    );\n  }\n\n  public onUpdate(callback: (state: SideMenuState<BSchema, I, S>) => void) {\n    return this.on(\"update\", callback);\n  }\n\n  /**\n   * Handles drag & drop events for blocks.\n   */\n  blockDragStart = (\n    event: {\n      dataTransfer: DataTransfer | null;\n      clientY: number;\n    },\n    block: Block<BSchema, I, S>,\n  ) => {\n    if (this.view) {\n      this.view.isDragOrigin = true;\n    }\n\n    dragStart(event, block, this.editor);\n  };\n\n  /**\n   * Handles drag & drop events for blocks.\n   */\n  blockDragEnd = () => {\n    unsetDragImage(this.editor.prosemirrorView.root);\n\n    if (this.view) {\n      this.view.isDragOrigin = false;\n    }\n  };\n  /**\n   * Freezes the side menu. When frozen, the side menu will stay\n   * attached to the same block regardless of which block is hovered by the\n   * mouse cursor.\n   */\n  freezeMenu = () => {\n    this.view!.menuFrozen = true;\n    this.view!.state!.show = true;\n    this.view!.emitUpdate(this.view!.state!);\n  };\n  /**\n   * Unfreezes the side menu. When frozen, the side menu will stay\n   * attached to the same block regardless of which block is hovered by the\n   * mouse cursor.\n   */\n  unfreezeMenu = () => {\n    this.view!.menuFrozen = false;\n    this.view!.state!.show = false;\n    this.view!.emitUpdate(this.view!.state!);\n  };\n}\n","import { Mapping } from \"prosemirror-transform\";\nimport {\n  absolutePositionToRelativePosition,\n  relativePositionToAbsolutePosition,\n  ySyncPluginKey,\n} from \"y-prosemirror\";\nimport type { BlockNoteEditor } from \"../editor/BlockNoteEditor.js\";\nimport * as Y from \"yjs\";\nimport type { ProsemirrorBinding } from \"y-prosemirror\";\n\n/**\n * This is used to track a mapping for each editor. The mapping stores the mappings for each transaction since the first transaction that was tracked.\n */\nconst editorToMapping = new Map<BlockNoteEditor<any, any, any>, Mapping>();\n\n/**\n * This initializes a single mapping for an editor instance.\n */\nfunction getMapping(editor: BlockNoteEditor<any, any, any>) {\n  if (editorToMapping.has(editor)) {\n    // Mapping already initialized, so we don't need to do anything\n    return editorToMapping.get(editor)!;\n  }\n  const mapping = new Mapping();\n  editor._tiptapEditor.on(\"transaction\", ({ transaction }) => {\n    mapping.appendMapping(transaction.mapping);\n  });\n  editor._tiptapEditor.on(\"destroy\", () => {\n    // Cleanup the mapping when the editor is destroyed\n    editorToMapping.delete(editor);\n  });\n\n  // There only is one mapping per editor, so we can just set it\n  editorToMapping.set(editor, mapping);\n\n  return mapping;\n}\n\n/**\n * This is used to keep track of positions of elements in the editor.\n * It is needed because y-prosemirror's sync plugin can disrupt normal prosemirror position mapping.\n *\n * It is specifically made to be able to be used whether the editor is being used in a collaboratively, or single user, providing the same API.\n *\n * @param editor The editor to track the position of.\n * @param position The position to track.\n * @param side The side of the position to track. \"left\" is the default. \"right\" would move with the change if the change is in the right direction.\n * @returns A function that returns the position of the element.\n */\nexport function trackPosition(\n  /**\n   * The editor to track the position of.\n   */\n  editor: BlockNoteEditor<any, any, any>,\n  /**\n   * The position to track.\n   */\n  position: number,\n  /**\n   * This is the side of the position to track. \"left\" is the default. \"right\" would move with the change if the change is in the right direction.\n   */\n  side: \"left\" | \"right\" = \"left\",\n): () => number {\n  const ySyncPluginState = ySyncPluginKey.getState(editor.prosemirrorState) as {\n    doc: Y.Doc;\n    binding: ProsemirrorBinding;\n  };\n\n  if (!ySyncPluginState) {\n    // No y-prosemirror sync plugin, so we need to track the mapping manually\n    // This will initialize the mapping for this editor, if needed\n    const mapping = getMapping(editor);\n\n    // This is the start point of tracking the mapping\n    const trackedMapLength = mapping.maps.length;\n\n    return () => {\n      const pos = mapping\n        // Only read the history of the mapping that we care about\n        .slice(trackedMapLength)\n        .map(position, side === \"left\" ? -1 : 1);\n\n      return pos;\n    };\n  }\n\n  const relativePosition = absolutePositionToRelativePosition(\n    // Track the position after the position if we are on the right side\n    position + (side === \"right\" ? 1 : -1),\n    ySyncPluginState.binding.type,\n    ySyncPluginState.binding.mapping,\n  );\n\n  return () => {\n    const curYSyncPluginState = ySyncPluginKey.getState(\n      editor.prosemirrorState,\n    ) as typeof ySyncPluginState;\n    const pos = relativePositionToAbsolutePosition(\n      curYSyncPluginState.doc,\n      curYSyncPluginState.binding.type,\n      relativePosition,\n      curYSyncPluginState.binding.mapping,\n    );\n\n    // This can happen if the element is garbage collected\n    if (pos === null) {\n      throw new Error(\"Position not found, cannot track positions\");\n    }\n\n    return pos + (side === \"right\" ? -1 : 1);\n  };\n}\n","import { findParentNode } from \"@tiptap/core\";\nimport { EditorState, Plugin, PluginKey } from \"prosemirror-state\";\nimport { Decoration, DecorationSet, EditorView } from \"prosemirror-view\";\n\nimport { trackPosition } from \"../../api/positionMapping.js\";\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport { BlockNoteExtension } from \"../../editor/BlockNoteExtension.js\";\nimport { UiElementPosition } from \"../../extensions-shared/UiElementPosition.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\n\nconst findBlock = findParentNode((node) => node.type.name === \"blockContainer\");\n\nexport type SuggestionMenuState = UiElementPosition & {\n  query: string;\n  ignoreQueryLength?: boolean;\n};\n\nclass SuggestionMenuView<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n> {\n  public state?: SuggestionMenuState;\n  public emitUpdate: (triggerCharacter: string) => void;\n  private rootEl?: Document | ShadowRoot;\n  pluginState: SuggestionPluginState;\n\n  constructor(\n    private readonly editor: BlockNoteEditor<BSchema, I, S>,\n    emitUpdate: (menuName: string, state: SuggestionMenuState) => void,\n    view: EditorView,\n  ) {\n    this.pluginState = undefined;\n\n    this.emitUpdate = (menuName: string) => {\n      if (!this.state) {\n        throw new Error(\"Attempting to update uninitialized suggestions menu\");\n      }\n\n      emitUpdate(menuName, {\n        ...this.state,\n        ignoreQueryLength: this.pluginState?.ignoreQueryLength,\n      });\n    };\n\n    this.rootEl = view.root;\n\n    // Setting capture=true ensures that any parent container of the editor that\n    // gets scrolled will trigger the scroll event. Scroll events do not bubble\n    // and so won't propagate to the document by default.\n    this.rootEl?.addEventListener(\"scroll\", this.handleScroll, true);\n  }\n\n  handleScroll = () => {\n    if (this.state?.show) {\n      const decorationNode = this.rootEl?.querySelector(\n        `[data-decoration-id=\"${this.pluginState!.decorationId}\"]`,\n      );\n      if (!decorationNode) {\n        return;\n      }\n      this.state.referencePos = decorationNode.getBoundingClientRect();\n      this.emitUpdate(this.pluginState!.triggerCharacter!);\n    }\n  };\n\n  update(view: EditorView, prevState: EditorState) {\n    const prev: SuggestionPluginState =\n      suggestionMenuPluginKey.getState(prevState);\n    const next: SuggestionPluginState = suggestionMenuPluginKey.getState(\n      view.state,\n    );\n\n    // See how the state changed\n    const started = prev === undefined && next !== undefined;\n    const stopped = prev !== undefined && next === undefined;\n    const changed = prev !== undefined && next !== undefined;\n\n    // Cancel when suggestion isn't active\n    if (!started && !changed && !stopped) {\n      return;\n    }\n\n    this.pluginState = stopped ? prev : next;\n\n    if (stopped || !this.editor.isEditable) {\n      if (this.state) {\n        this.state.show = false;\n      }\n      this.emitUpdate(this.pluginState!.triggerCharacter);\n\n      return;\n    }\n\n    const decorationNode = this.rootEl?.querySelector(\n      `[data-decoration-id=\"${this.pluginState!.decorationId}\"]`,\n    );\n\n    if (this.editor.isEditable && decorationNode) {\n      this.state = {\n        show: true,\n        referencePos: decorationNode.getBoundingClientRect(),\n        query: this.pluginState!.query,\n      };\n\n      this.emitUpdate(this.pluginState!.triggerCharacter!);\n    }\n  }\n\n  destroy() {\n    this.rootEl?.removeEventListener(\"scroll\", this.handleScroll, true);\n  }\n\n  closeMenu = () => {\n    this.editor.transact((tr) => tr.setMeta(suggestionMenuPluginKey, null));\n  };\n\n  clearQuery = () => {\n    if (this.pluginState === undefined) {\n      return;\n    }\n\n    this.editor._tiptapEditor\n      .chain()\n      .focus()\n      // TODO need to make an API for this\n      .deleteRange({\n        from:\n          this.pluginState.queryStartPos() -\n          (this.pluginState.deleteTriggerCharacter\n            ? this.pluginState.triggerCharacter!.length\n            : 0),\n        to: this.editor.transact((tr) => tr.selection.from),\n      })\n      .run();\n  };\n}\n\ntype SuggestionPluginState =\n  | {\n      triggerCharacter: string;\n      deleteTriggerCharacter: boolean;\n      queryStartPos: () => number;\n      query: string;\n      decorationId: string;\n      ignoreQueryLength?: boolean;\n    }\n  | undefined;\n\nconst suggestionMenuPluginKey = new PluginKey(\"SuggestionMenuPlugin\");\n\n/**\n * A ProseMirror plugin for suggestions, designed to make '/'-commands possible as well as mentions.\n *\n * This is basically a simplified version of TipTap's [Suggestions](https://github.com/ueberdosis/tiptap/tree/db92a9b313c5993b723c85cd30256f1d4a0b65e1/packages/suggestion) plugin.\n *\n * This version is adapted from the aforementioned version in the following ways:\n * - This version supports generic items instead of only strings (to allow for more advanced filtering for example)\n * - This version hides some unnecessary complexity from the user of the plugin.\n * - This version handles key events differently\n */\nexport class SuggestionMenuProseMirrorPlugin<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n> extends BlockNoteExtension {\n  public static key() {\n    return \"suggestionMenu\";\n  }\n\n  private view: SuggestionMenuView<BSchema, I, S> | undefined;\n  private triggerCharacters: string[] = [];\n\n  constructor(editor: BlockNoteEditor<BSchema, I, S>) {\n    super();\n    const triggerCharacters = this.triggerCharacters;\n    this.addProsemirrorPlugin(\n      new Plugin({\n        key: suggestionMenuPluginKey,\n\n        view: (view) => {\n          this.view = new SuggestionMenuView<BSchema, I, S>(\n            editor,\n            (triggerCharacter, state) => {\n              this.emit(`update ${triggerCharacter}`, state);\n            },\n            view,\n          );\n          return this.view;\n        },\n\n        state: {\n          // Initialize the plugin's internal state.\n          init(): SuggestionPluginState {\n            return undefined;\n          },\n\n          // Apply changes to the plugin state from an editor transaction.\n          apply: (\n            transaction,\n            prev,\n            _oldState,\n            newState,\n          ): SuggestionPluginState => {\n            // Ignore transactions in code blocks.\n            if (transaction.selection.$from.parent.type.spec.code) {\n              return prev;\n            }\n\n            // Either contains the trigger character if the menu should be shown,\n            // or null if it should be hidden.\n            const suggestionPluginTransactionMeta: {\n              triggerCharacter: string;\n              deleteTriggerCharacter?: boolean;\n              ignoreQueryLength?: boolean;\n            } | null = transaction.getMeta(suggestionMenuPluginKey);\n\n            if (\n              typeof suggestionPluginTransactionMeta === \"object\" &&\n              suggestionPluginTransactionMeta !== null\n            ) {\n              if (prev) {\n                // Close the previous menu if it exists\n                this.closeMenu();\n              }\n              const trackedPosition = trackPosition(\n                editor,\n                newState.selection.from -\n                  // Need to account for the trigger char that was inserted, so we offset the position by the length of the trigger character.\n                  suggestionPluginTransactionMeta.triggerCharacter.length,\n              );\n              return {\n                triggerCharacter:\n                  suggestionPluginTransactionMeta.triggerCharacter,\n                deleteTriggerCharacter:\n                  suggestionPluginTransactionMeta.deleteTriggerCharacter !==\n                  false,\n                // When reading the queryStartPos, we offset the result by the length of the trigger character, to make it easy on the caller\n                queryStartPos: () =>\n                  trackedPosition() +\n                  suggestionPluginTransactionMeta.triggerCharacter.length,\n                query: \"\",\n                decorationId: `id_${Math.floor(Math.random() * 0xffffffff)}`,\n                ignoreQueryLength:\n                  suggestionPluginTransactionMeta?.ignoreQueryLength,\n              };\n            }\n\n            // Checks if the menu is hidden, in which case it doesn't need to be hidden or updated.\n            if (prev === undefined) {\n              return prev;\n            }\n\n            // Checks if the menu should be hidden.\n            if (\n              // Highlighting text should hide the menu.\n              newState.selection.from !== newState.selection.to ||\n              // Transactions with plugin metadata should hide the menu.\n              suggestionPluginTransactionMeta === null ||\n              // Certain mouse events should hide the menu.\n              // TODO: Change to global mousedown listener.\n              transaction.getMeta(\"focus\") ||\n              transaction.getMeta(\"blur\") ||\n              transaction.getMeta(\"pointer\") ||\n              // Moving the caret before the character which triggered the menu should hide it.\n              (prev.triggerCharacter !== undefined &&\n                newState.selection.from < prev.queryStartPos()) ||\n              // Moving the caret to a new block should hide the menu.\n              !newState.selection.$from.sameParent(\n                newState.doc.resolve(prev.queryStartPos()),\n              )\n            ) {\n              return undefined;\n            }\n\n            const next = { ...prev };\n\n            // Updates the current query.\n            next.query = newState.doc.textBetween(\n              prev.queryStartPos(),\n              newState.selection.from,\n            );\n\n            return next;\n          },\n        },\n\n        props: {\n          handleTextInput(view, from, to, text) {\n            // only on insert\n            if (from === to) {\n              const doc = view.state.doc;\n              for (const str of triggerCharacters) {\n                const snippet =\n                  str.length > 1\n                    ? doc.textBetween(from - str.length, from) + text\n                    : text;\n\n                if (str === snippet) {\n                  view.dispatch(view.state.tr.insertText(text));\n                  view.dispatch(\n                    view.state.tr\n                      .setMeta(suggestionMenuPluginKey, {\n                        triggerCharacter: snippet,\n                      })\n                      .scrollIntoView(),\n                  );\n                  return true;\n                }\n              }\n            }\n            return false;\n          },\n\n          // Setup decorator on the currently active suggestion.\n          decorations(state) {\n            const suggestionPluginState: SuggestionPluginState = (\n              this as Plugin\n            ).getState(state);\n\n            if (suggestionPluginState === undefined) {\n              return null;\n            }\n\n            // If the menu was opened programmatically by another extension, it may not use a trigger character. In this\n            // case, the decoration is set on the whole block instead, as the decoration range would otherwise be empty.\n            if (!suggestionPluginState.deleteTriggerCharacter) {\n              const blockNode = findBlock(state.selection);\n              if (blockNode) {\n                return DecorationSet.create(state.doc, [\n                  Decoration.node(\n                    blockNode.pos,\n                    blockNode.pos + blockNode.node.nodeSize,\n                    {\n                      nodeName: \"span\",\n                      class: \"bn-suggestion-decorator\",\n                      \"data-decoration-id\": suggestionPluginState.decorationId,\n                    },\n                  ),\n                ]);\n              }\n            }\n            // Creates an inline decoration around the trigger character.\n            return DecorationSet.create(state.doc, [\n              Decoration.inline(\n                suggestionPluginState.queryStartPos() -\n                  suggestionPluginState.triggerCharacter!.length,\n                suggestionPluginState.queryStartPos(),\n                {\n                  nodeName: \"span\",\n                  class: \"bn-suggestion-decorator\",\n                  \"data-decoration-id\": suggestionPluginState.decorationId,\n                },\n              ),\n            ]);\n          },\n        },\n      }),\n    );\n  }\n\n  public onUpdate(\n    triggerCharacter: string,\n    callback: (state: SuggestionMenuState) => void,\n  ) {\n    if (!this.triggerCharacters.includes(triggerCharacter)) {\n      this.addTriggerCharacter(triggerCharacter);\n    }\n    // TODO: be able to remove the triggerCharacter\n    return this.on(`update ${triggerCharacter}`, callback);\n  }\n\n  addTriggerCharacter = (triggerCharacter: string) => {\n    this.triggerCharacters.push(triggerCharacter);\n  };\n\n  // TODO: Should this be called automatically when listeners are removed?\n  removeTriggerCharacter = (triggerCharacter: string) => {\n    this.triggerCharacters = this.triggerCharacters.filter(\n      (c) => c !== triggerCharacter,\n    );\n  };\n\n  closeMenu = () => this.view!.closeMenu();\n\n  clearQuery = () => this.view!.clearQuery();\n\n  public get shown() {\n    return this.view?.state?.show || false;\n  }\n}\n\nexport function createSuggestionMenu<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(editor: BlockNoteEditor<BSchema, I, S>, triggerCharacter: string) {\n  editor.suggestionMenus.addTriggerCharacter(triggerCharacter);\n}\n","import { Mark } from \"@tiptap/core\";\nimport { MarkSpec } from \"prosemirror-model\";\n\n// This copies the marks from @handlewithcare/prosemirror-suggest-changes,\n// but uses the Tiptap Mark API instead so we can use them in BlockNote\n\n// The ideal solution would be to not depend on tiptap nodes / marks, but be able to use prosemirror nodes / marks directly\n// this way we could directly use the exported marks from @handlewithcare/prosemirror-suggest-changes\nexport const SuggestionAddMark = Mark.create({\n  name: \"insertion\",\n  inclusive: false,\n  excludes: \"deletion modification insertion\",\n  addAttributes() {\n    return {\n      id: { default: null, validate: \"number\" }, // note: validate is supported in prosemirror but not in tiptap, so this doesn't actually work (considered not critical)\n    };\n  },\n  extendMarkSchema(extension) {\n    if (extension.name !== \"insertion\") {\n      return {};\n    }\n    return {\n      blocknoteIgnore: true,\n      inclusive: false,\n\n      toDOM(mark, inline) {\n        return [\n          \"ins\",\n          {\n            \"data-id\": String(mark.attrs[\"id\"]),\n            \"data-inline\": String(inline),\n            ...(!inline && { style: \"display: contents\" }), // changed to \"contents\" to make this work for table rows\n          },\n          0,\n        ];\n      },\n      parseDOM: [\n        {\n          tag: \"ins\",\n          getAttrs(node) {\n            if (!node.dataset[\"id\"]) {\n              return false;\n            }\n            return {\n              id: parseInt(node.dataset[\"id\"], 10),\n            };\n          },\n        },\n      ],\n    } satisfies MarkSpec;\n  },\n});\n\nexport const SuggestionDeleteMark = Mark.create({\n  name: \"deletion\",\n  inclusive: false,\n  excludes: \"insertion modification deletion\",\n  addAttributes() {\n    return {\n      id: { default: null, validate: \"number\" }, // note: validate is supported in prosemirror but not in tiptap\n    };\n  },\n  extendMarkSchema(extension) {\n    if (extension.name !== \"deletion\") {\n      return {};\n    }\n    return {\n      blocknoteIgnore: true,\n      inclusive: false,\n\n      // attrs: {\n      //   id: { validate: \"number\" },\n      // },\n      toDOM(mark, inline) {\n        return [\n          \"del\",\n          {\n            \"data-id\": String(mark.attrs[\"id\"]),\n            \"data-inline\": String(inline),\n            ...(!inline && { style: \"display: contents\" }), // changed to \"contents\" to make this work for table rows\n          },\n          0,\n        ];\n      },\n      parseDOM: [\n        {\n          tag: \"del\",\n          getAttrs(node) {\n            if (!node.dataset[\"id\"]) {\n              return false;\n            }\n            return {\n              id: parseInt(node.dataset[\"id\"], 10),\n            };\n          },\n        },\n      ],\n    } satisfies MarkSpec;\n  },\n});\n\nexport const SuggestionModificationMark = Mark.create({\n  name: \"modification\",\n  inclusive: false,\n  excludes: \"deletion insertion\",\n  addAttributes() {\n    // note: validate is supported in prosemirror but not in tiptap\n    return {\n      id: { default: null, validate: \"number\" },\n      type: { validate: \"string\" },\n      attrName: { default: null, validate: \"string|null\" },\n      previousValue: { default: null },\n      newValue: { default: null },\n    };\n  },\n  extendMarkSchema(extension) {\n    if (extension.name !== \"modification\") {\n      return {};\n    }\n    return {\n      blocknoteIgnore: true,\n      inclusive: false,\n      // attrs: {\n      //   id: { validate: \"number\" },\n      //   type: { validate: \"string\" },\n      //   attrName: { default: null, validate: \"string|null\" },\n      //   previousValue: { default: null },\n      //   newValue: { default: null },\n      // },\n      toDOM(mark, inline) {\n        return [\n          inline ? \"span\" : \"div\",\n          {\n            \"data-type\": \"modification\",\n            \"data-id\": String(mark.attrs[\"id\"]),\n            \"data-mod-type\": mark.attrs[\"type\"] as string,\n            \"data-mod-prev-val\": JSON.stringify(mark.attrs[\"previousValue\"]),\n            // TODO: Try to serialize marks with toJSON?\n            \"data-mod-new-val\": JSON.stringify(mark.attrs[\"newValue\"]),\n          },\n          0,\n        ];\n      },\n      parseDOM: [\n        {\n          tag: \"span[data-type='modification']\",\n          getAttrs(node) {\n            if (!node.dataset[\"id\"]) {\n              return false;\n            }\n            return {\n              id: parseInt(node.dataset[\"id\"], 10),\n              type: node.dataset[\"modType\"],\n              previousValue: node.dataset[\"modPrevVal\"],\n              newValue: node.dataset[\"modNewVal\"],\n            };\n          },\n        },\n        {\n          tag: \"div[data-type='modification']\",\n          getAttrs(node) {\n            if (!node.dataset[\"id\"]) {\n              return false;\n            }\n            return {\n              id: parseInt(node.dataset[\"id\"], 10),\n              type: node.dataset[\"modType\"],\n              previousValue: node.dataset[\"modPrevVal\"],\n            };\n          },\n        },\n      ],\n    } satisfies MarkSpec;\n  },\n});\n","import { EditorState, Plugin, PluginKey, PluginView } from \"prosemirror-state\";\nimport {\n  CellSelection,\n  addColumnAfter,\n  addColumnBefore,\n  addRowAfter,\n  addRowBefore,\n  deleteColumn,\n  deleteRow,\n  mergeCells,\n  splitCell,\n} from \"prosemirror-tables\";\nimport { Decoration, DecorationSet, EditorView } from \"prosemirror-view\";\nimport {\n  RelativeCellIndices,\n  addRowsOrColumns,\n  areInSameColumn,\n  canColumnBeDraggedInto,\n  canRowBeDraggedInto,\n  cropEmptyRowsOrColumns,\n  getCellsAtColumnHandle,\n  getCellsAtRowHandle,\n  getDimensionsOfTable,\n  moveColumn,\n  moveRow,\n} from \"../../api/blockManipulation/tables/tables.js\";\nimport { nodeToBlock } from \"../../api/nodeConversions/nodeToBlock.js\";\nimport { getNodeById } from \"../../api/nodeUtil.js\";\nimport {\n  editorHasBlockWithType,\n  isTableCellSelection,\n} from \"../../blocks/defaultBlockTypeGuards.js\";\nimport { DefaultBlockSchema } from \"../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport { BlockNoteExtension } from \"../../editor/BlockNoteExtension.js\";\nimport {\n  BlockFromConfigNoChildren,\n  BlockSchemaWithBlock,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\nimport { getDraggableBlockFromElement } from \"../getDraggableBlockFromElement.js\";\n\nlet dragImageElement: HTMLElement | undefined;\n\n// TODO consider switching this to jotai, it is a bit messy and noisy\nexport type TableHandlesState<\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n> = {\n  show: boolean;\n  showAddOrRemoveRowsButton: boolean;\n  showAddOrRemoveColumnsButton: boolean;\n  referencePosCell: DOMRect | undefined;\n  referencePosTable: DOMRect;\n\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], I, S>;\n  colIndex: number | undefined;\n  rowIndex: number | undefined;\n\n  draggingState:\n    | {\n        draggedCellOrientation: \"row\" | \"col\";\n        originalIndex: number;\n        mousePos: number;\n      }\n    | undefined;\n\n  widgetContainer: HTMLElement | undefined;\n};\n\nfunction setHiddenDragImage(rootEl: Document | ShadowRoot) {\n  if (dragImageElement) {\n    return;\n  }\n\n  dragImageElement = document.createElement(\"div\");\n  dragImageElement.innerHTML = \"_\";\n  dragImageElement.style.opacity = \"0\";\n  dragImageElement.style.height = \"1px\";\n  dragImageElement.style.width = \"1px\";\n  if (rootEl instanceof Document) {\n    rootEl.body.appendChild(dragImageElement);\n  } else {\n    rootEl.appendChild(dragImageElement);\n  }\n}\n\nfunction unsetHiddenDragImage(rootEl: Document | ShadowRoot) {\n  if (dragImageElement) {\n    if (rootEl instanceof Document) {\n      rootEl.body.removeChild(dragImageElement);\n    } else {\n      rootEl.removeChild(dragImageElement);\n    }\n    dragImageElement = undefined;\n  }\n}\n\nfunction getChildIndex(node: Element) {\n  return Array.prototype.indexOf.call(node.parentElement!.childNodes, node);\n}\n\n// Finds the DOM element corresponding to the table cell that the target element\n// is currently in. If the target element is not in a table cell, returns null.\nfunction domCellAround(target: Element) {\n  let currentTarget: Element | undefined = target;\n  while (\n    currentTarget &&\n    currentTarget.nodeName !== \"TD\" &&\n    currentTarget.nodeName !== \"TH\" &&\n    !currentTarget.classList.contains(\"tableWrapper\")\n  ) {\n    if (currentTarget.classList.contains(\"ProseMirror\")) {\n      return undefined;\n    }\n    const parent: ParentNode | null = currentTarget.parentNode;\n\n    if (!parent || !(parent instanceof Element)) {\n      return undefined;\n    }\n    currentTarget = parent;\n  }\n\n  return currentTarget.nodeName === \"TD\" || currentTarget.nodeName === \"TH\"\n    ? {\n        type: \"cell\",\n        domNode: currentTarget,\n        tbodyNode: currentTarget.closest(\"tbody\"),\n      }\n    : {\n        type: \"wrapper\",\n        domNode: currentTarget,\n        tbodyNode: currentTarget.querySelector(\"tbody\"),\n      };\n}\n\n// Hides elements in the DOMwith the provided class names.\nfunction hideElements(selector: string, rootEl: Document | ShadowRoot) {\n  const elementsToHide = rootEl.querySelectorAll(selector);\n\n  for (let i = 0; i < elementsToHide.length; i++) {\n    (elementsToHide[i] as HTMLElement).style.visibility = \"hidden\";\n  }\n}\n\nexport class TableHandlesView<\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n> implements PluginView\n{\n  public state?: TableHandlesState<I, S>;\n  public emitUpdate: () => void;\n\n  public tableId: string | undefined;\n  public tablePos: number | undefined;\n  public tableElement: HTMLElement | undefined;\n\n  public menuFrozen = false;\n\n  public mouseState: \"up\" | \"down\" | \"selecting\" = \"up\";\n\n  public prevWasEditable: boolean | null = null;\n\n  constructor(\n    private readonly editor: BlockNoteEditor<\n      BlockSchemaWithBlock<\"table\", DefaultBlockSchema[\"table\"]>,\n      I,\n      S\n    >,\n    private readonly pmView: EditorView,\n    emitUpdate: (state: TableHandlesState<I, S>) => void,\n  ) {\n    this.emitUpdate = () => {\n      if (!this.state) {\n        throw new Error(\"Attempting to update uninitialized image toolbar\");\n      }\n\n      emitUpdate(this.state);\n    };\n\n    pmView.dom.addEventListener(\"mousemove\", this.mouseMoveHandler);\n    pmView.dom.addEventListener(\"mousedown\", this.viewMousedownHandler);\n    window.addEventListener(\"mouseup\", this.mouseUpHandler);\n\n    pmView.root.addEventListener(\n      \"dragover\",\n      this.dragOverHandler as EventListener,\n    );\n    pmView.root.addEventListener(\n      \"drop\",\n      this.dropHandler as unknown as EventListener,\n    );\n  }\n\n  viewMousedownHandler = () => {\n    this.mouseState = \"down\";\n  };\n\n  mouseUpHandler = (event: MouseEvent) => {\n    this.mouseState = \"up\";\n    this.mouseMoveHandler(event);\n  };\n\n  mouseMoveHandler = (event: MouseEvent) => {\n    if (this.menuFrozen) {\n      return;\n    }\n\n    if (this.mouseState === \"selecting\") {\n      return;\n    }\n\n    if (\n      !(event.target instanceof Element) ||\n      !this.pmView.dom.contains(event.target)\n    ) {\n      return;\n    }\n\n    const target = domCellAround(event.target);\n\n    if (\n      target?.type === \"cell\" &&\n      this.mouseState === \"down\" &&\n      !this.state?.draggingState\n    ) {\n      // hide draghandles when selecting text as they could be in the way of the user\n      this.mouseState = \"selecting\";\n\n      if (this.state?.show) {\n        this.state.show = false;\n        this.state.showAddOrRemoveRowsButton = false;\n        this.state.showAddOrRemoveColumnsButton = false;\n        this.emitUpdate();\n      }\n      return;\n    }\n\n    if (!target || !this.editor.isEditable) {\n      if (this.state?.show) {\n        this.state.show = false;\n        this.state.showAddOrRemoveRowsButton = false;\n        this.state.showAddOrRemoveColumnsButton = false;\n        this.emitUpdate();\n      }\n      return;\n    }\n\n    if (!target.tbodyNode) {\n      return;\n    }\n\n    const tableRect = target.tbodyNode.getBoundingClientRect();\n\n    const blockEl = getDraggableBlockFromElement(target.domNode, this.pmView);\n    if (!blockEl) {\n      return;\n    }\n    this.tableElement = blockEl.node;\n\n    let tableBlock:\n      | BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], I, S>\n      | undefined;\n\n    const pmNodeInfo = this.editor.transact((tr) =>\n      getNodeById(blockEl.id, tr.doc),\n    );\n    if (!pmNodeInfo) {\n      throw new Error(`Block with ID ${blockEl.id} not found`);\n    }\n\n    const block = nodeToBlock(\n      pmNodeInfo.node,\n      this.editor.pmSchema,\n      this.editor.schema.blockSchema,\n      this.editor.schema.inlineContentSchema,\n      this.editor.schema.styleSchema,\n    );\n\n    if (editorHasBlockWithType(this.editor, \"table\")) {\n      this.tablePos = pmNodeInfo.posBeforeNode + 1;\n      tableBlock = block;\n    }\n\n    if (!tableBlock) {\n      return;\n    }\n\n    this.tableId = blockEl.id;\n    const widgetContainer = target.domNode\n      .closest(\".tableWrapper\")\n      ?.querySelector(\".table-widgets-container\") as HTMLElement;\n\n    if (target?.type === \"wrapper\") {\n      // if we're just to the right or below the table, show the extend buttons\n      // (this is a bit hacky. It would probably be cleaner to render the extend buttons in the Table NodeView instead)\n      const belowTable =\n        event.clientY >= tableRect.bottom - 1 && // -1 to account for fractions of pixels in \"bottom\"\n        event.clientY < tableRect.bottom + 20;\n      const toRightOfTable =\n        event.clientX >= tableRect.right - 1 &&\n        event.clientX < tableRect.right + 20;\n\n      // without this check, we'd also hide draghandles when hovering over them\n      const hideHandles =\n        event.clientX > tableRect.right || event.clientY > tableRect.bottom;\n\n      this.state = {\n        ...this.state!,\n        show: true,\n        showAddOrRemoveRowsButton: belowTable,\n        showAddOrRemoveColumnsButton: toRightOfTable,\n        referencePosTable: tableRect,\n        block: tableBlock,\n        widgetContainer,\n        colIndex: hideHandles ? undefined : this.state?.colIndex,\n        rowIndex: hideHandles ? undefined : this.state?.rowIndex,\n        referencePosCell: hideHandles\n          ? undefined\n          : this.state?.referencePosCell,\n      };\n    } else {\n      const colIndex = getChildIndex(target.domNode);\n      const rowIndex = getChildIndex(target.domNode.parentElement!);\n      const cellRect = target.domNode.getBoundingClientRect();\n\n      if (\n        this.state !== undefined &&\n        this.state.show &&\n        this.tableId === blockEl.id &&\n        this.state.rowIndex === rowIndex &&\n        this.state.colIndex === colIndex\n      ) {\n        // no update needed\n        return;\n      }\n\n      this.state = {\n        show: true,\n        showAddOrRemoveColumnsButton:\n          colIndex === tableBlock.content.rows[0].cells.length - 1,\n        showAddOrRemoveRowsButton:\n          rowIndex === tableBlock.content.rows.length - 1,\n        referencePosTable: tableRect,\n\n        block: tableBlock,\n        draggingState: undefined,\n        referencePosCell: cellRect,\n        colIndex: colIndex,\n        rowIndex: rowIndex,\n\n        widgetContainer,\n      };\n    }\n    this.emitUpdate();\n\n    return false;\n  };\n\n  dragOverHandler = (event: DragEvent) => {\n    if (this.state?.draggingState === undefined) {\n      return;\n    }\n\n    event.preventDefault();\n    event.dataTransfer!.dropEffect = \"move\";\n\n    hideElements(\n      \".prosemirror-dropcursor-block, .prosemirror-dropcursor-inline\",\n      this.pmView.root,\n    );\n\n    // The mouse cursor coordinates, bounded to the table's bounding box. The\n    // bounding box is shrunk by 1px on each side to ensure that the bounded\n    // coordinates are always inside a table cell.\n    const boundedMouseCoords = {\n      left: Math.min(\n        Math.max(event.clientX, this.state.referencePosTable.left + 1),\n        this.state.referencePosTable.right - 1,\n      ),\n      top: Math.min(\n        Math.max(event.clientY, this.state.referencePosTable.top + 1),\n        this.state.referencePosTable.bottom - 1,\n      ),\n    };\n\n    // Gets the table cell element that the bounded mouse cursor coordinates lie\n    // in.\n    const tableCellElements = this.pmView.root\n      .elementsFromPoint(boundedMouseCoords.left, boundedMouseCoords.top)\n      .filter(\n        (element) => element.tagName === \"TD\" || element.tagName === \"TH\",\n      );\n    if (tableCellElements.length === 0) {\n      return;\n    }\n    const tableCellElement = tableCellElements[0];\n\n    let emitStateUpdate = false;\n\n    // Gets current row and column index.\n    const rowIndex = getChildIndex(tableCellElement.parentElement!);\n    const colIndex = getChildIndex(tableCellElement);\n\n    // Checks if the drop cursor needs to be updated. This affects decorations\n    // only so it doesn't trigger a state update.\n    const oldIndex =\n      this.state.draggingState.draggedCellOrientation === \"row\"\n        ? this.state.rowIndex\n        : this.state.colIndex;\n    const newIndex =\n      this.state.draggingState.draggedCellOrientation === \"row\"\n        ? rowIndex\n        : colIndex;\n    const dispatchDecorationsTransaction = newIndex !== oldIndex;\n\n    // Checks if either the hovered cell has changed and updates the row and\n    // column index. Also updates the reference DOMRect.\n    if (this.state.rowIndex !== rowIndex || this.state.colIndex !== colIndex) {\n      this.state.rowIndex = rowIndex;\n      this.state.colIndex = colIndex;\n\n      this.state.referencePosCell = tableCellElement.getBoundingClientRect();\n\n      emitStateUpdate = true;\n    }\n\n    // Checks if the mouse cursor position along the axis that the user is\n    // dragging on has changed and updates it.\n    const mousePos =\n      this.state.draggingState.draggedCellOrientation === \"row\"\n        ? boundedMouseCoords.top\n        : boundedMouseCoords.left;\n    if (this.state.draggingState.mousePos !== mousePos) {\n      this.state.draggingState.mousePos = mousePos;\n\n      emitStateUpdate = true;\n    }\n\n    // Emits a state update if any of the fields have changed.\n    if (emitStateUpdate) {\n      this.emitUpdate();\n    }\n\n    // Dispatches a dummy transaction to force a decorations update if\n    // necessary.\n    if (dispatchDecorationsTransaction) {\n      this.editor.transact((tr) => tr.setMeta(tableHandlesPluginKey, true));\n    }\n  };\n\n  dropHandler = (event: DragEvent) => {\n    this.mouseState = \"up\";\n    if (this.state === undefined || this.state.draggingState === undefined) {\n      return false;\n    }\n\n    if (\n      this.state.rowIndex === undefined ||\n      this.state.colIndex === undefined\n    ) {\n      throw new Error(\n        \"Attempted to drop table row or column, but no table block was hovered prior.\",\n      );\n    }\n\n    event.preventDefault();\n\n    const { draggingState, colIndex, rowIndex } = this.state;\n\n    const columnWidths = this.state.block.content.columnWidths;\n\n    if (draggingState.draggedCellOrientation === \"row\") {\n      if (\n        !canRowBeDraggedInto(\n          this.state.block,\n          draggingState.originalIndex,\n          rowIndex,\n        )\n      ) {\n        // If the target row is invalid, don't move the row\n        return false;\n      }\n      const newTable = moveRow(\n        this.state.block,\n        draggingState.originalIndex,\n        rowIndex,\n      );\n      this.editor.updateBlock(this.state.block, {\n        type: \"table\",\n        content: {\n          ...this.state.block.content,\n          rows: newTable as any,\n        },\n      });\n    } else {\n      if (\n        !canColumnBeDraggedInto(\n          this.state.block,\n          draggingState.originalIndex,\n          colIndex,\n        )\n      ) {\n        // If the target column is invalid, don't move the column\n        return false;\n      }\n      const newTable = moveColumn(\n        this.state.block,\n        draggingState.originalIndex,\n        colIndex,\n      );\n      const [columnWidth] = columnWidths.splice(draggingState.originalIndex, 1);\n      columnWidths.splice(colIndex, 0, columnWidth);\n      this.editor.updateBlock(this.state.block, {\n        type: \"table\",\n        content: {\n          ...this.state.block.content,\n          columnWidths,\n          rows: newTable as any,\n        },\n      });\n    }\n\n    // Have to reset text cursor position to the block as `updateBlock` moves\n    // the existing selection out of the block.\n    this.editor.setTextCursorPosition(this.state.block.id);\n\n    return true;\n  };\n  // Updates drag handles when the table is modified or removed.\n  update() {\n    if (!this.state || !this.state.show) {\n      return;\n    }\n\n    // Hide handles if the table block has been removed.\n    this.state.block = this.editor.getBlock(this.state.block.id)!;\n    if (\n      !this.state.block ||\n      this.state.block.type !== \"table\" ||\n      // when collaborating, the table element might be replaced and out of date\n      // because yjs replaces the element when for example you change the color via the side menu\n      !this.tableElement?.isConnected\n    ) {\n      this.state.show = false;\n      this.state.showAddOrRemoveRowsButton = false;\n      this.state.showAddOrRemoveColumnsButton = false;\n      this.emitUpdate();\n\n      return;\n    }\n\n    const { height: rowCount, width: colCount } = getDimensionsOfTable(\n      this.state.block,\n    );\n\n    if (\n      this.state.rowIndex !== undefined &&\n      this.state.colIndex !== undefined\n    ) {\n      // If rows or columns are deleted in the update, the hovered indices for\n      // those may now be out of bounds. If this is the case, they are moved to\n      // the new last row or column.\n      if (this.state.rowIndex >= rowCount) {\n        this.state.rowIndex = rowCount - 1;\n      }\n      if (this.state.colIndex >= colCount) {\n        this.state.colIndex = colCount - 1;\n      }\n    }\n\n    // Update bounding boxes.\n    const tableBody = this.tableElement!.querySelector(\"tbody\");\n\n    if (!tableBody) {\n      throw new Error(\n        \"Table block does not contain a 'tbody' HTML element. This should never happen.\",\n      );\n    }\n\n    if (\n      this.state.rowIndex !== undefined &&\n      this.state.colIndex !== undefined\n    ) {\n      const row = tableBody.children[this.state.rowIndex];\n      const cell = row.children[this.state.colIndex];\n      if (cell) {\n        this.state.referencePosCell = cell.getBoundingClientRect();\n      } else {\n        this.state.rowIndex = undefined;\n        this.state.colIndex = undefined;\n      }\n    }\n    this.state.referencePosTable = tableBody.getBoundingClientRect();\n\n    this.emitUpdate();\n  }\n\n  destroy() {\n    this.pmView.dom.removeEventListener(\"mousemove\", this.mouseMoveHandler);\n    window.removeEventListener(\"mouseup\", this.mouseUpHandler);\n    this.pmView.dom.removeEventListener(\"mousedown\", this.viewMousedownHandler);\n    this.pmView.root.removeEventListener(\n      \"dragover\",\n      this.dragOverHandler as EventListener,\n    );\n    this.pmView.root.removeEventListener(\n      \"drop\",\n      this.dropHandler as unknown as EventListener,\n    );\n  }\n}\n\nexport const tableHandlesPluginKey = new PluginKey(\"TableHandlesPlugin\");\n\nexport class TableHandlesProsemirrorPlugin<\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n> extends BlockNoteExtension {\n  public static key() {\n    return \"tableHandles\";\n  }\n\n  private view: TableHandlesView<I, S> | undefined;\n\n  constructor(\n    private readonly editor: BlockNoteEditor<\n      BlockSchemaWithBlock<\"table\", DefaultBlockSchema[\"table\"]>,\n      I,\n      S\n    >,\n  ) {\n    super();\n    this.addProsemirrorPlugin(\n      new Plugin({\n        key: tableHandlesPluginKey,\n        view: (editorView) => {\n          this.view = new TableHandlesView(editor, editorView, (state) => {\n            this.emit(\"update\", state);\n          });\n          return this.view;\n        },\n        // We use decorations to render the drop cursor when dragging a table row\n        // or column. The decorations are updated in the `dragOverHandler` method.\n        props: {\n          decorations: (state) => {\n            if (\n              this.view === undefined ||\n              this.view.state === undefined ||\n              this.view.state.draggingState === undefined ||\n              this.view.tablePos === undefined\n            ) {\n              return;\n            }\n\n            const newIndex =\n              this.view.state.draggingState.draggedCellOrientation === \"row\"\n                ? this.view.state.rowIndex\n                : this.view.state.colIndex;\n\n            if (newIndex === undefined) {\n              return;\n            }\n\n            const decorations: Decoration[] = [];\n            const { block, draggingState } = this.view.state;\n            const { originalIndex, draggedCellOrientation } = draggingState;\n\n            // Return empty decorations if:\n            // - Dragging to same position\n            // - No block exists\n            // - Row drag not allowed\n            // - Column drag not allowed\n            if (\n              newIndex === originalIndex ||\n              !block ||\n              (draggedCellOrientation === \"row\" &&\n                !canRowBeDraggedInto(block, originalIndex, newIndex)) ||\n              (draggedCellOrientation === \"col\" &&\n                !canColumnBeDraggedInto(block, originalIndex, newIndex))\n            ) {\n              return DecorationSet.create(state.doc, decorations);\n            }\n\n            // Gets the table to show the drop cursor in.\n            const tableResolvedPos = state.doc.resolve(this.view.tablePos + 1);\n\n            if (\n              this.view.state.draggingState.draggedCellOrientation === \"row\"\n            ) {\n              const cellsInRow = getCellsAtRowHandle(\n                this.view.state.block,\n                newIndex,\n              );\n\n              cellsInRow.forEach(({ row, col }) => {\n                // Gets each row in the table.\n                const rowResolvedPos = state.doc.resolve(\n                  tableResolvedPos.posAtIndex(row) + 1,\n                );\n\n                // Gets the cell within the row.\n                const cellResolvedPos = state.doc.resolve(\n                  rowResolvedPos.posAtIndex(col) + 1,\n                );\n                const cellNode = cellResolvedPos.node();\n                // Creates a decoration at the start or end of each cell,\n                // depending on whether the new index is before or after the\n                // original index.\n                const decorationPos =\n                  cellResolvedPos.pos +\n                  (newIndex > originalIndex ? cellNode.nodeSize - 2 : 0);\n                decorations.push(\n                  // The widget is a small bar which spans the width of the cell.\n                  Decoration.widget(decorationPos, () => {\n                    const widget = document.createElement(\"div\");\n                    widget.className = \"bn-table-drop-cursor\";\n                    widget.style.left = \"0\";\n                    widget.style.right = \"0\";\n                    // This is only necessary because the drop indicator's height\n                    // is an even number of pixels, whereas the border between\n                    // table cells is an odd number of pixels. So this makes the\n                    // positioning slightly more consistent regardless of where\n                    // the row is being dropped.\n                    if (newIndex > originalIndex) {\n                      widget.style.bottom = \"-2px\";\n                    } else {\n                      widget.style.top = \"-3px\";\n                    }\n                    widget.style.height = \"4px\";\n\n                    return widget;\n                  }),\n                );\n              });\n            } else {\n              const cellsInColumn = getCellsAtColumnHandle(\n                this.view.state.block,\n                newIndex,\n              );\n\n              cellsInColumn.forEach(({ row, col }) => {\n                // Gets each row in the table.\n                const rowResolvedPos = state.doc.resolve(\n                  tableResolvedPos.posAtIndex(row) + 1,\n                );\n\n                // Gets the cell within the row.\n                const cellResolvedPos = state.doc.resolve(\n                  rowResolvedPos.posAtIndex(col) + 1,\n                );\n                const cellNode = cellResolvedPos.node();\n\n                // Creates a decoration at the start or end of each cell,\n                // depending on whether the new index is before or after the\n                // original index.\n                const decorationPos =\n                  cellResolvedPos.pos +\n                  (newIndex > originalIndex ? cellNode.nodeSize - 2 : 0);\n\n                decorations.push(\n                  // The widget is a small bar which spans the height of the cell.\n                  Decoration.widget(decorationPos, () => {\n                    const widget = document.createElement(\"div\");\n                    widget.className = \"bn-table-drop-cursor\";\n                    widget.style.top = \"0\";\n                    widget.style.bottom = \"0\";\n                    // This is only necessary because the drop indicator's width\n                    // is an even number of pixels, whereas the border between\n                    // table cells is an odd number of pixels. So this makes the\n                    // positioning slightly more consistent regardless of where\n                    // the column is being dropped.\n                    if (newIndex > originalIndex) {\n                      widget.style.right = \"-2px\";\n                    } else {\n                      widget.style.left = \"-3px\";\n                    }\n                    widget.style.width = \"4px\";\n\n                    return widget;\n                  }),\n                );\n              });\n            }\n\n            return DecorationSet.create(state.doc, decorations);\n          },\n        },\n      }),\n    );\n  }\n\n  public onUpdate(callback: (state: TableHandlesState<I, S>) => void) {\n    return this.on(\"update\", callback);\n  }\n\n  /**\n   * Callback that should be set on the `dragStart` event for whichever element\n   * is used as the column drag handle.\n   */\n  colDragStart = (event: {\n    dataTransfer: DataTransfer | null;\n    clientX: number;\n  }) => {\n    if (\n      this.view!.state === undefined ||\n      this.view!.state.colIndex === undefined\n    ) {\n      throw new Error(\n        \"Attempted to drag table column, but no table block was hovered prior.\",\n      );\n    }\n\n    this.view!.state.draggingState = {\n      draggedCellOrientation: \"col\",\n      originalIndex: this.view!.state.colIndex,\n      mousePos: event.clientX,\n    };\n    this.view!.emitUpdate();\n\n    this.editor.transact((tr) =>\n      tr.setMeta(tableHandlesPluginKey, {\n        draggedCellOrientation:\n          this.view!.state!.draggingState!.draggedCellOrientation,\n        originalIndex: this.view!.state!.colIndex,\n        newIndex: this.view!.state!.colIndex,\n        tablePos: this.view!.tablePos,\n      }),\n    );\n\n    if (this.editor.headless) {\n      return;\n    }\n\n    setHiddenDragImage(this.editor.prosemirrorView.root);\n    event.dataTransfer!.setDragImage(dragImageElement!, 0, 0);\n    event.dataTransfer!.effectAllowed = \"move\";\n  };\n\n  /**\n   * Callback that should be set on the `dragStart` event for whichever element\n   * is used as the row drag handle.\n   */\n  rowDragStart = (event: {\n    dataTransfer: DataTransfer | null;\n    clientY: number;\n  }) => {\n    if (\n      this.view!.state === undefined ||\n      this.view!.state.rowIndex === undefined\n    ) {\n      throw new Error(\n        \"Attempted to drag table row, but no table block was hovered prior.\",\n      );\n    }\n\n    this.view!.state.draggingState = {\n      draggedCellOrientation: \"row\",\n      originalIndex: this.view!.state.rowIndex,\n      mousePos: event.clientY,\n    };\n    this.view!.emitUpdate();\n\n    this.editor.transact((tr) =>\n      tr.setMeta(tableHandlesPluginKey, {\n        draggedCellOrientation:\n          this.view!.state!.draggingState!.draggedCellOrientation,\n        originalIndex: this.view!.state!.rowIndex,\n        newIndex: this.view!.state!.rowIndex,\n        tablePos: this.view!.tablePos,\n      }),\n    );\n\n    if (this.editor.headless) {\n      return;\n    }\n\n    setHiddenDragImage(this.editor.prosemirrorView.root);\n    event.dataTransfer!.setDragImage(dragImageElement!, 0, 0);\n    event.dataTransfer!.effectAllowed = \"copyMove\";\n  };\n\n  /**\n   * Callback that should be set on the `dragEnd` event for both the element\n   * used as the row drag handle, and the one used as the column drag handle.\n   */\n  dragEnd = () => {\n    if (this.view!.state === undefined) {\n      throw new Error(\n        \"Attempted to drag table row, but no table block was hovered prior.\",\n      );\n    }\n\n    this.view!.state.draggingState = undefined;\n    this.view!.emitUpdate();\n\n    this.editor.transact((tr) => tr.setMeta(tableHandlesPluginKey, null));\n\n    if (this.editor.headless) {\n      return;\n    }\n\n    unsetHiddenDragImage(this.editor.prosemirrorView.root);\n  };\n\n  /**\n   * Freezes the drag handles. When frozen, they will stay attached to the same\n   * cell regardless of which cell is hovered by the mouse cursor.\n   */\n  freezeHandles = () => {\n    this.view!.menuFrozen = true;\n  };\n\n  /**\n   * Unfreezes the drag handles. When frozen, they will stay attached to the\n   * same cell regardless of which cell is hovered by the mouse cursor.\n   */\n  unfreezeHandles = () => {\n    this.view!.menuFrozen = false;\n  };\n\n  getCellsAtRowHandle = (\n    block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n    relativeRowIndex: RelativeCellIndices[\"row\"],\n  ) => {\n    return getCellsAtRowHandle(block, relativeRowIndex);\n  };\n\n  /**\n   * Get all the cells in a column of the table block.\n   */\n  getCellsAtColumnHandle = (\n    block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n    relativeColumnIndex: RelativeCellIndices[\"col\"],\n  ) => {\n    return getCellsAtColumnHandle(block, relativeColumnIndex);\n  };\n\n  /**\n   * Sets the selection to the given cell or a range of cells.\n   * @returns The new state after the selection has been set.\n   */\n  private setCellSelection = (\n    state: EditorState,\n    relativeStartCell: RelativeCellIndices,\n    relativeEndCell: RelativeCellIndices = relativeStartCell,\n  ) => {\n    const view = this.view;\n\n    if (!view) {\n      throw new Error(\"Table handles view not initialized\");\n    }\n\n    const tableResolvedPos = state.doc.resolve(view.tablePos! + 1);\n    const startRowResolvedPos = state.doc.resolve(\n      tableResolvedPos.posAtIndex(relativeStartCell.row) + 1,\n    );\n    const startCellResolvedPos = state.doc.resolve(\n      // No need for +1, since CellSelection expects the position before the cell\n      startRowResolvedPos.posAtIndex(relativeStartCell.col),\n    );\n    const endRowResolvedPos = state.doc.resolve(\n      tableResolvedPos.posAtIndex(relativeEndCell.row) + 1,\n    );\n    const endCellResolvedPos = state.doc.resolve(\n      // No need for +1, since CellSelection expects the position before the cell\n      endRowResolvedPos.posAtIndex(relativeEndCell.col),\n    );\n\n    // Begin a new transaction to set the selection\n    const tr = state.tr;\n\n    // Set the selection to the given cell or a range of cells\n    tr.setSelection(\n      new CellSelection(startCellResolvedPos, endCellResolvedPos),\n    );\n\n    // Quickly apply the transaction to get the new state to update the selection before splitting the cell\n    return state.apply(tr);\n  };\n\n  /**\n   * Adds a row or column to the table using prosemirror-table commands\n   */\n  addRowOrColumn = (\n    index: RelativeCellIndices[\"row\"] | RelativeCellIndices[\"col\"],\n    direction:\n      | { orientation: \"row\"; side: \"above\" | \"below\" }\n      | { orientation: \"column\"; side: \"left\" | \"right\" },\n  ) => {\n    this.editor.exec((beforeState, dispatch) => {\n      const state = this.setCellSelection(\n        beforeState,\n        direction.orientation === \"row\"\n          ? { row: index, col: 0 }\n          : { row: 0, col: index },\n      );\n\n      if (direction.orientation === \"row\") {\n        if (direction.side === \"above\") {\n          return addRowBefore(state, dispatch);\n        } else {\n          return addRowAfter(state, dispatch);\n        }\n      } else {\n        if (direction.side === \"left\") {\n          return addColumnBefore(state, dispatch);\n        } else {\n          return addColumnAfter(state, dispatch);\n        }\n      }\n    });\n  };\n\n  /**\n   * Removes a row or column from the table using prosemirror-table commands\n   */\n  removeRowOrColumn = (\n    index: RelativeCellIndices[\"row\"] | RelativeCellIndices[\"col\"],\n    direction: \"row\" | \"column\",\n  ) => {\n    if (direction === \"row\") {\n      return this.editor.exec((beforeState, dispatch) => {\n        const state = this.setCellSelection(beforeState, {\n          row: index,\n          col: 0,\n        });\n        return deleteRow(state, dispatch);\n      });\n    } else {\n      return this.editor.exec((beforeState, dispatch) => {\n        const state = this.setCellSelection(beforeState, {\n          row: 0,\n          col: index,\n        });\n        return deleteColumn(state, dispatch);\n      });\n    }\n  };\n\n  /**\n   * Merges the cells in the table block.\n   */\n  mergeCells = (cellsToMerge?: {\n    relativeStartCell: RelativeCellIndices;\n    relativeEndCell: RelativeCellIndices;\n  }) => {\n    return this.editor.exec((beforeState, dispatch) => {\n      const state = cellsToMerge\n        ? this.setCellSelection(\n            beforeState,\n            cellsToMerge.relativeStartCell,\n            cellsToMerge.relativeEndCell,\n          )\n        : beforeState;\n\n      return mergeCells(state, dispatch);\n    });\n  };\n\n  /**\n   * Splits the cell in the table block.\n   * If no cell is provided, the current cell selected will be split.\n   */\n  splitCell = (relativeCellToSplit?: RelativeCellIndices) => {\n    return this.editor.exec((beforeState, dispatch) => {\n      const state = relativeCellToSplit\n        ? this.setCellSelection(beforeState, relativeCellToSplit)\n        : beforeState;\n\n      return splitCell(state, dispatch);\n    });\n  };\n\n  /**\n   * Gets the start and end cells of the current cell selection.\n   * @returns The start and end cells of the current cell selection.\n   */\n  getCellSelection = ():\n    | undefined\n    | {\n        from: RelativeCellIndices;\n        to: RelativeCellIndices;\n        /**\n         * All of the cells that are within the selected range.\n         */\n        cells: RelativeCellIndices[];\n      } => {\n    // Based on the current selection, find the table cells that are within the selected range\n\n    return this.editor.transact((tr) => {\n      const selection = tr.selection;\n\n      let $fromCell = selection.$from;\n      let $toCell = selection.$to;\n      if (isTableCellSelection(selection)) {\n        // When the selection is a table cell selection, we can find the\n        // from and to cells by iterating over the ranges in the selection\n        const { ranges } = selection;\n        ranges.forEach((range) => {\n          $fromCell = range.$from.min($fromCell ?? range.$from);\n          $toCell = range.$to.max($toCell ?? range.$to);\n        });\n      } else {\n        // When the selection is a normal text selection\n        // Assumes we are within a tableParagraph\n        // And find the from and to cells by resolving the positions\n        $fromCell = tr.doc.resolve(\n          selection.$from.pos - selection.$from.parentOffset - 1,\n        );\n        $toCell = tr.doc.resolve(\n          selection.$to.pos - selection.$to.parentOffset - 1,\n        );\n\n        // Opt-out when the selection is not pointing into cells\n        if ($fromCell.pos === 0 || $toCell.pos === 0) {\n          return undefined;\n        }\n      }\n\n      // Find the row and table that the from and to cells are in\n      const $fromRow = tr.doc.resolve(\n        $fromCell.pos - $fromCell.parentOffset - 1,\n      );\n      const $toRow = tr.doc.resolve($toCell.pos - $toCell.parentOffset - 1);\n\n      // Find the table\n      const $table = tr.doc.resolve($fromRow.pos - $fromRow.parentOffset - 1);\n\n      // Find the column and row indices of the from and to cells\n      const fromColIndex = $fromCell.index($fromRow.depth);\n      const fromRowIndex = $fromRow.index($table.depth);\n      const toColIndex = $toCell.index($toRow.depth);\n      const toRowIndex = $toRow.index($table.depth);\n\n      const cells: RelativeCellIndices[] = [];\n      for (let row = fromRowIndex; row <= toRowIndex; row++) {\n        for (let col = fromColIndex; col <= toColIndex; col++) {\n          cells.push({ row, col });\n        }\n      }\n\n      return {\n        from: {\n          row: fromRowIndex,\n          col: fromColIndex,\n        },\n        to: {\n          row: toRowIndex,\n          col: toColIndex,\n        },\n        cells,\n      };\n    });\n  };\n\n  /**\n   * Gets the direction of the merge based on the current cell selection.\n   *\n   * Returns undefined when there is no cell selection, or the selection is not within a table.\n   */\n  getMergeDirection = (\n    block:\n      | BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>\n      | undefined,\n  ) => {\n    return this.editor.transact((tr) => {\n      const isSelectingTableCells = isTableCellSelection(tr.selection)\n        ? tr.selection\n        : undefined;\n\n      if (\n        !isSelectingTableCells ||\n        !block ||\n        // Only offer the merge button if there is more than one cell selected.\n        isSelectingTableCells.ranges.length <= 1\n      ) {\n        return undefined;\n      }\n\n      const cellSelection = this.getCellSelection();\n\n      if (!cellSelection) {\n        return undefined;\n      }\n\n      if (areInSameColumn(cellSelection.from, cellSelection.to, block)) {\n        return \"vertical\";\n      }\n\n      return \"horizontal\";\n    });\n  };\n\n  cropEmptyRowsOrColumns = (\n    block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n    removeEmpty: \"columns\" | \"rows\",\n  ) => {\n    return cropEmptyRowsOrColumns(block, removeEmpty);\n  };\n\n  addRowsOrColumns = (\n    block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n    addType: \"columns\" | \"rows\",\n    numToAdd: number,\n  ) => {\n    return addRowsOrColumns(block, addType, numToAdd);\n  };\n}\n","import { Extension } from \"@tiptap/core\";\n\nexport const TextAlignmentExtension = Extension.create({\n  name: \"textAlignment\",\n\n  addGlobalAttributes() {\n    return [\n      {\n        // Generally text alignment is handled through props using the custom\n        // blocks API. Tables are the only blocks that are created as TipTap\n        // nodes and ported to blocks, so we need to add text alignment in a\n        // separate extension.\n        types: [\"tableCell\", \"tableHeader\"],\n        attributes: {\n          textAlignment: {\n            default: \"left\",\n            parseHTML: (element) => {\n              return element.getAttribute(\"data-text-alignment\");\n            },\n            renderHTML: (attributes) => {\n              if (attributes.textAlignment === \"left\") {\n                return {};\n              }\n              return {\n                \"data-text-alignment\": attributes.textAlignment,\n              };\n            },\n          },\n        },\n      },\n    ];\n  },\n});\n","import { Extension } from \"@tiptap/core\";\nimport { getTextColorAttribute } from \"../../blocks/defaultProps.js\";\n\nexport const TextColorExtension = Extension.create({\n  name: \"blockTextColor\",\n\n  addGlobalAttributes() {\n    return [\n      {\n        types: [\"table\", \"tableCell\", \"tableHeader\"],\n        attributes: {\n          textColor: getTextColorAttribute(),\n        },\n      },\n    ];\n  },\n});\n","import { Extension } from \"@tiptap/core\";\nimport { Plugin, PluginKey } from \"prosemirror-state\";\n\n// based on https://github.com/ueberdosis/tiptap/blob/40a9404c94c7fef7900610c195536384781ae101/demos/src/Experiments/TrailingNode/Vue/trailing-node.ts\n\n/**\n * Extension based on:\n * - https://github.com/ueberdosis/tiptap/blob/v1/packages/tiptap-extensions/src/extensions/TrailingNode.js\n * - https://github.com/remirror/remirror/blob/e0f1bec4a1e8073ce8f5500d62193e52321155b9/packages/prosemirror-trailing-node/src/trailing-node-plugin.ts\n */\n\nexport interface TrailingNodeOptions {\n  node: string;\n}\n\n/**\n * Add a trailing node to the document so the user can always click at the bottom of the document and start typing\n */\nexport const TrailingNode = Extension.create<TrailingNodeOptions>({\n  name: \"trailingNode\",\n\n  addProseMirrorPlugins() {\n    const plugin = new PluginKey(this.name);\n    // const disabledNodes = Object.entries(this.editor.schema.nodes)\n    //   .map(([, value]) => value)\n    //   .filter((node) => this.options.notAfter.includes(node.name));\n\n    return [\n      new Plugin({\n        key: plugin,\n        appendTransaction: (_, __, state) => {\n          const { doc, tr, schema } = state;\n          const shouldInsertNodeAtEnd = plugin.getState(state);\n          const endPosition = doc.content.size - 2;\n          const type = schema.nodes[\"blockContainer\"];\n          const contentType = schema.nodes[\"paragraph\"];\n          if (!shouldInsertNodeAtEnd) {\n            return;\n          }\n\n          return tr.insert(\n            endPosition,\n            type.create(undefined, contentType.create()),\n          );\n        },\n        state: {\n          init: (_, _state) => {\n            // (maybe fix): use same logic as apply() here\n            // so it works when initializing\n          },\n          apply: (tr, value) => {\n            if (!tr.docChanged) {\n              return value;\n            }\n\n            let lastNode = tr.doc.lastChild;\n\n            if (!lastNode || lastNode.type.name !== \"blockGroup\") {\n              throw new Error(\"Expected blockGroup\");\n            }\n\n            lastNode = lastNode.lastChild;\n\n            if (!lastNode || lastNode.type.name !== \"blockContainer\") {\n              return true; // not a blockContainer, but for example Columns. Insert trailing node\n            }\n\n            const lastContentNode = lastNode.firstChild;\n\n            if (!lastContentNode) {\n              throw new Error(\"Expected blockContent\");\n            }\n\n            // If last node is not empty (size > 4) or it doesn't contain\n            // inline content, we need to add a trailing node.\n            return (\n              lastNode.nodeSize > 4 ||\n              lastContentNode.type.spec.content !== \"inline*\"\n            );\n          },\n        },\n      }),\n    ];\n  },\n});\n","import { Node } from \"@tiptap/core\";\n\nimport type { BlockNoteEditor } from \"../editor/BlockNoteEditor.js\";\nimport { BlockNoteDOMAttributes } from \"../schema/index.js\";\nimport { mergeCSSClasses } from \"../util/browser.js\";\n\n// Object containing all possible block attributes.\nconst BlockAttributes: Record<string, string> = {\n  blockColor: \"data-block-color\",\n  blockStyle: \"data-block-style\",\n  id: \"data-id\",\n  depth: \"data-depth\",\n  depthChange: \"data-depth-change\",\n};\n\n/**\n * The main \"Block node\" documents consist of\n */\nexport const BlockContainer = Node.create<{\n  domAttributes?: BlockNoteDOMAttributes;\n  editor: BlockNoteEditor<any, any, any>;\n}>({\n  name: \"blockContainer\",\n  group: \"blockGroupChild bnBlock\",\n  // A block always contains content, and optionally a blockGroup which contains nested blocks\n  content: \"blockContent blockGroup?\",\n  // Ensures content-specific keyboard handlers trigger first.\n  priority: 50,\n  defining: true,\n  marks: \"insertion modification deletion\",\n  parseHTML() {\n    return [\n      {\n        tag: \"div[data-node-type=\" + this.name + \"]\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          const attrs: Record<string, string> = {};\n          for (const [nodeAttr, HTMLAttr] of Object.entries(BlockAttributes)) {\n            if (element.getAttribute(HTMLAttr)) {\n              attrs[nodeAttr] = element.getAttribute(HTMLAttr)!;\n            }\n          }\n\n          return attrs;\n        },\n      },\n      // Ignore `blockOuter` divs, but parse the `blockContainer` divs inside them.\n      {\n        tag: `div[data-node-type=\"blockOuter\"]`,\n        skip: true,\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    const blockOuter = document.createElement(\"div\");\n    blockOuter.className = \"bn-block-outer\";\n    blockOuter.setAttribute(\"data-node-type\", \"blockOuter\");\n    for (const [attribute, value] of Object.entries(HTMLAttributes)) {\n      if (attribute !== \"class\") {\n        blockOuter.setAttribute(attribute, value);\n      }\n    }\n\n    const blockHTMLAttributes = {\n      ...(this.options.domAttributes?.block || {}),\n      ...HTMLAttributes,\n    };\n    const block = document.createElement(\"div\");\n    block.className = mergeCSSClasses(\"bn-block\", blockHTMLAttributes.class);\n    block.setAttribute(\"data-node-type\", this.name);\n    for (const [attribute, value] of Object.entries(blockHTMLAttributes)) {\n      if (attribute !== \"class\") {\n        block.setAttribute(attribute, value);\n      }\n    }\n\n    blockOuter.appendChild(block);\n\n    return {\n      dom: blockOuter,\n      contentDOM: block,\n    };\n  },\n});\n","import { Node } from \"@tiptap/core\";\nimport { BlockNoteDOMAttributes } from \"../schema/index.js\";\nimport { mergeCSSClasses } from \"../util/browser.js\";\n\nexport const BlockGroup = Node.create<{\n  domAttributes?: BlockNoteDOMAttributes;\n}>({\n  name: \"blockGroup\",\n  group: \"childContainer\",\n  content: \"blockGroupChild+\",\n  marks: \"deletion insertion modification\",\n  parseHTML() {\n    return [\n      {\n        tag: \"div\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          if (element.getAttribute(\"data-node-type\") === \"blockGroup\") {\n            // Null means the element matches, but we don't want to add any attributes to the node.\n            return null;\n          }\n\n          return false;\n        },\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    const blockGroupHTMLAttributes = {\n      ...(this.options.domAttributes?.blockGroup || {}),\n      ...HTMLAttributes,\n    };\n    const blockGroup = document.createElement(\"div\");\n    blockGroup.className = mergeCSSClasses(\n      \"bn-block-group\",\n      blockGroupHTMLAttributes.class,\n    );\n    blockGroup.setAttribute(\"data-node-type\", \"blockGroup\");\n    for (const [attribute, value] of Object.entries(blockGroupHTMLAttributes)) {\n      if (attribute !== \"class\") {\n        blockGroup.setAttribute(attribute, value);\n      }\n    }\n\n    return {\n      dom: blockGroup,\n      contentDOM: blockGroup,\n    };\n  },\n});\n","import { Node } from \"@tiptap/core\";\n\nexport const Doc = Node.create({\n  name: \"doc\",\n  topNode: true,\n  content: \"blockGroup\",\n  marks: \"insertion modification deletion\",\n});\n","import { AnyExtension, Extension, extensions, Node } from \"@tiptap/core\";\nimport { Gapcursor } from \"@tiptap/extension-gapcursor\";\nimport { History } from \"@tiptap/extension-history\";\nimport { Link } from \"@tiptap/extension-link\";\nimport { Text } from \"@tiptap/extension-text\";\nimport { Plugin } from \"prosemirror-state\";\nimport * as Y from \"yjs\";\n\nimport { createDropFileExtension } from \"../api/clipboard/fromClipboard/fileDropExtension.js\";\nimport { createPasteFromClipboardExtension } from \"../api/clipboard/fromClipboard/pasteExtension.js\";\nimport { createCopyToClipboardExtension } from \"../api/clipboard/toClipboard/copyExtension.js\";\nimport type { ThreadStore, User } from \"../comments/index.js\";\nimport { BackgroundColorExtension } from \"../extensions/BackgroundColor/BackgroundColorExtension.js\";\nimport { BlockChangePlugin } from \"../extensions/BlockChange/BlockChangePlugin.js\";\nimport { CursorPlugin } from \"../extensions/Collaboration/CursorPlugin.js\";\nimport { ForkYDocPlugin } from \"../extensions/Collaboration/ForkYDocPlugin.js\";\nimport { SyncPlugin } from \"../extensions/Collaboration/SyncPlugin.js\";\nimport { UndoPlugin } from \"../extensions/Collaboration/UndoPlugin.js\";\nimport { SchemaMigrationPlugin } from \"../extensions/Collaboration/schemaMigration/SchemaMigrationPlugin.js\";\nimport { CommentMark } from \"../extensions/Comments/CommentMark.js\";\nimport { CommentsPlugin } from \"../extensions/Comments/CommentsPlugin.js\";\nimport { FilePanelProsemirrorPlugin } from \"../extensions/FilePanel/FilePanelPlugin.js\";\nimport { FormattingToolbarProsemirrorPlugin } from \"../extensions/FormattingToolbar/FormattingToolbarPlugin.js\";\nimport { HardBreak } from \"../extensions/HardBreak/HardBreak.js\";\nimport { KeyboardShortcutsExtension } from \"../extensions/KeyboardShortcuts/KeyboardShortcutsExtension.js\";\nimport { LinkToolbarProsemirrorPlugin } from \"../extensions/LinkToolbar/LinkToolbarPlugin.js\";\nimport {\n  DEFAULT_LINK_PROTOCOL,\n  VALID_LINK_PROTOCOLS,\n} from \"../extensions/LinkToolbar/protocols.js\";\nimport { NodeSelectionKeyboardPlugin } from \"../extensions/NodeSelectionKeyboard/NodeSelectionKeyboardPlugin.js\";\nimport { PlaceholderPlugin } from \"../extensions/Placeholder/PlaceholderPlugin.js\";\nimport { PreviousBlockTypePlugin } from \"../extensions/PreviousBlockType/PreviousBlockTypePlugin.js\";\nimport { ShowSelectionPlugin } from \"../extensions/ShowSelection/ShowSelectionPlugin.js\";\nimport { SideMenuProsemirrorPlugin } from \"../extensions/SideMenu/SideMenuPlugin.js\";\nimport { SuggestionMenuProseMirrorPlugin } from \"../extensions/SuggestionMenu/SuggestionPlugin.js\";\nimport {\n  SuggestionAddMark,\n  SuggestionDeleteMark,\n  SuggestionModificationMark,\n} from \"../extensions/Suggestions/SuggestionMarks.js\";\nimport { TableHandlesProsemirrorPlugin } from \"../extensions/TableHandles/TableHandlesPlugin.js\";\nimport { TextAlignmentExtension } from \"../extensions/TextAlignment/TextAlignmentExtension.js\";\nimport { TextColorExtension } from \"../extensions/TextColor/TextColorExtension.js\";\nimport { TrailingNode } from \"../extensions/TrailingNode/TrailingNodeExtension.js\";\nimport UniqueID from \"../extensions/UniqueID/UniqueID.js\";\nimport { BlockContainer, BlockGroup, Doc } from \"../pm-nodes/index.js\";\nimport {\n  BlockNoteDOMAttributes,\n  BlockSchema,\n  BlockSpecs,\n  InlineContentSchema,\n  InlineContentSpecs,\n  StyleSchema,\n  StyleSpecs,\n} from \"../schema/index.js\";\nimport type {\n  BlockNoteEditor,\n  BlockNoteEditorOptions,\n  SupportedExtension,\n} from \"./BlockNoteEditor.js\";\nimport { BlockNoteSchema } from \"../blocks/BlockNoteSchema.js\";\n\ntype ExtensionOptions<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n> = {\n  editor: BlockNoteEditor<BSchema, I, S>;\n  domAttributes: Partial<BlockNoteDOMAttributes>;\n  blockSpecs: BlockSpecs;\n  inlineContentSpecs: InlineContentSpecs;\n  styleSpecs: StyleSpecs;\n  trailingBlock: boolean | undefined;\n  collaboration?: {\n    fragment: Y.XmlFragment;\n    user: {\n      name: string;\n      color: string;\n      [key: string]: string;\n    };\n    provider: any;\n    renderCursor?: (user: any) => HTMLElement;\n    showCursorLabels?: \"always\" | \"activity\";\n  };\n  disableExtensions: string[] | undefined;\n  setIdAttribute?: boolean;\n  animations: boolean;\n  tableHandles: boolean;\n  dropCursor: (opts: any) => Plugin;\n  placeholders: Record<\n    string | \"default\" | \"emptyDocument\",\n    string | undefined\n  >;\n  tabBehavior?: \"prefer-navigate-ui\" | \"prefer-indent\";\n  comments?: {\n    schema?: BlockNoteSchema<any, any, any>;\n    threadStore: ThreadStore;\n    resolveUsers?: (userIds: string[]) => Promise<User[]>;\n  };\n  pasteHandler: BlockNoteEditorOptions<any, any, any>[\"pasteHandler\"];\n};\n\n/**\n * Get all the Tiptap extensions BlockNote is configured with by default\n */\nexport const getBlockNoteExtensions = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  opts: ExtensionOptions<BSchema, I, S>,\n) => {\n  const ret: Record<string, SupportedExtension> = {};\n  const tiptapExtensions = getTipTapExtensions(opts);\n\n  for (const ext of tiptapExtensions) {\n    ret[ext.name] = ext;\n  }\n\n  if (opts.collaboration) {\n    ret[\"ySyncPlugin\"] = new SyncPlugin(opts.collaboration.fragment);\n    ret[\"yUndoPlugin\"] = new UndoPlugin({ editor: opts.editor });\n\n    if (opts.collaboration.provider?.awareness) {\n      ret[\"yCursorPlugin\"] = new CursorPlugin(opts.collaboration);\n    }\n    ret[\"forkYDocPlugin\"] = new ForkYDocPlugin({\n      editor: opts.editor,\n      collaboration: opts.collaboration,\n    });\n    ret[\"schemaMigrationPlugin\"] = new SchemaMigrationPlugin(\n      opts.collaboration.fragment,\n    );\n  }\n\n  // Note: this is pretty hardcoded and will break when user provides plugins with same keys.\n  // Define name on plugins instead and not make this a map?\n  ret[\"formattingToolbar\"] = new FormattingToolbarProsemirrorPlugin(\n    opts.editor,\n  );\n  ret[\"linkToolbar\"] = new LinkToolbarProsemirrorPlugin(opts.editor);\n  ret[\"sideMenu\"] = new SideMenuProsemirrorPlugin(opts.editor);\n  ret[\"suggestionMenus\"] = new SuggestionMenuProseMirrorPlugin(opts.editor);\n  ret[\"filePanel\"] = new FilePanelProsemirrorPlugin(opts.editor as any);\n  ret[\"placeholder\"] = new PlaceholderPlugin(opts.editor, opts.placeholders);\n\n  if (opts.animations ?? true) {\n    ret[\"animations\"] = new PreviousBlockTypePlugin();\n  }\n\n  if (opts.tableHandles) {\n    ret[\"tableHandles\"] = new TableHandlesProsemirrorPlugin(opts.editor as any);\n  }\n\n  ret[\"nodeSelectionKeyboard\"] = new NodeSelectionKeyboardPlugin();\n  ret[\"blockChange\"] = new BlockChangePlugin();\n\n  ret[\"showSelection\"] = new ShowSelectionPlugin(opts.editor);\n\n  if (opts.comments) {\n    ret[\"comments\"] = new CommentsPlugin(\n      opts.editor,\n      opts.comments.threadStore,\n      CommentMark.name,\n      opts.comments.resolveUsers,\n      opts.comments.schema,\n    );\n  }\n\n  const disableExtensions: string[] = opts.disableExtensions || [];\n  for (const ext of disableExtensions) {\n    delete ret[ext];\n  }\n\n  return ret;\n};\n\nlet LINKIFY_INITIALIZED = false;\n\n/**\n * Get all the Tiptap extensions BlockNote is configured with by default\n */\nconst getTipTapExtensions = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  opts: ExtensionOptions<BSchema, I, S>,\n) => {\n  const tiptapExtensions: AnyExtension[] = [\n    extensions.ClipboardTextSerializer,\n    extensions.Commands,\n    extensions.Editable,\n    extensions.FocusEvents,\n    extensions.Tabindex,\n\n    // DevTools,\n    Gapcursor,\n\n    // DropCursor,\n    Extension.create({\n      name: \"dropCursor\",\n      addProseMirrorPlugins: () => [\n        opts.dropCursor({\n          width: 5,\n          color: \"#ddeeff\",\n          editor: opts.editor,\n        }),\n      ],\n    }),\n\n    UniqueID.configure({\n      // everything from bnBlock group (nodes that represent a BlockNote block should have an id)\n      types: [\"blockContainer\", \"columnList\", \"column\"],\n      setIdAttribute: opts.setIdAttribute,\n    }),\n    HardBreak,\n    // Comments,\n\n    // basics:\n    Text,\n\n    // marks:\n    SuggestionAddMark,\n    SuggestionDeleteMark,\n    SuggestionModificationMark,\n    Link.extend({\n      inclusive: false,\n    }).configure({\n      defaultProtocol: DEFAULT_LINK_PROTOCOL,\n      // only call this once if we have multiple editors installed. Or fix https://github.com/ueberdosis/tiptap/issues/5450\n      protocols: LINKIFY_INITIALIZED ? [] : VALID_LINK_PROTOCOLS,\n    }),\n    ...(Object.values(opts.styleSpecs).map((styleSpec) => {\n      return styleSpec.implementation.mark.configure({\n        editor: opts.editor as any,\n      });\n    }) as any[]),\n\n    TextColorExtension,\n\n    BackgroundColorExtension,\n    TextAlignmentExtension,\n\n    // make sure escape blurs editor, so that we can tab to other elements in the host page (accessibility)\n    Extension.create({\n      name: \"OverrideEscape\",\n      addKeyboardShortcuts() {\n        return {\n          Escape: () => {\n            if (opts.editor.suggestionMenus.shown) {\n              // escape is handled by suggestionmenu\n              return false;\n            }\n            return this.editor.commands.blur();\n          },\n        };\n      },\n    }),\n\n    // nodes\n    Doc,\n    BlockContainer.configure({\n      editor: opts.editor,\n      domAttributes: opts.domAttributes,\n    }),\n    KeyboardShortcutsExtension.configure({\n      editor: opts.editor,\n      tabBehavior: opts.tabBehavior,\n    }),\n    BlockGroup.configure({\n      domAttributes: opts.domAttributes,\n    }),\n    ...Object.values(opts.inlineContentSpecs)\n      .filter((a) => a.config !== \"link\" && a.config !== \"text\")\n      .map((inlineContentSpec) => {\n        return inlineContentSpec.implementation!.node.configure({\n          editor: opts.editor as any,\n        });\n      }),\n\n    ...Object.values(opts.blockSpecs).flatMap((blockSpec) => {\n      return [\n        // the node extension implementations\n        ...(\"node\" in blockSpec.implementation\n          ? [\n              (blockSpec.implementation.node as Node).configure({\n                editor: opts.editor,\n                domAttributes: opts.domAttributes,\n              }),\n            ]\n          : []),\n      ];\n    }),\n    createCopyToClipboardExtension(opts.editor),\n    createPasteFromClipboardExtension(\n      opts.editor,\n      opts.pasteHandler ||\n        ((context: {\n          defaultPasteHandler: (context?: {\n            prioritizeMarkdownOverHTML?: boolean;\n            plainTextAsMarkdown?: boolean;\n          }) => boolean | undefined;\n        }) => context.defaultPasteHandler()),\n    ),\n    createDropFileExtension(opts.editor),\n\n    // This needs to be at the bottom of this list, because Key events (such as enter, when selecting a /command),\n    // should be handled before Enter handlers in other components like splitListItem\n    ...(opts.trailingBlock === undefined || opts.trailingBlock\n      ? [TrailingNode]\n      : []),\n    ...(opts.comments ? [CommentMark] : []),\n  ];\n\n  LINKIFY_INITIALIZED = true;\n\n  if (!opts.collaboration) {\n    // disable history extension when collaboration is enabled as y-prosemirror takes care of undo / redo\n    tiptapExtensions.push(History);\n  }\n\n  return tiptapExtensions;\n};\n","import {\n  NodeSelection,\n  Selection,\n  TextSelection,\n  Transaction,\n} from \"prosemirror-state\";\nimport { CellSelection } from \"prosemirror-tables\";\n\nimport { Block } from \"../../../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../../../editor/BlockNoteEditor\";\nimport { BlockIdentifier } from \"../../../../schema/index.js\";\nimport { getNearestBlockPos } from \"../../../getBlockInfoFromPos.js\";\nimport { getNodeById } from \"../../../nodeUtil.js\";\n\ntype BlockSelectionData = (\n  | {\n      type: \"text\";\n      headBlockId: string;\n      anchorOffset: number;\n      headOffset: number;\n    }\n  | {\n      type: \"node\";\n    }\n  | {\n      type: \"cell\";\n      anchorCellOffset: number;\n      headCellOffset: number;\n    }\n) & {\n  anchorBlockId: string;\n};\n\n/**\n * `getBlockSelectionData` and `updateBlockSelectionFromData` are used to save\n * and restore the selection within a block, when the block is moved. This is\n * done by first saving the offsets of the anchor and head from the before\n * positions of their surrounding blocks, as well as the IDs of those blocks. We\n * can then recreate the selection by finding the blocks with those IDs, getting\n * their before positions, and adding the offsets to those positions.\n * @param editor The BlockNote editor instance to get the selection data from.\n */\nfunction getBlockSelectionData(\n  editor: BlockNoteEditor<any, any, any>,\n): BlockSelectionData {\n  return editor.transact((tr) => {\n    const anchorBlockPosInfo = getNearestBlockPos(tr.doc, tr.selection.anchor);\n\n    if (tr.selection instanceof CellSelection) {\n      return {\n        type: \"cell\" as const,\n        anchorBlockId: anchorBlockPosInfo.node.attrs.id,\n        anchorCellOffset:\n          tr.selection.$anchorCell.pos - anchorBlockPosInfo.posBeforeNode,\n        headCellOffset:\n          tr.selection.$headCell.pos - anchorBlockPosInfo.posBeforeNode,\n      };\n    } else if (tr.selection instanceof NodeSelection) {\n      return {\n        type: \"node\" as const,\n        anchorBlockId: anchorBlockPosInfo.node.attrs.id,\n      };\n    } else {\n      const headBlockPosInfo = getNearestBlockPos(tr.doc, tr.selection.head);\n\n      return {\n        type: \"text\" as const,\n        anchorBlockId: anchorBlockPosInfo.node.attrs.id,\n        headBlockId: headBlockPosInfo.node.attrs.id,\n        anchorOffset: tr.selection.anchor - anchorBlockPosInfo.posBeforeNode,\n        headOffset: tr.selection.head - headBlockPosInfo.posBeforeNode,\n      };\n    }\n  });\n}\n\n/**\n * `getBlockSelectionData` and `updateBlockSelectionFromData` are used to save\n * and restore the selection within a block, when the block is moved. This is\n * done by first saving the offsets of the anchor and head from the before\n * positions of their surrounding blocks, as well as the IDs of those blocks. We\n * can then recreate the selection by finding the blocks with those IDs, getting\n * their before positions, and adding the offsets to those positions.\n * @param tr The transaction to update the selection in.\n * @param data The selection data to update the selection with (generated by\n * `getBlockSelectionData`).\n */\nfunction updateBlockSelectionFromData(\n  tr: Transaction,\n  data: BlockSelectionData,\n) {\n  const anchorBlockPos = getNodeById(data.anchorBlockId, tr.doc)?.posBeforeNode;\n  if (anchorBlockPos === undefined) {\n    throw new Error(\n      `Could not find block with ID ${data.anchorBlockId} to update selection`,\n    );\n  }\n\n  let selection: Selection;\n  if (data.type === \"cell\") {\n    selection = CellSelection.create(\n      tr.doc,\n      anchorBlockPos + data.anchorCellOffset,\n      anchorBlockPos + data.headCellOffset,\n    );\n  } else if (data.type === \"node\") {\n    selection = NodeSelection.create(tr.doc, anchorBlockPos + 1);\n  } else {\n    const headBlockPos = getNodeById(data.headBlockId, tr.doc)?.posBeforeNode;\n    if (headBlockPos === undefined) {\n      throw new Error(\n        `Could not find block with ID ${data.headBlockId} to update selection`,\n      );\n    }\n\n    selection = TextSelection.create(\n      tr.doc,\n      anchorBlockPos + data.anchorOffset,\n      headBlockPos + data.headOffset,\n    );\n  }\n\n  tr.setSelection(selection);\n}\n\n/**\n * Replaces any `columnList` blocks with the children of their columns. This is\n * done here instead of in `getSelection` as we still need to remove the entire\n * `columnList` node but only insert the `blockContainer` nodes inside it.\n * @param blocks The blocks to flatten.\n */\nfunction flattenColumns(\n  blocks: Block<any, any, any>[],\n): Block<any, any, any>[] {\n  return blocks\n    .map((block) => {\n      if (block.type === \"columnList\") {\n        return block.children\n          .map((column) => flattenColumns(column.children))\n          .flat();\n      }\n\n      return {\n        ...block,\n        children: flattenColumns(block.children),\n      };\n    })\n    .flat();\n}\n\n/**\n * Removes the selected blocks from the editor, then inserts them before/after a\n * reference block. Also updates the selection to match the original selection\n * using `getBlockSelectionData` and `updateBlockSelectionFromData`.\n * @param editor The BlockNote editor instance to move the blocks in.\n * @param referenceBlock The reference block to insert the selected blocks\n * before/after.\n * @param placement Whether to insert the selected blocks before or after the\n * reference block.\n */\nexport function moveSelectedBlocksAndSelection(\n  editor: BlockNoteEditor<any, any, any>,\n  referenceBlock: BlockIdentifier,\n  placement: \"before\" | \"after\",\n) {\n  // We want this to be a single step in the undo history\n  editor.transact((tr) => {\n    const blocks = editor.getSelection()?.blocks || [\n      editor.getTextCursorPosition().block,\n    ];\n    const selectionData = getBlockSelectionData(editor);\n\n    editor.removeBlocks(blocks);\n    editor.insertBlocks(flattenColumns(blocks), referenceBlock, placement);\n\n    updateBlockSelectionFromData(tr, selectionData);\n  });\n}\n\n// Checks if a block is in a valid place after being moved. This check is\n// primitive at the moment and only returns false if the block's parent is a\n// `columnList` block. This is because regular blocks cannot be direct children\n// of `columnList` blocks.\nfunction checkPlacementIsValid(parentBlock?: Block<any, any, any>): boolean {\n  return !parentBlock || parentBlock.type !== \"columnList\";\n}\n\n// Gets the placement for moving a block up. This has 3 cases:\n// 1. If the block has a previous sibling without children, the placement is\n// before it.\n// 2. If the block has a previous sibling with children, the placement is after\n// the last child.\n// 3. If the block has no previous sibling, but is nested, the placement is\n// before its parent.\n// If the placement is invalid, the function is called recursively until a valid\n// placement is found. Returns undefined if no valid placement is found, meaning\n// the block is already at the top of the document.\nfunction getMoveUpPlacement(\n  editor: BlockNoteEditor<any, any, any>,\n  prevBlock?: Block<any, any, any>,\n  parentBlock?: Block<any, any, any>,\n):\n  | { referenceBlock: BlockIdentifier; placement: \"before\" | \"after\" }\n  | undefined {\n  let referenceBlock: Block<any, any, any> | undefined;\n  let placement: \"before\" | \"after\" | undefined;\n\n  if (!prevBlock) {\n    if (parentBlock) {\n      referenceBlock = parentBlock;\n      placement = \"before\";\n    }\n  } else if (prevBlock.children.length > 0) {\n    referenceBlock = prevBlock.children[prevBlock.children.length - 1];\n    placement = \"after\";\n  } else {\n    referenceBlock = prevBlock;\n    placement = \"before\";\n  }\n\n  // Case when the block is already at the top of the document.\n  if (!referenceBlock || !placement) {\n    return undefined;\n  }\n\n  const referenceBlockParent = editor.getParentBlock(referenceBlock);\n  if (!checkPlacementIsValid(referenceBlockParent)) {\n    return getMoveUpPlacement(\n      editor,\n      placement === \"after\"\n        ? referenceBlock\n        : editor.getPrevBlock(referenceBlock),\n      referenceBlockParent,\n    );\n  }\n\n  return { referenceBlock, placement };\n}\n\n// Gets the placement for moving a block down. This has 3 cases:\n// 1. If the block has a next sibling without children, the placement is  after\n// it.\n// 2. If the block has a next sibling with children, the placement is before the\n// first child.\n// 3. If the block has no next sibling, but is nested, the placement is\n// after its parent.\n// If the placement is invalid, the function is called recursively until a valid\n// placement is found. Returns undefined if no valid placement is found, meaning\n// the block is already at the bottom of the document.\nfunction getMoveDownPlacement(\n  editor: BlockNoteEditor<any, any, any>,\n  nextBlock?: Block<any, any, any>,\n  parentBlock?: Block<any, any, any>,\n):\n  | { referenceBlock: BlockIdentifier; placement: \"before\" | \"after\" }\n  | undefined {\n  let referenceBlock: Block<any, any, any> | undefined;\n  let placement: \"before\" | \"after\" | undefined;\n\n  if (!nextBlock) {\n    if (parentBlock) {\n      referenceBlock = parentBlock;\n      placement = \"after\";\n    }\n  } else if (nextBlock.children.length > 0) {\n    referenceBlock = nextBlock.children[0];\n    placement = \"before\";\n  } else {\n    referenceBlock = nextBlock;\n    placement = \"after\";\n  }\n\n  // Case when the block is already at the bottom of the document.\n  if (!referenceBlock || !placement) {\n    return undefined;\n  }\n\n  const referenceBlockParent = editor.getParentBlock(referenceBlock);\n  if (!checkPlacementIsValid(referenceBlockParent)) {\n    return getMoveDownPlacement(\n      editor,\n      placement === \"before\"\n        ? referenceBlock\n        : editor.getNextBlock(referenceBlock),\n      referenceBlockParent,\n    );\n  }\n\n  return { referenceBlock, placement };\n}\n\nexport function moveBlocksUp(editor: BlockNoteEditor<any, any, any>) {\n  editor.transact(() => {\n    const selection = editor.getSelection();\n    const block = selection?.blocks[0] || editor.getTextCursorPosition().block;\n\n    const moveUpPlacement = getMoveUpPlacement(\n      editor,\n      editor.getPrevBlock(block),\n      editor.getParentBlock(block),\n    );\n\n    if (!moveUpPlacement) {\n      return;\n    }\n\n    moveSelectedBlocksAndSelection(\n      editor,\n      moveUpPlacement.referenceBlock,\n      moveUpPlacement.placement,\n    );\n  });\n}\n\nexport function moveBlocksDown(editor: BlockNoteEditor<any, any, any>) {\n  editor.transact(() => {\n    const selection = editor.getSelection();\n    const block =\n      selection?.blocks[selection?.blocks.length - 1] ||\n      editor.getTextCursorPosition().block;\n\n    const moveDownPlacement = getMoveDownPlacement(\n      editor,\n      editor.getNextBlock(block),\n      editor.getParentBlock(block),\n    );\n\n    if (!moveDownPlacement) {\n      return;\n    }\n\n    moveSelectedBlocksAndSelection(\n      editor,\n      moveDownPlacement.referenceBlock,\n      moveDownPlacement.placement,\n    );\n  });\n}\n","import type { Node } from \"prosemirror-model\";\nimport type { Block } from \"../../../blocks/defaultBlocks.js\";\nimport type {\n  BlockIdentifier,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { nodeToBlock } from \"../../nodeConversions/nodeToBlock.js\";\nimport { getNodeById } from \"../../nodeUtil.js\";\nimport { getPmSchema } from \"../../pmUtil.js\";\n\nexport function getBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  doc: Node,\n  blockIdentifier: BlockIdentifier,\n): Block<BSchema, I, S> | undefined {\n  const id =\n    typeof blockIdentifier === \"string\" ? blockIdentifier : blockIdentifier.id;\n  const pmSchema = getPmSchema(doc);\n\n  const posInfo = getNodeById(id, doc);\n  if (!posInfo) {\n    return undefined;\n  }\n\n  return nodeToBlock(posInfo.node, pmSchema);\n}\n\nexport function getPrevBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  doc: Node,\n  blockIdentifier: BlockIdentifier,\n): Block<BSchema, I, S> | undefined {\n  const id =\n    typeof blockIdentifier === \"string\" ? blockIdentifier : blockIdentifier.id;\n\n  const posInfo = getNodeById(id, doc);\n  const pmSchema = getPmSchema(doc);\n  if (!posInfo) {\n    return undefined;\n  }\n\n  const $posBeforeNode = doc.resolve(posInfo.posBeforeNode);\n  const nodeToConvert = $posBeforeNode.nodeBefore;\n  if (!nodeToConvert) {\n    return undefined;\n  }\n\n  return nodeToBlock(nodeToConvert, pmSchema);\n}\n\nexport function getNextBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  doc: Node,\n  blockIdentifier: BlockIdentifier,\n): Block<BSchema, I, S> | undefined {\n  const id =\n    typeof blockIdentifier === \"string\" ? blockIdentifier : blockIdentifier.id;\n  const posInfo = getNodeById(id, doc);\n  const pmSchema = getPmSchema(doc);\n  if (!posInfo) {\n    return undefined;\n  }\n\n  const $posAfterNode = doc.resolve(\n    posInfo.posBeforeNode + posInfo.node.nodeSize,\n  );\n  const nodeToConvert = $posAfterNode.nodeAfter;\n  if (!nodeToConvert) {\n    return undefined;\n  }\n\n  return nodeToBlock(nodeToConvert, pmSchema);\n}\n\nexport function getParentBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  doc: Node,\n  blockIdentifier: BlockIdentifier,\n): Block<BSchema, I, S> | undefined {\n  const id =\n    typeof blockIdentifier === \"string\" ? blockIdentifier : blockIdentifier.id;\n  const pmSchema = getPmSchema(doc);\n  const posInfo = getNodeById(id, doc);\n  if (!posInfo) {\n    return undefined;\n  }\n\n  const $posBeforeNode = doc.resolve(posInfo.posBeforeNode);\n  const parentNode = $posBeforeNode.node();\n  const grandparentNode = $posBeforeNode.node(-1);\n  const nodeToConvert =\n    grandparentNode.type.name !== \"doc\"\n      ? parentNode.type.name === \"blockGroup\"\n        ? grandparentNode\n        : parentNode\n      : undefined;\n  if (!nodeToConvert) {\n    return undefined;\n  }\n\n  return nodeToBlock(nodeToConvert, pmSchema);\n}\n","import { insertBlocks } from \"../../api/blockManipulation/commands/insertBlocks/insertBlocks.js\";\nimport {\n  moveBlocksDown,\n  moveBlocksUp,\n} from \"../../api/blockManipulation/commands/moveBlocks/moveBlocks.js\";\nimport {\n  canNestBlock,\n  canUnnestBlock,\n  nestBlock,\n  unnestBlock,\n} from \"../../api/blockManipulation/commands/nestBlock/nestBlock.js\";\nimport { removeAndInsertBlocks } from \"../../api/blockManipulation/commands/replaceBlocks/replaceBlocks.js\";\nimport { updateBlock } from \"../../api/blockManipulation/commands/updateBlock/updateBlock.js\";\nimport {\n  getBlock,\n  getNextBlock,\n  getParentBlock,\n  getPrevBlock,\n} from \"../../api/blockManipulation/getBlock/getBlock.js\";\nimport { docToBlocks } from \"../../api/nodeConversions/nodeToBlock.js\";\nimport {\n  Block,\n  DefaultBlockSchema,\n  DefaultInlineContentSchema,\n  DefaultStyleSchema,\n  PartialBlock,\n} from \"../../blocks/defaultBlocks.js\";\nimport {\n  BlockIdentifier,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\nimport { BlockNoteEditor } from \"../BlockNoteEditor.js\";\n\nexport class BlockManager<\n  BSchema extends BlockSchema = DefaultBlockSchema,\n  ISchema extends InlineContentSchema = DefaultInlineContentSchema,\n  SSchema extends StyleSchema = DefaultStyleSchema,\n> {\n  constructor(private editor: BlockNoteEditor<BSchema, ISchema, SSchema>) {}\n\n  /**\n   * Gets a snapshot of all top-level (non-nested) blocks in the editor.\n   * @returns A snapshot of all top-level (non-nested) blocks in the editor.\n   */\n  public get document(): Block<BSchema, ISchema, SSchema>[] {\n    return this.editor.transact((tr) => {\n      return docToBlocks(tr.doc, this.editor.pmSchema);\n    });\n  }\n\n  /**\n   * Gets a snapshot of an existing block from the editor.\n   * @param blockIdentifier The identifier of an existing block that should be\n   * retrieved.\n   * @returns The block that matches the identifier, or `undefined` if no\n   * matching block was found.\n   */\n  public getBlock(\n    blockIdentifier: BlockIdentifier,\n  ): Block<BSchema, ISchema, SSchema> | undefined {\n    return this.editor.transact((tr) => getBlock(tr.doc, blockIdentifier));\n  }\n\n  /**\n   * Gets a snapshot of the previous sibling of an existing block from the\n   * editor.\n   * @param blockIdentifier The identifier of an existing block for which the\n   * previous sibling should be retrieved.\n   * @returns The previous sibling of the block that matches the identifier.\n   * `undefined` if no matching block was found, or it's the first child/block\n   * in the document.\n   */\n  public getPrevBlock(\n    blockIdentifier: BlockIdentifier,\n  ): Block<BSchema, ISchema, SSchema> | undefined {\n    return this.editor.transact((tr) => getPrevBlock(tr.doc, blockIdentifier));\n  }\n\n  /**\n   * Gets a snapshot of the next sibling of an existing block from the editor.\n   * @param blockIdentifier The identifier of an existing block for which the\n   * next sibling should be retrieved.\n   * @returns The next sibling of the block that matches the identifier.\n   * `undefined` if no matching block was found, or it's the last child/block in\n   * the document.\n   */\n  public getNextBlock(\n    blockIdentifier: BlockIdentifier,\n  ): Block<BSchema, ISchema, SSchema> | undefined {\n    return this.editor.transact((tr) => getNextBlock(tr.doc, blockIdentifier));\n  }\n\n  /**\n   * Gets a snapshot of the parent of an existing block from the editor.\n   * @param blockIdentifier The identifier of an existing block for which the\n   * parent should be retrieved.\n   * @returns The parent of the block that matches the identifier. `undefined`\n   * if no matching block was found, or the block isn't nested.\n   */\n  public getParentBlock(\n    blockIdentifier: BlockIdentifier,\n  ): Block<BSchema, ISchema, SSchema> | undefined {\n    return this.editor.transact((tr) =>\n      getParentBlock(tr.doc, blockIdentifier),\n    );\n  }\n\n  /**\n   * Traverses all blocks in the editor depth-first, and executes a callback for each.\n   * @param callback The callback to execute for each block. Returning `false` stops the traversal.\n   * @param reverse Whether the blocks should be traversed in reverse order.\n   */\n  public forEachBlock(\n    callback: (block: Block<BSchema, ISchema, SSchema>) => boolean,\n    reverse = false,\n  ): void {\n    const blocks = this.document.slice();\n\n    if (reverse) {\n      blocks.reverse();\n    }\n\n    function traverseBlockArray(\n      blockArray: Block<BSchema, ISchema, SSchema>[],\n    ): boolean {\n      for (const block of blockArray) {\n        if (callback(block) === false) {\n          return false;\n        }\n\n        const children = reverse\n          ? block.children.slice().reverse()\n          : block.children;\n\n        if (!traverseBlockArray(children)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    traverseBlockArray(blocks);\n  }\n\n  /**\n   * Inserts new blocks into the editor. If a block's `id` is undefined, BlockNote generates one automatically. Throws an\n   * error if the reference block could not be found.\n   * @param blocksToInsert An array of partial blocks that should be inserted.\n   * @param referenceBlock An identifier for an existing block, at which the new blocks should be inserted.\n   * @param placement Whether the blocks should be inserted just before, just after, or nested inside the\n   * `referenceBlock`.\n   */\n  public insertBlocks(\n    blocksToInsert: PartialBlock<BSchema, ISchema, SSchema>[],\n    referenceBlock: BlockIdentifier,\n    placement: \"before\" | \"after\" = \"before\",\n  ) {\n    return this.editor.transact((tr) =>\n      insertBlocks(tr, blocksToInsert, referenceBlock, placement),\n    );\n  }\n\n  /**\n   * Updates an existing block in the editor. Since updatedBlock is a PartialBlock object, some fields might not be\n   * defined. These undefined fields are kept as-is from the existing block. Throws an error if the block to update could\n   * not be found.\n   * @param blockToUpdate The block that should be updated.\n   * @param update A partial block which defines how the existing block should be changed.\n   */\n  public updateBlock(\n    blockToUpdate: BlockIdentifier,\n    update: PartialBlock<BSchema, ISchema, SSchema>,\n  ) {\n    return this.editor.transact((tr) => updateBlock(tr, blockToUpdate, update));\n  }\n\n  /**\n   * Removes existing blocks from the editor. Throws an error if any of the blocks could not be found.\n   * @param blocksToRemove An array of identifiers for existing blocks that should be removed.\n   */\n  public removeBlocks(blocksToRemove: BlockIdentifier[]) {\n    return this.editor.transact(\n      (tr) => removeAndInsertBlocks(tr, blocksToRemove, []).removedBlocks,\n    );\n  }\n\n  /**\n   * Replaces existing blocks in the editor with new blocks. If the blocks that should be removed are not adjacent or\n   * are at different nesting levels, `blocksToInsert` will be inserted at the position of the first block in\n   * `blocksToRemove`. Throws an error if any of the blocks to remove could not be found.\n   * @param blocksToRemove An array of blocks that should be replaced.\n   * @param blocksToInsert An array of partial blocks to replace the old ones with.\n   */\n  public replaceBlocks(\n    blocksToRemove: BlockIdentifier[],\n    blocksToInsert: PartialBlock<BSchema, ISchema, SSchema>[],\n  ) {\n    return this.editor.transact((tr) =>\n      removeAndInsertBlocks(tr, blocksToRemove, blocksToInsert),\n    );\n  }\n\n  /**\n   * Checks if the block containing the text cursor can be nested.\n   */\n  public canNestBlock() {\n    return canNestBlock(this.editor);\n  }\n\n  /**\n   * Nests the block containing the text cursor into the block above it.\n   */\n  public nestBlock() {\n    nestBlock(this.editor);\n  }\n\n  /**\n   * Checks if the block containing the text cursor is nested.\n   */\n  public canUnnestBlock() {\n    return canUnnestBlock(this.editor);\n  }\n\n  /**\n   * Lifts the block containing the text cursor out of its parent.\n   */\n  public unnestBlock() {\n    unnestBlock(this.editor);\n  }\n\n  /**\n   * Moves the selected blocks up. If the previous block has children, moves\n   * them to the end of its children. If there is no previous block, but the\n   * current blocks share a common parent, moves them out of & before it.\n   */\n  public moveBlocksUp() {\n    return moveBlocksUp(this.editor);\n  }\n\n  /**\n   * Moves the selected blocks down. If the next block has children, moves\n   * them to the start of its children. If there is no next block, but the\n   * current blocks share a common parent, moves them out of & after it.\n   */\n  public moveBlocksDown() {\n    return moveBlocksDown(this.editor);\n  }\n}\n","import * as Y from \"yjs\";\nimport { redoCommand, undoCommand } from \"y-prosemirror\";\nimport { CommentsPlugin } from \"../../extensions/Comments/CommentsPlugin.js\";\nimport { CommentMark } from \"../../extensions/Comments/CommentMark.js\";\nimport { ForkYDocPlugin } from \"../../extensions/Collaboration/ForkYDocPlugin.js\";\nimport { SyncPlugin } from \"../../extensions/Collaboration/SyncPlugin.js\";\nimport { UndoPlugin } from \"../../extensions/Collaboration/UndoPlugin.js\";\nimport { CursorPlugin } from \"../../extensions/Collaboration/CursorPlugin.js\";\nimport type { ThreadStore, User } from \"../../comments/index.js\";\nimport type { BlockNoteEditor } from \"../BlockNoteEditor.js\";\nimport { CustomBlockNoteSchema } from \"../../schema/schema.js\";\n\nexport interface CollaborationOptions {\n  /**\n   * The Yjs XML fragment that's used for collaboration.\n   */\n  fragment: Y.XmlFragment;\n  /**\n   * The user info for the current user that's shown to other collaborators.\n   */\n  user: {\n    name: string;\n    color: string;\n  };\n  /**\n   * A Yjs provider (used for awareness / cursor information)\n   * Can be null for comments-only mode\n   */\n  provider: any;\n  /**\n   * Optional function to customize how cursors of users are rendered\n   */\n  renderCursor?: (user: any) => HTMLElement;\n  /**\n   * Optional flag to set when the user label should be shown with the default\n   * collaboration cursor. Setting to \"always\" will always show the label,\n   * while \"activity\" will only show the label when the user moves the cursor\n   * or types. Defaults to \"activity\".\n   */\n  showCursorLabels?: \"always\" | \"activity\";\n  /**\n   * Comments configuration - can be used with or without collaboration\n   */\n  comments?: {\n    schema?: CustomBlockNoteSchema<any, any, any>;\n    threadStore: ThreadStore;\n  };\n  /**\n   * Function to resolve user IDs to user objects - required for comments\n   */\n  resolveUsers?: (userIds: string[]) => Promise<User[]>;\n}\n\n/**\n * CollaborationManager handles all collaboration-related functionality\n * This manager is completely optional and can be tree-shaken if not used\n */\nexport class CollaborationManager {\n  private editor: BlockNoteEditor;\n  private options: CollaborationOptions;\n  private _commentsPlugin?: CommentsPlugin;\n  private _forkYDocPlugin?: ForkYDocPlugin;\n  private _syncPlugin?: SyncPlugin;\n  private _undoPlugin?: UndoPlugin;\n  private _cursorPlugin?: CursorPlugin;\n\n  constructor(editor: BlockNoteEditor, options: CollaborationOptions) {\n    this.editor = editor;\n    this.options = options;\n  }\n\n  /**\n   * Get the sync plugin instance\n   */\n  public get syncPlugin(): SyncPlugin | undefined {\n    return this._syncPlugin;\n  }\n\n  /**\n   * Get the undo plugin instance\n   */\n  public get undoPlugin(): UndoPlugin | undefined {\n    return this._undoPlugin;\n  }\n\n  /**\n   * Get the cursor plugin instance\n   */\n  public get cursorPlugin(): CursorPlugin | undefined {\n    return this._cursorPlugin;\n  }\n\n  /**\n   * Get the fork YDoc plugin instance\n   */\n  public get forkYDocPlugin(): ForkYDocPlugin | undefined {\n    return this._forkYDocPlugin;\n  }\n\n  // Initialize collaboration plugins\n  public initExtensions(): Record<string, unknown> {\n    // Only create collaboration plugins when real-time collaboration is enabled\n    const extensions: Record<string, unknown> = {};\n\n    // Initialize sync plugin\n    this._syncPlugin = new SyncPlugin(this.options.fragment);\n    extensions.ySyncPlugin = this._syncPlugin;\n\n    // Initialize undo plugin\n    this._undoPlugin = new UndoPlugin({ editor: this.editor });\n    extensions.yUndoPlugin = this._undoPlugin;\n\n    // Initialize cursor plugin if provider has awareness\n    if (this.options.provider?.awareness) {\n      this._cursorPlugin = new CursorPlugin(this.options);\n      extensions.yCursorPlugin = this._cursorPlugin;\n    }\n\n    // Initialize fork YDoc plugin\n    this._forkYDocPlugin = new ForkYDocPlugin({\n      editor: this.editor,\n      collaboration: this.options,\n    });\n    extensions.forkYDocPlugin = this._forkYDocPlugin;\n\n    if (this.options.comments) {\n      if (!this.options.resolveUsers) {\n        throw new Error(\"resolveUsers is required when using comments\");\n      }\n\n      // Create CommentsPlugin instance and add it to editor extensions\n      this._commentsPlugin = new CommentsPlugin(\n        this.editor,\n        this.options.comments.threadStore,\n        CommentMark.name,\n        this.options.resolveUsers,\n        this.options.comments.schema,\n      );\n\n      // Add the comments plugin to the editor's extensions\n      extensions.comments = this._commentsPlugin;\n      extensions.commentMark = CommentMark;\n    }\n    return extensions;\n  }\n\n  /**\n   * Update the user info for the current user that's shown to other collaborators\n   */\n  public updateUserInfo(user: { name: string; color: string }) {\n    const cursor = this.cursorPlugin;\n    if (!cursor) {\n      throw new Error(\n        \"Cannot update collaboration user info when collaboration is disabled.\",\n      );\n    }\n    cursor.updateUser(user);\n  }\n\n  /**\n   * Get the collaboration undo command\n   */\n  public getUndoCommand() {\n    return undoCommand;\n  }\n\n  /**\n   * Get the collaboration redo command\n   */\n  public getRedoCommand() {\n    return redoCommand;\n  }\n\n  /**\n   * Check if initial content should be avoided due to collaboration\n   */\n  public shouldAvoidInitialContent(): boolean {\n    // Only avoid initial content when real-time collaboration is enabled\n    // (i.e., when we have a provider)\n    return !!this.options.provider;\n  }\n\n  /**\n   * Get the collaboration options\n   */\n  public getOptions(): CollaborationOptions {\n    return this.options;\n  }\n\n  /**\n   * Get the comments plugin if available\n   */\n  public get comments(): CommentsPlugin | undefined {\n    return this._commentsPlugin;\n  }\n\n  /**\n   * Check if comments are enabled\n   */\n  public get hasComments(): boolean {\n    return !!this.options.comments;\n  }\n\n  /**\n   * Get the resolveUsers function\n   */\n  public get resolveUsers():\n    | ((userIds: string[]) => Promise<User[]>)\n    | undefined {\n    return this.options.resolveUsers;\n  }\n}\n","import type { BlockNoteEditor } from \"../BlockNoteEditor.js\";\nimport {\n  getBlocksChangedByTransaction,\n  type BlocksChanged,\n} from \"../../api/getBlocksChangedByTransaction.js\";\nimport { Transaction } from \"prosemirror-state\";\nimport { EventEmitter } from \"../../util/EventEmitter.js\";\n\n/**\n * A function that can be used to unsubscribe from an event.\n */\nexport type Unsubscribe = () => void;\n\n/**\n * EventManager is a class which manages the events of the editor\n */\nexport class EventManager<Editor extends BlockNoteEditor> extends EventEmitter<{\n  onChange: [\n    editor: Editor,\n    ctx: {\n      getChanges(): BlocksChanged<\n        Editor[\"schema\"][\"blockSchema\"],\n        Editor[\"schema\"][\"inlineContentSchema\"],\n        Editor[\"schema\"][\"styleSchema\"]\n      >;\n    },\n  ];\n  onSelectionChange: [ctx: { editor: Editor; transaction: Transaction }];\n  onMount: [ctx: { editor: Editor }];\n  onUnmount: [ctx: { editor: Editor }];\n}> {\n  constructor(private editor: Editor) {\n    super();\n    // We register tiptap events only once the editor is finished initializing\n    // otherwise we would be trying to register events on a tiptap editor which does not exist yet\n    editor.onCreate(() => {\n      editor._tiptapEditor.on(\n        \"update\",\n        ({ transaction, appendedTransactions }) => {\n          this.emit(\"onChange\", editor, {\n            getChanges() {\n              return getBlocksChangedByTransaction(\n                transaction,\n                appendedTransactions,\n              );\n            },\n          });\n        },\n      );\n      editor._tiptapEditor.on(\"selectionUpdate\", ({ transaction }) => {\n        this.emit(\"onSelectionChange\", { editor, transaction });\n      });\n      editor._tiptapEditor.on(\"mount\", () => {\n        this.emit(\"onMount\", { editor });\n      });\n      editor._tiptapEditor.on(\"unmount\", () => {\n        this.emit(\"onUnmount\", { editor });\n      });\n    });\n  }\n\n  /**\n   * Register a callback that will be called when the editor changes.\n   */\n  public onChange(\n    callback: (\n      editor: Editor,\n      ctx: {\n        getChanges(): BlocksChanged<\n          Editor[\"schema\"][\"blockSchema\"],\n          Editor[\"schema\"][\"inlineContentSchema\"],\n          Editor[\"schema\"][\"styleSchema\"]\n        >;\n      },\n    ) => void,\n  ): Unsubscribe {\n    this.on(\"onChange\", callback);\n\n    return () => {\n      this.off(\"onChange\", callback);\n    };\n  }\n\n  /**\n   * Register a callback that will be called when the selection changes.\n   */\n  public onSelectionChange(\n    callback: (editor: Editor) => void,\n    /**\n     * If true, the callback will be triggered when the selection changes due to a yjs sync (i.e.: other user was typing)\n     */\n    includeSelectionChangedByRemote = false,\n  ): Unsubscribe {\n    const cb = (e: { transaction: Transaction }) => {\n      if (\n        e.transaction.getMeta(\"$y-sync\") &&\n        !includeSelectionChangedByRemote\n      ) {\n        // selection changed because of a yjs sync (i.e.: other user was typing)\n        // we don't want to trigger the callback in this case\n        return;\n      }\n      callback(this.editor);\n    };\n\n    this.on(\"onSelectionChange\", cb);\n\n    return () => {\n      this.off(\"onSelectionChange\", cb);\n    };\n  }\n\n  /**\n   * Register a callback that will be called when the editor is mounted.\n   */\n  public onMount(callback: (ctx: { editor: Editor }) => void): Unsubscribe {\n    this.on(\"onMount\", callback);\n\n    return () => {\n      this.off(\"onMount\", callback);\n    };\n  }\n\n  /**\n   * Register a callback that will be called when the editor is unmounted.\n   */\n  public onUnmount(callback: (ctx: { editor: Editor }) => void): Unsubscribe {\n    this.on(\"onUnmount\", callback);\n\n    return () => {\n      this.off(\"onUnmount\", callback);\n    };\n  }\n}\n","function getChildIndex(node: Element) {\n  return Array.prototype.indexOf.call(node.parentElement!.childNodes, node);\n}\n\nfunction isWhitespaceNode(node: Node) {\n  return node.nodeType === 3 && !/\\S/.test(node.nodeValue || \"\");\n}\n\n/**\n * Step 1, Turns:\n *\n * <ul>\n *  <li>item</li>\n *  <li>\n *   <ul>\n *      <li>...</li>\n *      <li>...</li>\n *   </ul>\n * </li>\n *\n * Into:\n * <ul>\n *  <li>item</li>\n *  <ul>\n *      <li>...</li>\n *      <li>...</li>\n *  </ul>\n * </ul>\n *\n */\nfunction liftNestedListsToParent(element: HTMLElement) {\n  element.querySelectorAll(\"li > ul, li > ol\").forEach((list) => {\n    const index = getChildIndex(list);\n    const parentListItem = list.parentElement!;\n    const siblingsAfter = Array.from(parentListItem.childNodes).slice(\n      index + 1,\n    );\n    list.remove();\n    siblingsAfter.forEach((sibling) => {\n      sibling.remove();\n    });\n\n    parentListItem.insertAdjacentElement(\"afterend\", list);\n\n    siblingsAfter.reverse().forEach((sibling) => {\n      if (isWhitespaceNode(sibling)) {\n        return;\n      }\n      const siblingContainer = document.createElement(\"li\");\n      siblingContainer.append(sibling);\n      list.insertAdjacentElement(\"afterend\", siblingContainer);\n    });\n    if (parentListItem.childNodes.length === 0) {\n      parentListItem.remove();\n    }\n  });\n}\n\n/**\n * Step 2, Turns (output of liftNestedListsToParent):\n *\n * <li>item</li>\n * <ul>\n *   <li>...</li>\n *   <li>...</li>\n * </ul>\n *\n * Into:\n * <div>\n *  <li>item</li>\n *  <div data-node-type=\"blockGroup\">\n *      <ul>\n *          <li>...</li>\n *          <li>...</li>\n *      </ul>\n *  </div>\n * </div>\n *\n * This resulting format is parsed\n */\nfunction createGroups(element: HTMLElement) {\n  element.querySelectorAll(\"li + ul, li + ol\").forEach((list) => {\n    const listItem = list.previousElementSibling as HTMLElement;\n    const blockContainer = document.createElement(\"div\");\n\n    listItem.insertAdjacentElement(\"afterend\", blockContainer);\n    blockContainer.append(listItem);\n\n    const blockGroup = document.createElement(\"div\");\n    blockGroup.setAttribute(\"data-node-type\", \"blockGroup\");\n    blockContainer.append(blockGroup);\n\n    while (\n      blockContainer.nextElementSibling?.nodeName === \"UL\" ||\n      blockContainer.nextElementSibling?.nodeName === \"OL\"\n    ) {\n      blockGroup.append(blockContainer.nextElementSibling);\n    }\n  });\n}\n\n// prevent XSS, similar to https://github.com/ProseMirror/prosemirror-view/blob/1251b2b412656a2a06263e4187574beb43651273/src/clipboard.ts#L204\n// https://github.com/TypeCellOS/BlockNote/issues/601\nlet _detachedDoc: Document | null = null;\nfunction detachedDoc() {\n  return (\n    _detachedDoc ||\n    (_detachedDoc = document.implementation.createHTMLDocument(\"title\"))\n  );\n}\n\nexport function nestedListsToBlockNoteStructure(\n  elementOrHTML: HTMLElement | string,\n) {\n  if (typeof elementOrHTML === \"string\") {\n    const element = detachedDoc().createElement(\"div\");\n    element.innerHTML = elementOrHTML;\n    elementOrHTML = element;\n  }\n  liftNestedListsToParent(elementOrHTML);\n  createGroups(elementOrHTML);\n  return elementOrHTML;\n}\n","import { DOMParser, Schema } from \"prosemirror-model\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\n\nimport { Block } from \"../../../blocks/defaultBlocks.js\";\nimport { nodeToBlock } from \"../../nodeConversions/nodeToBlock.js\";\nimport { nestedListsToBlockNoteStructure } from \"./util/nestedLists.js\";\n\nexport function HTMLToBlocks<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(html: string, pmSchema: Schema): Block<BSchema, I, S>[] {\n  const htmlNode = nestedListsToBlockNoteStructure(html);\n  const parser = DOMParser.fromSchema(pmSchema);\n\n  // Other approach might be to use\n  // const doc = pmSchema.nodes[\"doc\"].createAndFill()!;\n  // and context: doc.resolve(3),\n\n  const parentNode = parser.parse(htmlNode, {\n    topNode: pmSchema.nodes[\"blockGroup\"].create(),\n  });\n\n  const blocks: Block<BSchema, I, S>[] = [];\n\n  for (let i = 0; i < parentNode.childCount; i++) {\n    blocks.push(nodeToBlock(parentNode.child(i), pmSchema));\n  }\n\n  return blocks;\n}\n","import { Schema } from \"prosemirror-model\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkParse from \"remark-parse\";\nimport remarkRehype, {\n  defaultHandlers as remarkRehypeDefaultHandlers,\n} from \"remark-rehype\";\nimport rehypeStringify from \"rehype-stringify\";\nimport { unified } from \"unified\";\n\nimport { Block } from \"../../../blocks/defaultBlocks.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { HTMLToBlocks } from \"../html/parseHTML.js\";\nimport { isVideoUrl } from \"../../../util/string.js\";\n\n// modified version of https://github.com/syntax-tree/mdast-util-to-hast/blob/main/lib/handlers/code.js\n// that outputs a data-language attribute instead of a CSS class (e.g.: language-typescript)\nfunction code(state: any, node: any) {\n  const value = node.value ? node.value : \"\";\n  /** @type {Properties} */\n  const properties: any = {};\n\n  if (node.lang) {\n    // changed line\n    properties[\"data-language\"] = node.lang;\n  }\n\n  // Create `<code>`.\n  /** @type {Element} */\n  let result: any = {\n    type: \"element\",\n    tagName: \"code\",\n    properties,\n    children: [{ type: \"text\", value }],\n  };\n\n  if (node.meta) {\n    result.data = { meta: node.meta };\n  }\n\n  state.patch(node, result);\n  result = state.applyData(node, result);\n\n  // Create `<pre>`.\n  result = {\n    type: \"element\",\n    tagName: \"pre\",\n    properties: {},\n    children: [result],\n  };\n  state.patch(node, result);\n  return result;\n}\n\nfunction video(state: any, node: any) {\n  const url = String(node?.url || \"\");\n  const title = node?.title ? String(node.title) : undefined;\n\n  let result: any = {\n    type: \"element\",\n    tagName: \"video\",\n    properties: {\n      src: url,\n      \"data-name\": title,\n      \"data-url\": url,\n      controls: true,\n    },\n    children: [],\n  };\n  state.patch?.(node, result);\n  result = state.applyData ? state.applyData(node, result) : result;\n\n  return result;\n}\n\nexport function markdownToHTML(markdown: string): string {\n  const htmlString = unified()\n    .use(remarkParse)\n    .use(remarkGfm)\n    .use(remarkRehype, {\n      handlers: {\n        ...(remarkRehypeDefaultHandlers as any),\n        image: (state: any, node: any) => {\n          const url = String(node?.url || \"\");\n\n          if (isVideoUrl(url)) {\n            return video(state, node);\n          } else {\n            return remarkRehypeDefaultHandlers.image(state, node);\n          }\n        },\n        code,\n      },\n    })\n    .use(rehypeStringify)\n    .processSync(markdown);\n\n  return htmlString.value as string;\n}\n\nexport function markdownToBlocks<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(markdown: string, pmSchema: Schema): Block<BSchema, I, S>[] {\n  const htmlString = markdownToHTML(markdown);\n\n  return HTMLToBlocks(htmlString, pmSchema);\n}\n","import { createExternalHTMLExporter } from \"../../api/exporters/html/externalHTMLExporter.js\";\nimport { createInternalHTMLSerializer } from \"../../api/exporters/html/internalHTMLSerializer.js\";\nimport { blocksToMarkdown } from \"../../api/exporters/markdown/markdownExporter.js\";\nimport { HTMLToBlocks } from \"../../api/parsers/html/parseHTML.js\";\nimport {\n  markdownToBlocks,\n  markdownToHTML,\n} from \"../../api/parsers/markdown/parseMarkdown.js\";\nimport {\n  Block,\n  DefaultBlockSchema,\n  DefaultInlineContentSchema,\n  DefaultStyleSchema,\n  PartialBlock,\n} from \"../../blocks/defaultBlocks.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\nimport { BlockNoteEditor } from \"../BlockNoteEditor.js\";\n\nexport class ExportManager<\n  BSchema extends BlockSchema = DefaultBlockSchema,\n  ISchema extends InlineContentSchema = DefaultInlineContentSchema,\n  SSchema extends StyleSchema = DefaultStyleSchema,\n> {\n  constructor(private editor: BlockNoteEditor<BSchema, ISchema, SSchema>) {}\n\n  /**\n   * Exports blocks into a simplified HTML string. To better conform to HTML standards, children of blocks which aren't list\n   * items are un-nested in the output HTML.\n   *\n   * @param blocks An array of blocks that should be serialized into HTML.\n   * @returns The blocks, serialized as an HTML string.\n   */\n  public blocksToHTMLLossy(\n    blocks: PartialBlock<BSchema, ISchema, SSchema>[] = this.editor.document,\n  ): string {\n    const exporter = createExternalHTMLExporter(\n      this.editor.pmSchema,\n      this.editor,\n    );\n    return exporter.exportBlocks(blocks, {});\n  }\n\n  /**\n   * Serializes blocks into an HTML string in the format that would normally be rendered by the editor.\n   *\n   * Use this method if you want to server-side render HTML (for example, a blog post that has been edited in BlockNote)\n   * and serve it to users without loading the editor on the client (i.e.: displaying the blog post)\n   *\n   * @param blocks An array of blocks that should be serialized into HTML.\n   * @returns The blocks, serialized as an HTML string.\n   */\n  public blocksToFullHTML(\n    blocks: PartialBlock<BSchema, ISchema, SSchema>[],\n  ): string {\n    const exporter = createInternalHTMLSerializer(\n      this.editor.pmSchema,\n      this.editor,\n    );\n    return exporter.serializeBlocks(blocks, {});\n  }\n\n  /**\n   * Parses blocks from an HTML string. Tries to create `Block` objects out of any HTML block-level elements, and\n   * `InlineNode` objects from any HTML inline elements, though not all element types are recognized. If BlockNote\n   * doesn't recognize an HTML element's tag, it will parse it as a paragraph or plain text.\n   * @param html The HTML string to parse blocks from.\n   * @returns The blocks parsed from the HTML string.\n   */\n  public tryParseHTMLToBlocks(\n    html: string,\n  ): Block<BSchema, ISchema, SSchema>[] {\n    return HTMLToBlocks(html, this.editor.pmSchema);\n  }\n\n  /**\n   * Serializes blocks into a Markdown string. The output is simplified as Markdown does not support all features of\n   * BlockNote - children of blocks which aren't list items are un-nested and certain styles are removed.\n   * @param blocks An array of blocks that should be serialized into Markdown.\n   * @returns The blocks, serialized as a Markdown string.\n   */\n  public blocksToMarkdownLossy(\n    blocks: PartialBlock<BSchema, ISchema, SSchema>[] = this.editor.document,\n  ): string {\n    return blocksToMarkdown(blocks, this.editor.pmSchema, this.editor, {});\n  }\n\n  /**\n   * Creates a list of blocks from a Markdown string. Tries to create `Block` and `InlineNode` objects based on\n   * Markdown syntax, though not all symbols are recognized. If BlockNote doesn't recognize a symbol, it will parse it\n   * as text.\n   * @param markdown The Markdown string to parse blocks from.\n   * @returns The blocks parsed from the Markdown string.\n   */\n  public tryParseMarkdownToBlocks(\n    markdown: string,\n  ): Block<BSchema, ISchema, SSchema>[] {\n    return markdownToBlocks(markdown, this.editor.pmSchema);\n  }\n\n  /**\n   * Paste HTML into the editor. Defaults to converting HTML to BlockNote HTML.\n   * @param html The HTML to paste.\n   * @param raw Whether to paste the HTML as is, or to convert it to BlockNote HTML.\n   */\n  public pasteHTML(html: string, raw = false) {\n    let htmlToPaste = html;\n    if (!raw) {\n      const blocks = this.tryParseHTMLToBlocks(html);\n      htmlToPaste = this.blocksToFullHTML(blocks);\n    }\n    if (!htmlToPaste) {\n      return;\n    }\n    this.editor.prosemirrorView?.pasteHTML(htmlToPaste);\n  }\n\n  /**\n   * Paste text into the editor. Defaults to interpreting text as markdown.\n   * @param text The text to paste.\n   */\n  public pasteText(text: string) {\n    return this.editor.prosemirrorView?.pasteText(text);\n  }\n\n  /**\n   * Paste markdown into the editor.\n   * @param markdown The markdown to paste.\n   */\n  public pasteMarkdown(markdown: string) {\n    const html = markdownToHTML(markdown);\n    return this.pasteHTML(html);\n  }\n}\n","import { FilePanelProsemirrorPlugin } from \"../../extensions/FilePanel/FilePanelPlugin.js\";\nimport { FormattingToolbarProsemirrorPlugin } from \"../../extensions/FormattingToolbar/FormattingToolbarPlugin.js\";\nimport { LinkToolbarProsemirrorPlugin } from \"../../extensions/LinkToolbar/LinkToolbarPlugin.js\";\nimport { ShowSelectionPlugin } from \"../../extensions/ShowSelection/ShowSelectionPlugin.js\";\nimport { SideMenuProsemirrorPlugin } from \"../../extensions/SideMenu/SideMenuPlugin.js\";\nimport { SuggestionMenuProseMirrorPlugin } from \"../../extensions/SuggestionMenu/SuggestionPlugin.js\";\nimport { TableHandlesProsemirrorPlugin } from \"../../extensions/TableHandles/TableHandlesPlugin.js\";\nimport { BlockNoteExtension } from \"../BlockNoteExtension.js\";\nimport { BlockNoteEditor } from \"../BlockNoteEditor.js\";\n\nexport class ExtensionManager {\n  constructor(private editor: BlockNoteEditor) {}\n\n  /**\n   * Shorthand to get a typed extension from the editor, by\n   * just passing in the extension class.\n   *\n   * @param ext - The extension class to get\n   * @param key - optional, the key of the extension in the extensions object (defaults to the extension name)\n   * @returns The extension instance\n   */\n  public extension<T extends BlockNoteExtension>(\n    ext: { new (...args: any[]): T } & typeof BlockNoteExtension,\n    key = ext.key(),\n  ): T {\n    const extension = this.editor.extensions[key] as T;\n    if (!extension) {\n      throw new Error(`Extension ${key} not found`);\n    }\n    return extension;\n  }\n\n  /**\n   * Get all extensions\n   */\n  public getExtensions() {\n    return this.editor.extensions;\n  }\n\n  /**\n   * Get a specific extension by key\n   */\n  public getExtension(key: string) {\n    return this.editor.extensions[key];\n  }\n\n  /**\n   * Check if an extension exists\n   */\n  public hasExtension(key: string): boolean {\n    return key in this.editor.extensions;\n  }\n\n  // Plugin getters - these provide access to the core BlockNote plugins\n\n  /**\n   * Get the formatting toolbar plugin\n   */\n  public get formattingToolbar(): FormattingToolbarProsemirrorPlugin {\n    return this.editor.extensions[\n      \"formattingToolbar\"\n    ] as FormattingToolbarProsemirrorPlugin;\n  }\n\n  /**\n   * Get the link toolbar plugin\n   */\n  public get linkToolbar(): LinkToolbarProsemirrorPlugin<any, any, any> {\n    return this.editor.extensions[\n      \"linkToolbar\"\n    ] as LinkToolbarProsemirrorPlugin<any, any, any>;\n  }\n\n  /**\n   * Get the side menu plugin\n   */\n  public get sideMenu(): SideMenuProsemirrorPlugin<any, any, any> {\n    return this.editor.extensions[\"sideMenu\"] as SideMenuProsemirrorPlugin<\n      any,\n      any,\n      any\n    >;\n  }\n\n  /**\n   * Get the suggestion menus plugin\n   */\n  public get suggestionMenus(): SuggestionMenuProseMirrorPlugin<any, any, any> {\n    return this.editor.extensions[\n      \"suggestionMenus\"\n    ] as SuggestionMenuProseMirrorPlugin<any, any, any>;\n  }\n\n  /**\n   * Get the file panel plugin (if available)\n   */\n  public get filePanel(): FilePanelProsemirrorPlugin<any, any> | undefined {\n    return this.editor.extensions[\"filePanel\"] as\n      | FilePanelProsemirrorPlugin<any, any>\n      | undefined;\n  }\n\n  /**\n   * Get the table handles plugin (if available)\n   */\n  public get tableHandles():\n    | TableHandlesProsemirrorPlugin<any, any>\n    | undefined {\n    return this.editor.extensions[\"tableHandles\"] as\n      | TableHandlesProsemirrorPlugin<any, any>\n      | undefined;\n  }\n\n  /**\n   * Get the show selection plugin\n   */\n  public get showSelectionPlugin(): ShowSelectionPlugin {\n    return this.editor.extensions[\"showSelection\"] as ShowSelectionPlugin;\n  }\n\n  /**\n   * Check if collaboration is enabled (Yjs or Liveblocks)\n   */\n  public get isCollaborationEnabled(): boolean {\n    return (\n      this.hasExtension(\"ySyncPlugin\") ||\n      this.hasExtension(\"liveblocksExtension\")\n    );\n  }\n}\n","import { TextSelection, type Transaction } from \"prosemirror-state\";\nimport { TableMap } from \"prosemirror-tables\";\n\nimport { Block } from \"../../../blocks/defaultBlocks.js\";\nimport { Selection } from \"../../../editor/selectionTypes.js\";\nimport {\n  BlockIdentifier,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { getBlockInfo, getNearestBlockPos } from \"../../getBlockInfoFromPos.js\";\nimport {\n  nodeToBlock,\n  prosemirrorSliceToSlicedBlocks,\n} from \"../../nodeConversions/nodeToBlock.js\";\nimport { getNodeById } from \"../../nodeUtil.js\";\nimport { getBlockNoteSchema, getPmSchema } from \"../../pmUtil.js\";\n\nexport function getSelection<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(tr: Transaction): Selection<BSchema, I, S> | undefined {\n  const pmSchema = getPmSchema(tr);\n  // Return undefined if the selection is collapsed or a node is selected.\n  if (tr.selection.empty || \"node\" in tr.selection) {\n    return undefined;\n  }\n\n  const $startBlockBeforePos = tr.doc.resolve(\n    getNearestBlockPos(tr.doc, tr.selection.from).posBeforeNode,\n  );\n  const $endBlockBeforePos = tr.doc.resolve(\n    getNearestBlockPos(tr.doc, tr.selection.to).posBeforeNode,\n  );\n\n  // Converts the node at the given index and depth around `$startBlockBeforePos`\n  // to a block. Used to get blocks at given indices at the shared depth and\n  // at the depth of `$startBlockBeforePos`.\n  const indexToBlock = (\n    index: number,\n    depth?: number,\n  ): Block<BSchema, I, S> => {\n    const pos = $startBlockBeforePos.posAtIndex(index, depth);\n    const node = tr.doc.resolve(pos).nodeAfter;\n\n    if (!node) {\n      throw new Error(\n        `Error getting selection - node not found at position ${pos}`,\n      );\n    }\n\n    return nodeToBlock(node, pmSchema);\n  };\n\n  const blocks: Block<BSchema, I, S>[] = [];\n  // Minimum depth at which the blocks share a common ancestor.\n  const sharedDepth = $startBlockBeforePos.sharedDepth($endBlockBeforePos.pos);\n  const startIndex = $startBlockBeforePos.index(sharedDepth);\n  const endIndex = $endBlockBeforePos.index(sharedDepth);\n\n  // In most cases, we want to return the blocks spanned by the selection at the\n  // shared depth. However, when the block in which the selection starts is at a\n  // higher depth than the shared depth, we omit the first block at the shared\n  // depth. Instead, we include the first block at its depth, and any blocks at\n  // a higher index up to the shared depth. The following  example illustrates\n  // this:\n  // - id-0\n  //   - id-1\n  //     - >|id-2\n  //     - id-3\n  //   - id-4\n  //     - id-5\n  //   - id-6\n  // - id-7\n  // - id-8\n  // - id-9|<\n  //   - id-10\n  // Here, each block is represented by its ID, and the selection is represented\n  // by the `>|` and `|<` markers. So the selection starts in block `id-2` and\n  // ends in block `id-8`. In this case, the shared depth is 0, since the blocks\n  // `id-6`, `id-7`, and `id-8` set the shared depth, as they are the least\n  // nested blocks spanned by the selection. Therefore, these blocks are all\n  // added to the `blocks` array. However, the selection starts in block `id-2`,\n  // which is at a higher depth than the shared depth. So we add block `id-2` to\n  // the `blocks` array, as well as any later siblings (in this case, `id-3`),\n  // and move up one level of depth. The ancestor of block `id-2` at this depth\n  // is block `id-1`, so we add all its later siblings to the `blocks` array as\n  // well, again moving up one level of depth. Since we're now at the shared\n  // depth, we are done. The final `blocks` array for this example would be:\n  // [ id-2, id-3, id-4, id-6, id-7, id-8, id-9 ]\n  if ($startBlockBeforePos.depth > sharedDepth) {\n    // Adds the block that the selection starts in.\n    blocks.push(nodeToBlock($startBlockBeforePos.nodeAfter!, pmSchema));\n\n    // Traverses all depths from the depth of the block in which the selection\n    // starts, up to the shared depth.\n    for (let depth = $startBlockBeforePos.depth; depth > sharedDepth; depth--) {\n      const parentNode = $startBlockBeforePos.node(depth);\n\n      if (parentNode.type.isInGroup(\"childContainer\")) {\n        const startIndexAtDepth = $startBlockBeforePos.index(depth) + 1;\n        const childCountAtDepth = $startBlockBeforePos.node(depth).childCount;\n\n        // Adds all blocks after the index of the block in which the selection\n        // starts (or its ancestors at lower depths).\n        for (let i = startIndexAtDepth; i < childCountAtDepth; i++) {\n          blocks.push(indexToBlock(i, depth));\n        }\n      }\n    }\n  } else {\n    // Adds the first block spanned by the selection at the shared depth.\n    blocks.push(indexToBlock(startIndex, sharedDepth));\n  }\n\n  // Adds all blocks spanned by the selection at the shared depth, excluding\n  // the first.\n  for (let i = startIndex + 1; i <= endIndex; i++) {\n    blocks.push(indexToBlock(i, sharedDepth));\n  }\n\n  if (blocks.length === 0) {\n    throw new Error(\n      `Error getting selection - selection doesn't span any blocks (${tr.selection})`,\n    );\n  }\n\n  return {\n    blocks,\n  };\n}\n\nexport function setSelection(\n  tr: Transaction,\n  startBlock: BlockIdentifier,\n  endBlock: BlockIdentifier,\n) {\n  const startBlockId =\n    typeof startBlock === \"string\" ? startBlock : startBlock.id;\n  const endBlockId = typeof endBlock === \"string\" ? endBlock : endBlock.id;\n  const pmSchema = getPmSchema(tr);\n  const schema = getBlockNoteSchema(pmSchema);\n\n  if (startBlockId === endBlockId) {\n    throw new Error(\n      `Attempting to set selection with the same anchor and head blocks (id ${startBlockId})`,\n    );\n  }\n  const anchorPosInfo = getNodeById(startBlockId, tr.doc);\n  if (!anchorPosInfo) {\n    throw new Error(`Block with ID ${startBlockId} not found`);\n  }\n  const headPosInfo = getNodeById(endBlockId, tr.doc);\n  if (!headPosInfo) {\n    throw new Error(`Block with ID ${endBlockId} not found`);\n  }\n\n  const anchorBlockInfo = getBlockInfo(anchorPosInfo);\n  const headBlockInfo = getBlockInfo(headPosInfo);\n\n  const anchorBlockConfig =\n    schema.blockSchema[\n      anchorBlockInfo.blockNoteType as keyof typeof schema.blockSchema\n    ];\n  const headBlockConfig =\n    schema.blockSchema[\n      headBlockInfo.blockNoteType as keyof typeof schema.blockSchema\n    ];\n\n  if (\n    !anchorBlockInfo.isBlockContainer ||\n    anchorBlockConfig.content === \"none\"\n  ) {\n    throw new Error(\n      `Attempting to set selection anchor in block without content (id ${startBlockId})`,\n    );\n  }\n  if (!headBlockInfo.isBlockContainer || headBlockConfig.content === \"none\") {\n    throw new Error(\n      `Attempting to set selection anchor in block without content (id ${endBlockId})`,\n    );\n  }\n\n  let startPos: number;\n  let endPos: number;\n\n  if (anchorBlockConfig.content === \"table\") {\n    const tableMap = TableMap.get(anchorBlockInfo.blockContent.node);\n    const firstCellPos =\n      anchorBlockInfo.blockContent.beforePos +\n      tableMap.positionAt(0, 0, anchorBlockInfo.blockContent.node) +\n      1;\n    startPos = firstCellPos + 2;\n  } else {\n    startPos = anchorBlockInfo.blockContent.beforePos + 1;\n  }\n\n  if (headBlockConfig.content === \"table\") {\n    const tableMap = TableMap.get(headBlockInfo.blockContent.node);\n    const lastCellPos =\n      headBlockInfo.blockContent.beforePos +\n      tableMap.positionAt(\n        tableMap.height - 1,\n        tableMap.width - 1,\n        headBlockInfo.blockContent.node,\n      ) +\n      1;\n    const lastCellNodeSize = tr.doc.resolve(lastCellPos).nodeAfter!.nodeSize;\n    endPos = lastCellPos + lastCellNodeSize - 2;\n  } else {\n    endPos = headBlockInfo.blockContent.afterPos - 1;\n  }\n\n  // TODO: We should polish up the `MultipleNodeSelection` and use that instead.\n  //  Right now it's missing a few things like a jsonID and styling to show\n  //  which nodes are selected. `TextSelection` is ok for now, but has the\n  //  restriction that the start/end blocks must have content.\n  tr.setSelection(TextSelection.create(tr.doc, startPos, endPos));\n}\n\nexport function getSelectionCutBlocks(tr: Transaction) {\n  // TODO: fix image node selection\n\n  const pmSchema = getPmSchema(tr);\n  let start = tr.selection.$from;\n  let end = tr.selection.$to;\n\n  // the selection moves below are used to make sure `prosemirrorSliceToSlicedBlocks` returns\n  // the correct information about whether content is cut at the start or end of a block\n\n  // if the end is at the end of a node (|</span></p>) move it forward so we include all closing tags (</span></p>|)\n  while (end.parentOffset >= end.parent.nodeSize - 2 && end.depth > 0) {\n    end = tr.doc.resolve(end.pos + 1);\n  }\n\n  // if the end is at the start of an empty node (</span></p><p>|) move it backwards so we drop empty start tags (</span></p>|)\n  while (end.parentOffset === 0 && end.depth > 0) {\n    end = tr.doc.resolve(end.pos - 1);\n  }\n\n  // if the start is at the start of a node (<p><span>|) move it backwards so we include all open tags (|<p><span>)\n  while (start.parentOffset === 0 && start.depth > 0) {\n    start = tr.doc.resolve(start.pos - 1);\n  }\n\n  // if the start is at the end of a node (|</p><p><span>|) move it forwards so we drop all closing tags (|<p><span>)\n  while (start.parentOffset >= start.parent.nodeSize - 2 && start.depth > 0) {\n    start = tr.doc.resolve(start.pos + 1);\n  }\n\n  const selectionInfo = prosemirrorSliceToSlicedBlocks(\n    tr.doc.slice(start.pos, end.pos, true),\n    pmSchema,\n  );\n\n  return {\n    _meta: {\n      startPos: start.pos,\n      endPos: end.pos,\n    },\n    ...selectionInfo,\n  };\n}\n","import type { Node } from \"prosemirror-model\";\nimport {\n  NodeSelection,\n  TextSelection,\n  type Transaction,\n} from \"prosemirror-state\";\nimport type { TextCursorPosition } from \"../../../editor/cursorPositionTypes.js\";\nimport type {\n  BlockIdentifier,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../../schema/index.js\";\nimport { UnreachableCaseError } from \"../../../util/typescript.js\";\nimport {\n  getBlockInfo,\n  getBlockInfoFromTransaction,\n} from \"../../getBlockInfoFromPos.js\";\nimport { nodeToBlock } from \"../../nodeConversions/nodeToBlock.js\";\nimport { getNodeById } from \"../../nodeUtil.js\";\nimport { getBlockNoteSchema, getPmSchema } from \"../../pmUtil.js\";\n\nexport function getTextCursorPosition<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(tr: Transaction): TextCursorPosition<BSchema, I, S> {\n  const { bnBlock } = getBlockInfoFromTransaction(tr);\n  const pmSchema = getPmSchema(tr.doc);\n\n  const resolvedPos = tr.doc.resolve(bnBlock.beforePos);\n  // Gets previous blockContainer node at the same nesting level, if the current node isn't the first child.\n  const prevNode = resolvedPos.nodeBefore;\n\n  // Gets next blockContainer node at the same nesting level, if the current node isn't the last child.\n  const nextNode = tr.doc.resolve(bnBlock.afterPos).nodeAfter;\n\n  // Gets parent blockContainer node, if the current node is nested.\n  let parentNode: Node | undefined = undefined;\n  if (resolvedPos.depth > 1) {\n    // for nodes nested in bnBlocks\n    parentNode = resolvedPos.node();\n    if (!parentNode.type.isInGroup(\"bnBlock\")) {\n      // for blockGroups, we need to go one level up\n      parentNode = resolvedPos.node(resolvedPos.depth - 1);\n    }\n  }\n\n  return {\n    block: nodeToBlock(bnBlock.node, pmSchema),\n    prevBlock: prevNode === null ? undefined : nodeToBlock(prevNode, pmSchema),\n    nextBlock: nextNode === null ? undefined : nodeToBlock(nextNode, pmSchema),\n    parentBlock:\n      parentNode === undefined ? undefined : nodeToBlock(parentNode, pmSchema),\n  };\n}\n\nexport function setTextCursorPosition(\n  tr: Transaction,\n  targetBlock: BlockIdentifier,\n  placement: \"start\" | \"end\" = \"start\",\n) {\n  const id = typeof targetBlock === \"string\" ? targetBlock : targetBlock.id;\n  const pmSchema = getPmSchema(tr.doc);\n  const schema = getBlockNoteSchema(pmSchema);\n\n  const posInfo = getNodeById(id, tr.doc);\n  if (!posInfo) {\n    throw new Error(`Block with ID ${id} not found`);\n  }\n\n  const info = getBlockInfo(posInfo);\n\n  const contentType: \"none\" | \"inline\" | \"table\" =\n    schema.blockSchema[info.blockNoteType]!.content;\n\n  if (info.isBlockContainer) {\n    const blockContent = info.blockContent;\n    if (contentType === \"none\") {\n      tr.setSelection(NodeSelection.create(tr.doc, blockContent.beforePos));\n      return;\n    }\n\n    if (contentType === \"inline\") {\n      if (placement === \"start\") {\n        tr.setSelection(\n          TextSelection.create(tr.doc, blockContent.beforePos + 1),\n        );\n      } else {\n        tr.setSelection(\n          TextSelection.create(tr.doc, blockContent.afterPos - 1),\n        );\n      }\n    } else if (contentType === \"table\") {\n      if (placement === \"start\") {\n        // Need to offset the position as we have to get through the `tableRow`\n        // and `tableCell` nodes to get to the `tableParagraph` node we want to\n        // set the selection in.\n        tr.setSelection(\n          TextSelection.create(tr.doc, blockContent.beforePos + 4),\n        );\n      } else {\n        tr.setSelection(\n          TextSelection.create(tr.doc, blockContent.afterPos - 4),\n        );\n      }\n    } else {\n      throw new UnreachableCaseError(contentType);\n    }\n  } else {\n    const child =\n      placement === \"start\"\n        ? info.childContainer.node.firstChild!\n        : info.childContainer.node.lastChild!;\n\n    setTextCursorPosition(tr, child.attrs.id, placement);\n  }\n}\n","import {\n  getSelection,\n  getSelectionCutBlocks,\n  setSelection,\n} from \"../../api/blockManipulation/selections/selection.js\";\nimport {\n  getTextCursorPosition,\n  setTextCursorPosition,\n} from \"../../api/blockManipulation/selections/textCursorPosition.js\";\nimport { isNodeSelection, posToDOMRect } from \"@tiptap/core\";\nimport {\n  BlockIdentifier,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\nimport {\n  DefaultBlockSchema,\n  DefaultInlineContentSchema,\n  DefaultStyleSchema,\n} from \"../../blocks/defaultBlocks.js\";\nimport { Selection } from \"../selectionTypes.js\";\nimport { TextCursorPosition } from \"../cursorPositionTypes.js\";\nimport { BlockNoteEditor } from \"../BlockNoteEditor.js\";\n\nexport class SelectionManager<\n  BSchema extends BlockSchema = DefaultBlockSchema,\n  ISchema extends InlineContentSchema = DefaultInlineContentSchema,\n  SSchema extends StyleSchema = DefaultStyleSchema,\n> {\n  constructor(private editor: BlockNoteEditor<BSchema, ISchema, SSchema>) {}\n\n  /**\n   * Gets a snapshot of the current selection. This contains all blocks (included nested blocks)\n   * that the selection spans across.\n   *\n   * If the selection starts / ends halfway through a block, the returned data will contain the entire block.\n   */\n  public getSelection(): Selection<BSchema, ISchema, SSchema> | undefined {\n    return this.editor.transact((tr) => getSelection(tr));\n  }\n\n  /**\n   * Gets a snapshot of the current selection. This contains all blocks (included nested blocks)\n   * that the selection spans across.\n   *\n   * If the selection starts / ends halfway through a block, the returned block will be\n   * only the part of the block that is included in the selection.\n   */\n  public getSelectionCutBlocks() {\n    return this.editor.transact((tr) => getSelectionCutBlocks(tr));\n  }\n\n  /**\n   * Sets the selection to a range of blocks.\n   * @param startBlock The identifier of the block that should be the start of the selection.\n   * @param endBlock The identifier of the block that should be the end of the selection.\n   */\n  public setSelection(startBlock: BlockIdentifier, endBlock: BlockIdentifier) {\n    return this.editor.transact((tr) => setSelection(tr, startBlock, endBlock));\n  }\n\n  /**\n   * Gets a snapshot of the current text cursor position.\n   * @returns A snapshot of the current text cursor position.\n   */\n  public getTextCursorPosition(): TextCursorPosition<\n    BSchema,\n    ISchema,\n    SSchema\n  > {\n    return this.editor.transact((tr) => getTextCursorPosition(tr));\n  }\n\n  /**\n   * Sets the text cursor position to the start or end of an existing block. Throws an error if the target block could\n   * not be found.\n   * @param targetBlock The identifier of an existing block that the text cursor should be moved to.\n   * @param placement Whether the text cursor should be placed at the start or end of the block.\n   */\n  public setTextCursorPosition(\n    targetBlock: BlockIdentifier,\n    placement: \"start\" | \"end\" = \"start\",\n  ) {\n    return this.editor.transact((tr) =>\n      setTextCursorPosition(tr, targetBlock, placement),\n    );\n  }\n\n  /**\n   * Gets the bounding box of the current selection.\n   */\n  public getSelectionBoundingBox() {\n    if (!this.editor.prosemirrorView) {\n      return undefined;\n    }\n\n    const { selection } = this.editor.prosemirrorState;\n\n    // support for CellSelections\n    const { ranges } = selection;\n    const from = Math.min(...ranges.map((range) => range.$from.pos));\n    const to = Math.max(...ranges.map((range) => range.$to.pos));\n\n    if (isNodeSelection(selection)) {\n      const node = this.editor.prosemirrorView.nodeDOM(from) as HTMLElement;\n      if (node) {\n        return node.getBoundingClientRect();\n      }\n    }\n\n    return posToDOMRect(this.editor.prosemirrorView, from, to);\n  }\n}\n","import { redo, undo } from \"@tiptap/pm/history\";\nimport { Command, Transaction } from \"prosemirror-state\";\nimport { BlockNoteEditor } from \"../BlockNoteEditor.js\";\n\nexport class StateManager {\n  constructor(\n    private editor: BlockNoteEditor,\n    private options?: {\n      /**\n       * Swap the default undo command with a custom command.\n       */\n      undo?: typeof undo;\n      /**\n       * Swap the default redo command with a custom command.\n       */\n      redo?: typeof redo;\n    },\n  ) {}\n\n  /**\n   * Stores the currently active transaction, which is the accumulated transaction from all {@link dispatch} calls during a {@link transact} calls\n   */\n  private activeTransaction: Transaction | null = null;\n\n  /**\n   * For any command that can be executed, you can check if it can be executed by calling `editor.can(command)`.\n   * @example\n   * ```ts\n   * if (editor.can(editor.undo)) {\n   *   // show button\n   * } else {\n   *   // hide button\n   * }\n   */\n  public can(cb: () => boolean) {\n    try {\n      this.isInCan = true;\n      return cb();\n    } finally {\n      this.isInCan = false;\n    }\n  }\n\n  // Flag to indicate if we're in a `can` call\n  private isInCan = false;\n\n  /**\n   * Execute a prosemirror command. This is mostly for backwards compatibility with older code.\n   *\n   * @note You should prefer the {@link transact} method when possible, as it will automatically handle the dispatching of the transaction and work across blocknote transactions.\n   *\n   * @example\n   * ```ts\n   * editor.exec((state, dispatch, view) => {\n   *   dispatch(state.tr.insertText(\"Hello, world!\"));\n   * });\n   * ```\n   */\n  public exec(command: Command) {\n    if (this.activeTransaction) {\n      throw new Error(\n        \"`exec` should not be called within a `transact` call, move the `exec` call outside of the `transact` call\",\n      );\n    }\n    if (this.isInCan) {\n      return this.canExec(command);\n    }\n    const state = this.prosemirrorState;\n    const view = this.prosemirrorView;\n    const dispatch = (tr: Transaction) => this.prosemirrorView.dispatch(tr);\n\n    return command(state, dispatch, view);\n  }\n\n  /**\n   * Check if a command can be executed. A command should return `false` if it is not valid in the current state.\n   *\n   * @example\n   * ```ts\n   * if (editor.canExec(command)) {\n   *   // show button\n   * } else {\n   *   // hide button\n   * }\n   * ```\n   */\n  public canExec(command: Command): boolean {\n    if (this.activeTransaction) {\n      throw new Error(\n        \"`canExec` should not be called within a `transact` call, move the `canExec` call outside of the `transact` call\",\n      );\n    }\n    const state = this.prosemirrorState;\n    const view = this.prosemirrorView;\n\n    return command(state, undefined, view);\n  }\n\n  /**\n   * Execute a function within a \"blocknote transaction\".\n   * All changes to the editor within the transaction will be grouped together, so that\n   * we can dispatch them as a single operation (thus creating only a single undo step)\n   *\n   * @note There is no need to dispatch the transaction, as it will be automatically dispatched when the callback is complete.\n   *\n   * @example\n   * ```ts\n   * // All changes to the editor will be grouped together\n   * editor.transact((tr) => {\n   *   tr.insertText(\"Hello, world!\");\n   * // These two operations will be grouped together in a single undo step\n   *   editor.transact((tr) => {\n   *     tr.insertText(\"Hello, world!\");\n   *   });\n   * });\n   * ```\n   */\n  public transact<T>(\n    callback: (\n      /**\n       * The current active transaction, this will automatically be dispatched to the editor when the callback is complete\n       * If another `transact` call is made within the callback, it will be passed the same transaction as the parent call.\n       */\n      tr: Transaction,\n    ) => T,\n  ): T {\n    if (this.activeTransaction) {\n      // Already in a transaction, so we can just callback immediately\n      return callback(this.activeTransaction);\n    }\n\n    try {\n      // Enter transaction mode, by setting a starting transaction\n      this.activeTransaction = this.editor._tiptapEditor.state.tr;\n\n      // Capture all dispatch'd transactions\n      const result = callback(this.activeTransaction);\n\n      // Any transactions captured by the `dispatch` call will be stored in `this.activeTransaction`\n      const activeTr = this.activeTransaction;\n\n      this.activeTransaction = null;\n      if (\n        activeTr &&\n        // Only dispatch if the transaction was actually modified in some way\n        (activeTr.docChanged ||\n          activeTr.selectionSet ||\n          activeTr.scrolledIntoView ||\n          activeTr.storedMarksSet ||\n          !activeTr.isGeneric)\n      ) {\n        // Dispatch the transaction if it was modified\n        this.prosemirrorView.dispatch(activeTr);\n      }\n\n      return result;\n    } finally {\n      // We wrap this in a finally block to ensure we don't disable future transactions just because of an error in the callback\n      this.activeTransaction = null;\n    }\n  }\n  /**\n   * Get the underlying prosemirror state\n   * @note Prefer using `editor.transact` to read the current editor state, as that will ensure the state is up to date\n   * @see https://prosemirror.net/docs/ref/#state.EditorState\n   */\n  public get prosemirrorState() {\n    if (this.activeTransaction) {\n      throw new Error(\n        \"`prosemirrorState` should not be called within a `transact` call, move the `prosemirrorState` call outside of the `transact` call or use `editor.transact` to read the current editor state\",\n      );\n    }\n    return this.editor._tiptapEditor.state;\n  }\n\n  /**\n   * Get the underlying prosemirror view\n   * @see https://prosemirror.net/docs/ref/#view.EditorView\n   */\n  public get prosemirrorView() {\n    return this.editor._tiptapEditor.view;\n  }\n\n  public isFocused() {\n    return this.prosemirrorView?.hasFocus() || false;\n  }\n\n  public focus() {\n    this.prosemirrorView?.focus();\n  }\n\n  /**\n   * Checks if the editor is currently editable, or if it's locked.\n   * @returns True if the editor is editable, false otherwise.\n   */\n  public get isEditable(): boolean {\n    if (!this.editor._tiptapEditor) {\n      if (!this.editor.headless) {\n        throw new Error(\"no editor, but also not headless?\");\n      }\n      return false;\n    }\n    return this.editor._tiptapEditor.isEditable === undefined\n      ? true\n      : this.editor._tiptapEditor.isEditable;\n  }\n\n  /**\n   * Makes the editor editable or locks it, depending on the argument passed.\n   * @param editable True to make the editor editable, or false to lock it.\n   */\n  public set isEditable(editable: boolean) {\n    if (!this.editor._tiptapEditor) {\n      if (!this.editor.headless) {\n        throw new Error(\"no editor, but also not headless?\");\n      }\n      // not relevant on headless\n      return;\n    }\n    if (this.editor._tiptapEditor.options.editable !== editable) {\n      this.editor._tiptapEditor.setEditable(editable);\n    }\n  }\n\n  /**\n   * Undo the last action.\n   */\n  public undo() {\n    return this.exec(this.options?.undo ?? undo);\n  }\n\n  /**\n   * Redo the last action.\n   */\n  public redo() {\n    return this.exec(this.options?.redo ?? redo);\n  }\n}\n","import { selectionToInsertionEnd } from \"@tiptap/core\";\nimport { Node } from \"prosemirror-model\";\n\nimport type { Transaction } from \"prosemirror-state\";\n\n// similar to tiptap insertContentAt\nexport function insertContentAt(\n  tr: Transaction,\n  position: number | { from: number; to: number },\n  nodes: Node[],\n  options: {\n    updateSelection: boolean;\n  } = { updateSelection: true },\n) {\n  // don’t dispatch an empty fragment because this can lead to strange errors\n  // if (content.toString() === \"<>\") {\n  //   return true;\n  // }\n\n  let { from, to } =\n    typeof position === \"number\"\n      ? { from: position, to: position }\n      : { from: position.from, to: position.to };\n\n  let isOnlyTextContent = true;\n  let isOnlyBlockContent = true;\n  // const nodes = isFragment(content) ? content : [content];\n\n  let text = \"\";\n\n  nodes.forEach((node) => {\n    // check if added node is valid\n    node.check();\n\n    if (isOnlyTextContent && node.isText && node.marks.length === 0) {\n      text += node.text;\n    } else {\n      isOnlyTextContent = false;\n    }\n\n    isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;\n  });\n\n  // check if we can replace the wrapping node by\n  // the newly inserted content\n  // example:\n  // replace an empty paragraph by an inserted image\n  // instead of inserting the image below the paragraph\n  if (from === to && isOnlyBlockContent) {\n    const { parent } = tr.doc.resolve(from);\n    const isEmptyTextBlock =\n      parent.isTextblock && !parent.type.spec.code && !parent.childCount;\n\n    if (isEmptyTextBlock) {\n      from -= 1;\n      to += 1;\n    }\n  }\n\n  // if there is only plain text we have to use `insertText`\n  // because this will keep the current marks\n  if (isOnlyTextContent) {\n    // if value is string, we can use it directly\n    // otherwise if it is an array, we have to join it\n    // if (Array.isArray(value)) {\n    //   tr.insertText(value.map((v) => v.text || \"\").join(\"\"), from, to);\n    // } else if (typeof value === \"object\" && !!value && !!value.text) {\n    //   tr.insertText(value.text, from, to);\n    // } else {\n    //   tr.insertText(value as string, from, to);\n    // }\n    tr.insertText(text, from, to);\n  } else {\n    tr.replaceWith(from, to, nodes);\n  }\n\n  // set cursor at end of inserted content\n  if (options.updateSelection) {\n    selectionToInsertionEnd(tr, tr.steps.length - 1, -1);\n  }\n\n  return true;\n}\n","import { insertContentAt } from \"../../api/blockManipulation/insertContentAt.js\";\nimport { inlineContentToNodes } from \"../../api/nodeConversions/blockToNode.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  PartialInlineContent,\n  StyleSchema,\n  Styles,\n} from \"../../schema/index.js\";\nimport {\n  DefaultBlockSchema,\n  DefaultInlineContentSchema,\n  DefaultStyleSchema,\n} from \"../../blocks/defaultBlocks.js\";\nimport { TextSelection } from \"@tiptap/pm/state\";\nimport { UnreachableCaseError } from \"../../util/typescript.js\";\nimport { BlockNoteEditor } from \"../BlockNoteEditor.js\";\n\nexport class StyleManager<\n  BSchema extends BlockSchema = DefaultBlockSchema,\n  ISchema extends InlineContentSchema = DefaultInlineContentSchema,\n  SSchema extends StyleSchema = DefaultStyleSchema,\n> {\n  constructor(private editor: BlockNoteEditor<BSchema, ISchema, SSchema>) {}\n\n  /**\n   * Insert a piece of content at the current cursor position.\n   *\n   * @param content can be a string, or array of partial inline content elements\n   */\n  public insertInlineContent(\n    content: PartialInlineContent<ISchema, SSchema>,\n    { updateSelection = false }: { updateSelection?: boolean } = {},\n  ) {\n    const nodes = inlineContentToNodes(content, this.editor.pmSchema);\n\n    this.editor.transact((tr) => {\n      insertContentAt(\n        tr,\n        {\n          from: tr.selection.from,\n          to: tr.selection.to,\n        },\n        nodes,\n        {\n          updateSelection,\n        },\n      );\n    });\n  }\n\n  /**\n   * Gets the active text styles at the text cursor position or at the end of the current selection if it's active.\n   */\n  public getActiveStyles() {\n    return this.editor.transact((tr) => {\n      const styles: Styles<SSchema> = {};\n      const marks = tr.selection.$to.marks();\n\n      for (const mark of marks) {\n        const config = this.editor.schema.styleSchema[mark.type.name];\n        if (!config) {\n          if (\n            // Links are not considered styles in blocknote\n            mark.type.name !== \"link\" &&\n            // \"blocknoteIgnore\" tagged marks (such as comments) are also not considered BlockNote \"styles\"\n            !mark.type.spec.blocknoteIgnore\n          ) {\n            // eslint-disable-next-line no-console\n            console.warn(\"mark not found in styleschema\", mark.type.name);\n          }\n\n          continue;\n        }\n        if (config.propSchema === \"boolean\") {\n          (styles as any)[config.type] = true;\n        } else {\n          (styles as any)[config.type] = mark.attrs.stringValue;\n        }\n      }\n\n      return styles;\n    });\n  }\n\n  /**\n   * Adds styles to the currently selected content.\n   * @param styles The styles to add.\n   */\n  public addStyles(styles: Styles<SSchema>) {\n    for (const [style, value] of Object.entries(styles)) {\n      const config = this.editor.schema.styleSchema[style];\n      if (!config) {\n        throw new Error(`style ${style} not found in styleSchema`);\n      }\n      if (config.propSchema === \"boolean\") {\n        this.editor._tiptapEditor.commands.setMark(style);\n      } else if (config.propSchema === \"string\") {\n        this.editor._tiptapEditor.commands.setMark(style, {\n          stringValue: value,\n        });\n      } else {\n        throw new UnreachableCaseError(config.propSchema);\n      }\n    }\n  }\n\n  /**\n   * Removes styles from the currently selected content.\n   * @param styles The styles to remove.\n   */\n  public removeStyles(styles: Styles<SSchema>) {\n    for (const style of Object.keys(styles)) {\n      this.editor._tiptapEditor.commands.unsetMark(style);\n    }\n  }\n\n  /**\n   * Toggles styles on the currently selected content.\n   * @param styles The styles to toggle.\n   */\n  public toggleStyles(styles: Styles<SSchema>) {\n    for (const [style, value] of Object.entries(styles)) {\n      const config = this.editor.schema.styleSchema[style];\n      if (!config) {\n        throw new Error(`style ${style} not found in styleSchema`);\n      }\n      if (config.propSchema === \"boolean\") {\n        this.editor._tiptapEditor.commands.toggleMark(style);\n      } else if (config.propSchema === \"string\") {\n        this.editor._tiptapEditor.commands.toggleMark(style, {\n          stringValue: value,\n        });\n      } else {\n        throw new UnreachableCaseError(config.propSchema);\n      }\n    }\n  }\n\n  /**\n   * Gets the currently selected text.\n   */\n  public getSelectedText() {\n    return this.editor.transact((tr) => {\n      return tr.doc.textBetween(tr.selection.from, tr.selection.to);\n    });\n  }\n\n  /**\n   * Gets the URL of the last link in the current selection, or `undefined` if there are no links in the selection.\n   */\n  public getSelectedLinkUrl() {\n    return this.editor._tiptapEditor.getAttributes(\"link\").href as\n      | string\n      | undefined;\n  }\n\n  /**\n   * Creates a new link to replace the selected content.\n   * @param url The link URL.\n   * @param text The text to display the link with.\n   */\n  public createLink(url: string, text?: string) {\n    if (url === \"\") {\n      return;\n    }\n    const mark = this.editor.pmSchema.mark(\"link\", { href: url });\n    this.editor.transact((tr) => {\n      const { from, to } = tr.selection;\n\n      if (text) {\n        tr.insertText(text, from, to).addMark(from, from + text.length, mark);\n      } else {\n        tr.setSelection(TextSelection.create(tr.doc, to)).addMark(\n          from,\n          to,\n          mark,\n        );\n      }\n    });\n  }\n}\n","import { Fragment, Schema, Slice } from \"@tiptap/pm/model\";\nimport { EditorView } from \"@tiptap/pm/view\";\n\nimport { getBlockInfoFromSelection } from \"../api/getBlockInfoFromPos.js\";\n\n// helper function to remove a child from a fragment\nfunction removeChild(node: Fragment, n: number) {\n  const children: any[] = [];\n  node.forEach((child, _, i) => {\n    if (i !== n) {\n      children.push(child);\n    }\n  });\n  return Fragment.from(children);\n}\n\n/**\n * Wrap adjacent tableRow items in a table.\n *\n * This makes sure the content that we paste is always a table (and not a tableRow)\n * A table works better for the remaing paste handling logic, as it's actually a blockContent node\n */\nexport function wrapTableRows(f: Fragment, schema: Schema) {\n  const newItems: any[] = [];\n  for (let i = 0; i < f.childCount; i++) {\n    if (f.child(i).type.name === \"tableRow\") {\n      if (\n        newItems.length > 0 &&\n        newItems[newItems.length - 1].type.name === \"table\"\n      ) {\n        // append to existing table\n        const prevTable = newItems[newItems.length - 1];\n        const newTable = prevTable.copy(prevTable.content.addToEnd(f.child(i)));\n        newItems[newItems.length - 1] = newTable;\n      } else {\n        // create new table to wrap tableRow with\n        const newTable = schema.nodes.table.createChecked(\n          undefined,\n          f.child(i),\n        );\n        newItems.push(newTable);\n      }\n    } else {\n      newItems.push(f.child(i));\n    }\n  }\n  f = Fragment.from(newItems);\n  return f;\n}\n\n/**\n * fix for https://github.com/ProseMirror/prosemirror/issues/1430#issuecomment-1822570821\n *\n * This fix wraps pasted ProseMirror nodes in their own `blockContainer` nodes\n * in most cases. This is to ensure that ProseMirror inserts them as separate\n * blocks, which it sometimes doesn't do because it doesn't have enough context\n * about the hierarchy of the pasted nodes. The issue can be seen when pasting\n * e.g. an image or two consecutive paragraphs, where PM tries to nest the\n * pasted block(s) when it shouldn't.\n *\n * However, the fix is not applied in a few cases. See `shouldApplyFix` for\n * which cases are excluded.\n */\nexport function transformPasted(slice: Slice, view: EditorView) {\n  let f = Fragment.from(slice.content);\n  f = wrapTableRows(f, view.state.schema);\n\n  if (!shouldApplyFix(f, view)) {\n    // Don't apply the fix.\n    return new Slice(f, slice.openStart, slice.openEnd);\n  }\n\n  for (let i = 0; i < f.childCount; i++) {\n    if (f.child(i).type.spec.group === \"blockContent\") {\n      const content = [f.child(i)];\n\n      // when there is a blockGroup with lists, it should be nested in the new blockcontainer\n      // (if we remove this if-block, the nesting bug will be fixed, but lists won't be nested correctly)\n      if (\n        i + 1 < f.childCount &&\n        f.child(i + 1).type.name === \"blockGroup\" // TODO\n      ) {\n        const nestedChild = f\n          .child(i + 1)\n          .child(0)\n          .child(0);\n\n        if (\n          nestedChild.type.name === \"bulletListItem\" ||\n          nestedChild.type.name === \"numberedListItem\" ||\n          nestedChild.type.name === \"checkListItem\"\n        ) {\n          content.push(f.child(i + 1));\n          f = removeChild(f, i + 1);\n        }\n      }\n      const container = view.state.schema.nodes.blockContainer.createChecked(\n        undefined,\n        content,\n      );\n      f = f.replaceChild(i, container);\n    }\n  }\n  return new Slice(f, slice.openStart, slice.openEnd);\n}\n\n/**\n * Used in `transformPasted` to check if the fix there should be applied, i.e.\n * if the pasted fragment should be wrapped in a `blockContainer` node. This\n * will explicitly tell ProseMirror to treat it as a separate block.\n */\nfunction shouldApplyFix(fragment: Fragment, view: EditorView) {\n  const nodeHasSingleChild = fragment.childCount === 1;\n  const nodeHasInlineContent =\n    fragment.firstChild?.type.spec.content === \"inline*\";\n  const nodeHasTableContent =\n    fragment.firstChild?.type.spec.content === \"tableRow+\";\n\n  if (nodeHasSingleChild) {\n    if (nodeHasInlineContent) {\n      // Case when we paste a single node with inline content, e.g. a paragraph\n      // or heading. We want to insert the content in-line for better UX instead\n      // of a separate block, so we return false.\n      return false;\n    }\n\n    if (nodeHasTableContent) {\n      // Not ideal that we check selection here, as `transformPasted` is called\n      // for both paste and drop events. Drop events can potentially cause\n      // issues as they don't always happen at the current selection.\n      const blockInfo = getBlockInfoFromSelection(view.state);\n      if (blockInfo.isBlockContainer) {\n        const selectedBlockHasTableContent =\n          blockInfo.blockContent.node.type.spec.content === \"tableRow+\";\n\n        // Case for when we paste a single node with table content, i.e. a\n        // table. Normally, we return true as we want to ensure the table is\n        // inserted as a separate block. However, if the selection is in an\n        // existing table, we return false, as we want the content of the pasted\n        // table to be added to the existing one for better UX.\n        return !selectedBlockHasTableContent;\n      }\n    }\n  }\n\n  return true;\n}\n","import {\n  AnyExtension,\n  createDocument,\n  EditorOptions,\n  Extension,\n  FocusPosition,\n  getSchema,\n  InputRule,\n  Mark,\n  Editor as TiptapEditor,\n  Node as TipTapNode,\n} from \"@tiptap/core\";\nimport { type Command, type Plugin, type Transaction } from \"@tiptap/pm/state\";\nimport { dropCursor } from \"prosemirror-dropcursor\";\nimport { Node, Schema } from \"prosemirror-model\";\nimport * as Y from \"yjs\";\n\nimport type { BlocksChanged } from \"../api/getBlocksChangedByTransaction.js\";\nimport { editorHasBlockWithType } from \"../blocks/defaultBlockTypeGuards.js\";\nimport {\n  Block,\n  BlockNoteSchema,\n  DefaultBlockSchema,\n  DefaultInlineContentSchema,\n  DefaultStyleSchema,\n  PartialBlock,\n} from \"../blocks/index.js\";\nimport type { ThreadStore, User } from \"../comments/index.js\";\nimport type { CommentsPlugin } from \"../extensions/Comments/CommentsPlugin.js\";\nimport type { FilePanelProsemirrorPlugin } from \"../extensions/FilePanel/FilePanelPlugin.js\";\nimport type { FormattingToolbarProsemirrorPlugin } from \"../extensions/FormattingToolbar/FormattingToolbarPlugin.js\";\nimport type { LinkToolbarProsemirrorPlugin } from \"../extensions/LinkToolbar/LinkToolbarPlugin.js\";\nimport type { ShowSelectionPlugin } from \"../extensions/ShowSelection/ShowSelectionPlugin.js\";\nimport type { SideMenuProsemirrorPlugin } from \"../extensions/SideMenu/SideMenuPlugin.js\";\nimport type { SuggestionMenuProseMirrorPlugin } from \"../extensions/SuggestionMenu/SuggestionPlugin.js\";\nimport type { TableHandlesProsemirrorPlugin } from \"../extensions/TableHandles/TableHandlesPlugin.js\";\nimport { UniqueID } from \"../extensions/UniqueID/UniqueID.js\";\nimport type { Dictionary } from \"../i18n/dictionary.js\";\nimport { en } from \"../i18n/locales/index.js\";\nimport type {\n  BlockIdentifier,\n  BlockNoteDOMAttributes,\n  BlockSchema,\n  BlockSpecs,\n  CustomBlockNoteSchema,\n  InlineContentSchema,\n  InlineContentSpecs,\n  PartialInlineContent,\n  Styles,\n  StyleSchema,\n  StyleSpecs,\n} from \"../schema/index.js\";\nimport { mergeCSSClasses } from \"../util/browser.js\";\nimport { EventEmitter } from \"../util/EventEmitter.js\";\nimport type { NoInfer } from \"../util/typescript.js\";\nimport { BlockNoteExtension } from \"./BlockNoteExtension.js\";\nimport { getBlockNoteExtensions } from \"./BlockNoteExtensions.js\";\nimport type { TextCursorPosition } from \"./cursorPositionTypes.js\";\nimport {\n  BlockManager,\n  CollaborationManager,\n  type CollaborationOptions,\n  EventManager,\n  ExportManager,\n  ExtensionManager,\n  SelectionManager,\n  StateManager,\n  StyleManager,\n} from \"./managers/index.js\";\nimport type { Selection } from \"./selectionTypes.js\";\nimport { transformPasted } from \"./transformPasted.js\";\n\nimport { updateBlockTr } from \"../api/blockManipulation/commands/updateBlock/updateBlock.js\";\nimport { getBlockInfoFromTransaction } from \"../api/getBlockInfoFromPos.js\";\nimport { blockToNode } from \"../api/nodeConversions/blockToNode.js\";\nimport \"../style.css\";\n\n/**\n * A factory function that returns a BlockNoteExtension\n * This is useful so we can create extensions that require an editor instance\n * in the constructor\n */\nexport type BlockNoteExtensionFactory = (\n  editor: BlockNoteEditor<any, any, any>,\n) => BlockNoteExtension;\n\n/**\n * We support Tiptap extensions and BlockNoteExtension based extensions\n */\nexport type SupportedExtension = AnyExtension | BlockNoteExtension;\n\nexport type BlockCache<\n  BSchema extends BlockSchema = any,\n  ISchema extends InlineContentSchema = any,\n  SSchema extends StyleSchema = any,\n> = WeakMap<Node, Block<BSchema, ISchema, SSchema>>;\n\nexport type BlockNoteEditorOptions<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema,\n> = {\n  /**\n   * Whether changes to blocks (like indentation, creating lists, changing headings) should be animated or not. Defaults to `true`.\n   *\n   * @default true\n   */\n  animations?: boolean;\n\n  /**\n   * Whether the editor should be focused automatically when it's created.\n   *\n   * @default false\n   */\n  autofocus?: FocusPosition;\n\n  /**\n   * When enabled, allows for collaboration between multiple users.\n   * See [Real-time Collaboration](https://www.blocknotejs.org/docs/advanced/real-time-collaboration) for more info.\n   *\n   * @remarks `CollaborationOptions`\n   */\n  collaboration?: {\n    /**\n     * The Yjs XML fragment that's used for collaboration.\n     */\n    fragment: Y.XmlFragment;\n    /**\n     * The user info for the current user that's shown to other collaborators.\n     */\n    user: {\n      name: string;\n      color: string;\n    };\n    /**\n     * A Yjs provider (used for awareness / cursor information)\n     */\n    provider: any;\n    /**\n     * Optional function to customize how cursors of users are rendered\n     */\n    renderCursor?: (user: any) => HTMLElement;\n    /**\n     * Optional flag to set when the user label should be shown with the default\n     * collaboration cursor. Setting to \"always\" will always show the label,\n     * while \"activity\" will only show the label when the user moves the cursor\n     * or types. Defaults to \"activity\".\n     */\n    showCursorLabels?: \"always\" | \"activity\";\n  };\n\n  /**\n   * Configuration for the comments feature, requires a `threadStore`.\n   *\n   * See [Comments](https://www.blocknotejs.org/docs/features/collaboration/comments) for more info.\n   * @remarks `CommentsOptions`\n   */\n  comments?: {\n    schema?: BlockNoteSchema<any, any, any>;\n    threadStore: ThreadStore;\n  };\n\n  /**\n   * Use default BlockNote font and reset the styles of <p> <li> <h1> elements etc., that are used in BlockNote.\n   *\n   * @default true\n   */\n  defaultStyles?: boolean;\n\n  /**\n   * A dictionary object containing translations for the editor.\n   *\n   * See [Localization / i18n](https://www.blocknotejs.org/docs/advanced/localization) for more info.\n   *\n   * @remarks `Dictionary` is a type that contains all the translations for the editor.\n   */\n  dictionary?: Dictionary & Record<string, any>;\n\n  /**\n   * Disable internal extensions (based on keys / extension name)\n   *\n   * @note Advanced\n   */\n  disableExtensions?: string[];\n\n  /**\n   * An object containing attributes that should be added to HTML elements of the editor.\n   *\n   * See [Adding DOM Attributes](https://www.blocknotejs.org/docs/theming#adding-dom-attributes) for more info.\n   *\n   * @example { editor: { class: \"my-editor-class\" } }\n   * @remarks `Record<string, Record<string, string>>`\n   */\n  domAttributes?: Partial<BlockNoteDOMAttributes>;\n\n  /**\n   * A replacement indicator to use when dragging and dropping blocks. Uses the [ProseMirror drop cursor](https://github.com/ProseMirror/prosemirror-dropcursor), or a modified version when [Column Blocks](https://www.blocknotejs.org/docs/document-structure#column-blocks) are enabled.\n   * @remarks `() => Plugin`\n   */\n  dropCursor?: (opts: {\n    editor: BlockNoteEditor<\n      NoInfer<BSchema>,\n      NoInfer<ISchema>,\n      NoInfer<SSchema>\n    >;\n    color?: string | false;\n    width?: number;\n    class?: string;\n  }) => Plugin;\n\n  /**\n   * The content that should be in the editor when it's created, represented as an array of {@link PartialBlock} objects.\n   *\n   * See [Partial Blocks](https://www.blocknotejs.org/docs/editor-api/manipulating-blocks#partial-blocks) for more info.\n   *\n   * @remarks `PartialBlock[]`\n   */\n  initialContent?: PartialBlock<\n    NoInfer<BSchema>,\n    NoInfer<ISchema>,\n    NoInfer<SSchema>\n  >[];\n\n  /**\n   * @deprecated, provide placeholders via dictionary instead\n   * @internal\n   */\n  placeholders?: Record<\n    string | \"default\" | \"emptyDocument\",\n    string | undefined\n  >;\n\n  /**\n   * Custom paste handler that can be used to override the default paste behavior.\n   *\n   * See [Paste Handling](https://www.blocknotejs.org/docs/advanced/paste-handling) for more info.\n   *\n   * @remarks `PasteHandler`\n   * @returns The function should return `true` if the paste event was handled, otherwise it should return `false` if it should be canceled or `undefined` if it should be handled by another handler.\n   *\n   * @example\n   * ```ts\n   * pasteHandler: ({ defaultPasteHandler }) => {\n   *   return defaultPasteHandler({ pasteBehavior: \"prefer-html\" });\n   * }\n   * ```\n   */\n  pasteHandler?: (context: {\n    event: ClipboardEvent;\n    editor: BlockNoteEditor<\n      NoInfer<BSchema>,\n      NoInfer<ISchema>,\n      NoInfer<SSchema>\n    >;\n    /**\n     * The default paste handler\n     * @param context The context object\n     * @returns Whether the paste event was handled or not\n     */\n    defaultPasteHandler: (context?: {\n      /**\n       * Whether to prioritize Markdown content in `text/plain` over `text/html` when pasting from the clipboard.\n       * @default true\n       */\n      prioritizeMarkdownOverHTML?: boolean;\n      /**\n       * Whether to parse `text/plain` content from the clipboard as Markdown content.\n       * @default true\n       */\n      plainTextAsMarkdown?: boolean;\n    }) => boolean | undefined;\n  }) => boolean | undefined;\n\n  /**\n   * Resolve a URL of a file block to one that can be displayed or downloaded. This can be used for creating authenticated URL or\n   * implementing custom protocols / schemes\n   * @returns The URL that's\n   */\n  resolveFileUrl?: (url: string) => Promise<string>;\n\n  /**\n   * Resolve user information for comments.\n   *\n   * See [Comments](https://www.blocknotejs.org/docs/features/collaboration/comments) for more info.\n   */\n  resolveUsers?: (userIds: string[]) => Promise<User[]>;\n\n  /**\n   * The schema of the editor. The schema defines which Blocks, InlineContent, and Styles are available in the editor.\n   *\n   * See [Custom Schemas](https://www.blocknotejs.org/docs/custom-schemas) for more info.\n   * @remarks `BlockNoteSchema`\n   */\n  schema: CustomBlockNoteSchema<BSchema, ISchema, SSchema>;\n\n  /**\n   * A flag indicating whether to set an HTML ID for every block\n   *\n   * When set to `true`, on each block an id attribute will be set with the block id\n   * Otherwise, the HTML ID attribute will not be set.\n   *\n   * (note that the id is always set on the `data-id` attribute)\n   */\n  setIdAttribute?: boolean;\n\n  /**\n   * Determines behavior when pressing Tab (or Shift-Tab) while multiple blocks are selected and a toolbar is open.\n   * - `\"prefer-navigate-ui\"`: Changes focus to the toolbar. User must press Escape to close toolbar before indenting blocks. Better for keyboard accessibility.\n   * - `\"prefer-indent\"`: Always indents selected blocks, regardless of toolbar state. Keyboard navigation of toolbars not possible.\n   * @default \"prefer-navigate-ui\"\n   */\n  tabBehavior?: \"prefer-navigate-ui\" | \"prefer-indent\";\n\n  /**\n   * Allows enabling / disabling features of tables.\n   *\n   * See [Tables](https://www.blocknotejs.org/docs/editor-basics/document-structure#tables) for more info.\n   *\n   * @remarks `TableConfig`\n   */\n  tables?: {\n    /**\n     * Whether to allow splitting and merging cells within a table.\n     *\n     * @default false\n     */\n    splitCells?: boolean;\n    /**\n     * Whether to allow changing the background color of cells.\n     *\n     * @default false\n     */\n    cellBackgroundColor?: boolean;\n    /**\n     * Whether to allow changing the text color of cells.\n     *\n     * @default false\n     */\n    cellTextColor?: boolean;\n    /**\n     * Whether to allow changing cells into headers.\n     *\n     * @default false\n     */\n    headers?: boolean;\n  };\n\n  /**\n   * An option which user can pass with `false` value to disable the automatic creation of a trailing new block on the next line when the user types or edits any block.\n   *\n   * @default true\n   */\n  trailingBlock?: boolean;\n\n  /**\n   * The `uploadFile` method is what the editor uses when files need to be uploaded (for example when selecting an image to upload).\n   * This method should set when creating the editor as this is application-specific.\n   *\n   * `undefined` means the application doesn't support file uploads.\n   *\n   * @param file The file that should be uploaded.\n   * @returns The URL of the uploaded file OR an object containing props that should be set on the file block (such as an id)\n   * @remarks `(file: File) => Promise<UploadFileResult>`\n   */\n  uploadFile?: (\n    file: File,\n    blockId?: string,\n  ) => Promise<string | Record<string, any>>;\n\n  /**\n   * additional tiptap options, undocumented\n   * @internal\n   */\n  _tiptapOptions?: Partial<EditorOptions>;\n\n  /**\n   * (experimental) add extra extensions to the editor\n   *\n   * @deprecated, should use `extensions` instead\n   * @internal\n   */\n  _extensions?: Record<\n    string,\n    | { plugin: Plugin; priority?: number }\n    | ((editor: BlockNoteEditor<any, any, any>) => {\n        plugin: Plugin;\n        priority?: number;\n      })\n  >;\n\n  /**\n   * Register extensions to the editor.\n   *\n   * See [Extensions](/docs/features/extensions) for more info.\n   *\n   * @remarks `BlockNoteExtension[]`\n   */\n  extensions?: Array<BlockNoteExtension | BlockNoteExtensionFactory>;\n};\n\nconst blockNoteTipTapOptions = {\n  enableInputRules: true,\n  enablePasteRules: true,\n  enableCoreExtensions: false,\n};\n\nexport class BlockNoteEditor<\n  BSchema extends BlockSchema = DefaultBlockSchema,\n  ISchema extends InlineContentSchema = DefaultInlineContentSchema,\n  SSchema extends StyleSchema = DefaultStyleSchema,\n> extends EventEmitter<{\n  create: void;\n}> {\n  /**\n   * The underlying prosemirror schema\n   */\n  public readonly pmSchema: Schema;\n\n  /**\n   * extensions that are added to the editor, can be tiptap extensions or prosemirror plugins\n   */\n  public extensions: Record<string, SupportedExtension> = {};\n\n  public readonly _tiptapEditor: TiptapEditor & {\n    contentComponent: any;\n  };\n\n  /**\n   * Used by React to store a reference to an `ElementRenderer` helper utility to make sure we can render React elements\n   * in the correct context (used by `ReactRenderUtil`)\n   */\n  public elementRenderer: ((node: any, container: HTMLElement) => void) | null =\n    null;\n\n  /**\n   * Cache of all blocks. This makes sure we don't have to \"recompute\" blocks if underlying Prosemirror Nodes haven't changed.\n   * This is especially useful when we want to keep track of the same block across multiple operations,\n   * with this cache, blocks stay the same object reference (referential equality with ===).\n   */\n  public blockCache: BlockCache = new WeakMap();\n\n  /**\n   * The dictionary contains translations for the editor.\n   */\n  public readonly dictionary: Dictionary & Record<string, any>;\n\n  /**\n   * The schema of the editor. The schema defines which Blocks, InlineContent, and Styles are available in the editor.\n   */\n  public readonly schema: BlockNoteSchema<BSchema, ISchema, SSchema>;\n\n  public readonly blockImplementations: BlockSpecs;\n  public readonly inlineContentImplementations: InlineContentSpecs;\n  public readonly styleImplementations: StyleSpecs;\n\n  public get formattingToolbar(): FormattingToolbarProsemirrorPlugin {\n    return this._extensionManager.formattingToolbar;\n  }\n\n  public get linkToolbar(): LinkToolbarProsemirrorPlugin<\n    BSchema,\n    ISchema,\n    SSchema\n  > {\n    return this._extensionManager.linkToolbar;\n  }\n\n  public get sideMenu(): SideMenuProsemirrorPlugin<BSchema, ISchema, SSchema> {\n    return this._extensionManager.sideMenu;\n  }\n\n  public get suggestionMenus(): SuggestionMenuProseMirrorPlugin<\n    BSchema,\n    ISchema,\n    SSchema\n  > {\n    return this._extensionManager.suggestionMenus;\n  }\n\n  public get filePanel():\n    | FilePanelProsemirrorPlugin<ISchema, SSchema>\n    | undefined {\n    return this._extensionManager.filePanel;\n  }\n\n  public get tableHandles():\n    | TableHandlesProsemirrorPlugin<ISchema, SSchema>\n    | undefined {\n    return this._extensionManager.tableHandles;\n  }\n\n  public get comments(): CommentsPlugin | undefined {\n    return this._collaborationManager?.comments;\n  }\n\n  public get showSelectionPlugin(): ShowSelectionPlugin {\n    return this._extensionManager.showSelectionPlugin;\n  }\n\n  /**\n   * The plugin for forking a document, only defined if in collaboration mode\n   */\n  public get forkYDocPlugin() {\n    return this._collaborationManager?.forkYDocPlugin;\n  }\n  /**\n   * The `uploadFile` method is what the editor uses when files need to be uploaded (for example when selecting an image to upload).\n   * This method should set when creating the editor as this is application-specific.\n   *\n   * `undefined` means the application doesn't support file uploads.\n   *\n   * @param file The file that should be uploaded.\n   * @returns The URL of the uploaded file OR an object containing props that should be set on the file block (such as an id)\n   */\n  public readonly uploadFile:\n    | ((file: File, blockId?: string) => Promise<string | Record<string, any>>)\n    | undefined;\n\n  private onUploadStartCallbacks: ((blockId?: string) => void)[] = [];\n  private onUploadEndCallbacks: ((blockId?: string) => void)[] = [];\n\n  public readonly resolveFileUrl?: (url: string) => Promise<string>;\n  public readonly resolveUsers?: (userIds: string[]) => Promise<User[]>;\n  /**\n   * Editor settings\n   */\n  public readonly settings: {\n    tables: {\n      splitCells: boolean;\n      cellBackgroundColor: boolean;\n      cellTextColor: boolean;\n      headers: boolean;\n    };\n  };\n  public static create<\n    Options extends Partial<BlockNoteEditorOptions<any, any, any>> | undefined,\n  >(\n    options?: Options,\n  ): Options extends {\n    schema: CustomBlockNoteSchema<infer BSchema, infer ISchema, infer SSchema>;\n  }\n    ? BlockNoteEditor<BSchema, ISchema, SSchema>\n    : BlockNoteEditor<\n        DefaultBlockSchema,\n        DefaultInlineContentSchema,\n        DefaultStyleSchema\n      > {\n    return new BlockNoteEditor(options ?? {}) as any;\n  }\n\n  protected constructor(\n    protected readonly options: Partial<\n      BlockNoteEditorOptions<BSchema, ISchema, SSchema>\n    >,\n  ) {\n    super();\n    const anyOpts = options as any;\n    if (anyOpts.onEditorContentChange) {\n      throw new Error(\n        \"onEditorContentChange initialization option is deprecated, use <BlockNoteView onChange={...} />, the useEditorChange(...) hook, or editor.onChange(...)\",\n      );\n    }\n\n    if (anyOpts.onTextCursorPositionChange) {\n      throw new Error(\n        \"onTextCursorPositionChange initialization option is deprecated, use <BlockNoteView onSelectionChange={...} />, the useEditorSelectionChange(...) hook, or editor.onSelectionChange(...)\",\n      );\n    }\n\n    if (anyOpts.onEditorReady) {\n      throw new Error(\n        \"onEditorReady is deprecated. Editor is immediately ready for use after creation.\",\n      );\n    }\n\n    if (anyOpts.editable) {\n      throw new Error(\n        \"editable initialization option is deprecated, use <BlockNoteView editable={true/false} />, or alternatively editor.isEditable = true/false\",\n      );\n    }\n\n    this.dictionary = options.dictionary || en;\n    this.settings = {\n      tables: {\n        splitCells: options?.tables?.splitCells ?? false,\n        cellBackgroundColor: options?.tables?.cellBackgroundColor ?? false,\n        cellTextColor: options?.tables?.cellTextColor ?? false,\n        headers: options?.tables?.headers ?? false,\n      },\n    };\n\n    // apply defaults\n    const newOptions = {\n      defaultStyles: true,\n      schema:\n        options.schema ||\n        (BlockNoteSchema.create() as unknown as CustomBlockNoteSchema<\n          BSchema,\n          ISchema,\n          SSchema\n        >),\n      ...options,\n      placeholders: {\n        ...this.dictionary.placeholders,\n        ...options.placeholders,\n      },\n    };\n\n    // Initialize CollaborationManager if collaboration is enabled or if comments are configured\n    if (newOptions.collaboration || newOptions.comments) {\n      const collaborationOptions: CollaborationOptions = {\n        // Use collaboration options if available, otherwise provide defaults\n        fragment: newOptions.collaboration?.fragment || new Y.XmlFragment(),\n        user: newOptions.collaboration?.user || {\n          name: \"User\",\n          color: \"#FF0000\",\n        },\n        provider: newOptions.collaboration?.provider || null,\n        renderCursor: newOptions.collaboration?.renderCursor,\n        showCursorLabels: newOptions.collaboration?.showCursorLabels,\n        comments: newOptions.comments,\n        resolveUsers: newOptions.resolveUsers,\n      };\n      this._collaborationManager = new CollaborationManager(\n        this as any,\n        collaborationOptions,\n      );\n    } else {\n      this._collaborationManager = undefined;\n    }\n\n    if (newOptions.comments && !newOptions.resolveUsers) {\n      throw new Error(\"resolveUsers is required when using comments\");\n    }\n\n    // @ts-ignore\n    this.schema = newOptions.schema;\n    this.blockImplementations = newOptions.schema.blockSpecs;\n    this.inlineContentImplementations = newOptions.schema.inlineContentSpecs;\n    this.styleImplementations = newOptions.schema.styleSpecs;\n\n    this.extensions = {\n      ...getBlockNoteExtensions({\n        editor: this,\n        domAttributes: newOptions.domAttributes || {},\n        blockSpecs: this.schema.blockSpecs,\n        styleSpecs: this.schema.styleSpecs,\n        inlineContentSpecs: this.schema.inlineContentSpecs,\n        collaboration: newOptions.collaboration,\n        trailingBlock: newOptions.trailingBlock,\n        disableExtensions: newOptions.disableExtensions,\n        setIdAttribute: newOptions.setIdAttribute,\n        animations: newOptions.animations ?? true,\n        tableHandles: editorHasBlockWithType(this, \"table\"),\n        dropCursor: this.options.dropCursor ?? dropCursor,\n        placeholders: newOptions.placeholders,\n        tabBehavior: newOptions.tabBehavior,\n        pasteHandler: newOptions.pasteHandler,\n      }),\n      ...this._collaborationManager?.initExtensions(),\n    } as any;\n\n    // add extensions from _tiptapOptions\n    (newOptions._tiptapOptions?.extensions || []).forEach((ext) => {\n      this.extensions[ext.name] = ext;\n    });\n\n    // add extensions from options\n    for (let ext of newOptions.extensions || []) {\n      if (typeof ext === \"function\") {\n        // factory\n        ext = ext(this);\n      }\n      const key = (ext as any).key ?? (ext.constructor as any).key();\n      if (!key) {\n        throw new Error(\n          `Extension ${ext.constructor.name} does not have a key method`,\n        );\n      }\n      if (this.extensions[key]) {\n        throw new Error(\n          `Extension ${ext.constructor.name} already exists with key ${key}`,\n        );\n      }\n      this.extensions[key] = ext;\n    }\n\n    // (when passed in via the deprecated `_extensions` option)\n    Object.entries(newOptions._extensions || {}).forEach(([key, ext]) => {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const editor = this;\n\n      const instance = typeof ext === \"function\" ? ext(editor) : ext;\n      if (!(\"plugin\" in instance)) {\n        // Assume it is an Extension/Mark/Node\n        this.extensions[key] = instance;\n        return;\n      }\n\n      this.extensions[key] = new (class extends BlockNoteExtension {\n        public static key() {\n          return key;\n        }\n        constructor() {\n          super();\n          this.addProsemirrorPlugin(instance.plugin);\n        }\n        public get priority() {\n          return instance.priority;\n        }\n      })();\n    });\n\n    if (newOptions.uploadFile) {\n      const uploadFile = newOptions.uploadFile;\n      this.uploadFile = async (file, blockId) => {\n        this.onUploadStartCallbacks.forEach((callback) =>\n          callback.apply(this, [blockId]),\n        );\n        try {\n          return await uploadFile(file, blockId);\n        } finally {\n          this.onUploadEndCallbacks.forEach((callback) =>\n            callback.apply(this, [blockId]),\n          );\n        }\n      };\n    }\n\n    this.resolveFileUrl = newOptions.resolveFileUrl;\n\n    const collaborationEnabled =\n      \"ySyncPlugin\" in this.extensions ||\n      \"liveblocksExtension\" in this.extensions;\n\n    if (collaborationEnabled && newOptions.initialContent) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        \"When using Collaboration, initialContent might cause conflicts, because changes should come from the collaboration provider\",\n      );\n    }\n\n    const blockExtensions = Object.fromEntries(\n      Object.values(this.schema.blockSpecs)\n        .map((block) => (block as any).extensions as any)\n        .filter((ext) => ext !== undefined)\n        .flat()\n        .map((ext) => [ext.key ?? ext.constructor.key(), ext]),\n    );\n    const tiptapExtensions = [\n      ...Object.entries({ ...this.extensions, ...blockExtensions }).map(\n        ([key, ext]) => {\n          if (\n            ext instanceof Extension ||\n            ext instanceof TipTapNode ||\n            ext instanceof Mark\n          ) {\n            // tiptap extension\n            return ext;\n          }\n\n          if (ext instanceof BlockNoteExtension) {\n            if (\n              !ext.plugins.length &&\n              !ext.keyboardShortcuts &&\n              !ext.inputRules &&\n              !ext.tiptapExtensions\n            ) {\n              return undefined;\n            }\n            // \"blocknote\" extensions (prosemirror plugins)\n            return Extension.create({\n              name: key,\n              priority: ext.priority,\n              addProseMirrorPlugins: () => ext.plugins,\n              addExtensions: () => ext.tiptapExtensions || [],\n              // TODO maybe collect all input rules from all extensions into one plugin\n              // TODO consider using the prosemirror-inputrules package instead\n              addInputRules: ext.inputRules\n                ? () =>\n                    ext.inputRules!.map(\n                      (inputRule) =>\n                        new InputRule({\n                          find: inputRule.find,\n                          handler: ({ range, match, state }) => {\n                            const replaceWith = inputRule.replace({\n                              match,\n                              range,\n                              editor: this,\n                            });\n                            if (replaceWith) {\n                              const cursorPosition =\n                                this.getTextCursorPosition();\n\n                              if (\n                                this.schema.blockSchema[\n                                  cursorPosition.block.type\n                                ].content !== \"inline\"\n                              ) {\n                                return undefined;\n                              }\n\n                              const blockInfo = getBlockInfoFromTransaction(\n                                state.tr,\n                              );\n                              const tr = state.tr.deleteRange(\n                                range.from,\n                                range.to,\n                              );\n\n                              updateBlockTr(\n                                tr,\n                                blockInfo.bnBlock.beforePos,\n                                replaceWith,\n                              );\n                              return undefined;\n                            }\n                            return null;\n                          },\n                        }),\n                    )\n                : undefined,\n              addKeyboardShortcuts: ext.keyboardShortcuts\n                ? () => {\n                    return Object.fromEntries(\n                      Object.entries(ext.keyboardShortcuts!).map(\n                        ([key, value]) => [\n                          key,\n                          () => value({ editor: this as any }),\n                        ],\n                      ),\n                    );\n                  }\n                : undefined,\n            });\n          }\n\n          return undefined;\n        },\n      ),\n    ].filter((ext): ext is Extension => ext !== undefined);\n    const tiptapOptions: EditorOptions = {\n      ...blockNoteTipTapOptions,\n      ...newOptions._tiptapOptions,\n      element: null,\n      autofocus: newOptions.autofocus ?? false,\n      extensions: tiptapExtensions,\n      editorProps: {\n        ...newOptions._tiptapOptions?.editorProps,\n        attributes: {\n          // As of TipTap v2.5.0 the tabIndex is removed when the editor is not\n          // editable, so you can't focus it. We want to revert this as we have\n          // UI behaviour that relies on it.\n          tabIndex: \"0\",\n          ...newOptions._tiptapOptions?.editorProps?.attributes,\n          ...newOptions.domAttributes?.editor,\n          class: mergeCSSClasses(\n            \"bn-editor\",\n            newOptions.defaultStyles ? \"bn-default-styles\" : \"\",\n            newOptions.domAttributes?.editor?.class || \"\",\n          ),\n        },\n        transformPasted,\n      },\n    } as any;\n\n    try {\n      const initialContent =\n        newOptions.initialContent ||\n        (collaborationEnabled\n          ? [\n              {\n                type: \"paragraph\",\n                id: \"initialBlockId\",\n              },\n            ]\n          : [\n              {\n                type: \"paragraph\",\n                id: UniqueID.options.generateID(),\n              },\n            ]);\n\n      if (!Array.isArray(initialContent) || initialContent.length === 0) {\n        throw new Error(\n          \"initialContent must be a non-empty array of blocks, received: \" +\n            initialContent,\n        );\n      }\n      const schema = getSchema(tiptapOptions.extensions!);\n      const pmNodes = initialContent.map((b) =>\n        blockToNode(b, schema, this.schema.styleSchema).toJSON(),\n      );\n      const doc = createDocument(\n        {\n          type: \"doc\",\n          content: [\n            {\n              type: \"blockGroup\",\n              content: pmNodes,\n            },\n          ],\n        },\n        schema,\n        tiptapOptions.parseOptions,\n      );\n\n      this._tiptapEditor = new TiptapEditor({\n        ...tiptapOptions,\n        content: doc.toJSON(),\n      }) as any;\n      this.pmSchema = this._tiptapEditor.schema;\n    } catch (e) {\n      throw new Error(\n        \"Error creating document from blocks passed as `initialContent`\",\n        { cause: e },\n      );\n    }\n\n    this.pmSchema.cached.blockNoteEditor = this;\n\n    // Initialize managers\n    this._blockManager = new BlockManager(this as any);\n\n    this._eventManager = new EventManager(this as any);\n    this._exportManager = new ExportManager(this as any);\n    this._extensionManager = new ExtensionManager(this as any);\n    this._selectionManager = new SelectionManager(this as any);\n    this._stateManager = new StateManager(\n      this as any,\n      collaborationEnabled\n        ? {\n            undo: this._collaborationManager?.getUndoCommand(),\n            redo: this._collaborationManager?.getRedoCommand(),\n          }\n        : undefined,\n    );\n    this._styleManager = new StyleManager(this as any);\n\n    this.emit(\"create\");\n  }\n\n  // Manager instances\n  private readonly _blockManager: BlockManager<any, any, any>;\n  private readonly _collaborationManager?: CollaborationManager;\n  private readonly _eventManager: EventManager<any>;\n  private readonly _exportManager: ExportManager<any, any, any>;\n  private readonly _extensionManager: ExtensionManager;\n  private readonly _selectionManager: SelectionManager<any, any, any>;\n  private readonly _stateManager: StateManager;\n  private readonly _styleManager: StyleManager<any, any, any>;\n\n  /**\n   * Execute a prosemirror command. This is mostly for backwards compatibility with older code.\n   *\n   * @note You should prefer the {@link transact} method when possible, as it will automatically handle the dispatching of the transaction and work across blocknote transactions.\n   *\n   * @example\n   * ```ts\n   * editor.exec((state, dispatch, view) => {\n   *   dispatch(state.tr.insertText(\"Hello, world!\"));\n   * });\n   * ```\n   */\n  public exec(command: Command) {\n    return this._stateManager.exec(command);\n  }\n\n  /**\n   * Check if a command can be executed. A command should return `false` if it is not valid in the current state.\n   *\n   * @example\n   * ```ts\n   * if (editor.canExec(command)) {\n   *   // show button\n   * } else {\n   *   // hide button\n   * }\n   * ```\n   */\n  public canExec(command: Command): boolean {\n    return this._stateManager.canExec(command);\n  }\n\n  /**\n   * Execute a function within a \"blocknote transaction\".\n   * All changes to the editor within the transaction will be grouped together, so that\n   * we can dispatch them as a single operation (thus creating only a single undo step)\n   *\n   * @note There is no need to dispatch the transaction, as it will be automatically dispatched when the callback is complete.\n   *\n   * @example\n   * ```ts\n   * // All changes to the editor will be grouped together\n   * editor.transact((tr) => {\n   *   tr.insertText(\"Hello, world!\");\n   * // These two operations will be grouped together in a single undo step\n   *   editor.transact((tr) => {\n   *     tr.insertText(\"Hello, world!\");\n   *   });\n   * });\n   * ```\n   */\n  public transact<T>(\n    callback: (\n      /**\n       * The current active transaction, this will automatically be dispatched to the editor when the callback is complete\n       * If another `transact` call is made within the callback, it will be passed the same transaction as the parent call.\n       */\n      tr: Transaction,\n    ) => T,\n  ): T {\n    return this._stateManager.transact(callback);\n  }\n\n  // TO DISCUSS\n  /**\n   * Shorthand to get a typed extension from the editor, by\n   * just passing in the extension class.\n   *\n   * @param ext - The extension class to get\n   * @param key - optional, the key of the extension in the extensions object (defaults to the extension name)\n   * @returns The extension instance\n   */\n  public extension<T extends BlockNoteExtension>(\n    ext: { new (...args: any[]): T } & typeof BlockNoteExtension,\n    key = ext.key(),\n  ): T {\n    return this._extensionManager.extension(ext, key);\n  }\n\n  /**\n   * Mount the editor to a DOM element.\n   *\n   * @warning Not needed to call manually when using React, use BlockNoteView to take care of mounting\n   */\n  public mount = (element: HTMLElement) => {\n    // TODO: Fix typing for this in a TipTap PR\n    this._tiptapEditor.mount({ mount: element } as any);\n  };\n\n  /**\n   * Unmount the editor from the DOM element it is bound to\n   */\n  public unmount = () => {\n    this._tiptapEditor.unmount();\n  };\n\n  /**\n   * Get the underlying prosemirror state\n   * @note Prefer using `editor.transact` to read the current editor state, as that will ensure the state is up to date\n   * @see https://prosemirror.net/docs/ref/#state.EditorState\n   */\n  public get prosemirrorState() {\n    return this._stateManager.prosemirrorState;\n  }\n\n  /**\n   * Get the underlying prosemirror view\n   * @see https://prosemirror.net/docs/ref/#view.EditorView\n   */\n  public get prosemirrorView() {\n    return this._stateManager.prosemirrorView;\n  }\n\n  public get domElement() {\n    return this.prosemirrorView?.dom as HTMLDivElement | undefined;\n  }\n\n  public isFocused() {\n    return this.prosemirrorView?.hasFocus() || false;\n  }\n\n  public get headless() {\n    return !this._tiptapEditor.isInitialized;\n  }\n\n  public focus() {\n    if (this.headless) {\n      return;\n    }\n    this.prosemirrorView.focus();\n  }\n\n  public onUploadStart(callback: (blockId?: string) => void) {\n    this.onUploadStartCallbacks.push(callback);\n\n    return () => {\n      const index = this.onUploadStartCallbacks.indexOf(callback);\n      if (index > -1) {\n        this.onUploadStartCallbacks.splice(index, 1);\n      }\n    };\n  }\n\n  public onUploadEnd(callback: (blockId?: string) => void) {\n    this.onUploadEndCallbacks.push(callback);\n\n    return () => {\n      const index = this.onUploadEndCallbacks.indexOf(callback);\n      if (index > -1) {\n        this.onUploadEndCallbacks.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * @deprecated, use `editor.document` instead\n   */\n  public get topLevelBlocks(): Block<BSchema, ISchema, SSchema>[] {\n    return this.document;\n  }\n\n  /**\n   * Gets a snapshot of all top-level (non-nested) blocks in the editor.\n   * @returns A snapshot of all top-level (non-nested) blocks in the editor.\n   */\n  public get document(): Block<BSchema, ISchema, SSchema>[] {\n    return this._blockManager.document;\n  }\n\n  /**\n   * Gets a snapshot of an existing block from the editor.\n   * @param blockIdentifier The identifier of an existing block that should be\n   * retrieved.\n   * @returns The block that matches the identifier, or `undefined` if no\n   * matching block was found.\n   */\n  public getBlock(\n    blockIdentifier: BlockIdentifier,\n  ): Block<BSchema, ISchema, SSchema> | undefined {\n    return this._blockManager.getBlock(blockIdentifier);\n  }\n\n  /**\n   * Gets a snapshot of the previous sibling of an existing block from the\n   * editor.\n   * @param blockIdentifier The identifier of an existing block for which the\n   * previous sibling should be retrieved.\n   * @returns The previous sibling of the block that matches the identifier.\n   * `undefined` if no matching block was found, or it's the first child/block\n   * in the document.\n   */\n  public getPrevBlock(\n    blockIdentifier: BlockIdentifier,\n  ): Block<BSchema, ISchema, SSchema> | undefined {\n    return this._blockManager.getPrevBlock(blockIdentifier);\n  }\n\n  /**\n   * Gets a snapshot of the next sibling of an existing block from the editor.\n   * @param blockIdentifier The identifier of an existing block for which the\n   * next sibling should be retrieved.\n   * @returns The next sibling of the block that matches the identifier.\n   * `undefined` if no matching block was found, or it's the last child/block in\n   * the document.\n   */\n  public getNextBlock(\n    blockIdentifier: BlockIdentifier,\n  ): Block<BSchema, ISchema, SSchema> | undefined {\n    return this._blockManager.getNextBlock(blockIdentifier);\n  }\n\n  /**\n   * Gets a snapshot of the parent of an existing block from the editor.\n   * @param blockIdentifier The identifier of an existing block for which the\n   * parent should be retrieved.\n   * @returns The parent of the block that matches the identifier. `undefined`\n   * if no matching block was found, or the block isn't nested.\n   */\n  public getParentBlock(\n    blockIdentifier: BlockIdentifier,\n  ): Block<BSchema, ISchema, SSchema> | undefined {\n    return this._blockManager.getParentBlock(blockIdentifier);\n  }\n\n  /**\n   * Traverses all blocks in the editor depth-first, and executes a callback for each.\n   * @param callback The callback to execute for each block. Returning `false` stops the traversal.\n   * @param reverse Whether the blocks should be traversed in reverse order.\n   */\n  public forEachBlock(\n    callback: (block: Block<BSchema, ISchema, SSchema>) => boolean,\n    reverse = false,\n  ): void {\n    this._blockManager.forEachBlock(callback, reverse);\n  }\n\n  /**\n   * Executes a callback whenever the editor's contents change.\n   * @param callback The callback to execute.\n   *\n   * @deprecated use {@link BlockNoteEditor.onChange} instead\n   */\n  public onEditorContentChange(callback: () => void) {\n    this._tiptapEditor.on(\"update\", callback);\n  }\n\n  /**\n   * Executes a callback whenever the editor's selection changes.\n   * @param callback The callback to execute.\n   *\n   * @deprecated use `onSelectionChange` instead\n   */\n  public onEditorSelectionChange(callback: () => void) {\n    this._tiptapEditor.on(\"selectionUpdate\", callback);\n  }\n\n  /**\n   * Gets a snapshot of the current text cursor position.\n   * @returns A snapshot of the current text cursor position.\n   */\n  public getTextCursorPosition(): TextCursorPosition<\n    BSchema,\n    ISchema,\n    SSchema\n  > {\n    return this._selectionManager.getTextCursorPosition();\n  }\n\n  /**\n   * Sets the text cursor position to the start or end of an existing block. Throws an error if the target block could\n   * not be found.\n   * @param targetBlock The identifier of an existing block that the text cursor should be moved to.\n   * @param placement Whether the text cursor should be placed at the start or end of the block.\n   */\n  public setTextCursorPosition(\n    targetBlock: BlockIdentifier,\n    placement: \"start\" | \"end\" = \"start\",\n  ) {\n    return this._selectionManager.setTextCursorPosition(targetBlock, placement);\n  }\n\n  /**\n   * Gets a snapshot of the current selection. This contains all blocks (included nested blocks)\n   * that the selection spans across.\n   *\n   * If the selection starts / ends halfway through a block, the returned data will contain the entire block.\n   */\n  public getSelection(): Selection<BSchema, ISchema, SSchema> | undefined {\n    return this._selectionManager.getSelection();\n  }\n\n  /**\n   * Gets a snapshot of the current selection. This contains all blocks (included nested blocks)\n   * that the selection spans across.\n   *\n   * If the selection starts / ends halfway through a block, the returned block will be\n   * only the part of the block that is included in the selection.\n   */\n  public getSelectionCutBlocks() {\n    return this._selectionManager.getSelectionCutBlocks();\n  }\n\n  /**\n   * Sets the selection to a range of blocks.\n   * @param startBlock The identifier of the block that should be the start of the selection.\n   * @param endBlock The identifier of the block that should be the end of the selection.\n   */\n  public setSelection(startBlock: BlockIdentifier, endBlock: BlockIdentifier) {\n    return this._selectionManager.setSelection(startBlock, endBlock);\n  }\n\n  /**\n   * Checks if the editor is currently editable, or if it's locked.\n   * @returns True if the editor is editable, false otherwise.\n   */\n  public get isEditable(): boolean {\n    return this._stateManager.isEditable;\n  }\n\n  /**\n   * Makes the editor editable or locks it, depending on the argument passed.\n   * @param editable True to make the editor editable, or false to lock it.\n   */\n  public set isEditable(editable: boolean) {\n    this._stateManager.isEditable = editable;\n  }\n\n  /**\n   * Inserts new blocks into the editor. If a block's `id` is undefined, BlockNote generates one automatically. Throws an\n   * error if the reference block could not be found.\n   * @param blocksToInsert An array of partial blocks that should be inserted.\n   * @param referenceBlock An identifier for an existing block, at which the new blocks should be inserted.\n   * @param placement Whether the blocks should be inserted just before, just after, or nested inside the\n   * `referenceBlock`.\n   */\n  public insertBlocks(\n    blocksToInsert: PartialBlock<BSchema, ISchema, SSchema>[],\n    referenceBlock: BlockIdentifier,\n    placement: \"before\" | \"after\" = \"before\",\n  ) {\n    return this._blockManager.insertBlocks(\n      blocksToInsert,\n      referenceBlock,\n      placement,\n    );\n  }\n\n  /**\n   * Updates an existing block in the editor. Since updatedBlock is a PartialBlock object, some fields might not be\n   * defined. These undefined fields are kept as-is from the existing block. Throws an error if the block to update could\n   * not be found.\n   * @param blockToUpdate The block that should be updated.\n   * @param update A partial block which defines how the existing block should be changed.\n   */\n  public updateBlock(\n    blockToUpdate: BlockIdentifier,\n    update: PartialBlock<BSchema, ISchema, SSchema>,\n  ) {\n    return this._blockManager.updateBlock(blockToUpdate, update);\n  }\n\n  /**\n   * Removes existing blocks from the editor. Throws an error if any of the blocks could not be found.\n   * @param blocksToRemove An array of identifiers for existing blocks that should be removed.\n   */\n  public removeBlocks(blocksToRemove: BlockIdentifier[]) {\n    return this._blockManager.removeBlocks(blocksToRemove);\n  }\n\n  /**\n   * Replaces existing blocks in the editor with new blocks. If the blocks that should be removed are not adjacent or\n   * are at different nesting levels, `blocksToInsert` will be inserted at the position of the first block in\n   * `blocksToRemove`. Throws an error if any of the blocks to remove could not be found.\n   * @param blocksToRemove An array of blocks that should be replaced.\n   * @param blocksToInsert An array of partial blocks to replace the old ones with.\n   */\n  public replaceBlocks(\n    blocksToRemove: BlockIdentifier[],\n    blocksToInsert: PartialBlock<BSchema, ISchema, SSchema>[],\n  ) {\n    return this._blockManager.replaceBlocks(blocksToRemove, blocksToInsert);\n  }\n\n  /**\n   * Undo the last action.\n   */\n  public undo() {\n    return this._stateManager.undo();\n  }\n\n  /**\n   * Redo the last action.\n   */\n  public redo() {\n    return this._stateManager.redo();\n  }\n\n  /**\n   * Insert a piece of content at the current cursor position.\n   *\n   * @param content can be a string, or array of partial inline content elements\n   */\n  public insertInlineContent(\n    content: PartialInlineContent<ISchema, SSchema>,\n    { updateSelection = false }: { updateSelection?: boolean } = {},\n  ) {\n    this._styleManager.insertInlineContent(content, { updateSelection });\n  }\n\n  /**\n   * Gets the active text styles at the text cursor position or at the end of the current selection if it's active.\n   */\n  public getActiveStyles(): Styles<SSchema> {\n    return this._styleManager.getActiveStyles();\n  }\n\n  /**\n   * Adds styles to the currently selected content.\n   * @param styles The styles to add.\n   */\n  public addStyles(styles: Styles<SSchema>) {\n    this._styleManager.addStyles(styles);\n  }\n\n  /**\n   * Removes styles from the currently selected content.\n   * @param styles The styles to remove.\n   */\n  public removeStyles(styles: Styles<SSchema>) {\n    this._styleManager.removeStyles(styles);\n  }\n\n  /**\n   * Toggles styles on the currently selected content.\n   * @param styles The styles to toggle.\n   */\n  public toggleStyles(styles: Styles<SSchema>) {\n    this._styleManager.toggleStyles(styles);\n  }\n\n  /**\n   * Gets the currently selected text.\n   */\n  public getSelectedText() {\n    return this._styleManager.getSelectedText();\n  }\n\n  /**\n   * Gets the URL of the last link in the current selection, or `undefined` if there are no links in the selection.\n   */\n  public getSelectedLinkUrl() {\n    return this._styleManager.getSelectedLinkUrl();\n  }\n\n  /**\n   * Creates a new link to replace the selected content.\n   * @param url The link URL.\n   * @param text The text to display the link with.\n   */\n  public createLink(url: string, text?: string) {\n    this._styleManager.createLink(url, text);\n  }\n\n  /**\n   * Checks if the block containing the text cursor can be nested.\n   */\n  public canNestBlock() {\n    return this._blockManager.canNestBlock();\n  }\n\n  /**\n   * Nests the block containing the text cursor into the block above it.\n   */\n  public nestBlock() {\n    this._blockManager.nestBlock();\n  }\n\n  /**\n   * Checks if the block containing the text cursor is nested.\n   */\n  public canUnnestBlock() {\n    return this._blockManager.canUnnestBlock();\n  }\n\n  /**\n   * Lifts the block containing the text cursor out of its parent.\n   */\n  public unnestBlock() {\n    this._blockManager.unnestBlock();\n  }\n\n  /**\n   * Moves the selected blocks up. If the previous block has children, moves\n   * them to the end of its children. If there is no previous block, but the\n   * current blocks share a common parent, moves them out of & before it.\n   */\n  public moveBlocksUp() {\n    return this._blockManager.moveBlocksUp();\n  }\n\n  /**\n   * Moves the selected blocks down. If the next block has children, moves\n   * them to the start of its children. If there is no next block, but the\n   * current blocks share a common parent, moves them out of & after it.\n   */\n  public moveBlocksDown() {\n    return this._blockManager.moveBlocksDown();\n  }\n\n  /**\n   * Exports blocks into a simplified HTML string. To better conform to HTML standards, children of blocks which aren't list\n   * items are un-nested in the output HTML.\n   *\n   * @param blocks An array of blocks that should be serialized into HTML.\n   * @returns The blocks, serialized as an HTML string.\n   */\n  public blocksToHTMLLossy(\n    blocks: PartialBlock<BSchema, ISchema, SSchema>[] = this.document,\n  ): string {\n    return this._exportManager.blocksToHTMLLossy(blocks);\n  }\n\n  /**\n   * Serializes blocks into an HTML string in the format that would normally be rendered by the editor.\n   *\n   * Use this method if you want to server-side render HTML (for example, a blog post that has been edited in BlockNote)\n   * and serve it to users without loading the editor on the client (i.e.: displaying the blog post)\n   *\n   * @param blocks An array of blocks that should be serialized into HTML.\n   * @returns The blocks, serialized as an HTML string.\n   */\n  public blocksToFullHTML(\n    blocks: PartialBlock<BSchema, ISchema, SSchema>[],\n  ): string {\n    return this._exportManager.blocksToFullHTML(blocks);\n  }\n  /**\n   * Parses blocks from an HTML string. Tries to create `Block` objects out of any HTML block-level elements, and\n   * `InlineNode` objects from any HTML inline elements, though not all element types are recognized. If BlockNote\n   * doesn't recognize an HTML element's tag, it will parse it as a paragraph or plain text.\n   * @param html The HTML string to parse blocks from.\n   * @returns The blocks parsed from the HTML string.\n   */\n  public tryParseHTMLToBlocks(\n    html: string,\n  ): Block<BSchema, ISchema, SSchema>[] {\n    return this._exportManager.tryParseHTMLToBlocks(html);\n  }\n\n  /**\n   * Serializes blocks into a Markdown string. The output is simplified as Markdown does not support all features of\n   * BlockNote - children of blocks which aren't list items are un-nested and certain styles are removed.\n   * @param blocks An array of blocks that should be serialized into Markdown.\n   * @returns The blocks, serialized as a Markdown string.\n   */\n  public blocksToMarkdownLossy(\n    blocks: PartialBlock<BSchema, ISchema, SSchema>[] = this.document,\n  ): string {\n    return this._exportManager.blocksToMarkdownLossy(blocks);\n  }\n\n  /**\n   * Creates a list of blocks from a Markdown string. Tries to create `Block` and `InlineNode` objects based on\n   * Markdown syntax, though not all symbols are recognized. If BlockNote doesn't recognize a symbol, it will parse it\n   * as text.\n   * @param markdown The Markdown string to parse blocks from.\n   * @returns The blocks parsed from the Markdown string.\n   */\n  public tryParseMarkdownToBlocks(\n    markdown: string,\n  ): Block<BSchema, ISchema, SSchema>[] {\n    return this._exportManager.tryParseMarkdownToBlocks(markdown);\n  }\n\n  /**\n   * Updates the user info for the current user that's shown to other collaborators.\n   */\n  public updateCollaborationUserInfo(user: { name: string; color: string }) {\n    if (!this._collaborationManager) {\n      throw new Error(\n        \"Cannot update collaboration user info when collaboration is disabled.\",\n      );\n    }\n\n    this._collaborationManager.updateUserInfo(user);\n  }\n\n  /**\n   * A callback function that runs whenever the editor's contents change.\n   *\n   * @param callback The callback to execute.\n   * @returns A function to remove the callback.\n   */\n  public onChange(\n    callback: (\n      editor: BlockNoteEditor<BSchema, ISchema, SSchema>,\n      context: {\n        /**\n         * Returns the blocks that were inserted, updated, or deleted by the change that occurred.\n         */\n        getChanges(): BlocksChanged<BSchema, ISchema, SSchema>;\n      },\n    ) => void,\n  ) {\n    return this._eventManager.onChange(callback);\n  }\n\n  /**\n   * A callback function that runs whenever the text cursor position or selection changes.\n   *\n   * @param callback The callback to execute.\n   * @returns A function to remove the callback.\n   */\n  public onSelectionChange(\n    callback: (editor: BlockNoteEditor<BSchema, ISchema, SSchema>) => void,\n    includeSelectionChangedByRemote?: boolean,\n  ) {\n    return this._eventManager.onSelectionChange(\n      callback,\n      includeSelectionChangedByRemote,\n    );\n  }\n\n  /**\n   * A callback function that runs when the editor has been initialized.\n   *\n   * This can be useful for plugins to initialize themselves after the editor has been initialized.\n   *\n   * @param callback The callback to execute.\n   * @returns A function to remove the callback.\n   */\n  public onCreate(callback: () => void) {\n    this.on(\"create\", callback);\n\n    return () => {\n      this.off(\"create\", callback);\n    };\n  }\n\n  /**\n   * A callback function that runs when the editor has been mounted.\n   *\n   * This can be useful for plugins to initialize themselves after the editor has been mounted.\n   *\n   * @param callback The callback to execute.\n   * @returns A function to remove the callback.\n   */\n  public onMount(\n    callback: (ctx: {\n      editor: BlockNoteEditor<BSchema, ISchema, SSchema>;\n    }) => void,\n  ) {\n    this._eventManager.onMount(callback);\n  }\n\n  /**\n   * A callback function that runs when the editor has been unmounted.\n   *\n   * This can be useful for plugins to clean up themselves after the editor has been unmounted.\n   *\n   * @param callback The callback to execute.\n   * @returns A function to remove the callback.\n   */\n  public onUnmount(\n    callback: (ctx: {\n      editor: BlockNoteEditor<BSchema, ISchema, SSchema>;\n    }) => void,\n  ) {\n    this._eventManager.onUnmount(callback);\n  }\n\n  /**\n   * Gets the bounding box of the current selection.\n   * @returns The bounding box of the current selection.\n   */\n  public getSelectionBoundingBox() {\n    return this._selectionManager.getSelectionBoundingBox();\n  }\n\n  public get isEmpty() {\n    const doc = this.document;\n    // Note: only works for paragraphs as default blocks (but for now this is default in blocknote)\n    // checking prosemirror directly might be faster\n    return (\n      doc.length === 0 ||\n      (doc.length === 1 &&\n        doc[0].type === \"paragraph\" &&\n        (doc[0].content as any).length === 0)\n    );\n  }\n\n  public openSuggestionMenu(\n    triggerCharacter: string,\n    pluginState?: {\n      deleteTriggerCharacter?: boolean;\n      ignoreQueryLength?: boolean;\n    },\n  ) {\n    if (!this.prosemirrorView) {\n      return;\n    }\n\n    this.focus();\n    this.transact((tr) => {\n      if (pluginState?.deleteTriggerCharacter) {\n        tr.insertText(triggerCharacter);\n      }\n      tr.scrollIntoView().setMeta(this.suggestionMenus.plugins[0], {\n        triggerCharacter: triggerCharacter,\n        deleteTriggerCharacter: pluginState?.deleteTriggerCharacter || false,\n        ignoreQueryLength: pluginState?.ignoreQueryLength || false,\n      });\n    });\n  }\n\n  // `forceSelectionVisible` determines whether the editor selection is shows\n  // even when the editor is not focused. This is useful for e.g. creating new\n  // links, so the user still sees the affected content when an input field is\n  // focused.\n  // TODO: Reconsider naming?\n  public getForceSelectionVisible() {\n    return this.showSelectionPlugin.getEnabled();\n  }\n\n  public setForceSelectionVisible(forceSelectionVisible: boolean) {\n    this.showSelectionPlugin.setEnabled(forceSelectionVisible);\n  }\n\n  /**\n   * Paste HTML into the editor. Defaults to converting HTML to BlockNote HTML.\n   * @param html The HTML to paste.\n   * @param raw Whether to paste the HTML as is, or to convert it to BlockNote HTML.\n   */\n  public pasteHTML(html: string, raw = false) {\n    this._exportManager.pasteHTML(html, raw);\n  }\n\n  /**\n   * Paste text into the editor. Defaults to interpreting text as markdown.\n   * @param text The text to paste.\n   */\n  public pasteText(text: string) {\n    return this._exportManager.pasteText(text);\n  }\n\n  /**\n   * Paste markdown into the editor.\n   * @param markdown The markdown to paste.\n   */\n  public pasteMarkdown(markdown: string) {\n    return this._exportManager.pasteMarkdown(markdown);\n  }\n}\n","import { BlockNoteSchema } from \"../blocks/BlockNoteSchema.js\";\nimport { COLORS_DEFAULT } from \"../editor/defaultColors.js\";\nimport {\n  BlockFromConfig,\n  BlockSchema,\n  InlineContent,\n  InlineContentSchema,\n  StyleSchema,\n  StyledText,\n  Styles,\n} from \"../schema/index.js\";\n\nimport type {\n  BlockMapping,\n  InlineContentMapping,\n  StyleMapping,\n} from \"./mapping.js\";\n\nexport type ExporterOptions = {\n  /**\n   * A function that can be used to resolve files, images, etc.\n   * Exporters might need the binary contents of files like images,\n   * which might not always be available from the same origin as the main page.\n   * You can use this option to proxy requests through a server you control\n   * to avoid cross-origin (CORS) issues.\n   *\n   * @default uses a BlockNote hosted proxy (https://corsproxy.api.blocknotejs.org/)\n   * @param url - The URL of the file to resolve\n   * @returns A Promise that resolves to a string (the URL to use instead of the original)\n   * or a Blob (you can return the Blob directly if you have already fetched it)\n   */\n  resolveFileUrl?: (url: string) => Promise<string | Blob>;\n  /**\n   * Colors to use for background of blocks, font colors, and highlight colors\n   */\n  colors: typeof COLORS_DEFAULT;\n};\nexport abstract class Exporter<\n  B extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n  RB,\n  RI,\n  RS,\n  TS,\n> {\n  public constructor(\n    _schema: BlockNoteSchema<B, I, S>, // only used for type inference\n    protected readonly mappings: {\n      blockMapping: BlockMapping<B, I, S, RB, RI>;\n      inlineContentMapping: InlineContentMapping<I, S, RI, TS>;\n      styleMapping: StyleMapping<S, RS>;\n    },\n    public readonly options: ExporterOptions,\n  ) {}\n\n  public async resolveFile(url: string) {\n    if (!this.options?.resolveFileUrl) {\n      return (await fetch(url)).blob();\n    }\n    const ret = await this.options.resolveFileUrl(url);\n    if (ret instanceof Blob) {\n      return ret;\n    }\n    return (await fetch(ret)).blob();\n  }\n\n  public mapStyles(styles: Styles<S>) {\n    const stylesArray = Object.entries(styles).map(([key, value]) => {\n      const mappedStyle = this.mappings.styleMapping[key](value, this);\n      return mappedStyle;\n    });\n    return stylesArray;\n  }\n\n  public mapInlineContent(inlineContent: InlineContent<I, S>) {\n    return this.mappings.inlineContentMapping[inlineContent.type](\n      inlineContent,\n      this,\n    );\n  }\n\n  public transformInlineContent(inlineContentArray: InlineContent<I, S>[]) {\n    return inlineContentArray.map((ic) => this.mapInlineContent(ic));\n  }\n\n  public abstract transformStyledText(styledText: StyledText<S>): TS;\n\n  public async mapBlock(\n    block: BlockFromConfig<B[keyof B], I, S>,\n    nestingLevel: number,\n    numberedListIndex: number,\n    children?: Array<Awaited<RB>>,\n  ) {\n    return this.mappings.blockMapping[block.type](\n      block,\n      this,\n      nestingLevel,\n      numberedListIndex,\n      children,\n    );\n  }\n}\n","import { BlockNoteSchema } from \"../blocks/BlockNoteSchema.js\";\nimport {\n  BlockFromConfigNoChildren,\n  BlockSchema,\n  InlineContentFromConfig,\n  InlineContentSchema,\n  StyleSchema,\n  Styles,\n} from \"../schema/index.js\";\nimport type { Exporter } from \"./Exporter.js\";\n\n/**\n * Defines a mapping from all block types with a schema to a result type `R`.\n */\nexport type BlockMapping<\n  B extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n  RB,\n  RI,\n> = {\n  [K in keyof B]: (\n    block: BlockFromConfigNoChildren<B[K], I, S>,\n    // we don't know the exact types that are supported by the exporter at this point,\n    // because the mapping only knows about converting certain types (which might be a subset of the supported types)\n    // this is why there are many `any` types here (same for types below)\n    exporter: Exporter<any, any, any, RB, RI, any, any>,\n    nestingLevel: number,\n    numberedListIndex?: number,\n    children?: Array<Awaited<RB>>,\n  ) => RB | Promise<RB>;\n};\n\n/**\n * Defines a mapping from all inline content types with a schema to a result type R.\n */\nexport type InlineContentMapping<\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n  RI,\n  TS,\n> = {\n  [K in keyof I]: (\n    inlineContent: InlineContentFromConfig<I[K], S>,\n    exporter: Exporter<any, I, S, any, RI, any, TS>,\n  ) => RI;\n};\n\n/**\n * Defines a mapping from all style types with a schema to a result type R.\n */\nexport type StyleMapping<S extends StyleSchema, RS> = {\n  [K in keyof S]: (\n    style: Styles<S>[K],\n    exporter: Exporter<any, any, any, any, any, RS, any>,\n  ) => RS;\n};\n\n/**\n * The mapping factory is a utility function to easily create mappings for\n * a BlockNoteSchema. Using the factory makes it easier to get typescript code completion etc.\n */\nexport function mappingFactory<\n  B extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(_schema: BlockNoteSchema<B, I, S>) {\n  return {\n    createBlockMapping: <R, RI>(mapping: BlockMapping<B, I, S, R, RI>) =>\n      mapping,\n    createInlineContentMapping: <R, RS>(\n      mapping: InlineContentMapping<I, S, R, RS>,\n    ) => mapping,\n    createStyleMapping: <R>(mapping: StyleMapping<S, R>) => mapping,\n  };\n}\n","import type { Emoji, EmojiMartData } from \"@emoji-mart/data\";\n\nimport { defaultInlineContentSchema } from \"../../blocks/defaultBlocks.js\";\nimport { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\nimport { DefaultGridSuggestionItem } from \"./DefaultGridSuggestionItem.js\";\n\n// Temporary fix for https://github.com/missive/emoji-mart/pull/929\nlet emojiLoadingPromise:\n  | Promise<{\n      emojiMart: typeof import(\"emoji-mart\");\n      emojiData: EmojiMartData;\n    }>\n  | undefined;\n\nasync function loadEmojiMart() {\n  if (emojiLoadingPromise) {\n    return emojiLoadingPromise;\n  }\n\n  emojiLoadingPromise = (async () => {\n    // load dynamically because emoji-mart doesn't specify type: module and breaks in nodejs\n    const [emojiMartModule, emojiDataModule] = await Promise.all([\n      import(\"emoji-mart\"),\n      // use a dynamic import to encourage bundle-splitting\n      // and a smaller initial client bundle size\n      import(\"@emoji-mart/data\"),\n    ]);\n\n    const emojiMart =\n      \"default\" in emojiMartModule ? emojiMartModule.default : emojiMartModule;\n    const emojiData =\n      \"default\" in emojiDataModule\n        ? (emojiDataModule.default as EmojiMartData)\n        : (emojiDataModule as EmojiMartData);\n\n    await emojiMart.init({ data: emojiData });\n\n    return { emojiMart, emojiData };\n  })();\n\n  return emojiLoadingPromise;\n}\n\nexport async function getDefaultEmojiPickerItems<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n  query: string,\n): Promise<DefaultGridSuggestionItem[]> {\n  if (\n    !(\"text\" in editor.schema.inlineContentSchema) ||\n    editor.schema.inlineContentSchema[\"text\"] !==\n      defaultInlineContentSchema[\"text\"]\n  ) {\n    return [];\n  }\n\n  const { emojiData, emojiMart } = await loadEmojiMart();\n\n  const emojisToShow =\n    query.trim() === \"\"\n      ? Object.values(emojiData.emojis)\n      : ((await emojiMart!.SearchIndex.search(query)) as Emoji[]);\n\n  return emojisToShow.map((emoji) => ({\n    id: emoji.skins[0].native,\n    onItemClick: () => editor.insertInlineContent(emoji.skins[0].native + \" \"),\n  }));\n}\n","/**\n * Combines items by group. This can be used to combine multiple slash menu item arrays,\n * while making sure that items from the same group are adjacent to each other.\n */\nexport function combineByGroup<T extends { group?: string }>(\n  items: T[],\n  ...additionalItemsArray: {\n    group?: string;\n  }[][]\n) {\n  const combinedItems = [...items];\n  for (const additionalItems of additionalItemsArray) {\n    for (const additionalItem of additionalItems) {\n      const lastItemWithSameGroup = combinedItems.findLastIndex(\n        (item) => item.group === additionalItem.group,\n      );\n      if (lastItemWithSameGroup === -1) {\n        combinedItems.push(additionalItem as T);\n      } else {\n        combinedItems.splice(lastItemWithSameGroup + 1, 0, additionalItem as T);\n      }\n    }\n  }\n  return combinedItems;\n}\n"],"names":["getInlineContentParseRules","config","customParseFunction","rules","element","htmlElement","node","props","createInlineContentSpec","inlineContentConfig","inlineContentImplementation","Node","_a","propsToAttributes","addInlineContentKeyboardShortcuts","editor","output","nodeToCustomInlineContent","addInlineContentAttributes","getPos","update","content","inlineContentToNodes","pos","tr","createInlineContentSpecFromTipTapNode","inlineContent","updateInlineContent","insertBlocks","blocksToInsert","referenceBlock","placement","id","pmSchema","getPmSchema","nodesToInsert","block","blockToNode","posInfo","getNodeById","ReplaceStep","Slice","Fragment","nodeToBlock","removeAndInsertBlocks","blocksToRemove","idsOfBlocksToRemove","removedBlocks","idOfFirstBlock","removedSize","oldDocSize","newDocSize","$pos","notFoundIds","addAttributesAndRemoveClasses","className","serializeInlineContentExternalHTML","blockContent","serializer","options","nodes","tableContentToNodes","UnreachableCaseError","fragment","contentFragment","dom","mark","newDom","domOutputSpec","DOMSerializer","nodeFragment","serializeBlock","orderedListItemBlockTypes","unorderedListItemBlockTypes","doc","BC_NODE","name","spec","bc","_b","attrs","blockImplementation","ret","_c","elementFragment","blockContentDataAttributes","attr","ic","listType","_d","list","childFragment","serializeBlocksToFragment","_e","_f","_g","_h","_i","blocks","serializeBlocksExternalHTML","createExternalHTMLExporter","schema","html","div","domFragment","parent","serializeInlineContentInternalHTML","blockType","children","serializeBlocks","serializeBlocksInternalHTML","blockDOM","BG_NODE","bg","createInternalHTMLSerializer","getParentBlockId","resolvedPos","i","isNodeBlock","determineChangeSource","transaction","collectSnapshot","ROOT_KEY","byId","childrenByParent","parentId","key","detectReorderedChildren","prevOrder","nextOrder","moved","prevIds","commonNext","commonPrev","indexInPrev","sequence","n","tailsValues","tailsEndsAtIndex","previousIndexInLis","lowerBound","arr","target","lo","hi","mid","value","lisIndexSet","getBlocksChangedByTransaction","appendedTransactions","source","combinedTransaction","combineTransactionSteps","prevSnap","nextSnap","changes","changedIds","prev","next","deepEqual","prevOrderByParent","nextOrderByParent","parents","addedMoveForId","parentKey","movedWithinParent","acceptedMIMETypes","checkFileExtensionsMatch","fileExtension1","fileExtension2","checkMIMETypesMatch","mimeType1","mimeType2","types1","types2","insertOrUpdateBlock","newBlock","insertedBlockId","handleFileInsertion","event","dataTransfer","format","mimeType","items","fileBlockType","blockSpec","isFileExtension","file","fileBlock","currentBlock","coords","getNearestBlockPos","blockElement","blockRect","updateData","updatedFileBlock","createDropFileExtension","Extension","Plugin","_view","h1","bold","link","code","ul","ol","hr","fences","title","blockquote","tableHeader","tableDivider","tableRow","isMarkdown","src","handleVSCodePaste","view","text","vscode","vscodeData","language","defaultPasteHandler","prioritizeMarkdownOverHTML","plainTextAsMarkdown","data","plainText","createPasteFromClipboardExtension","pasteHandler","removeUnderlines","removeUnderlinesHelper","tree","numChildElements","numElementsAdded","addSpacesToCheckboxes","helper","child","nextChild","fromDom","convertVideoToMarkdown","visit","index","cleanHTMLToMarkdown","cleanHTMLString","unified","rehypeParse","rehypeRemark","remarkGfm","remarkStringify","blocksToMarkdown","externalHTML","fragmentToBlocks","fragmentToExternalHTML","selectedFragment","isWithinBlockContent","isWithinTable","CellSelection","fragmentWithoutParents","externalHTMLExporter","contentNodeToTableContent","contentNodeToInlineContent","selectedFragmentToHTML","NodeSelection","clipboardHTML","markdown","checkIfSelectionInNonEditableBlock","selection","copyToClipboard","createCopyToClipboardExtension","BackgroundColorExtension","getBackgroundColorAttribute","BlockChangePlugin","BlockNoteExtension","__publicField","PluginKey","acc","cb","callback","_CursorPlugin","collaboration","user","clientID","cursorData","cursorElement","cursor","updated","yCursorPlugin","defaultSelectionBuilder","bgColor","color","g","b","c","col","caretElement","labelElement","CursorPlugin","SyncPlugin","ySyncPlugin","UndoPlugin","yUndoPlugin","ForkYDocPlugin","ytype","otherYdoc","ydoc","rootKey","ytypeItem","otherStructs","itemIndex","Y","originalFragment","forkedFragment","yUndoPluginKey","yCursorPluginKey","ySyncPluginKey","keepChanges","undoStack","traverseElement","rootElement","moveColorAttributes","targetBlockContainers","colors","defaultProps","migrationRules","SchemaMigrationPlugin","pluginKey","transactions","_oldState","newState","migrationRule","CommentMark","Mark","attributes","HTMLAttributes","mergeAttributes","extension","UserStore","EventEmitter","resolveUsers","userIds","missingUsers","users","userId","PLUGIN_KEY","SET_SELECTED_THREAD_ID","getUpdatedThreadPositions","markType","threadPositions","thisThreadId","from","to","currentPosition","CommentsPlugin","threadStore","commentEditorSchema","threads","markThreadId","thread","isOrphan","trimmedFrom","trimmedTo","self","DecorationSet","state","action","decorations","selectedThreadPosition","Decoration","commentMark","threadId","scrollToThread","pmSelection","ystate","getRelativeSelection","FilePanelView","pmView","emitUpdate","prevState","pluginState","prevPluginState","isOpening","isClosing","filePanelPluginKey","FilePanelProsemirrorPlugin","editorView","FormattingToolbarView","empty","isEmptyTextBlock","isTextSelection","isNodeSelection","focusedElement","editorWrapper","e","oldState","composing","isSame","ranges","range","shouldShow","jsdom","newReferencePos","nextState","TextSelection","posToDOMRect","formattingToolbarPluginKey","FormattingToolbarProsemirrorPlugin","HardBreak","getParentBlockInfo","beforePos","parentBeforePos","getBlockInfoFromResolvedPos","getPrevBlockInfo","indexInParent","prevBlockBeforePos","getBottomNestedBlockInfo","blockInfo","group","newPos","canMerge","prevBlockInfo","nextBlockInfo","mergeBlocks","dispatch","childBlocksStart","childBlocksEnd","childBlocksRange","mergeBlocksCommand","posBetweenBlocks","bottomNestedBlockInfo","sinkListItem","itemType","groupType","$from","$to","startIndex","nodeBefore","nestedBefore","inner","slice","before","after","ReplaceAroundStep","nestBlock","unnestBlock","canNestBlock","blockContainer","getBlockInfoFromTransaction","canUnnestBlock","KeyboardShortcutsExtension","handleBackspace","chain","commands","getBlockInfoFromSelection","selectionAtBlockStart","isParagraph","updateBlockCommand","selectionEmpty","parentBlockInfo","column","columnList","shouldRemoveColumn","shouldRemoveColumnList","isFirstColumn","blockToMove","chainedCommands","lastCellParagraphEndPos","nonEditableBlockContentStartPos","blockContentStartPos","bottomBlock","handleDelete","childContainer","depth","blockAtDocEnd","selectionAtBlockEnd","oldDepth","newDepth","handleEnter","withShift","blockEmpty","blockIndented","blockHardBreakShortcut","marks","m","newBlockInsertionPos","newBlockContentPos","splitBlockCommand","LinkToolbarView","hoveredLinkElement","posInHoveredLinkMark","resolvedPosInHoveredLinkMark","marksAtPos","getMarkRange","url","fromMouseOver","prevLinkMark","linkToolbarPluginKey","LinkToolbarProsemirrorPlugin","VALID_LINK_PROTOCOLS","DEFAULT_LINK_PROTOCOL","NodeSelectionKeyboardPlugin","PlaceholderPlugin","placeholders","uniqueEditorSelector","v4","styleEl","nonce","styleSheet","getSelector","additionalSelectors","defaultPlaceholder","emptyPlaceholder","rest","placeholder","blockTypeSelector","onlyBlockSelector","mustBeFocusedSelector","decs","nodeAttributes","PreviousBlockTypePlugin","timeout","_editorView","_prevState","currentTransactionOriginalOldBlockAttrs","oldNodes","findChildren","oldNodesById","newNodes","oldNode","oldContentNode","newContentNode","newAttrs","oldAttrs","prevAttrs","decorationAttrs","nodeAttr","val","decoration","ShowSelectionPlugin","dec","enabled","getDraggableBlockFromElement","MultipleNodeSelection","Selection","$anchor","$head","parentNode","_pos","mapping","fromResult","toResult","dragImageElement","blockPositionsFromSelection","beforeFirstBlockPos","afterLastBlockPos","selectionStartInBlockContent","selectionEndInBlockContent","minDepth","startFirstBlockPos","endLastBlockPos","setDragImage","parentClone","getElementIndex","parentElement","targetElement","firstSelectedBlockIndex","lastSelectedBlockIndex","unsetDragImage","iframes","iframe","inheritedClasses","rootEl","dragStart","draggedBlockInSelection","multipleBlocksSelected","selectedSlice","DISTANCE_TO_CONSIDER_EDITOR_BOUNDS","getBlockFromCoords","adjustForColumns","elements","getBlockFromMousePos","mousePos","editorBoundingBox","referenceBlocksBoundingBox","SideMenuView","closestEditor","blockContentBoundingBox","DOMParser","editors","minDistance","rect","distanceX","distanceY","distance","dragEventContext","evt","textContentIsBeingDragged","sideMenuIsBeingDragged","isDragOrigin","isDropPoint","isDropWithinEditorBounds","context","_event","editorOuterBoundingBox","cursorWithinEditor","dropPointBoundingBox","sideMenuPluginKey","SideMenuProsemirrorPlugin","editorToMapping","getMapping","Mapping","trackPosition","position","side","ySyncPluginState","trackedMapLength","relativePosition","absolutePositionToRelativePosition","curYSyncPluginState","relativePositionToAbsolutePosition","findBlock","findParentNode","SuggestionMenuView","decorationNode","suggestionMenuPluginKey","menuName","started","stopped","SuggestionMenuProseMirrorPlugin","triggerCharacter","triggerCharacters","suggestionPluginTransactionMeta","trackedPosition","str","snippet","suggestionPluginState","blockNode","createSuggestionMenu","SuggestionAddMark","inline","SuggestionDeleteMark","SuggestionModificationMark","setHiddenDragImage","unsetHiddenDragImage","getChildIndex","domCellAround","currentTarget","hideElements","selector","elementsToHide","TableHandlesView","tableRect","blockEl","tableBlock","pmNodeInfo","editorHasBlockWithType","widgetContainer","belowTable","toRightOfTable","hideHandles","colIndex","rowIndex","cellRect","boundedMouseCoords","tableCellElements","tableCellElement","emitStateUpdate","oldIndex","dispatchDecorationsTransaction","tableHandlesPluginKey","draggingState","columnWidths","canRowBeDraggedInto","newTable","moveRow","canColumnBeDraggedInto","moveColumn","columnWidth","rowCount","colCount","getDimensionsOfTable","tableBody","cell","TableHandlesProsemirrorPlugin","relativeRowIndex","getCellsAtRowHandle","relativeColumnIndex","getCellsAtColumnHandle","relativeStartCell","relativeEndCell","tableResolvedPos","startRowResolvedPos","startCellResolvedPos","endRowResolvedPos","endCellResolvedPos","direction","beforeState","addRowBefore","addRowAfter","addColumnBefore","addColumnAfter","deleteRow","deleteColumn","cellsToMerge","mergeCells","relativeCellToSplit","splitCell","$fromCell","$toCell","isTableCellSelection","$fromRow","$toRow","$table","fromColIndex","fromRowIndex","toColIndex","toRowIndex","cells","row","isSelectingTableCells","cellSelection","areInSameColumn","removeEmpty","cropEmptyRowsOrColumns","addType","numToAdd","addRowsOrColumns","newIndex","originalIndex","draggedCellOrientation","rowResolvedPos","cellResolvedPos","cellNode","decorationPos","widget","TextAlignmentExtension","TextColorExtension","getTextColorAttribute","TrailingNode","plugin","_","__","shouldInsertNodeAtEnd","endPosition","type","contentType","_state","lastNode","lastContentNode","BlockAttributes","BlockContainer","HTMLAttr","blockOuter","attribute","blockHTMLAttributes","mergeCSSClasses","BlockGroup","blockGroupHTMLAttributes","blockGroup","Doc","getBlockNoteExtensions","opts","tiptapExtensions","getTipTapExtensions","ext","disableExtensions","LINKIFY_INITIALIZED","extensions","Gapcursor","UniqueID","Text","Link","styleSpec","a","inlineContentSpec","History","getBlockSelectionData","anchorBlockPosInfo","headBlockPosInfo","updateBlockSelectionFromData","anchorBlockPos","headBlockPos","flattenColumns","moveSelectedBlocksAndSelection","selectionData","checkPlacementIsValid","parentBlock","getMoveUpPlacement","prevBlock","referenceBlockParent","getMoveDownPlacement","nextBlock","moveBlocksUp","moveUpPlacement","moveBlocksDown","moveDownPlacement","getBlock","blockIdentifier","getPrevBlock","nodeToConvert","getNextBlock","getParentBlock","$posBeforeNode","grandparentNode","BlockManager","docToBlocks","reverse","traverseBlockArray","blockArray","blockToUpdate","updateBlock","CollaborationManager","undoCommand","redoCommand","EventManager","includeSelectionChangedByRemote","isWhitespaceNode","liftNestedListsToParent","parentListItem","siblingsAfter","sibling","siblingContainer","createGroups","listItem","_detachedDoc","detachedDoc","nestedListsToBlockNoteStructure","elementOrHTML","HTMLToBlocks","htmlNode","properties","result","video","markdownToHTML","remarkParse","remarkRehype","remarkRehypeDefaultHandlers","isVideoUrl","rehypeStringify","markdownToBlocks","htmlString","ExportManager","raw","htmlToPaste","ExtensionManager","getSelection","$startBlockBeforePos","$endBlockBeforePos","indexToBlock","sharedDepth","endIndex","startIndexAtDepth","childCountAtDepth","setSelection","startBlock","endBlock","startBlockId","endBlockId","getBlockNoteSchema","anchorPosInfo","headPosInfo","anchorBlockInfo","getBlockInfo","headBlockInfo","anchorBlockConfig","headBlockConfig","startPos","endPos","tableMap","TableMap","lastCellPos","lastCellNodeSize","getSelectionCutBlocks","start","end","selectionInfo","prosemirrorSliceToSlicedBlocks","getTextCursorPosition","bnBlock","prevNode","nextNode","setTextCursorPosition","targetBlock","info","SelectionManager","StateManager","command","activeTr","editable","undo","redo","insertContentAt","isOnlyTextContent","isOnlyBlockContent","selectionToInsertionEnd","StyleManager","updateSelection","styles","style","removeChild","wrapTableRows","f","newItems","prevTable","transformPasted","shouldApplyFix","nestedChild","container","nodeHasSingleChild","nodeHasInlineContent","nodeHasTableContent","blockNoteTipTapOptions","BlockNoteEditor","anyOpts","en","newOptions","BlockNoteSchema","collaborationOptions","dropCursor","_j","_k","instance","uploadFile","blockId","collaborationEnabled","blockExtensions","TipTapNode","inputRule","InputRule","match","replaceWith","cursorPosition","updateBlockTr","tiptapOptions","_l","_n","_m","_o","_q","_p","initialContent","getSchema","pmNodes","createDocument","TiptapEditor","_r","_s","forceSelectionVisible","Exporter","_schema","mappings","inlineContentArray","nestingLevel","numberedListIndex","mappingFactory","emojiLoadingPromise","loadEmojiMart","emojiMartModule","emojiDataModule","emojiMart","emojiData","getDefaultEmojiPickerItems","query","defaultInlineContentSchema","emoji","combineByGroup","additionalItemsArray","combinedItems","additionalItems","additionalItem","lastItemWithSameGroup","item"],"mappings":"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"}