{"version":3,"file":"BlockNoteSchema-COA0fsXW.cjs","sources":["../src/extensions/UniqueID/UniqueID.ts","../src/schema/inlineContent/types.ts","../src/util/table.ts","../src/util/typescript.ts","../src/util/browser.ts","../src/blocks/defaultBlockHelpers.ts","../src/util/string.ts","../src/schema/blocks/internal.ts","../src/schema/blocks/createSpec.ts","../src/api/getBlockInfoFromPos.ts","../src/api/pmUtil.ts","../src/api/nodeConversions/nodeToBlock.ts","../src/schema/inlineContent/internal.ts","../src/schema/styles/internal.ts","../src/schema/styles/createSpec.ts","../src/util/topo-sort.ts","../src/schema/schema.ts","../src/api/blockManipulation/tables/tables.ts","../src/api/nodeConversions/blockToNode.ts","../src/api/nodeUtil.ts","../src/api/blockManipulation/commands/updateBlock/updateBlock.ts","../src/editor/defaultColors.ts","../src/blocks/defaultProps.ts","../src/blocks/File/helpers/parse/parseFigureElement.ts","../src/blocks/File/helpers/render/createAddFileButton.ts","../src/blocks/File/helpers/render/createFileNameWithIcon.ts","../src/blocks/File/helpers/render/createFileBlockWrapper.ts","../src/blocks/File/helpers/toExternalHTML/createFigureWithCaption.ts","../src/blocks/File/helpers/toExternalHTML/createLinkWithCaption.ts","../src/blocks/Audio/parseAudioElement.ts","../src/blocks/Audio/block.ts","../src/util/EventEmitter.ts","../src/editor/BlockNoteExtension.ts","../src/blocks/Code/shiki.ts","../src/blocks/Code/block.ts","../src/blocks/Divider/block.ts","../src/blocks/File/helpers/parse/parseEmbedElement.ts","../src/blocks/File/block.ts","../src/blocks/ToggleWrapper/createToggleWrapper.ts","../src/blocks/Heading/block.ts","../src/blocks/File/helpers/render/createResizableFileBlockWrapper.ts","../src/blocks/Image/parseImageElement.ts","../src/blocks/Image/block.ts","../src/api/blockManipulation/commands/splitBlock/splitBlock.ts","../src/blocks/utils/listItemEnterHandler.ts","../src/blocks/ListItem/getListItemContent.ts","../src/blocks/ListItem/BulletListItem/block.ts","../src/blocks/ListItem/CheckListItem/block.ts","../src/blocks/ListItem/NumberedListItem/IndexingPlugin.ts","../src/blocks/ListItem/NumberedListItem/block.ts","../src/blocks/ListItem/ToggleListItem/block.ts","../src/blocks/PageBreak/block.ts","../src/blocks/Paragraph/block.ts","../src/blocks/Quote/block.ts","../src/blocks/Table/TableExtension.ts","../src/blocks/Table/block.ts","../src/blocks/Video/parseVideoElement.ts","../src/blocks/Video/block.ts","../src/blocks/File/helpers/uploadToTmpFilesDotOrg_DEV_ONLY.ts","../src/blocks/defaultBlockTypeGuards.ts","../src/extensions/SuggestionMenu/getDefaultSlashMenuItems.ts","../src/blocks/PageBreak/getPageBreakSlashMenuItems.ts","../src/blocks/defaultBlocks.ts","../src/blocks/BlockNoteSchema.ts"],"sourcesContent":["import {\n  combineTransactionSteps,\n  Extension,\n  findChildrenInRange,\n  getChangedRanges,\n} from \"@tiptap/core\";\nimport { Fragment, Slice } from \"prosemirror-model\";\nimport { Plugin, PluginKey } from \"prosemirror-state\";\nimport { v4 } from \"uuid\";\n\n/**\n * Code from Tiptap UniqueID extension (https://tiptap.dev/api/extensions/unique-id)\n * This extension is licensed under MIT (even though it's part of Tiptap pro).\n *\n * If you're a user of BlockNote, we still recommend to support their awesome work and become a sponsor!\n * https://tiptap.dev/pro\n */\n\n/**\n * Removes duplicated values within an array.\n * Supports numbers, strings and objects.\n */\nfunction removeDuplicates(array: any, by = JSON.stringify) {\n  const seen: any = {};\n  return array.filter((item: any) => {\n    const key = by(item);\n    return Object.prototype.hasOwnProperty.call(seen, key)\n      ? false\n      : (seen[key] = true);\n  });\n}\n\n/**\n * Returns a list of duplicated items within an array.\n */\nfunction findDuplicates(items: any) {\n  const filtered = items.filter(\n    (el: any, index: number) => items.indexOf(el) !== index,\n  );\n  const duplicates = removeDuplicates(filtered);\n  return duplicates;\n}\n\nconst UniqueID = Extension.create({\n  name: \"uniqueID\",\n  // we’ll set a very high priority to make sure this runs first\n  // and is compatible with `appendTransaction` hooks of other extensions\n  priority: 10000,\n  addOptions() {\n    return {\n      attributeName: \"id\",\n      types: [],\n      setIdAttribute: false,\n      generateID: () => {\n        // Use mock ID if tests are running.\n        if (typeof window !== \"undefined\" && (window as any).__TEST_OPTIONS) {\n          const testOptions = (window as any).__TEST_OPTIONS;\n          if (testOptions.mockID === undefined) {\n            testOptions.mockID = 0;\n          } else {\n            testOptions.mockID++;\n          }\n\n          return testOptions.mockID.toString() as string;\n        }\n\n        return v4();\n      },\n      filterTransaction: null,\n    };\n  },\n  addGlobalAttributes() {\n    return [\n      {\n        types: this.options.types,\n        attributes: {\n          [this.options.attributeName]: {\n            default: null,\n            parseHTML: (element) =>\n              element.getAttribute(`data-${this.options.attributeName}`),\n            renderHTML: (attributes) => {\n              const defaultIdAttributes = {\n                [`data-${this.options.attributeName}`]:\n                  attributes[this.options.attributeName],\n              };\n              if (this.options.setIdAttribute) {\n                return {\n                  ...defaultIdAttributes,\n                  id: attributes[this.options.attributeName],\n                };\n              } else {\n                return defaultIdAttributes;\n              }\n            },\n          },\n        },\n      },\n    ];\n  },\n  // check initial content for missing ids\n  // onCreate() {\n  //   // Don’t do this when the collaboration extension is active\n  //   // because this may update the content, so Y.js tries to merge these changes.\n  //   // This leads to empty block nodes.\n  //   // See: https://github.com/ueberdosis/tiptap/issues/2400\n  //   if (\n  //     this.editor.extensionManager.extensions.find(\n  //       (extension) => extension.name === \"collaboration\"\n  //     )\n  //   ) {\n  //     return;\n  //   }\n  //   const { view, state } = this.editor;\n  //   const { tr, doc } = state;\n  //   const { types, attributeName, generateID } = this.options;\n  //   const nodesWithoutId = findChildren(doc, (node) => {\n  //     return (\n  //       types.includes(node.type.name) && node.attrs[attributeName] === null\n  //     );\n  //   });\n  //   nodesWithoutId.forEach(({ node, pos }) => {\n  //     tr.setNodeMarkup(pos, undefined, {\n  //       ...node.attrs,\n  //       [attributeName]: generateID(),\n  //     });\n  //   });\n  //   tr.setMeta(\"addToHistory\", false);\n  //   view.dispatch(tr);\n  // },\n  addProseMirrorPlugins() {\n    let dragSourceElement: any = null;\n    let transformPasted = false;\n    return [\n      new Plugin({\n        key: new PluginKey(\"uniqueID\"),\n        appendTransaction: (transactions, oldState, newState) => {\n          const docChanges =\n            transactions.some((transaction) => transaction.docChanged) &&\n            !oldState.doc.eq(newState.doc);\n          const filterTransactions =\n            this.options.filterTransaction &&\n            transactions.some((tr) => !this.options.filterTransaction?.(tr));\n          if (!docChanges || filterTransactions) {\n            return;\n          }\n          const { tr } = newState;\n          const { types, attributeName, generateID } = this.options;\n          const transform = combineTransactionSteps(\n            oldState.doc,\n            transactions as any,\n          );\n          const { mapping } = transform;\n          // get changed ranges based on the old state\n          const changes = getChangedRanges(transform);\n\n          changes.forEach(({ newRange }) => {\n            const newNodes = findChildrenInRange(\n              newState.doc,\n              newRange,\n              (node) => {\n                return types.includes(node.type.name);\n              },\n            );\n            const newIds = newNodes\n              .map(({ node }) => node.attrs[attributeName])\n              .filter((id) => id !== null);\n            const duplicatedNewIds = findDuplicates(newIds);\n\n            newNodes.forEach(({ node, pos }) => {\n              // instead of checking `node.attrs[attributeName]` directly\n              // we look at the current state of the node within `tr.doc`.\n              // this helps to prevent adding new ids to the same node\n              // if the node changed multiple times within one transaction\n              const id = tr.doc.nodeAt(pos)?.attrs[attributeName];\n\n              if (id === null) {\n                // edge case, when using collaboration, yjs will set the id to null in `_forceRerender`\n                // when loading the editor\n                // this checks for this case and keeps it at initialBlockId so there will be no change\n                const initialDoc = oldState.doc.type.createAndFill()!.content;\n                const wasInitial =\n                  oldState.doc.content.findDiffStart(initialDoc) === null;\n\n                if (wasInitial) {\n                  // the old state was the \"initial content\"\n                  const jsonNode = JSON.parse(\n                    JSON.stringify(newState.doc.toJSON()),\n                  );\n                  jsonNode.content[0].content[0].attrs.id = \"initialBlockId\";\n                  // would the new state with the fix also be the \"initial content\"?\n                  if (\n                    JSON.stringify(jsonNode.content) ===\n                    JSON.stringify(initialDoc.toJSON())\n                  ) {\n                    // yes, apply the fix\n                    tr.setNodeMarkup(pos, undefined, {\n                      ...node.attrs,\n                      [attributeName]: \"initialBlockId\",\n                    });\n                    return;\n                  }\n                }\n\n                tr.setNodeMarkup(pos, undefined, {\n                  ...node.attrs,\n                  [attributeName]: generateID(),\n                });\n                return;\n              }\n              // check if the node doesn’t exist in the old state\n              const { deleted } = mapping.invert().mapResult(pos);\n              const newNode = deleted && duplicatedNewIds.includes(id);\n              if (newNode) {\n                tr.setNodeMarkup(pos, undefined, {\n                  ...node.attrs,\n                  [attributeName]: generateID(),\n                });\n              }\n            });\n          });\n          if (!tr.steps.length) {\n            return;\n          }\n          // mark the transaction as having been processed by the uniqueID plugin\n          tr.setMeta(\"uniqueID\", true);\n          return tr;\n        },\n        // we register a global drag handler to track the current drag source element\n        view(view) {\n          const handleDragstart = (event: any) => {\n            let _a;\n            dragSourceElement = (\n              (_a = view.dom.parentElement) === null || _a === void 0\n                ? void 0\n                : _a.contains(event.target)\n            )\n              ? view.dom.parentElement\n              : null;\n          };\n          window.addEventListener(\"dragstart\", handleDragstart);\n          return {\n            destroy() {\n              window.removeEventListener(\"dragstart\", handleDragstart);\n            },\n          };\n        },\n        props: {\n          // `handleDOMEvents` is called before `transformPasted` so we can do\n          // some checks before. However, `transformPasted` only runs when\n          // editor content is pasted - not external content.\n          handleDOMEvents: {\n            // only create new ids for dropped content while holding `alt`\n            // or content is dragged from another editor\n            drop: (view, event: any) => {\n              let _a;\n              if (\n                dragSourceElement !== view.dom.parentElement ||\n                ((_a = event.dataTransfer) === null || _a === void 0\n                  ? void 0\n                  : _a.effectAllowed) === \"copy\"\n              ) {\n                transformPasted = true;\n              } else {\n                transformPasted = false;\n              }\n\n              dragSourceElement = null;\n\n              return false;\n            },\n            // always create new ids on pasted content\n            paste: () => {\n              transformPasted = true;\n              return false;\n            },\n          },\n          // we’ll remove ids for every pasted node\n          // so we can create a new one within `appendTransaction`\n          transformPasted: (slice) => {\n            if (!transformPasted) {\n              return slice;\n            }\n            const { types, attributeName } = this.options;\n            const removeId = (fragment: any) => {\n              const list: any[] = [];\n              fragment.forEach((node: any) => {\n                // don’t touch text nodes\n                if (node.isText) {\n                  list.push(node);\n                  return;\n                }\n                // check for any other child nodes\n                if (!types.includes(node.type.name)) {\n                  list.push(node.copy(removeId(node.content)));\n                  return;\n                }\n                // remove id\n                const nodeWithoutId = node.type.create(\n                  {\n                    ...node.attrs,\n                    [attributeName]: null,\n                  },\n                  removeId(node.content),\n                  node.marks,\n                );\n                list.push(nodeWithoutId);\n              });\n              return Fragment.from(list);\n            };\n            // reset check\n            transformPasted = false;\n            return new Slice(\n              removeId(slice.content),\n              slice.openStart,\n              slice.openEnd,\n            );\n          },\n        },\n      }),\n    ];\n  },\n});\n\nexport { UniqueID as default, UniqueID };\n","import { Node } from \"@tiptap/core\";\nimport { PropSchema, Props } from \"../propTypes.js\";\nimport { StyleSchema, Styles } from \"../styles/types.js\";\nimport { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport { ViewMutationRecord } from \"prosemirror-view\";\n\nexport type CustomInlineContentConfig = {\n  type: string;\n  content: \"styled\" | \"none\"; // | \"plain\"\n  readonly propSchema: PropSchema;\n};\n// InlineContentConfig contains the \"schema\" info about an InlineContent type\n// i.e. what props it supports, what content it supports, etc.\nexport type InlineContentConfig = CustomInlineContentConfig | \"text\" | \"link\";\n\n// InlineContentImplementation contains the \"implementation\" info about an InlineContent element\n// such as the functions / Nodes required to render and / or serialize it\n// @ts-ignore\nexport type InlineContentImplementation<T extends InlineContentConfig> =\n  T extends \"link\" | \"text\"\n    ? undefined\n    : {\n        meta?: {\n          draggable?: boolean;\n        };\n        node: Node;\n        toExternalHTML?: (\n          inlineContent: any,\n          editor: BlockNoteEditor<any, any, any>,\n        ) =>\n          | {\n              dom: HTMLElement | DocumentFragment;\n              contentDOM?: HTMLElement;\n            }\n          | undefined;\n        render: (\n          inlineContent: any,\n          updateInlineContent: (update: any) => void,\n          editor: BlockNoteEditor<any, any, any>,\n        ) => {\n          dom: HTMLElement | DocumentFragment;\n          contentDOM?: HTMLElement;\n          ignoreMutation?: (mutation: ViewMutationRecord) => boolean;\n          destroy?: () => void;\n        };\n      };\n\nexport type InlineContentSchemaWithInlineContent<\n  IType extends string,\n  C extends InlineContentConfig,\n> = {\n  [k in IType]: C;\n};\n\n// Container for both the config and implementation of InlineContent,\n// and the type of `implementation` is based on that of the config\nexport type InlineContentSpec<T extends InlineContentConfig> = {\n  config: T;\n  implementation: InlineContentImplementation<T>;\n};\n\n// A Schema contains all the types (Configs) supported in an editor\n// The keys are the \"type\" of InlineContent elements\nexport type InlineContentSchema = Record<string, InlineContentConfig>;\n\nexport type InlineContentSpecs = {\n  text: { config: \"text\"; implementation: undefined };\n  link: { config: \"link\"; implementation: undefined };\n} & Record<string, InlineContentSpec<InlineContentConfig>>;\n\nexport type InlineContentSchemaFromSpecs<T extends InlineContentSpecs> = {\n  [K in keyof T]: T[K][\"config\"];\n};\n\nexport type CustomInlineContentFromConfig<\n  I extends CustomInlineContentConfig,\n  S extends StyleSchema,\n> = {\n  type: I[\"type\"];\n  props: Props<I[\"propSchema\"]>;\n  content: I[\"content\"] extends \"styled\"\n    ? StyledText<S>[]\n    : I[\"content\"] extends \"plain\"\n      ? string\n      : I[\"content\"] extends \"none\"\n        ? undefined\n        : never;\n};\n\nexport type InlineContentFromConfig<\n  I extends InlineContentConfig,\n  S extends StyleSchema,\n> = I extends \"text\"\n  ? StyledText<S>\n  : I extends \"link\"\n    ? Link<S>\n    : I extends CustomInlineContentConfig\n      ? CustomInlineContentFromConfig<I, S>\n      : never;\n\nexport type PartialCustomInlineContentFromConfig<\n  I extends CustomInlineContentConfig,\n  S extends StyleSchema,\n> = {\n  type: I[\"type\"];\n  props?: Props<I[\"propSchema\"]>;\n  content?: I[\"content\"] extends \"styled\"\n    ? StyledText<S>[] | string\n    : I[\"content\"] extends \"plain\"\n      ? string\n      : I[\"content\"] extends \"none\"\n        ? undefined\n        : never;\n};\n\nexport type PartialInlineContentFromConfig<\n  I extends InlineContentConfig,\n  S extends StyleSchema,\n> = I extends \"text\"\n  ? string | StyledText<S>\n  : I extends \"link\"\n    ? PartialLink<S>\n    : I extends CustomInlineContentConfig\n      ? PartialCustomInlineContentFromConfig<I, S>\n      : never;\n\nexport type StyledText<T extends StyleSchema> = {\n  type: \"text\";\n  text: string;\n  styles: Styles<T>;\n};\n\nexport type Link<T extends StyleSchema> = {\n  type: \"link\";\n  href: string;\n  content: StyledText<T>[];\n};\n\nexport type PartialLink<T extends StyleSchema> = Omit<Link<T>, \"content\"> & {\n  content: string | Link<T>[\"content\"];\n};\n\nexport type InlineContent<\n  I extends InlineContentSchema,\n  T extends StyleSchema,\n> = InlineContentFromConfig<I[keyof I], T>;\n\ntype PartialInlineContentElement<\n  I extends InlineContentSchema,\n  T extends StyleSchema,\n> = PartialInlineContentFromConfig<I[keyof I], T>;\n\nexport type PartialInlineContent<\n  I extends InlineContentSchema,\n  T extends StyleSchema,\n> = PartialInlineContentElement<I, T>[] | string;\n\nexport function isLinkInlineContent<T extends StyleSchema>(\n  content: InlineContent<any, T>,\n): content is Link<T> {\n  return content.type === \"link\";\n}\n\nexport function isPartialLinkInlineContent<T extends StyleSchema>(\n  content: PartialInlineContentElement<any, T>,\n): content is PartialLink<T> {\n  return typeof content !== \"string\" && content.type === \"link\";\n}\n\nexport function isStyledTextInlineContent<T extends StyleSchema>(\n  content: PartialInlineContentElement<any, T>,\n): content is StyledText<T> {\n  return typeof content !== \"string\" && content.type === \"text\";\n}\n","import type {\n  InlineContentSchema,\n  StyleSchema,\n  PartialInlineContent,\n  InlineContent,\n} from \"../schema\";\nimport { PartialTableCell, TableCell } from \"../schema/blocks/types.js\";\n\n/**\n * This will map a table cell to a TableCell object.\n * This is useful for when we want to get the full table cell object from a partial table cell.\n * It is guaranteed to return a new TableCell object.\n */\nexport function mapTableCell<\n  T extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  content:\n    | PartialInlineContent<T, S>\n    | PartialTableCell<T, S>\n    | TableCell<T, S>,\n): TableCell<T, S> {\n  return isTableCell(content)\n    ? { ...content }\n    : isPartialTableCell(content)\n      ? {\n          type: \"tableCell\",\n          content: ([] as InlineContent<T, S>[]).concat(content.content as any),\n          props: {\n            backgroundColor: content.props?.backgroundColor ?? \"default\",\n            textColor: content.props?.textColor ?? \"default\",\n            textAlignment: content.props?.textAlignment ?? \"left\",\n            colspan: content.props?.colspan ?? 1,\n            rowspan: content.props?.rowspan ?? 1,\n          },\n        }\n      : {\n          type: \"tableCell\",\n          content: ([] as InlineContent<T, S>[]).concat(content as any),\n          props: {\n            backgroundColor: \"default\",\n            textColor: \"default\",\n            textAlignment: \"left\",\n            colspan: 1,\n            rowspan: 1,\n          },\n        };\n}\n\nexport function isPartialTableCell<\n  T extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  content:\n    | TableCell<T, S>\n    | PartialInlineContent<T, S>\n    | PartialTableCell<T, S>\n    | undefined\n    | null,\n): content is PartialTableCell<T, S> {\n  return (\n    content !== undefined &&\n    content !== null &&\n    typeof content !== \"string\" &&\n    !Array.isArray(content) &&\n    content.type === \"tableCell\"\n  );\n}\n\nexport function isTableCell<\n  T extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  content:\n    | TableCell<T, S>\n    | PartialInlineContent<T, S>\n    | PartialTableCell<T, S>\n    | undefined\n    | null,\n): content is TableCell<T, S> {\n  return (\n    isPartialTableCell(content) &&\n    content.props !== undefined &&\n    content.content !== undefined\n  );\n}\n\nexport function getColspan(\n  cell:\n    | TableCell<any, any>\n    | PartialTableCell<any, any>\n    | PartialInlineContent<any, any>,\n): number {\n  if (isTableCell(cell)) {\n    return cell.props.colspan ?? 1;\n  }\n  return 1;\n}\n\nexport function getRowspan(\n  cell:\n    | TableCell<any, any>\n    | PartialTableCell<any, any>\n    | PartialInlineContent<any, any>,\n): number {\n  if (isTableCell(cell)) {\n    return cell.props.rowspan ?? 1;\n  }\n  return 1;\n}\n","export class UnreachableCaseError extends Error {\n  constructor(val: never) {\n    super(`Unreachable case: ${val}`);\n  }\n}\n\nexport function assertEmpty(obj: Record<string, never>, throwError = true) {\n  const { \"data-test\": dataTest, ...rest } = obj; // exclude data-test\n\n  if (Object.keys(rest).length > 0 && throwError) {\n    throw new Error(\"Object must be empty \" + JSON.stringify(obj));\n  }\n}\n\n// TODO: change for built-in version of typescript 5.4 after upgrade\nexport type NoInfer<T> = [T][T extends any ? 0 : never];\n","export const isAppleOS = () =>\n  typeof navigator !== \"undefined\" &&\n  (/Mac/.test(navigator.platform) ||\n    (/AppleWebKit/.test(navigator.userAgent) &&\n      /Mobile\\/\\w+/.test(navigator.userAgent)));\n\nexport function formatKeyboardShortcut(shortcut: string, ctrlText = \"Ctrl\") {\n  if (isAppleOS()) {\n    return shortcut.replace(\"Mod\", \"⌘\");\n  } else {\n    return shortcut.replace(\"Mod\", ctrlText);\n  }\n}\n\nexport function mergeCSSClasses(...classes: (string | false | undefined)[]) {\n  return [\n    // Converts to & from set to remove duplicates.\n    ...new Set(\n      classes\n        .filter((c) => c)\n        // Ensures that if multiple classes are passed as a single string, they\n        // are split.\n        .join(\" \")\n        .split(\" \"),\n    ),\n  ].join(\" \");\n}\n\nexport const isSafari = () =>\n  /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n","import { blockToNode } from \"../api/nodeConversions/blockToNode.js\";\nimport type { BlockNoteEditor } from \"../editor/BlockNoteEditor.js\";\nimport type {\n  BlockNoDefaults,\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../schema/index.js\";\nimport { mergeCSSClasses } from \"../util/browser.js\";\n\n// Function that creates a ProseMirror `DOMOutputSpec` for a default block.\n// Since all default blocks have the same structure (`blockContent` div with a\n// `inlineContent` element inside), this function only needs the block's name\n// for the `data-content-type` attribute of the `blockContent` element and the\n// HTML tag of the `inlineContent` element, as well as any HTML attributes to\n// add to those.\nexport function createDefaultBlockDOMOutputSpec(\n  blockName: string,\n  htmlTag: string,\n  blockContentHTMLAttributes: Record<string, string>,\n  inlineContentHTMLAttributes: Record<string, string>,\n) {\n  const blockContent = document.createElement(\"div\");\n  blockContent.className = mergeCSSClasses(\n    \"bn-block-content\",\n    blockContentHTMLAttributes.class,\n  );\n  blockContent.setAttribute(\"data-content-type\", blockName);\n  for (const [attribute, value] of Object.entries(blockContentHTMLAttributes)) {\n    if (attribute !== \"class\") {\n      blockContent.setAttribute(attribute, value);\n    }\n  }\n\n  const inlineContent = document.createElement(htmlTag);\n  inlineContent.className = mergeCSSClasses(\n    \"bn-inline-content\",\n    inlineContentHTMLAttributes.class,\n  );\n  for (const [attribute, value] of Object.entries(\n    inlineContentHTMLAttributes,\n  )) {\n    if (attribute !== \"class\") {\n      inlineContent.setAttribute(attribute, value);\n    }\n  }\n\n  blockContent.appendChild(inlineContent);\n\n  return {\n    dom: blockContent,\n    contentDOM: inlineContent,\n  };\n}\n\n// Function used to convert default blocks to HTML. It uses the corresponding\n// node's `renderHTML` method to do the conversion by using a default\n// `DOMSerializer`.\nexport const defaultBlockToHTML = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  block: BlockNoDefaults<BSchema, I, S>,\n  editor: BlockNoteEditor<BSchema, I, S>,\n): {\n  dom: HTMLElement;\n  contentDOM?: HTMLElement;\n} => {\n  let node = blockToNode(block, editor.pmSchema);\n\n  if (node.type.name === \"blockContainer\") {\n    // for regular blocks, get the toDOM spec from the blockContent node\n    node = node.firstChild!;\n  }\n\n  const toDOM = editor.pmSchema.nodes[node.type.name].spec.toDOM;\n\n  if (toDOM === undefined) {\n    throw new Error(\n      \"This block has no default HTML serialization as its corresponding TipTap node doesn't implement `renderHTML`.\",\n    );\n  }\n\n  const renderSpec = toDOM(node);\n\n  if (typeof renderSpec !== \"object\" || !(\"dom\" in renderSpec)) {\n    throw new Error(\n      \"Cannot use this block's default HTML serialization as its corresponding TipTap node's `renderHTML` function does not return an object with the `dom` property.\",\n    );\n  }\n\n  return renderSpec as {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n  };\n};\n\n// Function that merges all paragraphs into a single one separated by line breaks.\n// This is used when parsing blocks like list items and table cells, as they may\n// contain multiple paragraphs that ProseMirror will not be able to handle\n// properly.\nexport function mergeParagraphs(element: HTMLElement, separator = \"<br>\") {\n  const paragraphs = element.querySelectorAll(\"p\");\n  if (paragraphs.length > 1) {\n    const firstParagraph = paragraphs[0];\n    for (let i = 1; i < paragraphs.length; i++) {\n      const paragraph = paragraphs[i];\n      firstParagraph.innerHTML += separator + paragraph.innerHTML;\n      paragraph.remove();\n    }\n  }\n}\n","export function camelToDataKebab(str: string): string {\n  return \"data-\" + str.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\n\nexport function filenameFromURL(url: string): string {\n  const parts = url.split(\"/\");\n  if (\n    !parts.length || // invalid?\n    parts[parts.length - 1] === \"\" // for example, URL ends in a directory-like trailing slash\n  ) {\n    // in this case just return the original url\n    return url;\n  }\n  return parts[parts.length - 1];\n}\n\nexport function isVideoUrl(url: string) {\n  const videoExtensions = [\n    \"mp4\",\n    \"webm\",\n    \"ogg\",\n    \"mov\",\n    \"mkv\",\n    \"flv\",\n    \"avi\",\n    \"wmv\",\n    \"m4v\",\n  ];\n  try {\n    const pathname = new URL(url).pathname;\n    const ext = pathname.split(\".\").pop()?.toLowerCase() || \"\";\n    return videoExtensions.includes(ext);\n  } catch (_) {\n    return false;\n  }\n}\n","import { Attribute, Attributes, Editor, Node } from \"@tiptap/core\";\nimport { defaultBlockToHTML } from \"../../blocks/defaultBlockHelpers.js\";\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport { BlockNoteExtension } from \"../../editor/BlockNoteExtension.js\";\nimport { mergeCSSClasses } from \"../../util/browser.js\";\nimport { camelToDataKebab } from \"../../util/string.js\";\nimport { InlineContentSchema } from \"../inlineContent/types.js\";\nimport { PropSchema, Props } from \"../propTypes.js\";\nimport { StyleSchema } from \"../styles/types.js\";\nimport {\n  BlockConfig,\n  BlockSchemaWithBlock,\n  LooseBlockSpec,\n  SpecificBlock,\n} from \"./types.js\";\n\n// Function that uses the 'propSchema' of a blockConfig to create a TipTap\n// node's `addAttributes` property.\n// TODO: extract function\nexport function propsToAttributes(propSchema: PropSchema): Attributes {\n  const tiptapAttributes: Record<string, Attribute> = {};\n\n  Object.entries(propSchema).forEach(([name, spec]) => {\n    tiptapAttributes[name] = {\n      default: spec.default,\n      keepOnSplit: true,\n      // Props are displayed in kebab-case as HTML attributes. If a prop's\n      // value is the same as its default, we don't display an HTML\n      // attribute for it.\n      parseHTML: (element) => {\n        const value = element.getAttribute(camelToDataKebab(name));\n\n        if (value === null) {\n          return null;\n        }\n\n        if (\n          (spec.default === undefined && spec.type === \"boolean\") ||\n          (spec.default !== undefined && typeof spec.default === \"boolean\")\n        ) {\n          if (value === \"true\") {\n            return true;\n          }\n\n          if (value === \"false\") {\n            return false;\n          }\n\n          return null;\n        }\n\n        if (\n          (spec.default === undefined && spec.type === \"number\") ||\n          (spec.default !== undefined && typeof spec.default === \"number\")\n        ) {\n          const asNumber = parseFloat(value);\n          const isNumeric =\n            !Number.isNaN(asNumber) && Number.isFinite(asNumber);\n\n          if (isNumeric) {\n            return asNumber;\n          }\n\n          return null;\n        }\n\n        return value;\n      },\n      renderHTML: (attributes) => {\n        // don't render to html if the value is the same as the default\n        return attributes[name] !== spec.default\n          ? {\n              [camelToDataKebab(name)]: attributes[name],\n            }\n          : {};\n      },\n    };\n  });\n\n  return tiptapAttributes;\n}\n\n// Used to figure out which block should be rendered. This block is then used to\n// create the node view.\nexport function getBlockFromPos<\n  BType extends string,\n  Config extends BlockConfig,\n  BSchema extends BlockSchemaWithBlock<BType, Config>,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  getPos: () => number | undefined,\n  editor: BlockNoteEditor<BSchema, I, S>,\n  tipTapEditor: Editor,\n  type: BType,\n) {\n  const pos = getPos();\n  // Gets position of the node\n  if (pos === undefined) {\n    throw new Error(\"Cannot find node position\");\n  }\n  // Gets parent blockContainer node\n  const blockContainer = tipTapEditor.state.doc.resolve(pos!).node();\n  // Gets block identifier\n  const blockIdentifier = blockContainer.attrs.id;\n\n  if (!blockIdentifier) {\n    throw new Error(\"Block doesn't have id\");\n  }\n\n  // Gets the block\n  const block = editor.getBlock(blockIdentifier)! as SpecificBlock<\n    BSchema,\n    BType,\n    I,\n    S\n  >;\n  if (block.type !== type) {\n    throw new Error(\"Block type does not match\");\n  }\n\n  return block;\n}\n\n// Function that wraps the `dom` element returned from 'blockConfig.render' in a\n// `blockContent` div, which contains the block type and props as HTML\n// attributes. If `blockConfig.render` also returns a `contentDOM`, it also adds\n// an `inlineContent` class to it.\nexport function wrapInBlockStructure<\n  BType extends string,\n  PSchema extends PropSchema,\n>(\n  element: {\n    dom: HTMLElement | DocumentFragment;\n    contentDOM?: HTMLElement;\n    destroy?: () => void;\n  },\n  blockType: BType,\n  blockProps: Partial<Props<PSchema>>,\n  propSchema: PSchema,\n  isFileBlock = false,\n  domAttributes?: Record<string, string>,\n): {\n  dom: HTMLElement;\n  contentDOM?: HTMLElement;\n  destroy?: () => void;\n} {\n  // Creates `blockContent` element\n  const blockContent = document.createElement(\"div\");\n\n  // Adds custom HTML attributes\n  if (domAttributes !== undefined) {\n    for (const [attr, value] of Object.entries(domAttributes)) {\n      if (attr !== \"class\") {\n        blockContent.setAttribute(attr, value);\n      }\n    }\n  }\n  // Sets blockContent class\n  blockContent.className = mergeCSSClasses(\n    \"bn-block-content\",\n    domAttributes?.class || \"\",\n  );\n  // Sets content type attribute\n  blockContent.setAttribute(\"data-content-type\", blockType);\n  // Adds props as HTML attributes in kebab-case with \"data-\" prefix. Skips props\n  // which are already added as HTML attributes to the parent `blockContent`\n  // element (inheritedProps) and props set to their default values.\n  for (const [prop, value] of Object.entries(blockProps)) {\n    const spec = propSchema[prop];\n    const defaultValue = spec.default;\n    if (value !== defaultValue) {\n      blockContent.setAttribute(camelToDataKebab(prop), value);\n    }\n  }\n  // Adds file block attribute\n  if (isFileBlock) {\n    blockContent.setAttribute(\"data-file-block\", \"\");\n  }\n\n  blockContent.appendChild(element.dom);\n\n  if (element.contentDOM) {\n    element.contentDOM.className = mergeCSSClasses(\n      \"bn-inline-content\",\n      element.contentDOM.className,\n    );\n  }\n\n  return {\n    ...element,\n    dom: blockContent,\n  };\n}\n\nexport function createBlockSpecFromTiptapNode<\n  const T extends {\n    node: Node;\n    type: string;\n    content: \"inline\" | \"table\" | \"none\";\n  },\n  P extends PropSchema,\n>(\n  config: T,\n  propSchema: P,\n  extensions?: BlockNoteExtension<any>[],\n): LooseBlockSpec<T[\"type\"], P, T[\"content\"]> {\n  return {\n    config: {\n      type: config.type as T[\"type\"],\n      content: config.content,\n      propSchema,\n    },\n    implementation: {\n      node: config.node,\n      render: defaultBlockToHTML,\n      toExternalHTML: defaultBlockToHTML,\n    },\n    extensions,\n  };\n}\n","import { Editor, Node } from \"@tiptap/core\";\nimport { DOMParser, Fragment, TagParseRule } from \"@tiptap/pm/model\";\nimport { NodeView } from \"@tiptap/pm/view\";\nimport { mergeParagraphs } from \"../../blocks/defaultBlockHelpers.js\";\nimport { BlockNoteExtension } from \"../../editor/BlockNoteExtension.js\";\nimport { PropSchema } from \"../propTypes.js\";\nimport {\n  getBlockFromPos,\n  propsToAttributes,\n  wrapInBlockStructure,\n} from \"./internal.js\";\nimport {\n  BlockConfig,\n  BlockImplementation,\n  BlockSpec,\n  LooseBlockSpec,\n} from \"./types.js\";\n\n// Function that causes events within non-selectable blocks to be handled by the\n// browser instead of the editor.\nexport function applyNonSelectableBlockFix(nodeView: NodeView, editor: Editor) {\n  nodeView.stopEvent = (event) => {\n    // Blurs the editor on mouse down as the block is non-selectable. This is\n    // mainly done to prevent UI elements like the formatting toolbar from being\n    // visible while content within a non-selectable block is selected.\n    if (event.type === \"mousedown\") {\n      setTimeout(() => {\n        editor.view.dom.blur();\n      }, 10);\n    }\n\n    return true;\n  };\n}\n\n// Function that uses the 'parse' function of a blockConfig to create a\n// TipTap node's `parseHTML` property. This is only used for parsing content\n// from the clipboard.\nexport function getParseRules<\n  TName extends string,\n  TProps extends PropSchema,\n  TContent extends \"inline\" | \"none\" | \"table\",\n>(\n  config: BlockConfig<TName, TProps, TContent>,\n  implementation: BlockImplementation<TName, TProps, TContent>,\n) {\n  const rules: TagParseRule[] = [\n    {\n      tag: \"[data-content-type=\" + config.type + \"]\",\n      contentElement: \".bn-inline-content\",\n    },\n  ];\n\n  if (implementation.parse) {\n    rules.push({\n      tag: \"*\",\n      getAttrs(node: string | HTMLElement) {\n        if (typeof node === \"string\") {\n          return false;\n        }\n\n        const props = implementation.parse?.(node);\n\n        if (props === undefined) {\n          return false;\n        }\n\n        return props;\n      },\n      getContent:\n        config.content === \"inline\" || config.content === \"none\"\n          ? (node, schema) => {\n              if (implementation.parseContent) {\n                return implementation.parseContent({\n                  el: node as HTMLElement,\n                  schema,\n                });\n              }\n\n              if (config.content === \"inline\") {\n                // Parse the inline content if it exists\n                const element = node as HTMLElement;\n\n                // Clone to avoid modifying the original\n                const clone = element.cloneNode(true) as HTMLElement;\n\n                // Merge multiple paragraphs into one with line breaks\n                mergeParagraphs(\n                  clone,\n                  implementation.meta?.code ? \"\\n\" : \"<br>\",\n                );\n\n                // Parse the content directly as a paragraph to extract inline content\n                const parser = DOMParser.fromSchema(schema);\n                const parsed = parser.parse(clone, {\n                  topNode: schema.nodes.paragraph.create(),\n                });\n\n                return parsed.content;\n              }\n              return Fragment.empty;\n            }\n          : undefined,\n    });\n  }\n  //     getContent(node, schema) {\n  //       const block = blockConfig.parse?.(node as HTMLElement);\n  //\n  //       if (block !== undefined && block.content !== undefined) {\n  //         return Fragment.from(\n  //           typeof block.content === \"string\"\n  //             ? schema.text(block.content)\n  //             : inlineContentToNodes(block.content, schema)\n  //         );\n  //       }\n  //\n  //       return Fragment.empty;\n  //     },\n  //   });\n  // }\n\n  return rules;\n}\n\n// A function to create custom block for API consumers\n// we want to hide the tiptap node from API consumers and provide a simpler API surface instead\nexport function addNodeAndExtensionsToSpec<\n  TName extends string,\n  TProps extends PropSchema,\n  TContent extends \"inline\" | \"none\" | \"table\",\n>(\n  blockConfig: BlockConfig<TName, TProps, TContent>,\n  blockImplementation: BlockImplementation<TName, TProps, TContent>,\n  extensions?: BlockNoteExtension<any>[],\n  priority?: number,\n): LooseBlockSpec<TName, TProps, TContent> {\n  const node =\n    ((blockImplementation as any).node as Node) ||\n    Node.create({\n      name: blockConfig.type,\n      content: (blockConfig.content === \"inline\"\n        ? \"inline*\"\n        : blockConfig.content === \"none\"\n          ? \"\"\n          : blockConfig.content) as TContent extends \"inline\" ? \"inline*\" : \"\",\n      group: \"blockContent\",\n      selectable: blockImplementation.meta?.selectable ?? true,\n      isolating: blockImplementation.meta?.isolating ?? true,\n      code: blockImplementation.meta?.code ?? false,\n      defining: blockImplementation.meta?.defining ?? true,\n      priority,\n      addAttributes() {\n        return propsToAttributes(blockConfig.propSchema);\n      },\n\n      parseHTML() {\n        return getParseRules(blockConfig, blockImplementation);\n      },\n\n      renderHTML({ HTMLAttributes }) {\n        // renderHTML is used for copy/pasting content from the editor back into\n        // the editor, so we need to make sure the `blockContent` element is\n        // structured correctly as this is what's used for parsing blocks. We\n        // just render a placeholder div inside as the `blockContent` element\n        // already has all the information needed for proper parsing.\n        const div = document.createElement(\"div\");\n        return wrapInBlockStructure(\n          {\n            dom: div,\n            contentDOM: blockConfig.content === \"inline\" ? div : undefined,\n          },\n          blockConfig.type,\n          {},\n          blockConfig.propSchema,\n          blockImplementation.meta?.fileBlockAccept !== undefined,\n          HTMLAttributes,\n        );\n      },\n\n      addNodeView() {\n        return (props) => {\n          // Gets the BlockNote editor instance\n          const editor = this.options.editor;\n          // Gets the block\n          const block = getBlockFromPos(\n            props.getPos,\n            editor,\n            this.editor,\n            blockConfig.type,\n          );\n          // Gets the custom HTML attributes for `blockContent` nodes\n          const blockContentDOMAttributes =\n            this.options.domAttributes?.blockContent || {};\n\n          const nodeView = blockImplementation.render.call(\n            { blockContentDOMAttributes, props, renderType: \"nodeView\" },\n            block as any,\n            editor as any,\n          );\n\n          if (blockImplementation.meta?.selectable === false) {\n            applyNonSelectableBlockFix(nodeView, this.editor);\n          }\n\n          // See explanation for why `update` is not implemented for NodeViews\n          // https://github.com/TypeCellOS/BlockNote/pull/1904#discussion_r2313461464\n          return nodeView;\n        };\n      },\n    });\n\n  if (node.name !== blockConfig.type) {\n    throw new Error(\n      \"Node name does not match block type. This is a bug in BlockNote.\",\n    );\n  }\n\n  return {\n    config: blockConfig,\n    implementation: {\n      ...blockImplementation,\n      node,\n      render(block, editor) {\n        const blockContentDOMAttributes =\n          node.options.domAttributes?.blockContent || {};\n\n        return blockImplementation.render.call(\n          {\n            blockContentDOMAttributes,\n            props: undefined,\n            renderType: \"dom\",\n          },\n          block as any,\n          editor as any,\n        );\n      },\n      // TODO: this should not have wrapInBlockStructure and generally be a lot simpler\n      // post-processing in externalHTMLExporter should not be necessary\n      toExternalHTML: (block, editor) => {\n        const blockContentDOMAttributes =\n          node.options.domAttributes?.blockContent || {};\n\n        return (\n          blockImplementation.toExternalHTML?.call(\n            { blockContentDOMAttributes },\n            block as any,\n            editor as any,\n          ) ??\n          blockImplementation.render.call(\n            { blockContentDOMAttributes, renderType: \"dom\", props: undefined },\n            block as any,\n            editor as any,\n          )\n        );\n      },\n    },\n    extensions,\n  };\n}\n\n/**\n * Helper function to create a block config.\n */\nexport function createBlockConfig<\n  TCallback extends (\n    options: Partial<Record<string, any>>,\n  ) => BlockConfig<any, any, any>,\n  TOptions extends Parameters<TCallback>[0],\n  TName extends ReturnType<TCallback>[\"type\"],\n  TProps extends ReturnType<TCallback>[\"propSchema\"],\n  TContent extends ReturnType<TCallback>[\"content\"],\n>(\n  callback: TCallback,\n): TOptions extends undefined\n  ? () => BlockConfig<TName, TProps, TContent>\n  : (options: TOptions) => BlockConfig<TName, TProps, TContent> {\n  return callback as any;\n}\n\n/**\n * Helper function to create a block definition.\n * Can accept either functions that return the required objects, or the objects directly.\n */\nexport function createBlockSpec<\n  const TName extends string,\n  const TProps extends PropSchema,\n  const TContent extends \"inline\" | \"none\",\n  const TOptions extends Partial<Record<string, any>> | undefined = undefined,\n>(\n  blockConfigOrCreator: BlockConfig<TName, TProps, TContent>,\n  blockImplementationOrCreator:\n    | BlockImplementation<TName, TProps, TContent>\n    | (TOptions extends undefined\n        ? () => BlockImplementation<TName, TProps, TContent>\n        : (\n            options: Partial<TOptions>,\n          ) => BlockImplementation<TName, TProps, TContent>),\n  extensionsOrCreator?:\n    | BlockNoteExtension<any>[]\n    | (TOptions extends undefined\n        ? () => BlockNoteExtension<any>[]\n        : (options: Partial<TOptions>) => BlockNoteExtension<any>[]),\n): (options?: Partial<TOptions>) => BlockSpec<TName, TProps, TContent>;\nexport function createBlockSpec<\n  const TName extends string,\n  const TProps extends PropSchema,\n  const TContent extends \"inline\" | \"none\",\n  const BlockConf extends BlockConfig<TName, TProps, TContent>,\n  const TOptions extends Partial<Record<string, any>>,\n>(\n  blockCreator: (options: Partial<TOptions>) => BlockConf,\n  blockImplementationOrCreator:\n    | BlockImplementation<\n        BlockConf[\"type\"],\n        BlockConf[\"propSchema\"],\n        BlockConf[\"content\"]\n      >\n    | (TOptions extends undefined\n        ? () => BlockImplementation<\n            BlockConf[\"type\"],\n            BlockConf[\"propSchema\"],\n            BlockConf[\"content\"]\n          >\n        : (\n            options: Partial<TOptions>,\n          ) => BlockImplementation<\n            BlockConf[\"type\"],\n            BlockConf[\"propSchema\"],\n            BlockConf[\"content\"]\n          >),\n  extensionsOrCreator?:\n    | BlockNoteExtension<any>[]\n    | (TOptions extends undefined\n        ? () => BlockNoteExtension<any>[]\n        : (options: Partial<TOptions>) => BlockNoteExtension<any>[]),\n): (\n  options?: Partial<TOptions>,\n) => BlockSpec<\n  BlockConf[\"type\"],\n  BlockConf[\"propSchema\"],\n  BlockConf[\"content\"]\n>;\nexport function createBlockSpec<\n  const TName extends string,\n  const TProps extends PropSchema,\n  const TContent extends \"inline\" | \"none\",\n  const TOptions extends Partial<Record<string, any>> | undefined = undefined,\n>(\n  blockConfigOrCreator:\n    | BlockConfig<TName, TProps, TContent>\n    | (TOptions extends undefined\n        ? () => BlockConfig<TName, TProps, TContent>\n        : (options: Partial<TOptions>) => BlockConfig<TName, TProps, TContent>),\n  blockImplementationOrCreator:\n    | BlockImplementation<TName, TProps, TContent>\n    | (TOptions extends undefined\n        ? () => BlockImplementation<TName, TProps, TContent>\n        : (\n            options: Partial<TOptions>,\n          ) => BlockImplementation<TName, TProps, TContent>),\n  extensionsOrCreator?:\n    | BlockNoteExtension<any>[]\n    | (TOptions extends undefined\n        ? () => BlockNoteExtension<any>[]\n        : (options: Partial<TOptions>) => BlockNoteExtension<any>[]),\n): (options?: Partial<TOptions>) => BlockSpec<TName, TProps, TContent> {\n  return (options = {} as TOptions) => {\n    const blockConfig =\n      typeof blockConfigOrCreator === \"function\"\n        ? blockConfigOrCreator(options as any)\n        : blockConfigOrCreator;\n\n    const blockImplementation =\n      typeof blockImplementationOrCreator === \"function\"\n        ? blockImplementationOrCreator(options as any)\n        : blockImplementationOrCreator;\n\n    const extensions = extensionsOrCreator\n      ? typeof extensionsOrCreator === \"function\"\n        ? extensionsOrCreator(options as any)\n        : extensionsOrCreator\n      : undefined;\n\n    return {\n      config: blockConfig,\n      implementation: {\n        ...blockImplementation,\n        // TODO: this should not have wrapInBlockStructure and generally be a lot simpler\n        // post-processing in externalHTMLExporter should not be necessary\n        toExternalHTML(block, editor) {\n          const output = blockImplementation.toExternalHTML?.call(\n            { blockContentDOMAttributes: this.blockContentDOMAttributes },\n            block as any,\n            editor as any,\n          );\n\n          if (output === undefined) {\n            return undefined;\n          }\n\n          return wrapInBlockStructure(\n            output,\n            block.type,\n            block.props,\n            blockConfig.propSchema,\n            blockImplementation.meta?.fileBlockAccept !== undefined,\n          );\n        },\n        render(block, editor) {\n          const output = blockImplementation.render.call(\n            {\n              blockContentDOMAttributes: this.blockContentDOMAttributes,\n              renderType: this.renderType,\n              props: this.props as any,\n            },\n            block as any,\n            editor as any,\n          );\n\n          const nodeView = wrapInBlockStructure(\n            output,\n            block.type,\n            block.props,\n            blockConfig.propSchema,\n            blockImplementation.meta?.fileBlockAccept !== undefined,\n            this.blockContentDOMAttributes,\n          ) satisfies NodeView;\n\n          return nodeView;\n        },\n      },\n      extensions: extensions,\n    };\n  };\n}\n","import { Node, ResolvedPos } from \"prosemirror-model\";\nimport { EditorState, Transaction } from \"prosemirror-state\";\n\ntype SingleBlockInfo = {\n  node: Node;\n  beforePos: number;\n  afterPos: number;\n};\n\nexport type BlockInfo = {\n  /**\n   * The outer node that represents a BlockNote block. This is the node that has the ID.\n   * Most of the time, this will be a blockContainer node, but it could also be a Column or ColumnList\n   */\n  bnBlock: SingleBlockInfo;\n  /**\n   * The type of BlockNote block that this node represents.\n   * When dealing with a blockContainer, this is retrieved from the blockContent node, otherwise it's retrieved from the bnBlock node.\n   */\n  blockNoteType: string;\n} & (\n  | {\n      // In case we're not dealing with a BlockContainer, we're dealing with a \"wrapper node\" (like a Column or ColumnList), so it will always have children\n\n      /**\n       * The Prosemirror node that holds block.children. For non-blockContainer, this node will be the same as bnBlock.\n       */\n      childContainer: SingleBlockInfo;\n      isBlockContainer: false;\n    }\n  | {\n      /**\n       * The Prosemirror node that holds block.children. For blockContainers, this is the blockGroup node, if it exists.\n       */\n      childContainer?: SingleBlockInfo;\n      /**\n       * The Prosemirror node that wraps block.content and has most of the props\n       */\n      blockContent: SingleBlockInfo;\n      /**\n       * Whether bnBlock is a blockContainer node\n       */\n      isBlockContainer: true;\n    }\n);\n\n/**\n * Retrieves the position just before the nearest block node in a ProseMirror\n * doc, relative to a position. If the position is within a block node or its\n * descendants, the position just before it is returned. If the position is not\n * within a block node or its descendants, the position just before the next\n * closest block node is returned. If the position is beyond the last block, the\n * position just before the last block is returned.\n * @param doc The ProseMirror doc.\n * @param pos An integer position in the document.\n * @returns The position just before the nearest blockContainer node.\n */\nexport function getNearestBlockPos(doc: Node, pos: number) {\n  const $pos = doc.resolve(pos);\n\n  // Checks if the position provided is already just before a block node, in\n  // which case we return the position.\n  if ($pos.nodeAfter && $pos.nodeAfter.type.isInGroup(\"bnBlock\")) {\n    return {\n      posBeforeNode: $pos.pos,\n      node: $pos.nodeAfter,\n    };\n  }\n\n  // Checks the node containing the position and its ancestors until a\n  // block node is found and returned.\n  let depth = $pos.depth;\n  let node = $pos.node(depth);\n  while (depth > 0) {\n    if (node.type.isInGroup(\"bnBlock\")) {\n      return {\n        posBeforeNode: $pos.before(depth),\n        node: node,\n      };\n    }\n\n    depth--;\n    node = $pos.node(depth);\n  }\n\n  // If the position doesn't lie within a block node, we instead find the\n  // position of the next closest one. If the position is beyond the last block,\n  // we return the position of the last block. While running `doc.descendants`\n  // is expensive, this case should be very rarely triggered. However, it's\n  // possible for the position to sometimes be beyond the last block node. This\n  // is a problem specifically when using the collaboration plugin.\n  const allBlockContainerPositions: number[] = [];\n  doc.descendants((node, pos) => {\n    if (node.type.isInGroup(\"bnBlock\")) {\n      allBlockContainerPositions.push(pos);\n    }\n  });\n\n  // eslint-disable-next-line no-console\n  console.warn(`Position ${pos} is not within a blockContainer node.`);\n\n  const resolvedPos = doc.resolve(\n    allBlockContainerPositions.find((position) => position >= pos) ||\n      allBlockContainerPositions[allBlockContainerPositions.length - 1],\n  );\n  return {\n    posBeforeNode: resolvedPos.pos,\n    node: resolvedPos.nodeAfter!,\n  };\n}\n\n/**\n * Gets information regarding the ProseMirror nodes that make up a block in a\n * BlockNote document. This includes the main `blockContainer` node, the\n * `blockContent` node with the block's main body, and the optional `blockGroup`\n * node which contains the block's children. As well as the nodes, also returns\n * the ProseMirror positions just before & after each node.\n * @param node The main `blockContainer` node that the block information should\n * be retrieved from,\n * @param bnBlockBeforePosOffset the position just before the\n * `blockContainer` node in the document.\n */\nexport function getBlockInfoWithManualOffset(\n  node: Node,\n  bnBlockBeforePosOffset: number,\n): BlockInfo {\n  if (!node.type.isInGroup(\"bnBlock\")) {\n    throw new Error(\n      `Attempted to get bnBlock node at position but found node of different type ${node.type.name}`,\n    );\n  }\n\n  const bnBlockNode = node;\n  const bnBlockBeforePos = bnBlockBeforePosOffset;\n  const bnBlockAfterPos = bnBlockBeforePos + bnBlockNode.nodeSize;\n\n  const bnBlock: SingleBlockInfo = {\n    node: bnBlockNode,\n    beforePos: bnBlockBeforePos,\n    afterPos: bnBlockAfterPos,\n  };\n\n  if (bnBlockNode.type.name === \"blockContainer\") {\n    let blockContent: SingleBlockInfo | undefined;\n    let blockGroup: SingleBlockInfo | undefined;\n\n    bnBlockNode.forEach((node, offset) => {\n      if (node.type.spec.group === \"blockContent\") {\n        // console.log(beforePos, offset);\n        const blockContentNode = node;\n        const blockContentBeforePos = bnBlockBeforePos + offset + 1;\n        const blockContentAfterPos = blockContentBeforePos + node.nodeSize;\n\n        blockContent = {\n          node: blockContentNode,\n          beforePos: blockContentBeforePos,\n          afterPos: blockContentAfterPos,\n        };\n      } else if (node.type.name === \"blockGroup\") {\n        const blockGroupNode = node;\n        const blockGroupBeforePos = bnBlockBeforePos + offset + 1;\n        const blockGroupAfterPos = blockGroupBeforePos + node.nodeSize;\n\n        blockGroup = {\n          node: blockGroupNode,\n          beforePos: blockGroupBeforePos,\n          afterPos: blockGroupAfterPos,\n        };\n      }\n    });\n\n    if (!blockContent) {\n      throw new Error(\n        `blockContainer node does not contain a blockContent node in its children: ${bnBlockNode}`,\n      );\n    }\n\n    return {\n      isBlockContainer: true,\n      bnBlock,\n      blockContent,\n      childContainer: blockGroup,\n      blockNoteType: blockContent.node.type.name,\n    };\n  } else {\n    if (!bnBlock.node.type.isInGroup(\"childContainer\")) {\n      throw new Error(\n        `bnBlock node is not in the childContainer group: ${bnBlock.node}`,\n      );\n    }\n\n    return {\n      isBlockContainer: false,\n      bnBlock: bnBlock,\n      childContainer: bnBlock,\n      blockNoteType: bnBlock.node.type.name,\n    };\n  }\n}\n\n/**\n * Gets information regarding the ProseMirror nodes that make up a block in a\n * BlockNote document. This includes the main `blockContainer` node, the\n * `blockContent` node with the block's main body, and the optional `blockGroup`\n * node which contains the block's children. As well as the nodes, also returns\n * the ProseMirror positions just before & after each node.\n * @param posInfo An object with the main `blockContainer` node that the block\n * information should be retrieved from, and the position just before it in the\n * document.\n */\nexport function getBlockInfo(posInfo: { posBeforeNode: number; node: Node }) {\n  return getBlockInfoWithManualOffset(posInfo.node, posInfo.posBeforeNode);\n}\n\n/**\n * Gets information regarding the ProseMirror nodes that make up a block from a\n * resolved position just before the `blockContainer` node in the document that\n * corresponds to it.\n * @param resolvedPos The resolved position just before the `blockContainer`\n * node.\n */\nexport function getBlockInfoFromResolvedPos(resolvedPos: ResolvedPos) {\n  if (!resolvedPos.nodeAfter) {\n    throw new Error(\n      `Attempted to get blockContainer node at position ${resolvedPos.pos} but a node at this position does not exist`,\n    );\n  }\n  return getBlockInfoWithManualOffset(resolvedPos.nodeAfter, resolvedPos.pos);\n}\n\n/**\n * Gets information regarding the ProseMirror nodes that make up a block. The\n * block chosen is the one currently containing the current ProseMirror\n * selection.\n * @param state The ProseMirror editor state.\n */\nexport function getBlockInfoFromSelection(state: EditorState) {\n  const posInfo = getNearestBlockPos(state.doc, state.selection.anchor);\n\n  return getBlockInfo(posInfo);\n}\n\n/**\n * Gets information regarding the ProseMirror nodes that make up a block. The\n * block chosen is the one currently containing the current ProseMirror\n * selection.\n * @param tr The ProseMirror transaction.\n */\nexport function getBlockInfoFromTransaction(tr: Transaction) {\n  const posInfo = getNearestBlockPos(tr.doc, tr.selection.anchor);\n\n  return getBlockInfo(posInfo);\n}\n","import type { Node, Schema } from \"prosemirror-model\";\nimport { Transform } from \"prosemirror-transform\";\nimport type { BlockNoteEditor } from \"../editor/BlockNoteEditor.js\";\nimport { BlockNoteSchema } from \"../blocks/BlockNoteSchema.js\";\nimport type { BlockSchema } from \"../schema/blocks/types.js\";\nimport type { InlineContentSchema } from \"../schema/inlineContent/types.js\";\nimport type { StyleSchema } from \"../schema/styles/types.js\";\n\nexport function getPmSchema(trOrNode: Transform | Node) {\n  if (\"doc\" in trOrNode) {\n    return trOrNode.doc.type.schema;\n  }\n  return trOrNode.type.schema;\n}\n\nfunction getBlockNoteEditor<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(schema: Schema): BlockNoteEditor<BSchema, I, S> {\n  return schema.cached.blockNoteEditor as BlockNoteEditor<BSchema, I, S>;\n}\n\nexport function getBlockNoteSchema<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(schema: Schema): BlockNoteSchema<BSchema, I, S> {\n  return getBlockNoteEditor(schema).schema as unknown as BlockNoteSchema<\n    BSchema,\n    I,\n    S\n  >;\n}\n\nexport function getBlockSchema<BSchema extends BlockSchema>(\n  schema: Schema,\n): BSchema {\n  return getBlockNoteSchema(schema).blockSchema as BSchema;\n}\n\nexport function getInlineContentSchema<I extends InlineContentSchema>(\n  schema: Schema,\n): I {\n  return getBlockNoteSchema(schema).inlineContentSchema as I;\n}\n\nexport function getStyleSchema<S extends StyleSchema>(schema: Schema): S {\n  return getBlockNoteSchema(schema).styleSchema as S;\n}\n\nexport function getBlockCache(schema: Schema) {\n  return getBlockNoteEditor(schema).blockCache;\n}\n","import { Mark, Node, Schema, Slice } from \"@tiptap/pm/model\";\nimport type { Block } from \"../../blocks/defaultBlocks.js\";\nimport UniqueID from \"../../extensions/UniqueID/UniqueID.js\";\nimport type {\n  BlockSchema,\n  CustomInlineContentConfig,\n  CustomInlineContentFromConfig,\n  InlineContent,\n  InlineContentFromConfig,\n  InlineContentSchema,\n  StyleSchema,\n  Styles,\n  TableCell,\n  TableContent,\n} from \"../../schema/index.js\";\nimport {\n  isLinkInlineContent,\n  isStyledTextInlineContent,\n} from \"../../schema/inlineContent/types.js\";\nimport { UnreachableCaseError } from \"../../util/typescript.js\";\nimport { getBlockInfoWithManualOffset } from \"../getBlockInfoFromPos.js\";\nimport {\n  getBlockCache,\n  getBlockSchema,\n  getInlineContentSchema,\n  getStyleSchema,\n} from \"../pmUtil.js\";\n\n/**\n * Converts an internal (prosemirror) table node contentto a BlockNote Tablecontent\n */\nexport function contentNodeToTableContent<\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(contentNode: Node, inlineContentSchema: I, styleSchema: S) {\n  const ret: TableContent<I, S> = {\n    type: \"tableContent\",\n    columnWidths: [],\n    headerRows: undefined,\n    headerCols: undefined,\n    rows: [],\n  };\n\n  /**\n   * A matrix of boolean values indicating whether a cell is a header.\n   * The first index is the row index, the second index is the cell index.\n   */\n  const headerMatrix: boolean[][] = [];\n\n  contentNode.content.forEach((rowNode, _offset, rowIndex) => {\n    const row: TableContent<I, S>[\"rows\"][0] = {\n      cells: [],\n    };\n\n    if (rowIndex === 0) {\n      rowNode.content.forEach((cellNode) => {\n        let colWidth = cellNode.attrs.colwidth as null | undefined | number[];\n        if (colWidth === undefined || colWidth === null) {\n          colWidth = new Array(cellNode.attrs.colspan ?? 1).fill(undefined);\n        }\n        ret.columnWidths.push(...colWidth);\n      });\n    }\n\n    row.cells = rowNode.content.content.map((cellNode, cellIndex) => {\n      if (!headerMatrix[rowIndex]) {\n        headerMatrix[rowIndex] = [];\n      }\n      // Mark the cell as a header if it is a tableHeader node.\n      headerMatrix[rowIndex][cellIndex] = cellNode.type.name === \"tableHeader\";\n      // Convert cell content to inline content and merge adjacent styled text nodes\n      const content = cellNode.content.content\n        .map((child) =>\n          contentNodeToInlineContent(child, inlineContentSchema, styleSchema),\n        )\n        // The reason that we merge this content is that we allow table cells to contain multiple tableParagraph nodes\n        // So that we can leverage prosemirror-tables native merging\n        // If the schema only allowed a single tableParagraph node, then the merging would not work and cause prosemirror to fit the content into a new cell\n        .reduce(\n          (acc, contentPartial) => {\n            if (!acc.length) {\n              return contentPartial;\n            }\n\n            const last = acc[acc.length - 1];\n            const first = contentPartial[0];\n\n            // Only merge if the last and first content are both styled text nodes and have the same styles\n            if (\n              first &&\n              isStyledTextInlineContent(last) &&\n              isStyledTextInlineContent(first) &&\n              JSON.stringify(last.styles) === JSON.stringify(first.styles)\n            ) {\n              // Join them together if they have the same styles\n              last.text += \"\\n\" + first.text;\n              acc.push(...contentPartial.slice(1));\n              return acc;\n            }\n            acc.push(...contentPartial);\n            return acc;\n          },\n          [] as InlineContent<I, S>[],\n        );\n\n      return {\n        type: \"tableCell\",\n        content,\n        props: {\n          colspan: cellNode.attrs.colspan,\n          rowspan: cellNode.attrs.rowspan,\n          backgroundColor: cellNode.attrs.backgroundColor,\n          textColor: cellNode.attrs.textColor,\n          textAlignment: cellNode.attrs.textAlignment,\n        },\n      } satisfies TableCell<I, S>;\n    });\n\n    ret.rows.push(row);\n  });\n\n  for (let i = 0; i < headerMatrix.length; i++) {\n    if (headerMatrix[i]?.every((isHeader) => isHeader)) {\n      ret.headerRows = (ret.headerRows ?? 0) + 1;\n    }\n  }\n\n  for (let i = 0; i < headerMatrix[0]?.length; i++) {\n    if (headerMatrix?.every((row) => row[i])) {\n      ret.headerCols = (ret.headerCols ?? 0) + 1;\n    }\n  }\n\n  return ret;\n}\n\n/**\n * Converts an internal (prosemirror) content node to a BlockNote InlineContent array.\n */\nexport function contentNodeToInlineContent<\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(contentNode: Node, inlineContentSchema: I, styleSchema: S) {\n  const content: InlineContent<any, S>[] = [];\n  let currentContent: InlineContent<any, S> | undefined = undefined;\n\n  // Most of the logic below is for handling links because in ProseMirror links are marks\n  // while in BlockNote links are a type of inline content\n  contentNode.content.forEach((node) => {\n    // hardBreak nodes do not have an InlineContent equivalent, instead we\n    // add a newline to the previous node.\n    if (node.type.name === \"hardBreak\") {\n      if (currentContent) {\n        // Current content exists.\n        if (isStyledTextInlineContent(currentContent)) {\n          // Current content is text.\n          currentContent.text += \"\\n\";\n        } else if (isLinkInlineContent(currentContent)) {\n          // Current content is a link.\n          currentContent.content[currentContent.content.length - 1].text +=\n            \"\\n\";\n        } else {\n          throw new Error(\"unexpected\");\n        }\n      } else {\n        // Current content does not exist.\n        currentContent = {\n          type: \"text\",\n          text: \"\\n\",\n          styles: {},\n        };\n      }\n\n      return;\n    }\n\n    if (node.type.name !== \"link\" && node.type.name !== \"text\") {\n      if (!inlineContentSchema[node.type.name]) {\n        // eslint-disable-next-line no-console\n        console.warn(\"unrecognized inline content type\", node.type.name);\n        return;\n      }\n      if (currentContent) {\n        content.push(currentContent);\n        currentContent = undefined;\n      }\n\n      content.push(\n        nodeToCustomInlineContent(node, inlineContentSchema, styleSchema),\n      );\n\n      return;\n    }\n\n    const styles: Styles<S> = {};\n    let linkMark: Mark | undefined;\n\n    for (const mark of node.marks) {\n      if (mark.type.name === \"link\") {\n        linkMark = mark;\n      } else {\n        const config = styleSchema[mark.type.name];\n        if (!config) {\n          if (mark.type.spec.blocknoteIgnore) {\n            // at this point, we don't want to show certain marks (such as comments)\n            // in the BlockNote JSON output. These marks should be tagged with \"blocknoteIgnore\" in the spec\n            continue;\n          }\n          throw new Error(`style ${mark.type.name} not found in styleSchema`);\n        }\n        if (config.propSchema === \"boolean\") {\n          (styles as any)[config.type] = true;\n        } else if (config.propSchema === \"string\") {\n          (styles as any)[config.type] = mark.attrs.stringValue;\n        } else {\n          throw new UnreachableCaseError(config.propSchema);\n        }\n      }\n    }\n\n    // Parsing links and text.\n    // Current content exists.\n    if (currentContent) {\n      // Current content is text.\n      if (isStyledTextInlineContent(currentContent)) {\n        if (!linkMark) {\n          // Node is text (same type as current content).\n          if (\n            JSON.stringify(currentContent.styles) === JSON.stringify(styles)\n          ) {\n            // Styles are the same.\n            currentContent.text += node.textContent;\n          } else {\n            // Styles are different.\n            content.push(currentContent);\n            currentContent = {\n              type: \"text\",\n              text: node.textContent,\n              styles,\n            };\n          }\n        } else {\n          // Node is a link (different type to current content).\n          content.push(currentContent);\n          currentContent = {\n            type: \"link\",\n            href: linkMark.attrs.href,\n            content: [\n              {\n                type: \"text\",\n                text: node.textContent,\n                styles,\n              },\n            ],\n          };\n        }\n      } else if (isLinkInlineContent(currentContent)) {\n        // Current content is a link.\n        if (linkMark) {\n          // Node is a link (same type as current content).\n          // Link URLs are the same.\n          if (currentContent.href === linkMark.attrs.href) {\n            // Styles are the same.\n            if (\n              JSON.stringify(\n                currentContent.content[currentContent.content.length - 1]\n                  .styles,\n              ) === JSON.stringify(styles)\n            ) {\n              currentContent.content[currentContent.content.length - 1].text +=\n                node.textContent;\n            } else {\n              // Styles are different.\n              currentContent.content.push({\n                type: \"text\",\n                text: node.textContent,\n                styles,\n              });\n            }\n          } else {\n            // Link URLs are different.\n            content.push(currentContent);\n            currentContent = {\n              type: \"link\",\n              href: linkMark.attrs.href,\n              content: [\n                {\n                  type: \"text\",\n                  text: node.textContent,\n                  styles,\n                },\n              ],\n            };\n          }\n        } else {\n          // Node is text (different type to current content).\n          content.push(currentContent);\n          currentContent = {\n            type: \"text\",\n            text: node.textContent,\n            styles,\n          };\n        }\n      } else {\n        // TODO\n      }\n    }\n    // Current content does not exist.\n    else {\n      // Node is text.\n      if (!linkMark) {\n        currentContent = {\n          type: \"text\",\n          text: node.textContent,\n          styles,\n        };\n      }\n      // Node is a link.\n      else {\n        currentContent = {\n          type: \"link\",\n          href: linkMark.attrs.href,\n          content: [\n            {\n              type: \"text\",\n              text: node.textContent,\n              styles,\n            },\n          ],\n        };\n      }\n    }\n  });\n\n  if (currentContent) {\n    content.push(currentContent);\n  }\n\n  return content as InlineContent<I, S>[];\n}\n\nexport function nodeToCustomInlineContent<\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(node: Node, inlineContentSchema: I, styleSchema: S): InlineContent<I, S> {\n  if (node.type.name === \"text\" || node.type.name === \"link\") {\n    throw new Error(\"unexpected\");\n  }\n  const props: any = {};\n  const icConfig = inlineContentSchema[\n    node.type.name\n  ] as CustomInlineContentConfig;\n  for (const [attr, value] of Object.entries(node.attrs)) {\n    if (!icConfig) {\n      throw Error(\"ic node is of an unrecognized type: \" + node.type.name);\n    }\n\n    const propSchema = icConfig.propSchema;\n\n    if (attr in propSchema) {\n      props[attr] = value;\n    }\n  }\n\n  let content: CustomInlineContentFromConfig<any, any>[\"content\"];\n\n  if (icConfig.content === \"styled\") {\n    content = contentNodeToInlineContent(\n      node,\n      inlineContentSchema,\n      styleSchema,\n    ) as any; // TODO: is this safe? could we have Links here that are undesired?\n  } else {\n    content = undefined;\n  }\n\n  const ic = {\n    type: node.type.name,\n    props,\n    content,\n  } as InlineContentFromConfig<I[keyof I], S>;\n  return ic;\n}\n\n/**\n * Convert a Prosemirror node to a BlockNote block.\n *\n * TODO: test changes\n */\nexport function nodeToBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  node: Node,\n  schema: Schema,\n  blockSchema: BSchema = getBlockSchema(schema) as BSchema,\n  inlineContentSchema: I = getInlineContentSchema(schema) as I,\n  styleSchema: S = getStyleSchema(schema) as S,\n  blockCache = getBlockCache(schema),\n): Block<BSchema, I, S> {\n  if (!node.type.isInGroup(\"bnBlock\")) {\n    throw Error(\"Node should be a bnBlock, but is instead: \" + node.type.name);\n  }\n\n  const cachedBlock = blockCache?.get(node);\n\n  if (cachedBlock) {\n    return cachedBlock;\n  }\n\n  const blockInfo = getBlockInfoWithManualOffset(node, 0);\n\n  let id = blockInfo.bnBlock.node.attrs.id;\n\n  // Only used for blocks converted from other formats.\n  if (id === null) {\n    id = UniqueID.options.generateID();\n  }\n\n  const blockSpec = blockSchema[blockInfo.blockNoteType];\n\n  if (!blockSpec) {\n    throw Error(\"Block is of an unrecognized type: \" + blockInfo.blockNoteType);\n  }\n\n  const props: any = {};\n  for (const [attr, value] of Object.entries({\n    ...node.attrs,\n    ...(blockInfo.isBlockContainer ? blockInfo.blockContent.node.attrs : {}),\n  })) {\n    const propSchema = blockSpec.propSchema;\n\n    if (\n      attr in propSchema &&\n      !(propSchema[attr].default === undefined && value === undefined)\n    ) {\n      props[attr] = value;\n    }\n  }\n\n  const blockConfig = blockSchema[blockInfo.blockNoteType];\n\n  const children: Block<BSchema, I, S>[] = [];\n  blockInfo.childContainer?.node.forEach((child) => {\n    children.push(\n      nodeToBlock(\n        child,\n        schema,\n        blockSchema,\n        inlineContentSchema,\n        styleSchema,\n        blockCache,\n      ),\n    );\n  });\n\n  let content: Block<any, any, any>[\"content\"];\n\n  if (blockConfig.content === \"inline\") {\n    if (!blockInfo.isBlockContainer) {\n      throw new Error(\"impossible\");\n    }\n    content = contentNodeToInlineContent(\n      blockInfo.blockContent.node,\n      inlineContentSchema,\n      styleSchema,\n    );\n  } else if (blockConfig.content === \"table\") {\n    if (!blockInfo.isBlockContainer) {\n      throw new Error(\"impossible\");\n    }\n    content = contentNodeToTableContent(\n      blockInfo.blockContent.node,\n      inlineContentSchema,\n      styleSchema,\n    );\n  } else if (blockConfig.content === \"none\") {\n    content = undefined;\n  } else {\n    throw new UnreachableCaseError(blockConfig.content);\n  }\n\n  const block = {\n    id,\n    type: blockConfig.type,\n    props,\n    content,\n    children,\n  } as Block<BSchema, I, S>;\n\n  blockCache?.set(node, block);\n\n  return block;\n}\n\n/**\n * Convert a Prosemirror document to a BlockNote document (array of blocks)\n */\nexport function docToBlocks<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  doc: Node,\n  schema: Schema,\n  blockSchema: BSchema = getBlockSchema(schema) as BSchema,\n  inlineContentSchema: I = getInlineContentSchema(schema) as I,\n  styleSchema: S = getStyleSchema(schema) as S,\n  blockCache = getBlockCache(schema),\n) {\n  const blocks: Block<BSchema, I, S>[] = [];\n  doc.firstChild!.descendants((node) => {\n    blocks.push(\n      nodeToBlock(\n        node,\n        schema,\n        blockSchema,\n        inlineContentSchema,\n        styleSchema,\n        blockCache,\n      ),\n    );\n    return false;\n  });\n  return blocks;\n}\n\n/**\n *\n * Parse a Prosemirror Slice into a BlockNote selection. The prosemirror schema looks like this:\n *\n * <blockGroup>\n *   <blockContainer> (main content of block)\n *       <p, heading, etc.>\n *   <blockGroup> (only if blocks has children)\n *     <blockContainer> (child block)\n *       <p, heading, etc.>\n *     </blockContainer>\n *    <blockContainer> (child block 2)\n *       <p, heading, etc.>\n *     </blockContainer>\n *   </blockContainer>\n *  </blockGroup>\n * </blockGroup>\n *\n */\nexport function prosemirrorSliceToSlicedBlocks<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  slice: Slice,\n  schema: Schema,\n  blockSchema: BSchema = getBlockSchema(schema) as BSchema,\n  inlineContentSchema: I = getInlineContentSchema(schema) as I,\n  styleSchema: S = getStyleSchema(schema) as S,\n  blockCache: WeakMap<Node, Block<BSchema, I, S>> = getBlockCache(schema),\n): {\n  /**\n   * The blocks that are included in the selection.\n   */\n  blocks: Block<BSchema, I, S>[];\n  /**\n   * If a block was \"cut\" at the start of the selection, this will be the id of the block that was cut.\n   */\n  blockCutAtStart: string | undefined;\n  /**\n   * If a block was \"cut\" at the end of the selection, this will be the id of the block that was cut.\n   */\n  blockCutAtEnd: string | undefined;\n} {\n  // console.log(JSON.stringify(slice.toJSON()));\n  function processNode(\n    node: Node,\n    openStart: number,\n    openEnd: number,\n  ): {\n    blocks: Block<BSchema, I, S>[];\n    blockCutAtStart: string | undefined;\n    blockCutAtEnd: string | undefined;\n  } {\n    if (node.type.name !== \"blockGroup\") {\n      throw new Error(\"unexpected\");\n    }\n    const blocks: Block<BSchema, I, S>[] = [];\n    let blockCutAtStart: string | undefined;\n    let blockCutAtEnd: string | undefined;\n\n    node.forEach((blockContainer, _offset, index) => {\n      if (blockContainer.type.name !== \"blockContainer\") {\n        throw new Error(\"unexpected\");\n      }\n      if (blockContainer.childCount === 0) {\n        return;\n      }\n      if (blockContainer.childCount === 0 || blockContainer.childCount > 2) {\n        throw new Error(\n          \"unexpected, blockContainer.childCount: \" + blockContainer.childCount,\n        );\n      }\n\n      const isFirstBlock = index === 0;\n      const isLastBlock = index === node.childCount - 1;\n\n      if (blockContainer.firstChild!.type.name === \"blockGroup\") {\n        // this is the parent where a selection starts within one of its children,\n        // e.g.:\n        // A\n        // ├── B\n        // selection starts within B, then this blockContainer is A, but we don't care about A\n        // so let's descend into B and continue processing\n        if (!isFirstBlock) {\n          throw new Error(\"unexpected\");\n        }\n        const ret = processNode(\n          blockContainer.firstChild!,\n          Math.max(0, openStart - 1),\n          isLastBlock ? Math.max(0, openEnd - 1) : 0,\n        );\n        blockCutAtStart = ret.blockCutAtStart;\n        if (isLastBlock) {\n          blockCutAtEnd = ret.blockCutAtEnd;\n        }\n        blocks.push(...ret.blocks);\n        return;\n      }\n\n      const block = nodeToBlock(\n        blockContainer,\n        schema,\n        blockSchema,\n        inlineContentSchema,\n        styleSchema,\n        blockCache,\n      );\n      const childGroup =\n        blockContainer.childCount > 1 ? blockContainer.child(1) : undefined;\n\n      let childBlocks: Block<BSchema, I, S>[] = [];\n      if (childGroup) {\n        const ret = processNode(\n          childGroup,\n          0, // TODO: can this be anything other than 0?\n          isLastBlock ? Math.max(0, openEnd - 1) : 0,\n        );\n        childBlocks = ret.blocks;\n        if (isLastBlock) {\n          blockCutAtEnd = ret.blockCutAtEnd;\n        }\n      }\n\n      if (isLastBlock && !childGroup && openEnd > 1) {\n        blockCutAtEnd = block.id;\n      }\n\n      if (isFirstBlock && openStart > 1) {\n        blockCutAtStart = block.id;\n      }\n\n      blocks.push({\n        ...(block as any),\n        children: childBlocks,\n      });\n    });\n\n    return { blocks, blockCutAtStart, blockCutAtEnd };\n  }\n\n  if (slice.content.childCount === 0) {\n    return {\n      blocks: [],\n      blockCutAtStart: undefined,\n      blockCutAtEnd: undefined,\n    };\n  }\n\n  if (slice.content.childCount !== 1) {\n    throw new Error(\n      \"slice must be a single block, did you forget includeParents=true?\",\n    );\n  }\n\n  return processNode(\n    slice.content.firstChild!,\n    Math.max(slice.openStart - 1, 0),\n    Math.max(slice.openEnd - 1, 0),\n  );\n}\n","import { KeyboardShortcutCommand, Node } from \"@tiptap/core\";\n\nimport { camelToDataKebab } from \"../../util/string.js\";\nimport { PropSchema, Props } from \"../propTypes.js\";\nimport {\n  CustomInlineContentConfig,\n  InlineContentImplementation,\n  InlineContentSchemaFromSpecs,\n  InlineContentSpec,\n  InlineContentSpecs,\n} from \"./types.js\";\n\n// Function that adds necessary classes and attributes to the `dom` element\n// returned from a custom inline content's 'render' function, to ensure no data\n// is lost on internal copy & paste.\nexport function addInlineContentAttributes<\n  IType extends string,\n  PSchema extends PropSchema,\n>(\n  element: {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n  },\n  inlineContentType: IType,\n  inlineContentProps: Props<PSchema>,\n  propSchema: PSchema,\n): {\n  dom: HTMLElement;\n  contentDOM?: HTMLElement;\n} {\n  // Sets content type attribute\n  element.dom.setAttribute(\"data-inline-content-type\", inlineContentType);\n  // Adds props as HTML attributes in kebab-case with \"data-\" prefix. Skips props\n  // set to their default values.\n  Object.entries(inlineContentProps)\n    .filter(([prop, value]) => {\n      const spec = propSchema[prop];\n      return value !== spec.default;\n    })\n    .map(([prop, value]) => {\n      return [camelToDataKebab(prop), value];\n    })\n    .forEach(([prop, value]) => element.dom.setAttribute(prop, value));\n\n  if (element.contentDOM) {\n    element.contentDOM.setAttribute(\"data-editable\", \"\");\n  }\n\n  return element;\n}\n\n// see https://github.com/TypeCellOS/BlockNote/pull/435\nexport function addInlineContentKeyboardShortcuts<\n  T extends CustomInlineContentConfig,\n>(\n  config: T,\n): {\n  [p: string]: KeyboardShortcutCommand;\n} {\n  return {\n    Backspace: ({ editor }) => {\n      const resolvedPos = editor.state.selection.$from;\n\n      return (\n        editor.state.selection.empty &&\n        resolvedPos.node().type.name === config.type &&\n        resolvedPos.parentOffset === 0\n      );\n    },\n  };\n}\n\n// This helper function helps to instantiate a InlineContentSpec with a\n// config and implementation that conform to the type of Config\nexport function createInternalInlineContentSpec<\n  const T extends CustomInlineContentConfig,\n>(\n  config: T,\n  implementation: InlineContentImplementation<NoInfer<T>>,\n): InlineContentSpec<T> {\n  return {\n    config,\n    implementation,\n  } as const;\n}\n\nexport function createInlineContentSpecFromTipTapNode<\n  T extends Node,\n  P extends PropSchema,\n>(\n  node: T,\n  propSchema: P,\n  implementation: Omit<\n    InlineContentImplementation<CustomInlineContentConfig>,\n    \"node\"\n  >,\n) {\n  return createInternalInlineContentSpec(\n    {\n      type: node.name as T[\"name\"],\n      propSchema,\n      content: node.config.content === \"inline*\" ? \"styled\" : \"none\",\n    },\n    {\n      ...implementation,\n      node,\n    },\n  );\n}\n\nexport function getInlineContentSchemaFromSpecs<T extends InlineContentSpecs>(\n  specs: T,\n) {\n  return Object.fromEntries(\n    Object.entries(specs).map(([key, value]) => [key, value.config]),\n  ) as InlineContentSchemaFromSpecs<T>;\n}\n","import { Attributes, Mark } from \"@tiptap/core\";\nimport { DOMSerializer } from \"@tiptap/pm/model\";\nimport {\n  StyleConfig,\n  StyleImplementation,\n  StylePropSchema,\n  StyleSchemaFromSpecs,\n  StyleSpec,\n  StyleSpecs,\n} from \"./types.js\";\n\nexport function stylePropsToAttributes(\n  propSchema: StylePropSchema,\n): Attributes {\n  if (propSchema === \"boolean\") {\n    return {};\n  }\n  return {\n    stringValue: {\n      default: undefined,\n      keepOnSplit: true,\n      parseHTML: (element) => element.getAttribute(\"data-value\"),\n      renderHTML: (attributes) =>\n        attributes.stringValue !== undefined\n          ? {\n              \"data-value\": attributes.stringValue,\n            }\n          : {},\n    },\n  };\n}\n\n// Function that adds necessary classes and attributes to the `dom` element\n// returned from a custom style's 'render' function, to ensure no data is lost\n// on internal copy & paste.\nexport function addStyleAttributes<\n  SType extends string,\n  PSchema extends StylePropSchema,\n>(\n  element: {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n  },\n  styleType: SType,\n  styleValue: PSchema extends \"boolean\" ? undefined : string,\n  propSchema: PSchema,\n): {\n  dom: HTMLElement;\n  contentDOM?: HTMLElement;\n} {\n  // Sets content type attribute\n  element.dom.setAttribute(\"data-style-type\", styleType);\n  // Adds style value as an HTML attribute in kebab-case with \"data-\" prefix, if\n  // the style takes a string value.\n  if (propSchema === \"string\") {\n    element.dom.setAttribute(\"data-value\", styleValue as string);\n  }\n\n  if (element.contentDOM) {\n    element.contentDOM.setAttribute(\"data-editable\", \"\");\n  }\n\n  return element;\n}\n\n// This helper function helps to instantiate a stylespec with a\n// config and implementation that conform to the type of Config\nexport function createInternalStyleSpec<T extends StyleConfig>(\n  config: T,\n  implementation: StyleImplementation<T>,\n) {\n  return {\n    config,\n    implementation,\n  } satisfies StyleSpec<T>;\n}\n\nexport function createStyleSpecFromTipTapMark<\n  T extends Mark,\n  P extends StylePropSchema,\n>(mark: T, propSchema: P) {\n  return createInternalStyleSpec(\n    {\n      type: mark.name as T[\"name\"],\n      propSchema,\n    },\n    {\n      mark,\n      render(value, editor) {\n        const toDOM = editor.pmSchema.marks[mark.name].spec.toDOM;\n\n        if (toDOM === undefined) {\n          throw new Error(\n            \"This block has no default HTML serialization as its corresponding TipTap node doesn't implement `renderHTML`.\",\n          );\n        }\n\n        const markInstance = editor.pmSchema.mark(mark.name, {\n          stringValue: value,\n        });\n\n        const renderSpec = DOMSerializer.renderSpec(\n          document,\n          toDOM(markInstance, true),\n        );\n\n        if (typeof renderSpec !== \"object\" || !(\"dom\" in renderSpec)) {\n          throw new Error(\n            \"Cannot use this block's default HTML serialization as its corresponding TipTap mark's `renderHTML` function does not return an object with the `dom` property.\",\n          );\n        }\n\n        return renderSpec as {\n          dom: HTMLElement;\n          contentDOM?: HTMLElement;\n        };\n      },\n      toExternalHTML(value, editor) {\n        const toDOM = editor.pmSchema.marks[mark.name].spec.toDOM;\n\n        if (toDOM === undefined) {\n          throw new Error(\n            \"This block has no default HTML serialization as its corresponding TipTap node doesn't implement `renderHTML`.\",\n          );\n        }\n\n        const markInstance = editor.pmSchema.mark(mark.name, {\n          stringValue: value,\n        });\n\n        const renderSpec = DOMSerializer.renderSpec(\n          document,\n          toDOM(markInstance, true),\n        );\n\n        if (typeof renderSpec !== \"object\" || !(\"dom\" in renderSpec)) {\n          throw new Error(\n            \"Cannot use this block's default HTML serialization as its corresponding TipTap mark's `renderHTML` function does not return an object with the `dom` property.\",\n          );\n        }\n\n        return renderSpec as {\n          dom: HTMLElement;\n          contentDOM?: HTMLElement;\n        };\n      },\n    },\n  );\n}\n\nexport function getStyleSchemaFromSpecs<T extends StyleSpecs>(specs: T) {\n  return Object.fromEntries(\n    Object.entries(specs).map(([key, value]) => [key, value.config]),\n  ) as StyleSchemaFromSpecs<T>;\n}\n","import { Mark } from \"@tiptap/core\";\n\nimport { ParseRule, TagParseRule } from \"@tiptap/pm/model\";\nimport {\n  addStyleAttributes,\n  createInternalStyleSpec,\n  stylePropsToAttributes,\n} from \"./internal.js\";\nimport { StyleConfig, StyleSpec } from \"./types.js\";\n\nexport type CustomStyleImplementation<T extends StyleConfig> = {\n  render: (value: T[\"propSchema\"] extends \"boolean\" ? undefined : string) => {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n  };\n  toExternalHTML?: (\n    value: T[\"propSchema\"] extends \"boolean\" ? undefined : string,\n  ) => {\n    dom: HTMLElement;\n    contentDOM?: HTMLElement;\n  };\n  parse?: (\n    element: HTMLElement,\n  ) => (T[\"propSchema\"] extends \"boolean\" ? true : string) | undefined;\n};\n\nexport function getStyleParseRules<T extends StyleConfig>(\n  config: T,\n  customParseFunction?: CustomStyleImplementation<T>[\"parse\"],\n): ParseRule[] {\n  const rules: TagParseRule[] = [\n    {\n      tag: `[data-style-type=\"${config.type}\"]`,\n      contentElement: (element) => {\n        const htmlElement = element as HTMLElement;\n\n        if (htmlElement.matches(\"[data-editable]\")) {\n          return htmlElement;\n        }\n\n        return htmlElement.querySelector(\"[data-editable]\") || htmlElement;\n      },\n    },\n  ];\n\n  if (customParseFunction) {\n    rules.push({\n      tag: \"*\",\n      getAttrs(node: string | HTMLElement) {\n        if (typeof node === \"string\") {\n          return false;\n        }\n\n        const stringValue = customParseFunction?.(node);\n\n        if (stringValue === undefined) {\n          return false;\n        }\n\n        return { stringValue };\n      },\n    });\n  }\n  return rules;\n}\n\nexport function createStyleSpec<const T extends StyleConfig>(\n  styleConfig: T,\n  styleImplementation: CustomStyleImplementation<T>,\n): StyleSpec<T> {\n  const mark = Mark.create({\n    name: styleConfig.type,\n\n    addAttributes() {\n      return stylePropsToAttributes(styleConfig.propSchema);\n    },\n\n    parseHTML() {\n      return getStyleParseRules(styleConfig, styleImplementation.parse);\n    },\n\n    renderHTML({ mark }) {\n      const renderResult = (\n        styleImplementation.toExternalHTML || styleImplementation.render\n      )(mark.attrs.stringValue);\n\n      return addStyleAttributes(\n        renderResult,\n        styleConfig.type,\n        mark.attrs.stringValue,\n        styleConfig.propSchema,\n      );\n    },\n\n    addMarkView() {\n      return ({ mark }) => {\n        const renderResult = styleImplementation.render(mark.attrs.stringValue);\n\n        return addStyleAttributes(\n          renderResult,\n          styleConfig.type,\n          mark.attrs.stringValue,\n          styleConfig.propSchema,\n        );\n      };\n    },\n  });\n\n  return createInternalStyleSpec(styleConfig, {\n    mark,\n    render: (value) => {\n      const renderResult = styleImplementation.render(value as any);\n\n      return addStyleAttributes(\n        renderResult,\n        styleConfig.type,\n        value,\n        styleConfig.propSchema,\n      );\n    },\n    toExternalHTML: (value) => {\n      const renderResult = (\n        styleImplementation.toExternalHTML || styleImplementation.render\n      )(value as any);\n\n      return addStyleAttributes(\n        renderResult,\n        styleConfig.type,\n        value,\n        styleConfig.propSchema,\n      );\n    },\n  });\n}\n","/**\n * Instead of depending on the NPM package, we vendor this file from https://github.com/n1ru4l/toposort/blob/main/src/toposort.ts (MIT)\n *\n * There was a recent publish, despite not having been updated in 2 years, which is suspicious.\n *\n * This file is also simple enough that we can maintain it ourselves.\n */\n\nexport type DirectedAcyclicGraph = Map<string, Iterable<string>>;\nexport type DependencyGraph = DirectedAcyclicGraph;\n\nexport type TaskList = Array<Set<string>>;\n\n// Add more specific types for better type safety\nexport type NodeId = string;\nexport type DependencyMap = Map<NodeId, Set<NodeId>>;\n\nexport function toposort(dag: DirectedAcyclicGraph): TaskList {\n  const inDegrees = countInDegrees(dag);\n\n  let { roots, nonRoots } = getRootsAndNonRoots(inDegrees);\n\n  const sorted: TaskList = [];\n\n  while (roots.size) {\n    sorted.push(roots);\n\n    const newRoots = new Set<NodeId>();\n    for (const root of roots) {\n      const dependents = dag.get(root);\n      if (!dependents) {\n        // Handle case where node has no dependents\n        continue;\n      }\n\n      for (const dependent of dependents) {\n        const currentDegree = inDegrees.get(dependent);\n        if (currentDegree === undefined) {\n          // Handle case where dependent node is not in inDegrees\n          continue;\n        }\n\n        const newDegree = currentDegree - 1;\n        inDegrees.set(dependent, newDegree);\n\n        if (newDegree === 0) {\n          newRoots.add(dependent);\n        }\n      }\n    }\n\n    roots = newRoots;\n  }\n  nonRoots = getRootsAndNonRoots(inDegrees).nonRoots;\n\n  if (nonRoots.size) {\n    throw new Error(\n      `Cycle(s) detected; toposort only works on acyclic graphs. Cyclic nodes: ${Array.from(nonRoots).join(\", \")}`,\n    );\n  }\n\n  return sorted;\n}\n\nexport function toposortReverse(deps: DependencyGraph): TaskList {\n  const dag = reverse(deps);\n  return toposort(dag);\n}\n\ntype InDegrees = Map<NodeId, number>;\n\nfunction countInDegrees(dag: DirectedAcyclicGraph): InDegrees {\n  const counts: InDegrees = new Map();\n\n  for (const [vx, dependents] of dag.entries()) {\n    // Initialize count for current node if not present\n    if (!counts.has(vx)) {\n      counts.set(vx, 0);\n    }\n\n    for (const dependent of dependents) {\n      const currentCount = counts.get(dependent) ?? 0;\n      counts.set(dependent, currentCount + 1);\n    }\n  }\n\n  return counts;\n}\n\nfunction getRootsAndNonRoots(counts: InDegrees) {\n  const roots = new Set<NodeId>();\n  const nonRoots = new Set<NodeId>();\n\n  for (const [id, deg] of counts.entries()) {\n    if (deg === 0) {\n      roots.add(id);\n    } else {\n      nonRoots.add(id);\n    }\n  }\n\n  return { roots, nonRoots };\n}\n\nfunction reverse(deps: DirectedAcyclicGraph): DependencyGraph {\n  const reversedDeps: DependencyMap = new Map();\n\n  for (const [name, dependsOn] of deps.entries()) {\n    // Ensure the source node exists in the reversed map\n    if (!reversedDeps.has(name)) {\n      reversedDeps.set(name, new Set());\n    }\n\n    for (const dependsOnName of dependsOn) {\n      if (!reversedDeps.has(dependsOnName)) {\n        reversedDeps.set(dependsOnName, new Set());\n      }\n      reversedDeps.get(dependsOnName)!.add(name);\n    }\n  }\n\n  return reversedDeps;\n}\n\nexport function createDependencyGraph(): DependencyMap {\n  return new Map();\n}\n\nexport function addDependency(\n  graph: DependencyMap,\n  from: NodeId,\n  to: NodeId,\n): DependencyMap {\n  if (!graph.has(from)) {\n    graph.set(from, new Set());\n  }\n  graph.get(from)!.add(to);\n  return graph;\n}\n\nexport function removeDependency(\n  graph: DependencyMap,\n  from: NodeId,\n  to: NodeId,\n): boolean {\n  const dependents = graph.get(from);\n  if (!dependents) {\n    return false;\n  }\n  return dependents.delete(to);\n}\n\nexport function hasDependency(\n  graph: DependencyMap,\n  from: NodeId,\n  to: NodeId,\n): boolean {\n  const dependents = graph.get(from);\n  return dependents ? dependents.has(to) : false;\n}\n","import { BlockNoteEditor } from \"../editor/BlockNoteEditor.js\";\nimport { createDependencyGraph, toposortReverse } from \"../util/topo-sort.js\";\nimport {\n  BlockNoDefaults,\n  BlockSchema,\n  BlockSpecs,\n  InlineContentConfig,\n  InlineContentSchema,\n  InlineContentSpec,\n  InlineContentSpecs,\n  LooseBlockSpec,\n  PartialBlockNoDefaults,\n  StyleSchema,\n  StyleSpecs,\n  addNodeAndExtensionsToSpec,\n  getInlineContentSchemaFromSpecs,\n  getStyleSchemaFromSpecs,\n} from \"./index.js\";\n\nfunction removeUndefined<T extends Record<string, any> | undefined>(obj: T): T {\n  if (!obj) {\n    return obj;\n  }\n  return Object.fromEntries(\n    Object.entries(obj).filter(([, value]) => value !== undefined),\n  ) as T;\n}\n\nexport class CustomBlockNoteSchema<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema,\n> {\n  // Helper so that you can use typeof schema.BlockNoteEditor\n  public readonly BlockNoteEditor: BlockNoteEditor<BSchema, ISchema, SSchema> =\n    \"only for types\" as any;\n\n  public readonly Block: BlockNoDefaults<BSchema, ISchema, SSchema> =\n    \"only for types\" as any;\n\n  public readonly PartialBlock: PartialBlockNoDefaults<\n    BSchema,\n    ISchema,\n    SSchema\n  > = \"only for types\" as any;\n\n  public inlineContentSpecs: InlineContentSpecs;\n  public styleSpecs: StyleSpecs;\n  public blockSpecs: {\n    [K in keyof BSchema]: K extends string\n      ? LooseBlockSpec<K, BSchema[K][\"propSchema\"], BSchema[K][\"content\"]>\n      : never;\n  };\n\n  public blockSchema: BSchema;\n  public inlineContentSchema: ISchema;\n  public styleSchema: SSchema;\n\n  constructor(\n    private opts: {\n      blockSpecs: BlockSpecs;\n      inlineContentSpecs: InlineContentSpecs;\n      styleSpecs: StyleSpecs;\n    },\n  ) {\n    const {\n      blockSpecs,\n      inlineContentSpecs,\n      styleSpecs,\n      blockSchema,\n      inlineContentSchema,\n      styleSchema,\n    } = this.init();\n    this.blockSpecs = blockSpecs;\n    this.styleSpecs = styleSpecs;\n    this.styleSchema = styleSchema;\n    this.inlineContentSpecs = inlineContentSpecs;\n    this.blockSchema = blockSchema;\n    this.inlineContentSchema = inlineContentSchema;\n  }\n\n  private init() {\n    const dag = createDependencyGraph();\n    const defaultSet = new Set<string>();\n    dag.set(\"default\", defaultSet);\n\n    for (const [key, specDef] of Object.entries(this.opts.blockSpecs)) {\n      if (specDef.implementation.runsBefore) {\n        dag.set(key, new Set(specDef.implementation.runsBefore));\n      } else {\n        defaultSet.add(key);\n      }\n    }\n    const sortedSpecs = toposortReverse(dag);\n    const defaultIndex = sortedSpecs.findIndex((set) => set.has(\"default\"));\n\n    /**\n     * The priority of a block is described relative to the \"default\" block (an arbitrary block which can be used as the reference)\n     *\n     * Since blocks are topologically sorted, we can see what their relative position is to the \"default\" block\n     * Each layer away from the default block is 10 priority points (arbitrarily chosen)\n     * The default block is fixed at 101 (1 point higher than any tiptap extension, giving priority to custom blocks than any defaults)\n     *\n     * This is a bit of a hack, but it's a simple way to ensure that custom blocks are always rendered with higher priority than default blocks\n     * and that custom blocks are rendered in the order they are defined in the schema\n     */\n    const getPriority = (key: string) => {\n      const index = sortedSpecs.findIndex((set) => set.has(key));\n      // the default index should map to 101\n      // one before the default index is 91\n      // one after is 111\n      return 91 + (index + defaultIndex) * 10;\n    };\n\n    const blockSpecs = Object.fromEntries(\n      Object.entries(this.opts.blockSpecs).map(([key, blockSpec]) => {\n        return [\n          key,\n          addNodeAndExtensionsToSpec(\n            blockSpec.config,\n            blockSpec.implementation,\n            blockSpec.extensions,\n            getPriority(key),\n          ),\n        ];\n      }),\n    ) as {\n      [K in keyof BSchema]: K extends string\n        ? LooseBlockSpec<K, BSchema[K][\"propSchema\"], BSchema[K][\"content\"]>\n        : never;\n    };\n\n    return {\n      blockSpecs,\n      blockSchema: Object.fromEntries(\n        Object.entries(blockSpecs).map(([key, blockDef]) => {\n          return [key, blockDef.config];\n        }),\n      ) as any,\n      inlineContentSpecs: removeUndefined(this.opts.inlineContentSpecs),\n      styleSpecs: removeUndefined(this.opts.styleSpecs),\n      inlineContentSchema: getInlineContentSchemaFromSpecs(\n        this.opts.inlineContentSpecs,\n      ) as any,\n      styleSchema: getStyleSchemaFromSpecs(this.opts.styleSpecs) as any,\n    };\n  }\n\n  /**\n   * Adds additional block specs to the current schema in a builder pattern.\n   * This method allows extending the schema after it has been created.\n   *\n   * @param additionalBlockSpecs - Additional block specs to add to the schema\n   * @returns The current schema instance for chaining\n   */\n  public extend<\n    AdditionalBlockSpecs extends BlockSpecs = Record<string, never>,\n    AdditionalInlineContentSpecs extends Record<\n      string,\n      InlineContentSpec<InlineContentConfig>\n    > = Record<string, never>,\n    AdditionalStyleSpecs extends StyleSpecs = Record<string, never>,\n  >(opts: {\n    blockSpecs?: AdditionalBlockSpecs;\n    inlineContentSpecs?: AdditionalInlineContentSpecs;\n    styleSpecs?: AdditionalStyleSpecs;\n  }): CustomBlockNoteSchema<\n    AdditionalBlockSpecs extends undefined | Record<string, never>\n      ? BSchema\n      : BSchema & {\n          [K in keyof AdditionalBlockSpecs]: K extends string\n            ? AdditionalBlockSpecs[K][\"config\"]\n            : never;\n        },\n    AdditionalInlineContentSpecs extends undefined | Record<string, never>\n      ? ISchema\n      : ISchema & {\n          [K in keyof AdditionalInlineContentSpecs]: AdditionalInlineContentSpecs[K][\"config\"];\n        },\n    AdditionalStyleSpecs extends undefined | Record<string, never>\n      ? SSchema\n      : SSchema & {\n          [K in keyof AdditionalStyleSpecs]: AdditionalStyleSpecs[K][\"config\"];\n        }\n  > {\n    // Merge the new specs with existing ones\n    Object.assign(this.opts.blockSpecs, opts.blockSpecs);\n    Object.assign(this.opts.inlineContentSpecs, opts.inlineContentSpecs);\n    Object.assign(this.opts.styleSpecs, opts.styleSpecs);\n\n    // Reinitialize the block specs with the merged specs\n    const {\n      blockSpecs,\n      inlineContentSpecs,\n      styleSpecs,\n      blockSchema,\n      inlineContentSchema,\n      styleSchema,\n    } = this.init();\n    this.blockSpecs = blockSpecs;\n    this.styleSpecs = styleSpecs;\n    this.styleSchema = styleSchema;\n    this.inlineContentSpecs = inlineContentSpecs;\n    this.blockSchema = blockSchema;\n    this.inlineContentSchema = inlineContentSchema;\n\n    return this as any;\n  }\n}\n","import { DefaultBlockSchema } from \"../../../blocks/defaultBlocks.js\";\nimport {\n  BlockFromConfigNoChildren,\n  PartialTableContent,\n  TableCell,\n  TableContent,\n} from \"../../../schema/blocks/types.js\";\nimport {\n  isPartialLinkInlineContent,\n  isStyledTextInlineContent,\n} from \"../../../schema/index.js\";\nimport {\n  getColspan,\n  getRowspan,\n  isPartialTableCell,\n  mapTableCell,\n} from \"../../../util/table.js\";\n\n/**\n * Here be dragons.\n *\n * Tables are complex because of rowspan and colspan behavior.\n * The majority of this file is concerned with translating between \"relative\" and \"absolute\" indices.\n *\n * The following diagram may help explain the relationship between the different indices:\n *\n *  One-based indexing of rows and columns in a table:\n *  | 1-1 | 1-2 | 1-3 |\n *  | 2-1 | 2-2 | 2-3 |\n *  | 3-1 | 3-2 | 3-3 |\n *\n *  A complicated table with colspans and rowspans:\n *  | 1-1 | 1-2 | 1-2 |\n *  | 2-1 | 2-1 | 2-2 |\n *  | 2-1 | 2-1 | 3-1 |\n *\n * You can see here that we have:\n *  - two cells that contain the value \"1-2\", because it has a colspan of 2.\n *  - four cells that contain the value \"2-1\", because it has a rowspan of 2 and a colspan of 2.\n *\n * This would be represented in block note json (roughly) as:\n *  [\n *      {\n *       \"cells\": [\n *         {\n *           \"type\": \"tableCell\",\n *             \"content\": [\"1,1\"],\n *             \"props\": {\n *               \"colspan\": 1,\n *               \"rowspan\": 1\n *             },\n *           },\n *           {\n *             \"type\": \"tableCell\",\n *             \"content\": [\"1,2\"],\n *             \"props\": {\n *               \"colspan\": 2,\n *               \"rowspan\": 1\n *             }\n *           }\n *         ],\n *       },\n *       {\n *         \"cells\": [\n *           {\n *             \"type\": \"tableCell\",\n *             \"content\": [\"2,1\"],\n *             \"props\": {\n *                 \"colspan\": 2,\n *                 \"rowspan\": 2\n *               }\n *             },\n *           {\n *             \"type\": \"tableCell\",\n *             \"content\": [\"2,2\"],\n *             \"props\": {\n *               \"colspan\": 1,\n *               \"rowspan\": 1\n *            }\n *         ],\n *       },\n *       {\n *         \"cells\": [\n *           {\n *             \"type\": \"tableCell\",\n *             \"content\": [\"3,1\"],\n *             \"props\": {\n *               \"colspan\": 1,\n *               \"rowspan\": 1,\n *             }\n *           }\n *         ]\n *       }\n *     ]\n *\n * Which maps cleanly to the following HTML:\n *\n * <table>\n *   <tr>\n *     <td>1-1</td>\n *     <td colspan=\"2\">1-2</td>\n *   </tr>\n *   <tr>\n *     <td rowspan=\"2\" colspan=\"2\">2-1</td>\n *     <td>2-2</td>\n *   </tr>\n *   <tr>\n *     <td>3-1</td>\n *   </tr>\n * </table>\n *\n * We have a problem though, from the block json, there is no way to tell that the cell \"2-1\" is the second cell in the second row.\n * To resolve this, we created the occupancy grid, which is a grid of all the cells in the table, as though they were only 1x1 cells.\n * See {@link OccupancyGrid} for more information.\n *\n */\n\n/**\n * Relative cell indices are relative to the table block's content.\n *\n * This is a sparse representation of the table and is how HTML and BlockNote JSON represent tables.\n *\n * For example, if we have a table with a rowspan of 2, the second row may only have 1 element in a 2x2 table.\n *\n * ```\n * // Visual representation of the table\n *     | 1-1 | 1-2 | // has 2 cells\n *     | 1-1 | 2-2 | // has only 1 cell\n * // Relative cell indices\n *     [{ row: 1, col: 1, rowspan: 2 }, { row: 1, col: 2 }] // has 2 cells\n *     [{ row: 1, col: 2 }] // has only 1 cell\n * ```\n */\nexport type RelativeCellIndices = {\n  row: number;\n  col: number;\n};\n\n/**\n * Absolute cell indices are relative to the table's layout (it's {@link OccupancyGrid}).\n *\n * It is as though the table is a grid of 1x1 cells, and any colspan or rowspan results in multiple 1x1 cells being occupied.\n *\n * For example, if we have a table with a colspan of 2, it will occupy 2 cells in the layout grid.\n *\n * ```\n * // Visual representation of the table\n *     | 1-1 | 1-1 | // has 2 cells\n *     | 2-1 | 2-2 | // has 2 cell\n * // Absolute cell indices\n *     [{ row: 1, col: 1, colspan: 2 }, { row: 1, col: 2, colspan: 2 }] // has 2 cells\n *     [{ row: 1, col: 1 }, { row: 1, col: 2 }] // has 2 cells\n * ```\n */\nexport type AbsoluteCellIndices = {\n  row: number;\n  col: number;\n};\n\n/**\n * An occupancy grid is a grid of the occupied cells in the table.\n * It is used to track the occupied cells in the table to know where to place the next cell.\n *\n * Since it allows us to resolve cell indices both {@link RelativeCellIndices} and {@link AbsoluteCellIndices}, it is the core data structure for table operations.\n */\ntype OccupancyGrid = (RelativeCellIndices & {\n  /**\n   * The rowspan of the cell.\n   */\n  rowspan: number;\n  /**\n   * The colspan of the cell.\n   */\n  colspan: number;\n  /**\n   * The cell.\n   */\n  cell: TableCell<any, any>;\n})[][];\n\n/**\n * This will return the {@link OccupancyGrid} of the table.\n * By laying out the table as though it were a grid of 1x1 cells, we can easily track where the cells are located (both relatively and absolutely).\n *\n * @returns an {@link OccupancyGrid}\n */\nexport function getTableCellOccupancyGrid(\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n): OccupancyGrid {\n  const { height, width } = getDimensionsOfTable(block);\n\n  /**\n   * Create a grid to track occupied cells\n   * This is used because rowspans and colspans take up multiple spaces\n   * So, we need to track the occupied cells in the grid to know where to place the next cell\n   */\n  const grid: OccupancyGrid = new Array(height)\n    .fill(false)\n    .map(() => new Array(width).fill(null));\n\n  // Find the next unoccupied cell in the table, row-major order\n  const findNextAvailable = (row: number, col: number) => {\n    for (let i = row; i < height; i++) {\n      for (let j = col; j < width; j++) {\n        if (!grid[i][j]) {\n          return { row: i, col: j };\n        }\n      }\n    }\n\n    throw new Error(\n      \"Unable to create occupancy grid for table, no more available cells\",\n    );\n  };\n\n  // Build up the grid, trying to fill in the cells with the correct relative row and column indices\n  for (let row = 0; row < block.content.rows.length; row++) {\n    for (let col = 0; col < block.content.rows[row].cells.length; col++) {\n      const cell = mapTableCell(block.content.rows[row].cells[col]);\n      const rowspan = getRowspan(cell);\n      const colspan = getColspan(cell);\n\n      // Rowspan and colspan complicate things, by taking up multiple cells in the grid\n      // We need to iterate over the cells that the rowspan and colspan take up\n      // and fill in the grid with the correct relative row and column indices\n      const { row: startRow, col: startCol } = findNextAvailable(row, col);\n\n      // Fill in the rowspan X colspan cells, starting from the next available cell, with the correct relative row and column indices\n      for (let i = startRow; i < startRow + rowspan; i++) {\n        for (let j = startCol; j < startCol + colspan; j++) {\n          if (grid[i][j]) {\n            // The cell is already occupied, the table is malformed\n            throw new Error(\n              `Unable to create occupancy grid for table, cell at ${i},${j} is already occupied`,\n            );\n          }\n\n          grid[i][j] = {\n            row,\n            col,\n            rowspan,\n            colspan,\n            cell,\n          };\n        }\n      }\n    }\n  }\n\n  // console.log(grid);\n\n  return grid;\n}\n\n/**\n * Given an {@link OccupancyGrid}, this will return the {@link TableContent} rows.\n *\n * @note This will remove duplicates from the occupancy grid. And does no bounds checking for validity of the occupancy grid.\n */\nexport function getTableRowsFromOccupancyGrid(\n  occupancyGrid: OccupancyGrid,\n): TableContent<any, any>[\"rows\"] {\n  // Because a cell can have a rowspan or colspan, it can occupy multiple cells in the occupancy grid\n  // So, we need to remove duplicates from the occupancy grid before we can return the table rows\n  const seen = new Set<string>();\n\n  return occupancyGrid.map((row) => {\n    // Just read out the cells in the occupancy grid, removing duplicates\n    return {\n      cells: row\n        .map((cell) => {\n          if (seen.has(cell.row + \":\" + cell.col)) {\n            return false;\n          }\n          seen.add(cell.row + \":\" + cell.col);\n          return cell.cell;\n        })\n        .filter((cell): cell is TableCell<any, any> => cell !== false),\n    };\n  });\n}\n\n/**\n * This will resolve the relative cell indices within the table block to the absolute cell indices within the table, accounting for colspan and rowspan.\n *\n * @note It will return only the first cell (i.e. top-left) that matches the relative cell indices. To find the other absolute cell indices this cell occupies, you can assume it is the rowspan and colspan number of cells away from the top-left cell.\n *\n * @returns The {@link AbsoluteCellIndices} and the {@link TableCell} at the absolute position.\n */\nexport function getAbsoluteTableCells(\n  /**\n   * The relative position of the cell in the table.\n   */\n  relativeCellIndices: RelativeCellIndices,\n  /**\n   * The table block containing the cell.\n   */\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n  /**\n   * The occupancy grid of the table.\n   */\n  occupancyGrid: OccupancyGrid = getTableCellOccupancyGrid(block),\n): AbsoluteCellIndices & {\n  cell: TableCell<any, any>;\n} {\n  for (let r = 0; r < occupancyGrid.length; r++) {\n    for (let c = 0; c < occupancyGrid[r].length; c++) {\n      // console.log(r, c, occupancyGrid);\n      const cell = occupancyGrid[r][c];\n      if (\n        cell.row === relativeCellIndices.row &&\n        cell.col === relativeCellIndices.col\n      ) {\n        return { row: r, col: c, cell: cell.cell };\n      }\n    }\n  }\n\n  throw new Error(\n    `Unable to resolve relative table cell indices for table, cell at ${relativeCellIndices.row},${relativeCellIndices.col} is not occupied`,\n  );\n}\n\n/**\n * This will get the dimensions of the table block.\n *\n * @returns The height and width of the table.\n */\nexport function getDimensionsOfTable(\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n): {\n  /**\n   * The number of rows in the table.\n   */\n  height: number;\n  /**\n   * The number of columns in the table.\n   */\n  width: number;\n} {\n  // Due to the way we store the table, the height is always the number of rows\n  const height = block.content.rows.length;\n\n  // Calculating the width is a bit more complex, as it is the maximum width of any row\n  let width = 0;\n  block.content.rows.forEach((row) => {\n    // Find the width of the row by summing the colspan of each cell\n    let rowWidth = 0;\n    row.cells.forEach((cell) => {\n      rowWidth += getColspan(cell);\n    });\n\n    // Update the width if the row is wider than the current width\n    width = Math.max(width, rowWidth);\n  });\n\n  return { height, width };\n}\n\n/**\n * This will resolve the absolute cell indices within the table block to the relative cell indices within the table, accounting for colspan and rowspan.\n *\n * @returns The {@link RelativeCellIndices} and the {@link TableCell} at the relative position.\n */\nexport function getRelativeTableCells(\n  /**\n   * The {@link AbsoluteCellIndices} of the cell in the table.\n   */\n  absoluteCellIndices: AbsoluteCellIndices,\n  /**\n   * The table block containing the cell.\n   */\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n  /**\n   * The occupancy grid of the table.\n   */\n  occupancyGrid: OccupancyGrid = getTableCellOccupancyGrid(block),\n):\n  | (RelativeCellIndices & {\n      cell: TableContent<any, any>[\"rows\"][number][\"cells\"][number];\n    })\n  | undefined {\n  const occupancyCell =\n    occupancyGrid[absoluteCellIndices.row]?.[absoluteCellIndices.col];\n\n  // Double check that the cell can be accessed\n  if (!occupancyCell) {\n    // The cell is not occupied, so it is invalid\n    return undefined;\n  }\n\n  return {\n    row: occupancyCell.row,\n    col: occupancyCell.col,\n    cell: occupancyCell.cell,\n  };\n}\n\n/**\n * This will get all the cells within a relative row of a table block.\n *\n * This method always starts the search for the row at the first column of the table.\n *\n * ```\n * // Visual representation of a table\n * | A | B | C |\n * |   | D | E |\n * | F | G | H |\n * // \"A\" has a rowspan of 2\n *\n * // getCellsAtRowHandle(0)\n * // returns [\n *  { row: 0, col: 0, cell: \"A\" },\n *  { row: 0, col: 1, cell: \"B\" },\n *  { row: 0, col: 2, cell: \"C\" },\n * ]\n *\n * // getCellsAtColumnHandle(1)\n * // returns [\n *  { row: 1, col: 0, cell: \"F\" },\n *  { row: 1, col: 1, cell: \"G\" },\n *  { row: 1, col: 2, cell: \"H\" },\n * ]\n * ```\n *\n * As you can see, you may not be able to retrieve all nodes given a relative row index, as cells can span multiple rows.\n *\n * @returns All of the cells associated with the relative row of the table. (All cells that have the same relative row index)\n */\nexport function getCellsAtRowHandle(\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n  relativeRowIndex: RelativeCellIndices[\"row\"],\n) {\n  const occupancyGrid = getTableCellOccupancyGrid(block);\n\n  if (relativeRowIndex < 0 || relativeRowIndex >= occupancyGrid.length) {\n    return [];\n  }\n\n  // First need to resolve the relative row index to an absolute row index\n  let absoluteRow = 0;\n\n  // Jump through the occupied cells ${relativeCellIndices.row} times to find the absolute row position\n  for (let i = 0; i < relativeRowIndex; i++) {\n    const cell = occupancyGrid[absoluteRow]?.[0];\n\n    if (!cell) {\n      return [];\n    }\n\n    // Skip the cells that the rowspan takes up\n    absoluteRow += cell.rowspan;\n  }\n\n  // Then for each column, get the cell at the absolute row index as a relative cell index\n  const cells = new Array(occupancyGrid[0].length)\n    .fill(false)\n    .map((_v, col) => {\n      return getRelativeTableCells(\n        { row: absoluteRow, col },\n        block,\n        occupancyGrid,\n      );\n    })\n    .filter(\n      (a): a is RelativeCellIndices & { cell: TableCell<any, any> } =>\n        a !== undefined,\n    );\n\n  // Filter out duplicates based on row and col properties\n  return cells.filter((cell, index) => {\n    return (\n      cells.findIndex((c) => c.row === cell.row && c.col === cell.col) === index\n    );\n  });\n}\n\n/**\n * This will get all the cells within a relative column of a table block.\n *\n * This method always starts the search for the column at the first row of the table.\n *\n * ```\n * // Visual representation of a table\n * |   A   | B |\n * | C | D | E |\n * | F | G | H |\n * // \"A\" has a colspan of 2\n *\n * // getCellsAtColumnHandle(0)\n * // returns [\n *  { row: 0, col: 0, cell: \"A\" },\n *  { row: 1, col: 0, cell: \"C\" },\n *  { row: 2, col: 0, cell: \"F\" },\n * ]\n *\n * // getCellsAtColumnHandle(1)\n * // returns [\n *  { row: 0, col: 1, cell: \"B\" },\n *  { row: 1, col: 2, cell: \"E\" },\n *  { row: 2, col: 2, cell: \"F\" },\n * ]\n * ```\n *\n * As you can see, you may not be able to retrieve all nodes given a relative column index, as cells can span multiple columns.\n *\n * @returns All of the cells associated with the relative column of the table. (All cells that have the same relative column index)\n */\nexport function getCellsAtColumnHandle(\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n  relativeColumnIndex: RelativeCellIndices[\"col\"],\n) {\n  const occupancyGrid = getTableCellOccupancyGrid(block);\n\n  if (\n    relativeColumnIndex < 0 ||\n    relativeColumnIndex >= occupancyGrid[0].length\n  ) {\n    return [];\n  }\n\n  // First need to resolve the relative column index to an absolute column index\n  let absoluteCol = 0;\n\n  // Now that we've already resolved the absolute row position, we can jump through the occupied cells ${relativeCellIndices.col} times to find the absolute column position\n  for (let i = 0; i < relativeColumnIndex; i++) {\n    const cell = occupancyGrid[0]?.[absoluteCol];\n\n    if (!cell) {\n      return [];\n    }\n\n    // Skip the cells that the colspan takes up\n    absoluteCol += cell.colspan;\n  }\n\n  // Then for each row, get the cell at the absolute column index as a relative cell index\n  const cells = new Array(occupancyGrid.length)\n    .fill(false)\n    .map((_v, row) => {\n      return getRelativeTableCells(\n        { row, col: absoluteCol },\n        block,\n        occupancyGrid,\n      );\n    })\n    .filter(\n      (a): a is RelativeCellIndices & { cell: TableCell<any, any> } =>\n        a !== undefined,\n    );\n\n  // Filter out duplicates based on row and col properties\n  return cells.filter((cell, index) => {\n    return (\n      cells.findIndex((c) => c.row === cell.row && c.col === cell.col) === index\n    );\n  });\n}\n\n/**\n * This moves a column from one index to another.\n *\n * @note This is a destructive operation, it will modify the provided {@link OccupancyGrid} in place.\n */\nexport function moveColumn(\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n  fromColIndex: RelativeCellIndices[\"col\"],\n  toColIndex: RelativeCellIndices[\"col\"],\n  occupancyGrid: OccupancyGrid = getTableCellOccupancyGrid(block),\n): TableContent<any, any>[\"rows\"] {\n  // To move cells in a column, we need to layout the whole table\n  // and then move the cells accordingly.\n  const { col: absoluteSourceCol } = getAbsoluteTableCells(\n    {\n      row: 0,\n      col: fromColIndex,\n    },\n    block,\n    occupancyGrid,\n  );\n  const { col: absoluteTargetCol } = getAbsoluteTableCells(\n    {\n      row: 0,\n      col: toColIndex,\n    },\n    block,\n    occupancyGrid,\n  );\n\n  /**\n   * Currently, this function assumes that the caller has already checked that the source and target columns are valid.\n   * Such as by using {@link canColumnBeDraggedInto}. In the future, we may want to have the move logic be smarter\n   * and handle invalid column indices in some way.\n   */\n  occupancyGrid.forEach((row) => {\n    // Move the cell to the target column\n    const [sourceCell] = row.splice(absoluteSourceCol, 1);\n    row.splice(absoluteTargetCol, 0, sourceCell);\n  });\n\n  return getTableRowsFromOccupancyGrid(occupancyGrid);\n}\n\n/**\n * This moves a row from one index to another.\n *\n * @note This is a destructive operation, it will modify the {@link OccupancyGrid} in place.\n */\nexport function moveRow(\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n  fromRowIndex: RelativeCellIndices[\"row\"],\n  toRowIndex: RelativeCellIndices[\"row\"],\n  occupancyGrid: OccupancyGrid = getTableCellOccupancyGrid(block),\n): TableContent<any, any>[\"rows\"] {\n  // To move cells in a column, we need to layout the whole table\n  // and then move the cells accordingly.\n  const { row: absoluteSourceRow } = getAbsoluteTableCells(\n    {\n      row: fromRowIndex,\n      col: 0,\n    },\n    block,\n    occupancyGrid,\n  );\n  const { row: absoluteTargetRow } = getAbsoluteTableCells(\n    {\n      row: toRowIndex,\n      col: 0,\n    },\n    block,\n    occupancyGrid,\n  );\n\n  /**\n   * Currently, this function assumes that the caller has already checked that the source and target rows are valid.\n   * Such as by using {@link canRowBeDraggedInto}. In the future, we may want to have the move logic be smarter\n   * and handle invalid row indices in some way.\n   */\n  const [sourceRow] = occupancyGrid.splice(absoluteSourceRow, 1);\n  occupancyGrid.splice(absoluteTargetRow, 0, sourceRow);\n\n  return getTableRowsFromOccupancyGrid(occupancyGrid);\n}\n\n/**\n * This will check if a cell is empty.\n *\n * @returns True if the cell is empty, false otherwise.\n */\nfunction isCellEmpty(\n  cell:\n    | PartialTableContent<any, any>[\"rows\"][number][\"cells\"][number]\n    | undefined,\n): boolean {\n  if (!cell) {\n    return true;\n  }\n  if (isPartialTableCell(cell)) {\n    return isCellEmpty(cell.content);\n  } else if (typeof cell === \"string\") {\n    return cell.length === 0;\n  } else if (Array.isArray(cell)) {\n    return cell.every((c) =>\n      typeof c === \"string\"\n        ? c.length === 0\n        : isStyledTextInlineContent(c)\n          ? c.text.length === 0\n          : isPartialLinkInlineContent(c)\n            ? typeof c.content === \"string\"\n              ? c.content.length === 0\n              : c.content.every((s) => s.text.length === 0)\n            : false,\n    );\n  } else {\n    return false;\n  }\n}\n\n/**\n * This will remove empty rows or columns from the table.\n *\n * @note This is a destructive operation, it will modify the {@link OccupancyGrid} in place.\n */\nexport function cropEmptyRowsOrColumns(\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n  removeEmpty: \"columns\" | \"rows\",\n  occupancyGrid: OccupancyGrid = getTableCellOccupancyGrid(block),\n): TableContent<any, any>[\"rows\"] {\n  if (removeEmpty === \"columns\") {\n    // strips empty columns on the right\n    let emptyColsOnRight = 0;\n    for (\n      let cellIndex = occupancyGrid[0].length - 1;\n      cellIndex >= 0;\n      cellIndex--\n    ) {\n      const isEmpty = occupancyGrid.every(\n        (row) =>\n          isCellEmpty(row[cellIndex].cell) && row[cellIndex].colspan === 1,\n      );\n      if (!isEmpty) {\n        break;\n      }\n\n      emptyColsOnRight++;\n    }\n\n    for (let i = occupancyGrid.length - 1; i >= 0; i--) {\n      // We maintain at least one cell, even if all the cells are empty\n      const cellsToRemove = Math.max(\n        occupancyGrid[i].length - emptyColsOnRight,\n        1,\n      );\n      occupancyGrid[i] = occupancyGrid[i].slice(0, cellsToRemove);\n    }\n\n    return getTableRowsFromOccupancyGrid(occupancyGrid);\n  }\n\n  // strips empty rows at the bottom\n  let emptyRowsOnBottom = 0;\n  for (let rowIndex = occupancyGrid.length - 1; rowIndex >= 0; rowIndex--) {\n    const isEmpty = occupancyGrid[rowIndex].every(\n      (cell) => isCellEmpty(cell.cell) && cell.rowspan === 1,\n    );\n    if (!isEmpty) {\n      break;\n    }\n\n    emptyRowsOnBottom++;\n  }\n\n  // We maintain at least one row, even if all the rows are empty\n  const rowsToRemove = Math.min(emptyRowsOnBottom, occupancyGrid.length - 1);\n\n  occupancyGrid.splice(occupancyGrid.length - rowsToRemove, rowsToRemove);\n\n  return getTableRowsFromOccupancyGrid(occupancyGrid);\n}\n\n/**\n * This will add a specified number of rows or columns to the table (filling with empty cells).\n *\n * @note This is a destructive operation, it will modify the {@link OccupancyGrid} in place.\n */\nexport function addRowsOrColumns(\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n  addType: \"columns\" | \"rows\",\n  /**\n   * The number of rows or columns to add.\n   *\n   * @note if negative, it will remove rows or columns.\n   */\n  numToAdd: number,\n  occupancyGrid: OccupancyGrid = getTableCellOccupancyGrid(block),\n): TableContent<any, any>[\"rows\"] {\n  const { width, height } = getDimensionsOfTable(block);\n\n  if (addType === \"columns\") {\n    // Add empty columns to the right\n    occupancyGrid.forEach((row, rowIndex) => {\n      if (numToAdd >= 0) {\n        for (let i = 0; i < numToAdd; i++) {\n          row.push({\n            row: rowIndex,\n            col: Math.max(...row.map((r) => r.col)) + 1,\n            rowspan: 1,\n            colspan: 1,\n            cell: mapTableCell(\"\"),\n          });\n        }\n      } else {\n        // Remove columns on the right\n        row.splice(width + numToAdd, -1 * numToAdd);\n      }\n    });\n  } else {\n    if (numToAdd > 0) {\n      // Add empty rows to the bottom\n      for (let i = 0; i < numToAdd; i++) {\n        const newRow = new Array(width).fill(null).map((_, colIndex) => ({\n          row: height + i,\n          col: colIndex,\n          rowspan: 1,\n          colspan: 1,\n          cell: mapTableCell(\"\"),\n        }));\n        occupancyGrid.push(newRow);\n      }\n    } else if (numToAdd < 0) {\n      // Remove rows at the bottom\n      occupancyGrid.splice(height + numToAdd, -1 * numToAdd);\n    }\n  }\n\n  return getTableRowsFromOccupancyGrid(occupancyGrid);\n}\n\n/**\n * Checks if a row can be safely dropped at the target row index without splitting merged cells.\n */\nexport function canRowBeDraggedInto(\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n  draggingIndex: RelativeCellIndices[\"row\"],\n  targetRowIndex: RelativeCellIndices[\"row\"],\n) {\n  // Check cells at the target row\n  const targetCells = getCellsAtRowHandle(block, targetRowIndex);\n\n  // If no cells have rowspans > 1, dragging is always allowed\n  const hasMergedCells = targetCells.some((cell) => getRowspan(cell.cell) > 1);\n  if (!hasMergedCells) {\n    return true;\n  }\n\n  let endRowIndex = targetRowIndex;\n  let startRowIndex = targetRowIndex;\n  targetCells.forEach((cell) => {\n    const rowspan = getRowspan(cell.cell);\n    endRowIndex = Math.max(endRowIndex, cell.row + rowspan - 1);\n    startRowIndex = Math.min(startRowIndex, cell.row);\n  });\n\n  // Check the direction of the drag\n  const isDraggingDown = draggingIndex < targetRowIndex;\n\n  // Allow dragging only at the start/end of merged cells\n  // Otherwise, the target row was within a merged cell which we don't allow\n  return isDraggingDown\n    ? targetRowIndex === endRowIndex\n    : targetRowIndex === startRowIndex;\n}\n\n/**\n * Checks if a column can be safely dropped at the target column index without splitting merged cells.\n */\nexport function canColumnBeDraggedInto(\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n  draggingIndex: RelativeCellIndices[\"col\"],\n  targetColumnIndex: RelativeCellIndices[\"col\"],\n) {\n  // Check cells at the target column\n  const targetCells = getCellsAtColumnHandle(block, targetColumnIndex);\n\n  // If no cells have colspans > 1, dragging is always allowed\n  const hasMergedCells = targetCells.some((cell) => getColspan(cell.cell) > 1);\n  if (!hasMergedCells) {\n    return true;\n  }\n\n  let endColumnIndex = targetColumnIndex;\n  let startColumnIndex = targetColumnIndex;\n  targetCells.forEach((cell) => {\n    const colspan = getColspan(cell.cell);\n    endColumnIndex = Math.max(endColumnIndex, cell.col + colspan - 1);\n    startColumnIndex = Math.min(startColumnIndex, cell.col);\n  });\n\n  // Check the direction of the drag\n  const isDraggingRight = draggingIndex < targetColumnIndex;\n\n  // Allow dragging only at the start/end of merged cells\n  // Otherwise, the target column was within a merged cell which we don't allow\n  return isDraggingRight\n    ? targetColumnIndex === endColumnIndex\n    : targetColumnIndex === startColumnIndex;\n}\n\n/**\n * Checks if two cells are in the same column.\n *\n * @returns True if the cells are in the same column, false otherwise.\n */\nexport function areInSameColumn(\n  from: RelativeCellIndices,\n  to: RelativeCellIndices,\n  block: BlockFromConfigNoChildren<DefaultBlockSchema[\"table\"], any, any>,\n) {\n  // Table indices are relative to the table, so we need to resolve the absolute cell indices\n  const anchorAbsoluteCellIndices = getAbsoluteTableCells(from, block);\n\n  // Table indices are relative to the table, so we need to resolve the absolute cell indices\n  const headAbsoluteCellIndices = getAbsoluteTableCells(to, block);\n\n  // Compare the column indices to determine the merge direction\n  return anchorAbsoluteCellIndices.col === headAbsoluteCellIndices.col;\n}\n","import { Attrs, Fragment, Mark, Node, Schema } from \"@tiptap/pm/model\";\n\nimport UniqueID from \"../../extensions/UniqueID/UniqueID.js\";\nimport type {\n  InlineContentSchema,\n  PartialCustomInlineContentFromConfig,\n  PartialInlineContent,\n  PartialLink,\n  PartialTableContent,\n  StyleSchema,\n  StyledText,\n} from \"../../schema\";\n\nimport type { PartialBlock } from \"../../blocks/defaultBlocks\";\nimport {\n  isPartialLinkInlineContent,\n  isStyledTextInlineContent,\n} from \"../../schema/inlineContent/types.js\";\nimport { getColspan, isPartialTableCell } from \"../../util/table.js\";\nimport { UnreachableCaseError } from \"../../util/typescript.js\";\nimport { getAbsoluteTableCells } from \"../blockManipulation/tables/tables.js\";\nimport { getStyleSchema } from \"../pmUtil.js\";\n\n/**\n * Convert a StyledText inline element to a\n * prosemirror text node with the appropriate marks\n */\nfunction styledTextToNodes<T extends StyleSchema>(\n  styledText: StyledText<T>,\n  schema: Schema,\n  styleSchema: T,\n  blockType?: string,\n): Node[] {\n  const marks: Mark[] = [];\n\n  for (const [style, value] of Object.entries(styledText.styles || {})) {\n    const config = styleSchema[style];\n    if (!config) {\n      throw new Error(`style ${style} not found in styleSchema`);\n    }\n\n    if (config.propSchema === \"boolean\") {\n      if (value) {\n        marks.push(schema.mark(style));\n      }\n    } else if (config.propSchema === \"string\") {\n      if (value) {\n        marks.push(schema.mark(style, { stringValue: value }));\n      }\n    } else {\n      throw new UnreachableCaseError(config.propSchema);\n    }\n  }\n\n  const parseHardBreaks = !blockType || !schema.nodes[blockType].spec.code;\n\n  if (!parseHardBreaks) {\n    return styledText.text.length > 0\n      ? [schema.text(styledText.text, marks)]\n      : [];\n  }\n\n  return (\n    styledText.text\n      // Splits text & line breaks.\n      .split(/(\\n)/g)\n      // If the content ends with a line break, an empty string is added to the\n      // end, which this removes.\n      .filter((text) => text.length > 0)\n      // Converts text & line breaks to nodes.\n      .map((text) => {\n        if (text === \"\\n\") {\n          return schema.nodes[\"hardBreak\"].createChecked();\n        } else {\n          return schema.text(text, marks);\n        }\n      })\n  );\n}\n\n/**\n * Converts a Link inline content element to\n * prosemirror text nodes with the appropriate marks\n */\nfunction linkToNodes(\n  link: PartialLink<StyleSchema>,\n  schema: Schema,\n  styleSchema: StyleSchema,\n): Node[] {\n  const linkMark = schema.marks.link.create({\n    href: link.href,\n  });\n\n  return styledTextArrayToNodes(link.content, schema, styleSchema).map(\n    (node) => {\n      if (node.type.name === \"text\") {\n        return node.mark([...node.marks, linkMark]);\n      }\n\n      if (node.type.name === \"hardBreak\") {\n        return node;\n      }\n      throw new Error(\"unexpected node type\");\n    },\n  );\n}\n\n/**\n * Converts an array of StyledText inline content elements to\n * prosemirror text nodes with the appropriate marks\n */\nfunction styledTextArrayToNodes<S extends StyleSchema>(\n  content: string | StyledText<S>[],\n  schema: Schema,\n  styleSchema: S,\n  blockType?: string,\n): Node[] {\n  const nodes: Node[] = [];\n\n  if (typeof content === \"string\") {\n    nodes.push(\n      ...styledTextToNodes(\n        { type: \"text\", text: content, styles: {} },\n        schema,\n        styleSchema,\n        blockType,\n      ),\n    );\n    return nodes;\n  }\n\n  for (const styledText of content) {\n    nodes.push(\n      ...styledTextToNodes(styledText, schema, styleSchema, blockType),\n    );\n  }\n  return nodes;\n}\n\n/**\n * converts an array of inline content elements to prosemirror nodes\n */\nexport function inlineContentToNodes<\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  blockContent: PartialInlineContent<I, S>,\n  schema: Schema,\n  blockType?: string,\n  styleSchema: S = getStyleSchema(schema),\n): Node[] {\n  const nodes: Node[] = [];\n\n  for (const content of blockContent) {\n    if (typeof content === \"string\") {\n      nodes.push(\n        ...styledTextArrayToNodes(content, schema, styleSchema, blockType),\n      );\n    } else if (isPartialLinkInlineContent(content)) {\n      nodes.push(...linkToNodes(content, schema, styleSchema));\n    } else if (isStyledTextInlineContent(content)) {\n      nodes.push(\n        ...styledTextArrayToNodes([content], schema, styleSchema, blockType),\n      );\n    } else {\n      nodes.push(\n        blockOrInlineContentToContentNode(content, schema, styleSchema),\n      );\n    }\n  }\n  return nodes;\n}\n\n/**\n * converts an array of inline content elements to prosemirror nodes\n */\nexport function tableContentToNodes<\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  tableContent: PartialTableContent<I, S>,\n  schema: Schema,\n  styleSchema: StyleSchema = getStyleSchema(schema),\n): Node[] {\n  const rowNodes: Node[] = [];\n  // Header rows and columns are used to determine the type of the cell\n  // If headerRows is 1, then the first row is a header row\n  const headerRows = new Array(tableContent.headerRows ?? 0).fill(true);\n  // If headerCols is 1, then the first column is a header column\n  const headerCols = new Array(tableContent.headerCols ?? 0).fill(true);\n\n  const columnWidths: (number | undefined)[] = tableContent.columnWidths ?? [];\n\n  for (let rowIndex = 0; rowIndex < tableContent.rows.length; rowIndex++) {\n    const row = tableContent.rows[rowIndex];\n    const columnNodes: Node[] = [];\n    const isHeaderRow = headerRows[rowIndex];\n    for (let cellIndex = 0; cellIndex < row.cells.length; cellIndex++) {\n      const cell = row.cells[cellIndex];\n      const isHeaderCol = headerCols[cellIndex];\n      /**\n       * The attributes of the cell to apply to the node\n       */\n      const attrs: Attrs | undefined = undefined;\n      /**\n       * The content of the cell to apply to the node\n       */\n      let content: Fragment | Node | readonly Node[] | null = null;\n\n      // Colwidths are absolutely referenced to the table, so we need to resolve the relative cell index to the absolute cell index\n      const absoluteCellIndex = getAbsoluteTableCells(\n        {\n          row: rowIndex,\n          col: cellIndex,\n        },\n        { type: \"table\", content: tableContent } as any,\n      );\n\n      // Assume the column width is the width of the cell at the absolute cell index\n      let colwidth: (number | undefined)[] | null = columnWidths[\n        absoluteCellIndex.col\n      ]\n        ? [columnWidths[absoluteCellIndex.col]]\n        : null;\n\n      if (!cell) {\n        // No-op\n      } else if (typeof cell === \"string\") {\n        content = schema.text(cell);\n      } else if (isPartialTableCell(cell)) {\n        if (cell.content) {\n          content = inlineContentToNodes(\n            cell.content,\n            schema,\n            \"tableParagraph\",\n            styleSchema,\n          );\n        }\n        const colspan = getColspan(cell);\n\n        if (colspan > 1) {\n          // If the cell has a > 1 colspan, we need to get the column width for each cell in the span\n          colwidth = new Array(colspan).fill(false).map((_, i) => {\n            // Starting from the absolute column index, get the column width for each cell in the span\n            return columnWidths[absoluteCellIndex.col + i] ?? undefined;\n          });\n        }\n      } else {\n        content = inlineContentToNodes(\n          cell,\n          schema,\n          \"tableParagraph\",\n          styleSchema,\n        );\n      }\n\n      const cellNode = schema.nodes[\n        isHeaderCol || isHeaderRow ? \"tableHeader\" : \"tableCell\"\n      ].createChecked(\n        {\n          ...(isPartialTableCell(cell) ? cell.props : {}),\n          colwidth,\n        },\n        schema.nodes[\"tableParagraph\"].createChecked(attrs, content),\n      );\n      columnNodes.push(cellNode);\n    }\n\n    const rowNode = schema.nodes[\"tableRow\"].createChecked({}, columnNodes);\n    rowNodes.push(rowNode);\n  }\n  return rowNodes;\n}\n\nfunction blockOrInlineContentToContentNode(\n  block:\n    | PartialBlock<any, any, any>\n    | PartialCustomInlineContentFromConfig<any, any>,\n  schema: Schema,\n  styleSchema: StyleSchema,\n) {\n  let contentNode: Node;\n  let type = block.type;\n\n  // TODO: needed? came from previous code\n  if (type === undefined) {\n    type = \"paragraph\";\n  }\n\n  if (!schema.nodes[type]) {\n    throw new Error(`node type ${type} not found in schema`);\n  }\n\n  if (!block.content) {\n    contentNode = schema.nodes[type].createChecked(block.props);\n  } else if (typeof block.content === \"string\") {\n    const nodes = inlineContentToNodes(\n      [block.content],\n      schema,\n      type,\n      styleSchema,\n    );\n    contentNode = schema.nodes[type].createChecked(block.props, nodes);\n  } else if (Array.isArray(block.content)) {\n    const nodes = inlineContentToNodes(\n      block.content,\n      schema,\n      type,\n      styleSchema,\n    );\n    contentNode = schema.nodes[type].createChecked(block.props, nodes);\n  } else if (block.content.type === \"tableContent\") {\n    const nodes = tableContentToNodes(block.content, schema, styleSchema);\n    contentNode = schema.nodes[type].createChecked(block.props, nodes);\n  } else {\n    throw new UnreachableCaseError(block.content.type);\n  }\n  return contentNode;\n}\n\n/**\n * Converts a BlockNote block to a Prosemirror node.\n */\nexport function blockToNode(\n  block: PartialBlock<any, any, any>,\n  schema: Schema,\n  styleSchema: StyleSchema = getStyleSchema(schema),\n) {\n  let id = block.id;\n\n  if (id === undefined) {\n    id = UniqueID.options.generateID();\n  }\n\n  const children: Node[] = [];\n\n  if (block.children) {\n    for (const child of block.children) {\n      children.push(blockToNode(child, schema, styleSchema));\n    }\n  }\n\n  const isBlockContent =\n    !block.type || // can happen if block.type is not defined (this should create the default node)\n    schema.nodes[block.type].isInGroup(\"blockContent\");\n\n  if (isBlockContent) {\n    // Blocks with a type that matches \"blockContent\" group always need to be wrapped in a blockContainer\n\n    const contentNode = blockOrInlineContentToContentNode(\n      block,\n      schema,\n      styleSchema,\n    );\n\n    const groupNode =\n      children.length > 0\n        ? schema.nodes[\"blockGroup\"].createChecked({}, children)\n        : undefined;\n\n    return schema.nodes[\"blockContainer\"].createChecked(\n      {\n        id: id,\n        ...block.props,\n      },\n      groupNode ? [contentNode, groupNode] : contentNode,\n    );\n  } else if (schema.nodes[block.type].isInGroup(\"bnBlock\")) {\n    // this is a bnBlock node like Column or ColumnList that directly translates to a prosemirror node\n    return schema.nodes[block.type].createChecked(\n      {\n        id: id,\n        ...block.props,\n      },\n      children,\n    );\n  } else {\n    throw new Error(\n      `block type ${block.type} doesn't match blockContent or bnBlock group`,\n    );\n  }\n}\n","import type { Node } from \"prosemirror-model\";\n\n/**\n * Get a TipTap node by id\n */\nexport function getNodeById(\n  id: string,\n  doc: Node,\n): { node: Node; posBeforeNode: number } | undefined {\n  let targetNode: Node | undefined = undefined;\n  let posBeforeNode: number | undefined = undefined;\n\n  doc.firstChild!.descendants((node, pos) => {\n    // Skips traversing nodes after node with target ID has been found.\n    if (targetNode) {\n      return false;\n    }\n\n    // Keeps traversing nodes if block with target ID has not been found.\n    if (!isNodeBlock(node) || node.attrs.id !== id) {\n      return true;\n    }\n\n    targetNode = node;\n    posBeforeNode = pos + 1;\n\n    return false;\n  });\n\n  if (targetNode === undefined || posBeforeNode === undefined) {\n    return undefined;\n  }\n\n  return {\n    node: targetNode,\n    posBeforeNode: posBeforeNode,\n  };\n}\n\nexport function isNodeBlock(node: Node): boolean {\n  return node.type.isInGroup(\"bnBlock\");\n}\n","import {\n  Fragment,\n  type NodeType,\n  type Node as PMNode,\n  Slice,\n} from \"prosemirror-model\";\nimport { TextSelection, Transaction } from \"prosemirror-state\";\nimport { TableMap } from \"prosemirror-tables\";\nimport { ReplaceStep, Transform } from \"prosemirror-transform\";\n\nimport type { Block, PartialBlock } from \"../../../../blocks/defaultBlocks.js\";\nimport type {\n  BlockIdentifier,\n  BlockSchema,\n} from \"../../../../schema/blocks/types.js\";\nimport type { InlineContentSchema } from \"../../../../schema/inlineContent/types.js\";\nimport type { StyleSchema } from \"../../../../schema/styles/types.js\";\nimport { UnreachableCaseError } from \"../../../../util/typescript.js\";\nimport {\n  type BlockInfo,\n  getBlockInfoFromResolvedPos,\n} from \"../../../getBlockInfoFromPos.js\";\nimport {\n  blockToNode,\n  inlineContentToNodes,\n  tableContentToNodes,\n} from \"../../../nodeConversions/blockToNode.js\";\nimport { nodeToBlock } from \"../../../nodeConversions/nodeToBlock.js\";\nimport { getNodeById } from \"../../../nodeUtil.js\";\nimport { getPmSchema } from \"../../../pmUtil.js\";\n\n// for compatibility with tiptap. TODO: remove as we want to remove dependency on tiptap command interface\nexport const updateBlockCommand = <\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  posBeforeBlock: number,\n  block: PartialBlock<BSchema, I, S>,\n) => {\n  return ({\n    tr,\n    dispatch,\n  }: {\n    tr: Transaction;\n    dispatch?: () => void;\n  }): boolean => {\n    if (dispatch) {\n      updateBlockTr(tr, posBeforeBlock, block);\n    }\n    return true;\n  };\n};\n\nexport function updateBlockTr<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  tr: Transform | Transaction,\n  posBeforeBlock: number,\n  block: PartialBlock<BSchema, I, S>,\n  replaceFromPos?: number,\n  replaceToPos?: number,\n) {\n  const blockInfo = getBlockInfoFromResolvedPos(tr.doc.resolve(posBeforeBlock));\n\n  let cellAnchor: CellAnchor | null = null;\n  if (blockInfo.blockNoteType === \"table\") {\n    cellAnchor = captureCellAnchor(tr);\n  }\n\n  const pmSchema = getPmSchema(tr);\n\n  if (\n    replaceFromPos !== undefined &&\n    replaceToPos !== undefined &&\n    replaceFromPos > replaceToPos\n  ) {\n    throw new Error(\"Invalid replaceFromPos or replaceToPos\");\n  }\n\n  // Adds blockGroup node with child blocks if necessary.\n\n  const oldNodeType = pmSchema.nodes[blockInfo.blockNoteType];\n  const newNodeType = pmSchema.nodes[block.type || blockInfo.blockNoteType];\n  const newBnBlockNodeType = newNodeType.isInGroup(\"bnBlock\")\n    ? newNodeType\n    : pmSchema.nodes[\"blockContainer\"];\n\n  if (blockInfo.isBlockContainer && newNodeType.isInGroup(\"blockContent\")) {\n    const replaceFromOffset =\n      replaceFromPos !== undefined &&\n      replaceFromPos > blockInfo.blockContent.beforePos &&\n      replaceFromPos < blockInfo.blockContent.afterPos\n        ? replaceFromPos - blockInfo.blockContent.beforePos - 1\n        : undefined;\n\n    const replaceToOffset =\n      replaceToPos !== undefined &&\n      replaceToPos > blockInfo.blockContent.beforePos &&\n      replaceToPos < blockInfo.blockContent.afterPos\n        ? replaceToPos - blockInfo.blockContent.beforePos - 1\n        : undefined;\n\n    updateChildren(block, tr, blockInfo);\n    // The code below determines the new content of the block.\n    // or \"keep\" to keep as-is\n    updateBlockContentNode(\n      block,\n      tr,\n      oldNodeType,\n      newNodeType,\n      blockInfo,\n      replaceFromOffset,\n      replaceToOffset,\n    );\n  } else if (!blockInfo.isBlockContainer && newNodeType.isInGroup(\"bnBlock\")) {\n    updateChildren(block, tr, blockInfo);\n    // old node was a bnBlock type (like column or columnList) and new block as well\n    // No op, we just update the bnBlock below (at end of function) and have already updated the children\n  } else {\n    // switching from blockContainer to non-blockContainer or v.v.\n    // currently breaking for column slash menu items converting empty block\n    // to column.\n\n    // currently, we calculate the new node and replace the entire node with the desired new node.\n    // for this, we do a nodeToBlock on the existing block to get the children.\n    // it would be cleaner to use a ReplaceAroundStep, but this is a bit simpler and it's quite an edge case\n    const existingBlock = nodeToBlock(blockInfo.bnBlock.node, pmSchema);\n    tr.replaceWith(\n      blockInfo.bnBlock.beforePos,\n      blockInfo.bnBlock.afterPos,\n      blockToNode(\n        {\n          children: existingBlock.children, // if no children are passed in, use existing children\n          ...block,\n        },\n        pmSchema,\n      ),\n    );\n\n    return;\n  }\n\n  // Adds all provided props as attributes to the parent blockContainer node too, and also preserves existing\n  // attributes.\n  tr.setNodeMarkup(blockInfo.bnBlock.beforePos, newBnBlockNodeType, {\n    ...blockInfo.bnBlock.node.attrs,\n    ...block.props,\n  });\n\n  if (cellAnchor) {\n    restoreCellAnchor(tr, blockInfo, cellAnchor);\n  }\n}\n\nfunction updateBlockContentNode<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  block: PartialBlock<BSchema, I, S>,\n  tr: Transform,\n  oldNodeType: NodeType,\n  newNodeType: NodeType,\n  blockInfo: {\n    childContainer?:\n      | { node: PMNode; beforePos: number; afterPos: number }\n      | undefined;\n    blockContent: { node: PMNode; beforePos: number; afterPos: number };\n  },\n  replaceFromOffset?: number,\n  replaceToOffset?: number,\n) {\n  const pmSchema = getPmSchema(tr);\n  let content: PMNode[] | \"keep\" = \"keep\";\n\n  // Has there been any custom content provided?\n  if (block.content) {\n    if (typeof block.content === \"string\") {\n      // Adds a single text node with no marks to the content.\n      content = inlineContentToNodes(\n        [block.content],\n        pmSchema,\n        newNodeType.name,\n      );\n    } else if (Array.isArray(block.content)) {\n      // Adds a text node with the provided styles converted into marks to the content,\n      // for each InlineContent object.\n      content = inlineContentToNodes(block.content, pmSchema, newNodeType.name);\n    } else if (block.content.type === \"tableContent\") {\n      content = tableContentToNodes(block.content, pmSchema);\n    } else {\n      throw new UnreachableCaseError(block.content.type);\n    }\n  } else {\n    // no custom content has been provided, use existing content IF possible\n    // Since some block types contain inline content and others don't,\n    // we either need to call setNodeMarkup to just update type &\n    // attributes, or replaceWith to replace the whole blockContent.\n    if (oldNodeType.spec.content === \"\") {\n      // keep old content, because it's empty anyway and should be compatible with\n      // any newContentType\n    } else if (newNodeType.spec.content !== oldNodeType.spec.content) {\n      // the content type changed, replace the previous content\n      content = [];\n    } else {\n      // keep old content, because the content type is the same and should be compatible\n    }\n  }\n\n  // Now, changes the blockContent node type and adds the provided props\n  // as attributes. Also preserves all existing attributes that are\n  // compatible with the new type.\n  //\n  // Use either setNodeMarkup or replaceWith depending on whether the\n  // content is being replaced or not.\n  if (content === \"keep\") {\n    // use setNodeMarkup to only update the type and attributes\n    tr.setNodeMarkup(blockInfo.blockContent.beforePos, newNodeType, {\n      ...blockInfo.blockContent.node.attrs,\n      ...block.props,\n    });\n  } else if (replaceFromOffset !== undefined || replaceToOffset !== undefined) {\n    // first update markup of the containing node\n    tr.setNodeMarkup(blockInfo.blockContent.beforePos, newNodeType, {\n      ...blockInfo.blockContent.node.attrs,\n      ...block.props,\n    });\n\n    const start =\n      blockInfo.blockContent.beforePos + 1 + (replaceFromOffset ?? 0);\n    const end =\n      blockInfo.blockContent.beforePos +\n      1 +\n      (replaceToOffset ?? blockInfo.blockContent.node.content.size);\n\n    // for content like table cells (where the blockcontent has nested PM nodes),\n    // we need to figure out the correct openStart and openEnd for the slice when replacing\n\n    const contentDepth = tr.doc.resolve(blockInfo.blockContent.beforePos).depth;\n    const startDepth = tr.doc.resolve(start).depth;\n    const endDepth = tr.doc.resolve(end).depth;\n\n    tr.replace(\n      start,\n      end,\n      new Slice(\n        Fragment.from(content),\n        startDepth - contentDepth - 1,\n        endDepth - contentDepth - 1,\n      ),\n    );\n  } else {\n    // use replaceWith to replace the content and the block itself\n    // also reset the selection since replacing the block content\n    // sets it to the next block.\n    tr.replaceWith(\n      blockInfo.blockContent.beforePos,\n      blockInfo.blockContent.afterPos,\n      newNodeType.createChecked(\n        {\n          ...blockInfo.blockContent.node.attrs,\n          ...block.props,\n        },\n        content,\n      ),\n    );\n  }\n}\n\nfunction updateChildren<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(block: PartialBlock<BSchema, I, S>, tr: Transform, blockInfo: BlockInfo) {\n  const pmSchema = getPmSchema(tr);\n  if (block.children !== undefined && block.children.length > 0) {\n    const childNodes = block.children.map((child) => {\n      return blockToNode(child, pmSchema);\n    });\n\n    // Checks if a blockGroup node already exists.\n    if (blockInfo.childContainer) {\n      // Replaces all child nodes in the existing blockGroup with the ones created earlier.\n\n      // use a replacestep to avoid the fitting algorithm\n      tr.step(\n        new ReplaceStep(\n          blockInfo.childContainer.beforePos + 1,\n          blockInfo.childContainer.afterPos - 1,\n          new Slice(Fragment.from(childNodes), 0, 0),\n        ),\n      );\n    } else {\n      if (!blockInfo.isBlockContainer) {\n        throw new Error(\"impossible\");\n      }\n      // Inserts a new blockGroup containing the child nodes created earlier.\n      tr.insert(\n        blockInfo.blockContent.afterPos,\n        pmSchema.nodes[\"blockGroup\"].createChecked({}, childNodes),\n      );\n    }\n  }\n}\n\nexport function updateBlock<\n  BSchema extends BlockSchema = any,\n  I extends InlineContentSchema = any,\n  S extends StyleSchema = any,\n>(\n  tr: Transform,\n  blockToUpdate: BlockIdentifier,\n  update: PartialBlock<BSchema, I, S>,\n  replaceFromPos?: number,\n  replaceToPos?: number,\n): Block<BSchema, I, S> {\n  const id =\n    typeof blockToUpdate === \"string\" ? blockToUpdate : blockToUpdate.id;\n  const posInfo = getNodeById(id, tr.doc);\n  if (!posInfo) {\n    throw new Error(`Block with ID ${id} not found`);\n  }\n\n  updateBlockTr(\n    tr,\n    posInfo.posBeforeNode,\n    update,\n    replaceFromPos,\n    replaceToPos,\n  );\n\n  const blockContainerNode = tr.doc\n    .resolve(posInfo.posBeforeNode + 1) // TODO: clean?\n    .node();\n\n  const pmSchema = getPmSchema(tr);\n  return nodeToBlock(blockContainerNode, pmSchema);\n}\n\ntype CellAnchor = { row: number; col: number; offset: number };\n\n/**\n * Captures the cell anchor from the current selection.\n * @param tr - The transaction to capture the cell anchor from.\n *\n * @returns The cell anchor, or null if no cell is selected.\n */\nexport function captureCellAnchor(tr: Transform): CellAnchor | null {\n  const sel = \"selection\" in tr ? tr.selection : null;\n  if (!(sel instanceof TextSelection)) {\n    return null;\n  }\n\n  const $head = tr.doc.resolve(sel.head);\n  // Find enclosing cell and table\n  let cellDepth = -1;\n  let tableDepth = -1;\n  for (let d = $head.depth; d >= 0; d--) {\n    const name = $head.node(d).type.name;\n    if (cellDepth < 0 && (name === \"tableCell\" || name === \"tableHeader\")) {\n      cellDepth = d;\n    }\n    if (name === \"table\") {\n      tableDepth = d;\n      break;\n    }\n  }\n  if (cellDepth < 0 || tableDepth < 0) {\n    return null;\n  }\n\n  // Absolute positions (before the cell)\n  const cellPos = $head.before(cellDepth);\n  const tablePos = $head.before(tableDepth);\n  const table = tr.doc.nodeAt(tablePos);\n  if (!table || table.type.name !== \"table\") {\n    return null;\n  }\n\n  // Visual grid position via TableMap (handles spans)\n  const map = TableMap.get(table);\n  const rel = cellPos - (tablePos + 1); // relative to inside table\n  const idx = map.map.indexOf(rel);\n  if (idx < 0) {\n    return null;\n  }\n\n  const row = Math.floor(idx / map.width);\n  const col = idx % map.width;\n\n  // Caret offset relative to the start of paragraph text\n  const paraPos = cellPos + 1; // pos BEFORE tableParagraph\n  const textStart = paraPos + 1; // start of paragraph text\n  const offset = Math.max(0, sel.head - textStart);\n\n  return { row, col, offset };\n}\n\nfunction restoreCellAnchor(\n  tr: Transform | Transaction,\n  blockInfo: BlockInfo,\n  a: CellAnchor,\n): boolean {\n  if (blockInfo.blockNoteType !== \"table\") {\n    return false;\n  }\n\n  // 1) Resolve the table node in the current document\n  let tablePos = -1;\n\n  if (blockInfo.isBlockContainer) {\n    // Prefer the blockContent position when available (points directly at the PM table node)\n    tablePos = tr.mapping.map(blockInfo.blockContent.beforePos);\n  } else {\n    // Fallback: scan within the mapped bnBlock range to find the inner table node\n    const start = tr.mapping.map(blockInfo.bnBlock.beforePos);\n    const end = start + (tr.doc.nodeAt(start)?.nodeSize || 0);\n    tr.doc.nodesBetween(start, end, (node, pos) => {\n      if (node.type.name === \"table\") {\n        tablePos = pos;\n        return false;\n      }\n      return true;\n    });\n  }\n\n  const table = tablePos >= 0 ? tr.doc.nodeAt(tablePos) : null;\n  if (!table || table.type.name !== \"table\") {\n    return false;\n  }\n\n  // 2) Clamp row/col to the table’s current grid\n  const map = TableMap.get(table);\n  const row = Math.max(0, Math.min(a.row, map.height - 1));\n  const col = Math.max(0, Math.min(a.col, map.width - 1));\n\n  // 3) Compute the absolute position of the target cell (pos BEFORE the cell)\n  const cellIndex = row * map.width + col;\n  const relCellPos = map.map[cellIndex]; // relative to (tablePos + 1)\n  if (relCellPos == null) {\n    return false;\n  }\n  const cellPos = tablePos + 1 + relCellPos;\n\n  // 4) Place the caret inside the cell, clamping the text offset\n  const textPos = cellPos + 1;\n  const textNode = tr.doc.nodeAt(textPos);\n  const textStart = textPos + 1;\n  const max = textNode ? textNode.content.size : 0;\n  const head = textStart + Math.max(0, Math.min(a.offset, max));\n\n  if (\"selection\" in tr) {\n    tr.setSelection(TextSelection.create(tr.doc, head));\n  }\n  return true;\n}\n","export const COLORS_DEFAULT = {\n  gray: {\n    text: \"#9b9a97\",\n    background: \"#ebeced\",\n  },\n  brown: {\n    text: \"#64473a\",\n    background: \"#e9e5e3\",\n  },\n  red: {\n    text: \"#e03e3e\",\n    background: \"#fbe4e4\",\n  },\n  orange: {\n    text: \"#d9730d\",\n    background: \"#f6e9d9\",\n  },\n  yellow: {\n    text: \"#dfab01\",\n    background: \"#fbf3db\",\n  },\n  green: {\n    text: \"#4d6461\",\n    background: \"#ddedea\",\n  },\n  blue: {\n    text: \"#0b6e99\",\n    background: \"#ddebf1\",\n  },\n  purple: {\n    text: \"#6940a5\",\n    background: \"#eae4f2\",\n  },\n  pink: {\n    text: \"#ad1a72\",\n    background: \"#f4dfeb\",\n  },\n} as Record<string, { text: string; background: string }>;\n\nexport const COLORS_DARK_MODE_DEFAULT = {\n  gray: {\n    text: \"#bebdb8\",\n    background: \"#9b9a97\",\n  },\n  brown: {\n    text: \"#8e6552\",\n    background: \"#64473a\",\n  },\n  red: {\n    text: \"#ec4040\",\n    background: \"#be3434\",\n  },\n  orange: {\n    text: \"#e3790d\",\n    background: \"#b7600a\",\n  },\n  yellow: {\n    text: \"#dfab01\",\n    background: \"#b58b00\",\n  },\n  green: {\n    text: \"#6b8b87\",\n    background: \"#4d6461\",\n  },\n  blue: {\n    text: \"#0e87bc\",\n    background: \"#0b6e99\",\n  },\n  purple: {\n    text: \"#8552d7\",\n    background: \"#6940a5\",\n  },\n  pink: {\n    text: \"#da208f\",\n    background: \"#ad1a72\",\n  },\n} as Record<string, { text: string; background: string }>;\n","import { Attribute } from \"@tiptap/core\";\n\nimport { COLORS_DEFAULT } from \"../editor/defaultColors.js\";\nimport type { Props, PropSchema } from \"../schema/index.js\";\n\n// TODO: this system should probably be moved / refactored.\n// The dependency from schema on this file doesn't make sense\n\nexport const defaultProps = {\n  backgroundColor: {\n    default: \"default\" as const,\n  },\n  textColor: {\n    default: \"default\" as const,\n  },\n  textAlignment: {\n    default: \"left\" as const,\n    values: [\"left\", \"center\", \"right\", \"justify\"] as const,\n  },\n} satisfies PropSchema;\n\nexport type DefaultProps = Props<typeof defaultProps>;\n\nexport const parseDefaultProps = (element: HTMLElement) => {\n  const props: Partial<DefaultProps> = {};\n\n  // If the `data-` attribute is found, set the prop to the value, as this most\n  // likely means the parsed element was exported by BlockNote originally.\n  // Otherwise, just use whatever is found in the inline styles, if anything.\n  if (element.hasAttribute(\"data-background-color\")) {\n    props.backgroundColor = element.getAttribute(\"data-background-color\")!;\n  } else if (element.style.backgroundColor) {\n    props.backgroundColor = element.style.backgroundColor;\n  }\n\n  // If the `data-` attribute is found, set the prop to the value, as this most\n  // likely means the parsed element was exported by BlockNote originally.\n  // Otherwise, just use whatever is found in the inline styles, if anything.\n  if (element.hasAttribute(\"data-text-color\")) {\n    props.textColor = element.getAttribute(\"data-text-color\")!;\n  } else if (element.style.color) {\n    props.textColor = element.style.color;\n  }\n\n  props.textAlignment = defaultProps.textAlignment.values.includes(\n    element.style.textAlign as DefaultProps[\"textAlignment\"],\n  )\n    ? (element.style.textAlign as DefaultProps[\"textAlignment\"])\n    : undefined;\n\n  return props;\n};\n\nexport const addDefaultPropsExternalHTML = (\n  props: Partial<DefaultProps>,\n  element: HTMLElement,\n) => {\n  if (\n    props.backgroundColor &&\n    props.backgroundColor !== defaultProps.backgroundColor.default\n  ) {\n    // The color can be any string. If the string matches one of the default\n    // theme color names, set the theme color. Otherwise, set the color as-is\n    // (may be a CSS color name, hex value, RGB value, etc).\n    element.style.backgroundColor =\n      props.backgroundColor in COLORS_DEFAULT\n        ? COLORS_DEFAULT[props.backgroundColor].background\n        : props.backgroundColor;\n  }\n\n  if (props.textColor && props.textColor !== defaultProps.textColor.default) {\n    // The color can be any string. If the string matches one of the default\n    // theme color names, set the theme color. Otherwise, set the color as-is\n    // (may be a CSS color name, hex value, RGB value, etc).\n    element.style.color =\n      props.textColor in COLORS_DEFAULT\n        ? COLORS_DEFAULT[props.textColor].text\n        : props.textColor;\n  }\n\n  if (\n    props.textAlignment &&\n    props.textAlignment !== defaultProps.textAlignment.default\n  ) {\n    element.style.textAlign = props.textAlignment;\n  }\n};\n\nexport const getBackgroundColorAttribute = (\n  attributeName = \"backgroundColor\",\n): Attribute => ({\n  default: defaultProps.backgroundColor.default,\n  parseHTML: (element) => {\n    if (element.hasAttribute(\"data-background-color\")) {\n      return element.getAttribute(\"data-background-color\")!;\n    }\n\n    if (element.style.backgroundColor) {\n      return element.style.backgroundColor;\n    }\n\n    return defaultProps.backgroundColor.default;\n  },\n  renderHTML: (attributes) => {\n    if (attributes[attributeName] === defaultProps.backgroundColor.default) {\n      return {};\n    }\n\n    return {\n      \"data-background-color\": attributes[attributeName],\n    };\n  },\n});\n\nexport const getTextColorAttribute = (\n  attributeName = \"textColor\",\n): Attribute => ({\n  default: defaultProps.textColor.default,\n  parseHTML: (element) => {\n    if (element.hasAttribute(\"data-text-color\")) {\n      return element.getAttribute(\"data-text-color\")!;\n    }\n\n    if (element.style.color) {\n      return element.style.color;\n    }\n\n    return defaultProps.textColor.default;\n  },\n  renderHTML: (attributes) => {\n    if (attributes[attributeName] === defaultProps.textColor.default) {\n      return {};\n    }\n\n    return {\n      \"data-text-color\": attributes[attributeName],\n    };\n  },\n});\n\nexport const getTextAlignmentAttribute = (\n  attributeName = \"textAlignment\",\n): Attribute => ({\n  default: defaultProps.textAlignment.default,\n  parseHTML: (element) => {\n    if (element.hasAttribute(\"data-text-alignment\")) {\n      return element.getAttribute(\"data-text-alignment\");\n    }\n\n    if (element.style.textAlign) {\n      return element.style.textAlign;\n    }\n\n    return defaultProps.textAlignment.default;\n  },\n  renderHTML: (attributes) => {\n    if (attributes[attributeName] === defaultProps.textAlignment.default) {\n      return {};\n    }\n\n    return {\n      \"data-text-alignment\": attributes[attributeName],\n    };\n  },\n});\n","export const parseFigureElement = (\n  figureElement: HTMLElement,\n  targetTag: string,\n) => {\n  const targetElement = figureElement.querySelector(\n    targetTag,\n  ) as HTMLElement | null;\n  if (!targetElement) {\n    return undefined;\n  }\n\n  const captionElement = figureElement.querySelector(\"figcaption\");\n  const caption = captionElement?.textContent ?? undefined;\n\n  return { targetElement, caption };\n};\n","import type { BlockNoteEditor } from \"../../../../editor/BlockNoteEditor.js\";\nimport {\n  BlockConfig,\n  BlockFromConfigNoChildren,\n} from \"../../../../schema/index.js\";\n\nexport const createAddFileButton = (\n  block: BlockFromConfigNoChildren<BlockConfig<string, any, \"none\">, any, any>,\n  editor: BlockNoteEditor<any, any, any>,\n  buttonIcon?: HTMLElement,\n) => {\n  const addFileButton = document.createElement(\"div\");\n  addFileButton.className = \"bn-add-file-button\";\n\n  const addFileButtonIcon = document.createElement(\"div\");\n  addFileButtonIcon.className = \"bn-add-file-button-icon\";\n  if (buttonIcon) {\n    addFileButtonIcon.appendChild(buttonIcon);\n  } else {\n    addFileButtonIcon.innerHTML =\n      '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\"><path d=\"M3 8L9.00319 2H19.9978C20.5513 2 21 2.45531 21 2.9918V21.0082C21 21.556 20.5551 22 20.0066 22H3.9934C3.44476 22 3 21.5501 3 20.9932V8ZM10 4V9H5V20H19V4H10Z\"></path></svg>';\n  }\n  addFileButton.appendChild(addFileButtonIcon);\n\n  const addFileButtonText = document.createElement(\"p\");\n  addFileButtonText.className = \"bn-add-file-button-text\";\n  addFileButtonText.innerHTML =\n    block.type in editor.dictionary.file_blocks.add_button_text\n      ? editor.dictionary.file_blocks.add_button_text[block.type]\n      : editor.dictionary.file_blocks.add_button_text[\"file\"];\n  addFileButton.appendChild(addFileButtonText);\n\n  // Prevents focus from moving to the button.\n  const addFileButtonMouseDownHandler = (event: MouseEvent) => {\n    event.preventDefault();\n  };\n  // Opens the file toolbar.\n  const addFileButtonClickHandler = () => {\n    editor.transact((tr) =>\n      tr.setMeta(editor.filePanel!.plugins[0], {\n        block: block,\n      }),\n    );\n  };\n  addFileButton.addEventListener(\n    \"mousedown\",\n    addFileButtonMouseDownHandler,\n    true,\n  );\n  addFileButton.addEventListener(\"click\", addFileButtonClickHandler, true);\n\n  return {\n    dom: addFileButton,\n    destroy: () => {\n      addFileButton.removeEventListener(\n        \"mousedown\",\n        addFileButtonMouseDownHandler,\n        true,\n      );\n      addFileButton.removeEventListener(\n        \"click\",\n        addFileButtonClickHandler,\n        true,\n      );\n    },\n  };\n};\n","import {\n  BlockConfig,\n  BlockFromConfigNoChildren,\n} from \"../../../../schema/index.js\";\n\nexport const FILE_ICON_SVG = `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\"><path d=\"M3 8L9.00319 2H19.9978C20.5513 2 21 2.45531 21 2.9918V21.0082C21 21.556 20.5551 22 20.0066 22H3.9934C3.44476 22 3 21.5501 3 20.9932V8ZM10 4V9H5V20H19V4H10Z\"></path></svg>`;\n\nexport const createFileNameWithIcon = (\n  block: BlockFromConfigNoChildren<\n    BlockConfig<\n      string,\n      {\n        name: { default: \"\" };\n      },\n      \"none\"\n    >,\n    any,\n    any\n  >,\n): { dom: HTMLElement; destroy?: () => void } => {\n  const file = document.createElement(\"div\");\n  file.className = \"bn-file-name-with-icon\";\n\n  const icon = document.createElement(\"div\");\n  icon.className = \"bn-file-icon\";\n  icon.innerHTML = FILE_ICON_SVG;\n  file.appendChild(icon);\n\n  const fileName = document.createElement(\"p\");\n  fileName.className = \"bn-file-name\";\n  fileName.textContent = block.props.name;\n  file.appendChild(fileName);\n\n  return {\n    dom: file,\n  };\n};\n","import type { BlockNoteEditor } from \"../../../../editor/BlockNoteEditor.js\";\nimport {\n  BlockConfig,\n  BlockFromConfigNoChildren,\n} from \"../../../../schema/index.js\";\nimport { createAddFileButton } from \"./createAddFileButton.js\";\nimport { createFileNameWithIcon } from \"./createFileNameWithIcon.js\";\n\nexport const createFileBlockWrapper = (\n  block: BlockFromConfigNoChildren<\n    BlockConfig<\n      string,\n      {\n        backgroundColor: { default: \"default\" };\n        name: { default: \"\" };\n        url: { default: \"\" };\n        caption: { default: \"\" };\n        showPreview?: { default: true };\n      },\n      \"none\"\n    >,\n    any,\n    any\n  >,\n  editor: BlockNoteEditor<any, any, any>,\n  element?: { dom: HTMLElement; destroy?: () => void },\n  buttonIcon?: HTMLElement,\n) => {\n  const wrapper = document.createElement(\"div\");\n  wrapper.className = \"bn-file-block-content-wrapper\";\n\n  // Show the add file button if the file has not been uploaded yet. Change to\n  // show a loader if a file upload for the block begins.\n  if (block.props.url === \"\") {\n    const addFileButton = createAddFileButton(block, editor, buttonIcon);\n    wrapper.appendChild(addFileButton.dom);\n\n    const destroyUploadStartHandler = editor.onUploadStart((blockId) => {\n      if (blockId === block.id) {\n        wrapper.removeChild(addFileButton.dom);\n\n        const loading = document.createElement(\"div\");\n        loading.className = \"bn-file-loading-preview\";\n        loading.textContent = \"Loading...\";\n        wrapper.appendChild(loading);\n      }\n    });\n\n    return {\n      dom: wrapper,\n      destroy: () => {\n        destroyUploadStartHandler();\n        addFileButton.destroy();\n      },\n    };\n  }\n\n  const ret: { dom: HTMLElement; destroy?: () => void } = { dom: wrapper };\n\n  // Show the file preview, or the file name and icon.\n  if (block.props.showPreview === false || !element) {\n    // Show file name and icon.\n    const fileNameWithIcon = createFileNameWithIcon(block);\n    wrapper.appendChild(fileNameWithIcon.dom);\n\n    ret.destroy = () => {\n      fileNameWithIcon.destroy?.();\n    };\n  } else {\n    // Show file preview.\n    wrapper.appendChild(element.dom);\n  }\n\n  // Show the caption if there is one.\n  if (block.props.caption) {\n    const caption = document.createElement(\"p\");\n    caption.className = \"bn-file-caption\";\n    caption.textContent = block.props.caption;\n    wrapper.appendChild(caption);\n  }\n\n  return ret;\n};\n","export const createFigureWithCaption = (\n  element: HTMLElement,\n  caption: string,\n) => {\n  const figure = document.createElement(\"figure\");\n  const captionElement = document.createElement(\"figcaption\");\n  captionElement.textContent = caption;\n\n  figure.appendChild(element);\n  figure.appendChild(captionElement);\n\n  return { dom: figure };\n};\n","export const createLinkWithCaption = (\n  element: HTMLElement,\n  caption: string,\n) => {\n  const wrapper = document.createElement(\"div\");\n  const fileCaption = document.createElement(\"p\");\n  fileCaption.textContent = caption;\n\n  wrapper.appendChild(element);\n  wrapper.appendChild(fileCaption);\n\n  return {\n    dom: wrapper,\n  };\n};\n","export const parseAudioElement = (audioElement: HTMLAudioElement) => {\n  const url = audioElement.src || undefined;\n\n  return { url };\n};\n","import { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport {\n  BlockFromConfig,\n  createBlockConfig,\n  createBlockSpec,\n} from \"../../schema/index.js\";\nimport { defaultProps, parseDefaultProps } from \"../defaultProps.js\";\nimport { parseFigureElement } from \"../File/helpers/parse/parseFigureElement.js\";\nimport { createFileBlockWrapper } from \"../File/helpers/render/createFileBlockWrapper.js\";\nimport { createFigureWithCaption } from \"../File/helpers/toExternalHTML/createFigureWithCaption.js\";\nimport { createLinkWithCaption } from \"../File/helpers/toExternalHTML/createLinkWithCaption.js\";\nimport { parseAudioElement } from \"./parseAudioElement.js\";\n\nexport const FILE_AUDIO_ICON_SVG =\n  '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\"><path d=\"M2 16.0001H5.88889L11.1834 20.3319C11.2727 20.405 11.3846 20.4449 11.5 20.4449C11.7761 20.4449 12 20.2211 12 19.9449V4.05519C12 3.93977 11.9601 3.8279 11.887 3.73857C11.7121 3.52485 11.3971 3.49335 11.1834 3.66821L5.88889 8.00007H2C1.44772 8.00007 1 8.44778 1 9.00007V15.0001C1 15.5524 1.44772 16.0001 2 16.0001ZM23 12C23 15.292 21.5539 18.2463 19.2622 20.2622L17.8445 18.8444C19.7758 17.1937 21 14.7398 21 12C21 9.26016 19.7758 6.80629 17.8445 5.15557L19.2622 3.73779C21.5539 5.75368 23 8.70795 23 12ZM18 12C18 10.0883 17.106 8.38548 15.7133 7.28673L14.2842 8.71584C15.3213 9.43855 16 10.64 16 12C16 13.36 15.3213 14.5614 14.2842 15.2841L15.7133 16.7132C17.106 15.6145 18 13.9116 18 12Z\"></path></svg>';\n\nexport interface AudioOptions {\n  icon?: string;\n}\n\nexport type AudioBlockConfig = ReturnType<typeof createAudioBlockConfig>;\n\nexport const createAudioBlockConfig = createBlockConfig(\n  (_ctx: AudioOptions) =>\n    ({\n      type: \"audio\" as const,\n      propSchema: {\n        backgroundColor: defaultProps.backgroundColor,\n        // File name.\n        name: {\n          default: \"\" as const,\n        },\n        // File url.\n        url: {\n          default: \"\" as const,\n        },\n        // File caption.\n        caption: {\n          default: \"\" as const,\n        },\n\n        showPreview: {\n          default: true,\n        },\n      },\n      content: \"none\",\n    }) as const,\n);\n\nexport const audioParse =\n  (_config: AudioOptions = {}) =>\n  (element: HTMLElement) => {\n    if (element.tagName === \"AUDIO\") {\n      // Ignore if parent figure has already been parsed.\n      if (element.closest(\"figure\")) {\n        return undefined;\n      }\n\n      const { backgroundColor } = parseDefaultProps(element);\n\n      return {\n        ...parseAudioElement(element as HTMLAudioElement),\n        backgroundColor,\n      };\n    }\n\n    if (element.tagName === \"FIGURE\") {\n      const parsedFigure = parseFigureElement(element, \"audio\");\n      if (!parsedFigure) {\n        return undefined;\n      }\n\n      const { targetElement, caption } = parsedFigure;\n\n      const { backgroundColor } = parseDefaultProps(element);\n\n      return {\n        ...parseAudioElement(targetElement as HTMLAudioElement),\n        backgroundColor,\n        caption,\n      };\n    }\n\n    return undefined;\n  };\n\nexport const audioRender =\n  (config: AudioOptions = {}) =>\n  (\n    block: BlockFromConfig<ReturnType<typeof createAudioBlockConfig>, any, any>,\n    editor: BlockNoteEditor<\n      Record<\"audio\", ReturnType<typeof createAudioBlockConfig>>,\n      any,\n      any\n    >,\n  ) => {\n    const icon = document.createElement(\"div\");\n    icon.innerHTML = config.icon ?? FILE_AUDIO_ICON_SVG;\n\n    const audio = document.createElement(\"audio\");\n    audio.className = \"bn-audio\";\n    if (editor.resolveFileUrl) {\n      editor.resolveFileUrl(block.props.url).then((downloadUrl) => {\n        audio.src = downloadUrl;\n      });\n    } else {\n      audio.src = block.props.url;\n    }\n    audio.controls = true;\n    audio.contentEditable = \"false\";\n    audio.draggable = false;\n\n    return createFileBlockWrapper(\n      block,\n      editor,\n      { dom: audio },\n      icon.firstElementChild as HTMLElement,\n    );\n  };\n\nexport const audioToExternalHTML =\n  (_config: AudioOptions = {}) =>\n  (\n    block: BlockFromConfig<ReturnType<typeof createAudioBlockConfig>, any, any>,\n    _editor: BlockNoteEditor<\n      Record<\"audio\", ReturnType<typeof createAudioBlockConfig>>,\n      any,\n      any\n    >,\n  ) => {\n    if (!block.props.url) {\n      const div = document.createElement(\"p\");\n      div.textContent = \"Add audio\";\n\n      return {\n        dom: div,\n      };\n    }\n\n    let audio;\n    if (block.props.showPreview) {\n      audio = document.createElement(\"audio\");\n      audio.src = block.props.url;\n    } else {\n      audio = document.createElement(\"a\");\n      audio.href = block.props.url;\n      audio.textContent = block.props.name || block.props.url;\n    }\n\n    if (block.props.caption) {\n      if (block.props.showPreview) {\n        return createFigureWithCaption(audio, block.props.caption);\n      } else {\n        return createLinkWithCaption(audio, block.props.caption);\n      }\n    }\n\n    return {\n      dom: audio,\n    };\n  };\n\nexport const createAudioBlockSpec = createBlockSpec(\n  createAudioBlockConfig,\n  (config) => ({\n    meta: {\n      fileBlockAccept: [\"audio/*\"],\n    },\n    parse: audioParse(config),\n    render: audioRender(config),\n    toExternalHTML: audioToExternalHTML(config),\n    runsBefore: [\"file\"],\n  }),\n);\n","// from https://raw.githubusercontent.com/ueberdosis/tiptap/develop/packages/core/src/EventEmitter.ts (MIT)\n\ntype StringKeyOf<T> = Extract<keyof T, string>;\ntype CallbackType<\n  T extends Record<string, any>,\n  EventName extends StringKeyOf<T>,\n> = T[EventName] extends any[] ? T[EventName] : [T[EventName]];\ntype CallbackFunction<\n  T extends Record<string, any>,\n  EventName extends StringKeyOf<T>,\n> = (...props: CallbackType<T, EventName>) => any;\n\nexport class EventEmitter<T extends Record<string, any>> {\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  private callbacks: { [key: string]: Function[] } = {};\n\n  public on<EventName extends StringKeyOf<T>>(\n    event: EventName,\n    fn: CallbackFunction<T, EventName>,\n  ) {\n    if (!this.callbacks[event]) {\n      this.callbacks[event] = [];\n    }\n\n    this.callbacks[event].push(fn);\n\n    return () => this.off(event, fn);\n  }\n\n  protected emit<EventName extends StringKeyOf<T>>(\n    event: EventName,\n    ...args: CallbackType<T, EventName>\n  ) {\n    const callbacks = this.callbacks[event];\n\n    if (callbacks) {\n      callbacks.forEach((callback) => callback.apply(this, args));\n    }\n  }\n\n  public off<EventName extends StringKeyOf<T>>(\n    event: EventName,\n    fn?: CallbackFunction<T, EventName>,\n  ) {\n    const callbacks = this.callbacks[event];\n\n    if (callbacks) {\n      if (fn) {\n        this.callbacks[event] = callbacks.filter((callback) => callback !== fn);\n      } else {\n        delete this.callbacks[event];\n      }\n    }\n  }\n\n  protected removeAllListeners(): void {\n    this.callbacks = {};\n  }\n}\n","import { Plugin } from \"prosemirror-state\";\nimport { EventEmitter } from \"../util/EventEmitter.js\";\n\nimport { AnyExtension } from \"@tiptap/core\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  PartialBlockNoDefaults,\n  StyleSchema,\n} from \"../schema/index.js\";\nimport { BlockNoteEditor } from \"./BlockNoteEditor.js\";\n\nexport abstract class BlockNoteExtension<\n  TEvent extends Record<string, any> = any,\n> extends EventEmitter<TEvent> {\n  public static key(): string {\n    throw new Error(\"You must implement the key method in your extension\");\n  }\n\n  protected addProsemirrorPlugin(plugin: Plugin) {\n    this.plugins.push(plugin);\n  }\n\n  public readonly plugins: Plugin[] = [];\n  public get priority(): number | undefined {\n    return undefined;\n  }\n\n  // eslint-disable-next-line\n  constructor(..._args: any[]) {\n    super();\n    // Allow subclasses to have constructors with parameters\n    // without this, we can't easily implement BlockNoteEditor.extension(MyExtension) pattern\n  }\n\n  /**\n   * Input rules for the block\n   */\n  public inputRules?: InputRule[];\n\n  /**\n   * A mapping of a keyboard shortcut to a function that will be called when the shortcut is pressed\n   *\n   * The keys are in the format:\n   * - Key names may be strings like `Shift-Ctrl-Enter`—a key identifier prefixed with zero or more modifiers\n   * - Key identifiers are based on the strings that can appear in KeyEvent.key\n   * - Use lowercase letters to refer to letter keys (or uppercase letters if you want shift to be held)\n   * - You may use `Space` as an alias for the \" \" name\n   * - Modifiers can be given in any order: `Shift-` (or `s-`), `Alt-` (or `a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or `Meta-`)\n   * - For characters that are created by holding shift, the Shift- prefix is implied, and should not be added explicitly\n   * - You can use Mod- as a shorthand for Cmd- on Mac and Ctrl- on other platforms\n   *\n   * @example\n   * ```typescript\n   * keyboardShortcuts: {\n   *   \"Mod-Enter\": (ctx) => {  return true; },\n   *   \"Shift-Ctrl-Space\": (ctx) => { return true; },\n   *   \"a\": (ctx) => { return true; },\n   *   \"Space\": (ctx) => { return true; }\n   * }\n   * ```\n   */\n  public keyboardShortcuts?: Record<\n    string,\n    (ctx: {\n      editor: BlockNoteEditor<BlockSchema, InlineContentSchema, StyleSchema>;\n    }) => boolean\n  >;\n\n  public tiptapExtensions?: AnyExtension[];\n}\n\nexport type InputRule = {\n  /**\n   * The regex to match when to trigger the input rule\n   */\n  find: RegExp;\n  /**\n   * The function to call when the input rule is matched\n   * @returns undefined if the input rule should not be triggered, or an object with the type and props to update the block\n   */\n  replace: (props: {\n    /**\n     * The result of the regex match\n     */\n    match: RegExpMatchArray;\n    // TODO this will be a Point, when we have the Location API\n    /**\n     * The range of the text that was matched\n     */\n    range: { from: number; to: number };\n    /**\n     * The editor instance\n     */\n    editor: BlockNoteEditor<any, any, any>;\n  }) => undefined | PartialBlockNoDefaults<any, any, any>;\n};\n\n/**\n * This creates an instance of a BlockNoteExtension that can be used to add to a schema.\n * It is a bit of a hack, but it works.\n */\nexport function createBlockNoteExtension(\n  options: Partial<\n    Pick<\n      BlockNoteExtension,\n      \"inputRules\" | \"keyboardShortcuts\" | \"plugins\" | \"tiptapExtensions\"\n    >\n  > & { key: string },\n) {\n  const x = Object.create(BlockNoteExtension.prototype);\n  x.key = options.key;\n  x.inputRules = options.inputRules;\n  x.keyboardShortcuts = options.keyboardShortcuts;\n  x.plugins = options.plugins ?? [];\n  x.tiptapExtensions = options.tiptapExtensions;\n  return x as BlockNoteExtension;\n}\n","import type { HighlighterGeneric } from \"@shikijs/types\";\nimport { Parser, createHighlightPlugin } from \"prosemirror-highlight\";\nimport { createParser } from \"prosemirror-highlight/shiki\";\nimport { CodeBlockOptions, getLanguageId } from \"./block.js\";\n\nexport const shikiParserSymbol = Symbol.for(\"blocknote.shikiParser\");\nexport const shikiHighlighterPromiseSymbol = Symbol.for(\n  \"blocknote.shikiHighlighterPromise\",\n);\n\nexport function lazyShikiPlugin(options: CodeBlockOptions) {\n  const globalThisForShiki = globalThis as {\n    [shikiHighlighterPromiseSymbol]?: Promise<HighlighterGeneric<any, any>>;\n    [shikiParserSymbol]?: Parser;\n  };\n\n  let highlighter: HighlighterGeneric<any, any> | undefined;\n  let parser: Parser | undefined;\n  let hasWarned = false;\n  const lazyParser: Parser = (parserOptions) => {\n    if (!options.createHighlighter) {\n      if (process.env.NODE_ENV === \"development\" && !hasWarned) {\n        // eslint-disable-next-line no-console\n        console.log(\n          \"For syntax highlighting of code blocks, you must provide a `createCodeBlockSpec({ createHighlighter: () => ... })` function\",\n        );\n        hasWarned = true;\n      }\n      return [];\n    }\n    if (!highlighter) {\n      globalThisForShiki[shikiHighlighterPromiseSymbol] =\n        globalThisForShiki[shikiHighlighterPromiseSymbol] ||\n        options.createHighlighter();\n\n      return globalThisForShiki[shikiHighlighterPromiseSymbol].then(\n        (createdHighlighter) => {\n          highlighter = createdHighlighter;\n        },\n      );\n    }\n    const language = getLanguageId(options, parserOptions.language!);\n\n    if (\n      !language ||\n      language === \"text\" ||\n      language === \"none\" ||\n      language === \"plaintext\" ||\n      language === \"txt\"\n    ) {\n      return [];\n    }\n\n    if (!highlighter.getLoadedLanguages().includes(language)) {\n      return highlighter.loadLanguage(language);\n    }\n\n    if (!parser) {\n      parser =\n        globalThisForShiki[shikiParserSymbol] ||\n        createParser(highlighter as any);\n      globalThisForShiki[shikiParserSymbol] = parser;\n    }\n\n    return parser(parserOptions);\n  };\n\n  return createHighlightPlugin({\n    parser: lazyParser,\n    languageExtractor: (node) => node.attrs.language,\n    nodeTypes: [\"codeBlock\"],\n  });\n}\n","import type { HighlighterGeneric } from \"@shikijs/types\";\nimport { createBlockNoteExtension } from \"../../editor/BlockNoteExtension.js\";\nimport { createBlockConfig, createBlockSpec } from \"../../schema/index.js\";\nimport { lazyShikiPlugin } from \"./shiki.js\";\nimport { DOMParser } from \"@tiptap/pm/model\";\n\nexport type CodeBlockOptions = {\n  /**\n   * Whether to indent lines with a tab when the user presses `Tab` in a code block.\n   *\n   * @default true\n   */\n  indentLineWithTab?: boolean;\n  /**\n   * The default language to use for code blocks.\n   *\n   * @default \"text\"\n   */\n  defaultLanguage?: string;\n  /**\n   * The languages that are supported in the editor.\n   *\n   * @example\n   * {\n   *   javascript: {\n   *     name: \"JavaScript\",\n   *     aliases: [\"js\"],\n   *   },\n   *   typescript: {\n   *     name: \"TypeScript\",\n   *     aliases: [\"ts\"],\n   *   },\n   * }\n   */\n  supportedLanguages?: Record<\n    string,\n    {\n      /**\n       * The display name of the language.\n       */\n      name: string;\n      /**\n       * Aliases for this language.\n       */\n      aliases?: string[];\n    }\n  >;\n  /**\n   * The highlighter to use for code blocks.\n   */\n  createHighlighter?: () => Promise<HighlighterGeneric<any, any>>;\n};\n\nexport type CodeBlockConfig = ReturnType<typeof createCodeBlockConfig>;\n\nexport const createCodeBlockConfig = createBlockConfig(\n  ({ defaultLanguage = \"text\" }: CodeBlockOptions) =>\n    ({\n      type: \"codeBlock\" as const,\n      propSchema: {\n        language: {\n          default: defaultLanguage,\n        },\n      },\n      content: \"inline\",\n    }) as const,\n);\n\nexport const createCodeBlockSpec = createBlockSpec(\n  createCodeBlockConfig,\n  (options) => ({\n    meta: {\n      code: true,\n      defining: true,\n      isolating: false,\n    },\n    parse: (e) => {\n      if (e.tagName !== \"PRE\") {\n        return undefined;\n      }\n\n      if (\n        e.childElementCount !== 1 ||\n        e.firstElementChild?.tagName !== \"CODE\"\n      ) {\n        return undefined;\n      }\n\n      const code = e.firstElementChild!;\n      const language =\n        code.getAttribute(\"data-language\") ||\n        code.className\n          .split(\" \")\n          .find((name) => name.includes(\"language-\"))\n          ?.replace(\"language-\", \"\");\n\n      return { language };\n    },\n\n    parseContent: ({ el, schema }) => {\n      const parser = DOMParser.fromSchema(schema);\n      const code = el.firstElementChild!;\n\n      return parser.parse(code, {\n        topNode: schema.nodes[\"codeBlock\"].create(),\n      }).content;\n    },\n\n    render(block, editor) {\n      const wrapper = document.createDocumentFragment();\n      const pre = document.createElement(\"pre\");\n      const code = document.createElement(\"code\");\n      pre.appendChild(code);\n\n      let removeSelectChangeListener = undefined;\n\n      if (options.supportedLanguages) {\n        const select = document.createElement(\"select\");\n\n        Object.entries(options.supportedLanguages ?? {}).forEach(\n          ([id, { name }]) => {\n            const option = document.createElement(\"option\");\n\n            option.value = id;\n            option.text = name;\n            select.appendChild(option);\n          },\n        );\n        select.value =\n          block.props.language || options.defaultLanguage || \"text\";\n\n        const handleLanguageChange = (event: Event) => {\n          const language = (event.target as HTMLSelectElement).value;\n\n          editor.updateBlock(block.id, { props: { language } });\n        };\n        select.addEventListener(\"change\", handleLanguageChange);\n        removeSelectChangeListener = () =>\n          select.removeEventListener(\"change\", handleLanguageChange);\n\n        const selectWrapper = document.createElement(\"div\");\n        selectWrapper.contentEditable = \"false\";\n\n        selectWrapper.appendChild(select);\n        wrapper.appendChild(selectWrapper);\n      }\n      wrapper.appendChild(pre);\n\n      return {\n        dom: wrapper,\n        contentDOM: code,\n        destroy: () => {\n          removeSelectChangeListener?.();\n        },\n      };\n    },\n    toExternalHTML(block) {\n      const pre = document.createElement(\"pre\");\n      const code = document.createElement(\"code\");\n      code.className = `language-${block.props.language}`;\n      code.dataset.language = block.props.language;\n      pre.appendChild(code);\n      return {\n        dom: pre,\n        contentDOM: code,\n      };\n    },\n  }),\n  (options) => {\n    return [\n      createBlockNoteExtension({\n        key: \"code-block-highlighter\",\n        plugins: [lazyShikiPlugin(options)],\n      }),\n      createBlockNoteExtension({\n        key: \"code-block-keyboard-shortcuts\",\n        keyboardShortcuts: {\n          Delete: ({ editor }) => {\n            return editor.transact((tr) => {\n              const { block } = editor.getTextCursorPosition();\n              if (block.type !== \"codeBlock\") {\n                return false;\n              }\n              const { $from } = tr.selection;\n\n              // When inside empty codeblock, on `DELETE` key press, delete the codeblock\n              if (!$from.parent.textContent) {\n                editor.removeBlocks([block]);\n\n                return true;\n              }\n\n              return false;\n            });\n          },\n          Tab: ({ editor }) => {\n            if (options.indentLineWithTab === false) {\n              return false;\n            }\n\n            return editor.transact((tr) => {\n              const { block } = editor.getTextCursorPosition();\n              if (block.type === \"codeBlock\") {\n                // TODO should probably only tab when at a line start or already tabbed in\n                tr.insertText(\"  \");\n                return true;\n              }\n\n              return false;\n            });\n          },\n          Enter: ({ editor }) => {\n            return editor.transact((tr) => {\n              const { block, nextBlock } = editor.getTextCursorPosition();\n              if (block.type !== \"codeBlock\") {\n                return false;\n              }\n              const { $from } = tr.selection;\n\n              const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\n              const endsWithDoubleNewline =\n                $from.parent.textContent.endsWith(\"\\n\\n\");\n\n              // The user is trying to exit the code block by pressing enter at the end of the code block\n              if (isAtEnd && endsWithDoubleNewline) {\n                // Remove the double newline\n                tr.delete($from.pos - 2, $from.pos);\n\n                // If there is a next block, move the cursor to it\n                if (nextBlock) {\n                  editor.setTextCursorPosition(nextBlock, \"start\");\n                  return true;\n                }\n\n                // If there is no next block, insert a new paragraph\n                const [newBlock] = editor.insertBlocks(\n                  [{ type: \"paragraph\" }],\n                  block,\n                  \"after\",\n                );\n                // Move the cursor to the new block\n                editor.setTextCursorPosition(newBlock, \"start\");\n\n                return true;\n              }\n\n              tr.insertText(\"\\n\");\n              return true;\n            });\n          },\n          \"Shift-Enter\": ({ editor }) => {\n            return editor.transact(() => {\n              const { block } = editor.getTextCursorPosition();\n              if (block.type !== \"codeBlock\") {\n                return false;\n              }\n\n              const [newBlock] = editor.insertBlocks(\n                // insert a new paragraph\n                [{ type: \"paragraph\" }],\n                block,\n                \"after\",\n              );\n              // move the cursor to the new block\n              editor.setTextCursorPosition(newBlock, \"start\");\n              return true;\n            });\n          },\n        },\n        inputRules: [\n          {\n            find: /^```(.*?)\\s$/,\n            replace: ({ match }) => {\n              const languageName = match[1].trim();\n              const attributes = {\n                language: getLanguageId(options, languageName) ?? languageName,\n              };\n\n              return {\n                type: \"codeBlock\",\n                props: {\n                  language: attributes.language,\n                },\n                content: [],\n              };\n            },\n          },\n        ],\n      }),\n    ];\n  },\n);\n\nexport function getLanguageId(\n  options: CodeBlockOptions,\n  languageName: string,\n): string | undefined {\n  return Object.entries(options.supportedLanguages ?? {}).find(\n    ([id, { aliases }]) => {\n      return aliases?.includes(languageName) || id === languageName;\n    },\n  )?.[0];\n}\n","import { createBlockNoteExtension } from \"../../editor/BlockNoteExtension.js\";\nimport { createBlockConfig, createBlockSpec } from \"../../schema/index.js\";\n\nexport type DividerBlockConfig = ReturnType<typeof createDividerBlockConfig>;\n\nexport const createDividerBlockConfig = createBlockConfig(\n  () =>\n    ({\n      type: \"divider\" as const,\n      propSchema: {},\n      content: \"none\",\n    }) as const,\n);\n\nexport const createDividerBlockSpec = createBlockSpec(\n  createDividerBlockConfig,\n  {\n    meta: {\n      isolating: false,\n    },\n    parse(element) {\n      if (element.tagName === \"HR\") {\n        return {};\n      }\n\n      return undefined;\n    },\n    render() {\n      const dom = document.createElement(\"hr\");\n\n      return {\n        dom,\n      };\n    },\n  },\n  [\n    createBlockNoteExtension({\n      key: \"divider-block-shortcuts\",\n      inputRules: [\n        {\n          find: new RegExp(`^---$`),\n          replace() {\n            return { type: \"divider\", props: {}, content: [] };\n          },\n        },\n      ],\n    }),\n  ],\n);\n","export const parseEmbedElement = (embedElement: HTMLEmbedElement) => {\n  const url = embedElement.src || undefined;\n\n  return { url };\n};\n","import { createBlockConfig, createBlockSpec } from \"../../schema/index.js\";\nimport { defaultProps, parseDefaultProps } from \"../defaultProps.js\";\nimport { parseEmbedElement } from \"./helpers/parse/parseEmbedElement.js\";\nimport { parseFigureElement } from \"./helpers/parse/parseFigureElement.js\";\nimport { createFileBlockWrapper } from \"./helpers/render/createFileBlockWrapper.js\";\nimport { createLinkWithCaption } from \"./helpers/toExternalHTML/createLinkWithCaption.js\";\n\nexport type FileBlockConfig = ReturnType<typeof createFileBlockConfig>;\n\nexport const createFileBlockConfig = createBlockConfig(\n  () =>\n    ({\n      type: \"file\" as const,\n      propSchema: {\n        backgroundColor: defaultProps.backgroundColor,\n        // File name.\n        name: {\n          default: \"\" as const,\n        },\n        // File url.\n        url: {\n          default: \"\" as const,\n        },\n        // File caption.\n        caption: {\n          default: \"\" as const,\n        },\n      },\n      content: \"none\" as const,\n    }) as const,\n);\n\nexport const fileParse = () => (element: HTMLElement) => {\n  if (element.tagName === \"EMBED\") {\n    // Ignore if parent figure has already been parsed.\n    if (element.closest(\"figure\")) {\n      return undefined;\n    }\n\n    const { backgroundColor } = parseDefaultProps(element);\n\n    return {\n      ...parseEmbedElement(element as HTMLEmbedElement),\n      backgroundColor,\n    };\n  }\n\n  if (element.tagName === \"FIGURE\") {\n    const parsedFigure = parseFigureElement(element, \"embed\");\n    if (!parsedFigure) {\n      return undefined;\n    }\n\n    const { targetElement, caption } = parsedFigure;\n\n    const { backgroundColor } = parseDefaultProps(element);\n\n    return {\n      ...parseEmbedElement(targetElement as HTMLEmbedElement),\n      backgroundColor,\n      caption,\n    };\n  }\n\n  return undefined;\n};\n\nexport const createFileBlockSpec = createBlockSpec(createFileBlockConfig, {\n  meta: {\n    fileBlockAccept: [\"*/*\"],\n  },\n  parse: fileParse(),\n  render(block, editor) {\n    return createFileBlockWrapper(block, editor);\n  },\n  toExternalHTML(block) {\n    if (!block.props.url) {\n      const div = document.createElement(\"p\");\n      div.textContent = \"Add file\";\n\n      return {\n        dom: div,\n      };\n    }\n\n    const fileSrcLink = document.createElement(\"a\");\n    fileSrcLink.href = block.props.url;\n    fileSrcLink.textContent = block.props.name || block.props.url;\n\n    if (block.props.caption) {\n      return createLinkWithCaption(fileSrcLink, block.props.caption);\n    }\n\n    return {\n      dom: fileSrcLink,\n    };\n  },\n});\n","import { ViewMutationRecord } from \"@tiptap/pm/view\";\n\nimport { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport { Block } from \"../defaultBlocks.js\";\n\ntype ToggledState = {\n  set: (block: Block<any, any, any>, isToggled: boolean) => void;\n  get: (block: Block<any, any, any>) => boolean;\n};\n\nexport const defaultToggledState: ToggledState = {\n  set: (block, isToggled: boolean) =>\n    window.localStorage.setItem(\n      `toggle-${block.id}`,\n      isToggled ? \"true\" : \"false\",\n    ),\n  get: (block) => window.localStorage.getItem(`toggle-${block.id}`) === \"true\",\n};\n\nexport const createToggleWrapper = (\n  block: Block<any, any, any>,\n  editor: BlockNoteEditor<any, any, any>,\n  renderedElement: HTMLElement,\n  toggledState: ToggledState = defaultToggledState,\n): {\n  dom: HTMLElement;\n  contentDOM?: HTMLElement;\n  ignoreMutation?: (mutation: ViewMutationRecord) => boolean;\n  destroy?: () => void;\n} => {\n  if (\"isToggleable\" in block.props && !block.props.isToggleable) {\n    return {\n      dom: renderedElement,\n    };\n  }\n\n  const dom = document.createElement(\"div\");\n\n  const toggleWrapper = document.createElement(\"div\");\n  toggleWrapper.className = \"bn-toggle-wrapper\";\n\n  const toggleButton = document.createElement(\"button\");\n  toggleButton.className = \"bn-toggle-button\";\n  toggleButton.type = \"button\";\n  toggleButton.innerHTML =\n    // https://fonts.google.com/icons?selected=Material+Symbols+Rounded:chevron_right:FILL@0;wght@700;GRAD@0;opsz@24&icon.query=chevron&icon.style=Rounded&icon.size=24&icon.color=%23e8eaed\n    '<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\" viewBox=\"0 -960 960 960\" width=\"24px\" fill=\"CURRENTCOLOR\"><path d=\"M320-200v-560l440 280-440 280Z\"/></svg>';\n  const toggleButtonMouseDown = (event: MouseEvent) => event.preventDefault();\n  toggleButton.addEventListener(\"mousedown\", toggleButtonMouseDown);\n  const toggleButtonOnClick = () => {\n    // Toggles visibility of child blocks. Also adds/removes the \"add block\"\n    // button if there are no child blocks.\n    if (toggleWrapper.getAttribute(\"data-show-children\") === \"true\") {\n      toggleWrapper.setAttribute(\"data-show-children\", \"false\");\n      toggledState.set(editor.getBlock(block)!, false);\n\n      if (dom.contains(toggleAddBlockButton)) {\n        dom.removeChild(toggleAddBlockButton);\n      }\n    } else {\n      toggleWrapper.setAttribute(\"data-show-children\", \"true\");\n      toggledState.set(editor.getBlock(block)!, true);\n\n      if (\n        editor.getBlock(block)?.children.length === 0 &&\n        !dom.contains(toggleAddBlockButton)\n      ) {\n        dom.appendChild(toggleAddBlockButton);\n      }\n    }\n  };\n  toggleButton.addEventListener(\"click\", toggleButtonOnClick);\n\n  toggleWrapper.appendChild(toggleButton);\n  toggleWrapper.appendChild(renderedElement);\n\n  const toggleAddBlockButton = document.createElement(\"button\");\n  toggleAddBlockButton.className = \"bn-toggle-add-block-button\";\n  toggleAddBlockButton.type = \"button\";\n  toggleAddBlockButton.textContent =\n    editor.dictionary.toggle_blocks.add_block_button;\n  const toggleAddBlockButtonMouseDown = (event: MouseEvent) =>\n    event.preventDefault();\n  toggleAddBlockButton.addEventListener(\n    \"mousedown\",\n    toggleAddBlockButtonMouseDown,\n  );\n  const toggleAddBlockButtonOnClick = () => {\n    // Adds a single empty child block.\n    editor.transact(() => {\n      // dom.removeChild(toggleAddBlockButton);\n\n      const updatedBlock = editor.updateBlock(block, {\n        // Single empty block with default type.\n        children: [{}],\n      });\n      editor.setTextCursorPosition(updatedBlock.children[0].id, \"end\");\n      editor.focus();\n    });\n  };\n  toggleAddBlockButton.addEventListener(\"click\", toggleAddBlockButtonOnClick);\n\n  dom.appendChild(toggleWrapper);\n\n  let childCount = block.children.length;\n  const onEditorChange = editor.onChange(() => {\n    const newChildCount = editor.getBlock(block)?.children.length ?? 0;\n\n    if (newChildCount > childCount) {\n      // If a child block is added while children are hidden, show children.\n      if (toggleWrapper.getAttribute(\"data-show-children\") === \"false\") {\n        toggleWrapper.setAttribute(\"data-show-children\", \"true\");\n        toggledState.set(editor.getBlock(block)!, true);\n      }\n\n      // Remove the \"add block\" button as we want to show child blocks and\n      // there is at least one child block.\n      if (dom.contains(toggleAddBlockButton)) {\n        dom.removeChild(toggleAddBlockButton);\n      }\n    } else if (newChildCount === 0 && newChildCount < childCount) {\n      // If the last child block is removed while children are shown, hide\n      // children.\n      if (toggleWrapper.getAttribute(\"data-show-children\") === \"true\") {\n        toggleWrapper.setAttribute(\"data-show-children\", \"false\");\n        toggledState.set(editor.getBlock(block)!, false);\n      }\n\n      // Remove the \"add block\" button as we want to hide child blocks,\n      // regardless of whether there are child blocks or not.\n      if (dom.contains(toggleAddBlockButton)) {\n        dom.removeChild(toggleAddBlockButton);\n      }\n    }\n\n    childCount = newChildCount;\n  });\n\n  if (toggledState.get(block)) {\n    toggleWrapper.setAttribute(\"data-show-children\", \"true\");\n\n    if (block.children.length === 0) {\n      // If the toggle is set to show children, but there are no children,\n      // we add the \"add block\" button.\n      dom.appendChild(toggleAddBlockButton);\n    }\n  } else {\n    toggleWrapper.setAttribute(\"data-show-children\", \"false\");\n  }\n\n  return {\n    dom,\n    // Prevents re-renders when the toggle button is clicked.\n    ignoreMutation: (mutation) => {\n      if (\n        mutation instanceof MutationRecord &&\n        // We want to prevent re-renders when the view changes, so we ignore\n        // all mutations where the `data-show-children` attribute is changed\n        // or the \"add block\" button is added/removed.\n        ((mutation.type === \"attributes\" &&\n          mutation.target === toggleWrapper &&\n          mutation.attributeName === \"data-show-children\") ||\n          (mutation.type === \"childList\" &&\n            (mutation.addedNodes[0] === toggleAddBlockButton ||\n              mutation.removedNodes[0] === toggleAddBlockButton)))\n      ) {\n        return true;\n      }\n      return false;\n    },\n    destroy: () => {\n      toggleButton.removeEventListener(\"mousedown\", toggleButtonMouseDown);\n      toggleButton.removeEventListener(\"click\", toggleButtonOnClick);\n      toggleAddBlockButton.removeEventListener(\n        \"mousedown\",\n        toggleAddBlockButtonMouseDown,\n      );\n      toggleAddBlockButton.removeEventListener(\n        \"click\",\n        toggleAddBlockButtonOnClick,\n      );\n      onEditorChange?.();\n    },\n  };\n};\n","import { createBlockConfig, createBlockSpec } from \"../../schema/index.js\";\nimport { createBlockNoteExtension } from \"../../editor/BlockNoteExtension.js\";\nimport {\n  addDefaultPropsExternalHTML,\n  defaultProps,\n  parseDefaultProps,\n} from \"../defaultProps.js\";\nimport { createToggleWrapper } from \"../ToggleWrapper/createToggleWrapper.js\";\n\nconst HEADING_LEVELS = [1, 2, 3, 4, 5, 6] as const;\n\nexport interface HeadingOptions {\n  defaultLevel?: (typeof HEADING_LEVELS)[number];\n  levels?: readonly number[];\n  // TODO should probably use composition instead of this\n  allowToggleHeadings?: boolean;\n}\n\nexport type HeadingBlockConfig = ReturnType<typeof createHeadingBlockConfig>;\n\nexport const createHeadingBlockConfig = createBlockConfig(\n  ({\n    defaultLevel = 1,\n    levels = HEADING_LEVELS,\n    allowToggleHeadings = true,\n  }: HeadingOptions = {}) =>\n    ({\n      type: \"heading\" as const,\n      propSchema: {\n        ...defaultProps,\n        level: { default: defaultLevel, values: levels },\n        ...(allowToggleHeadings\n          ? { isToggleable: { default: false, optional: true } as const }\n          : {}),\n      },\n      content: \"inline\",\n    }) as const,\n);\n\nexport const createHeadingBlockSpec = createBlockSpec(\n  createHeadingBlockConfig,\n  ({ allowToggleHeadings = true }: HeadingOptions = {}) => ({\n    meta: {\n      isolating: false,\n    },\n    parse(e) {\n      let level: number;\n      switch (e.tagName) {\n        case \"H1\":\n          level = 1;\n          break;\n        case \"H2\":\n          level = 2;\n          break;\n        case \"H3\":\n          level = 3;\n          break;\n        case \"H4\":\n          level = 4;\n          break;\n        case \"H5\":\n          level = 5;\n          break;\n        case \"H6\":\n          level = 6;\n          break;\n        default:\n          return undefined;\n      }\n\n      return {\n        ...parseDefaultProps(e),\n        level,\n      };\n    },\n    render(block, editor) {\n      const dom = document.createElement(`h${block.props.level}`);\n\n      if (allowToggleHeadings) {\n        const toggleWrapper = createToggleWrapper(block, editor, dom);\n        return { ...toggleWrapper, contentDOM: dom };\n      }\n\n      return {\n        dom,\n        contentDOM: dom,\n      };\n    },\n    toExternalHTML(block) {\n      const dom = document.createElement(`h${block.props.level}`);\n      addDefaultPropsExternalHTML(block.props, dom);\n\n      return {\n        dom,\n        contentDOM: dom,\n      };\n    },\n  }),\n  ({ levels = HEADING_LEVELS }: HeadingOptions = {}) => [\n    createBlockNoteExtension({\n      key: \"heading-shortcuts\",\n      keyboardShortcuts: Object.fromEntries(\n        levels.map((level) => [\n          `Mod-Alt-${level}`,\n          ({ editor }) => {\n            const cursorPosition = editor.getTextCursorPosition();\n\n            if (\n              editor.schema.blockSchema[cursorPosition.block.type].content !==\n              \"inline\"\n            ) {\n              return false;\n            }\n\n            editor.updateBlock(cursorPosition.block, {\n              type: \"heading\",\n              props: {\n                level: level as any,\n              },\n            });\n            return true;\n          },\n        ]) ?? [],\n      ),\n      inputRules: levels.map((level) => ({\n        find: new RegExp(`^(#{${level}})\\\\s$`),\n        replace({ match }: { match: RegExpMatchArray }) {\n          return {\n            type: \"heading\",\n            props: {\n              level: match[1].length,\n            },\n          };\n        },\n      })),\n    }),\n  ],\n);\n","import type { BlockNoteEditor } from \"../../../../editor/BlockNoteEditor.js\";\nimport {\n  BlockConfig,\n  BlockFromConfigNoChildren,\n} from \"../../../../schema/index.js\";\nimport { createFileBlockWrapper } from \"./createFileBlockWrapper.js\";\n\nexport const createResizableFileBlockWrapper = (\n  block: BlockFromConfigNoChildren<\n    BlockConfig<\n      string,\n      {\n        backgroundColor: { default: \"default\" };\n        name: { default: \"\" };\n        url: { default: \"\" };\n        caption: { default: \"\" };\n        showPreview?: { default: true };\n        previewWidth?: { default: number };\n        textAlignment?: { default: \"left\" };\n      },\n      \"none\"\n    >,\n    any,\n    any\n  >,\n  editor: BlockNoteEditor<any, any, any>,\n  element: { dom: HTMLElement; destroy?: () => void },\n  resizeHandlesContainerElement: HTMLElement,\n  buttonIcon?: HTMLElement,\n): { dom: HTMLElement; destroy: () => void } => {\n  const { dom, destroy } = createFileBlockWrapper(\n    block,\n    editor,\n    element,\n    buttonIcon,\n  );\n  const wrapper = dom;\n  wrapper.style.position = \"relative\";\n  if (block.props.url && block.props.showPreview) {\n    if (block.props.previewWidth) {\n      wrapper.style.width = `${block.props.previewWidth}px`;\n    } else {\n      wrapper.style.width = \"fit-content\";\n    }\n  }\n\n  const leftResizeHandle = document.createElement(\"div\");\n  leftResizeHandle.className = \"bn-resize-handle\";\n  leftResizeHandle.style.left = \"4px\";\n  const rightResizeHandle = document.createElement(\"div\");\n  rightResizeHandle.className = \"bn-resize-handle\";\n  rightResizeHandle.style.right = \"4px\";\n\n  // This element ensures `mousemove` and `mouseup` events are captured while\n  // resizing when the cursor is over the wrapper content. This is because\n  // embeds are treated as separate HTML documents, so if the content is an\n  // embed, the events will only fire within that document.\n  const eventCaptureElement = document.createElement(\"div\");\n  eventCaptureElement.style.position = \"absolute\";\n  eventCaptureElement.style.height = \"100%\";\n  eventCaptureElement.style.width = \"100%\";\n\n  // Temporary parameters set when the user begins resizing the element, used to\n  // calculate the new width of the element.\n  let resizeParams:\n    | {\n        handleUsed: \"left\" | \"right\";\n        initialWidth: number;\n        initialClientX: number;\n      }\n    | undefined;\n  let width = block.props.previewWidth! as number;\n\n  // Updates the element width with an updated width depending on the cursor X\n  // offset from when the resize began, and which resize handle is being used.\n  const windowMouseMoveHandler = (event: MouseEvent | TouchEvent) => {\n    if (!resizeParams) {\n      if (\n        !editor.isEditable &&\n        resizeHandlesContainerElement.contains(leftResizeHandle) &&\n        resizeHandlesContainerElement.contains(rightResizeHandle)\n      ) {\n        resizeHandlesContainerElement.removeChild(leftResizeHandle);\n        resizeHandlesContainerElement.removeChild(rightResizeHandle);\n      }\n\n      return;\n    }\n\n    let newWidth: number;\n\n    const clientX =\n      \"touches\" in event ? event.touches[0].clientX : event.clientX;\n\n    if (block.props.textAlignment === \"center\") {\n      if (resizeParams.handleUsed === \"left\") {\n        newWidth =\n          resizeParams.initialWidth +\n          (resizeParams.initialClientX - clientX) * 2;\n      } else {\n        newWidth =\n          resizeParams.initialWidth +\n          (clientX - resizeParams.initialClientX) * 2;\n      }\n    } else {\n      if (resizeParams.handleUsed === \"left\") {\n        newWidth =\n          resizeParams.initialWidth + resizeParams.initialClientX - clientX;\n      } else {\n        newWidth =\n          resizeParams.initialWidth + clientX - resizeParams.initialClientX;\n      }\n    }\n\n    // Min element width in px.\n    const minWidth = 64;\n\n    // Ensures the element is not wider than the editor and not narrower than a\n    // predetermined minimum width.\n    width = Math.min(\n      Math.max(newWidth, minWidth),\n      editor.domElement?.firstElementChild?.clientWidth || Number.MAX_VALUE,\n    );\n    wrapper.style.width = `${width}px`;\n  };\n  // Stops mouse movements from resizing the element and updates the block's\n  // `width` prop to the new value.\n  const windowMouseUpHandler = (event: MouseEvent | TouchEvent) => {\n    // Hides the drag handles if the cursor is no longer over the element.\n    if (\n      (!event.target ||\n        !wrapper.contains(event.target as Node) ||\n        !editor.isEditable) &&\n      resizeHandlesContainerElement.contains(leftResizeHandle) &&\n      resizeHandlesContainerElement.contains(rightResizeHandle)\n    ) {\n      resizeHandlesContainerElement.removeChild(leftResizeHandle);\n      resizeHandlesContainerElement.removeChild(rightResizeHandle);\n    }\n\n    if (!resizeParams) {\n      return;\n    }\n\n    resizeParams = undefined;\n\n    if (wrapper.contains(eventCaptureElement)) {\n      wrapper.removeChild(eventCaptureElement);\n    }\n\n    editor.updateBlock(block, {\n      props: {\n        previewWidth: width,\n      },\n    });\n  };\n\n  // Shows the resize handles when hovering over the wrapper with the cursor.\n  const wrapperMouseEnterHandler = () => {\n    if (editor.isEditable) {\n      resizeHandlesContainerElement.appendChild(leftResizeHandle);\n      resizeHandlesContainerElement.appendChild(rightResizeHandle);\n    }\n  };\n  // Hides the resize handles when the cursor leaves the wrapper, unless the\n  // cursor moves to one of the resize handles.\n  const wrapperMouseLeaveHandler = (event: MouseEvent) => {\n    if (\n      event.relatedTarget === leftResizeHandle ||\n      event.relatedTarget === rightResizeHandle\n    ) {\n      return;\n    }\n\n    if (resizeParams) {\n      return;\n    }\n\n    if (\n      editor.isEditable &&\n      resizeHandlesContainerElement.contains(leftResizeHandle) &&\n      resizeHandlesContainerElement.contains(rightResizeHandle)\n    ) {\n      resizeHandlesContainerElement.removeChild(leftResizeHandle);\n      resizeHandlesContainerElement.removeChild(rightResizeHandle);\n    }\n  };\n\n  // Sets the resize params, allowing the user to begin resizing the element by\n  // moving the cursor left or right.\n  const leftResizeHandleMouseDownHandler = (event: MouseEvent | TouchEvent) => {\n    event.preventDefault();\n\n    if (!wrapper.contains(eventCaptureElement)) {\n      wrapper.appendChild(eventCaptureElement);\n    }\n\n    const clientX =\n      \"touches\" in event ? event.touches[0].clientX : event.clientX;\n\n    resizeParams = {\n      handleUsed: \"left\",\n      initialWidth: wrapper.clientWidth,\n      initialClientX: clientX,\n    };\n  };\n  const rightResizeHandleMouseDownHandler = (\n    event: MouseEvent | TouchEvent,\n  ) => {\n    event.preventDefault();\n\n    if (!wrapper.contains(eventCaptureElement)) {\n      wrapper.appendChild(eventCaptureElement);\n    }\n\n    const clientX =\n      \"touches\" in event ? event.touches[0].clientX : event.clientX;\n\n    resizeParams = {\n      handleUsed: \"right\",\n      initialWidth: wrapper.clientWidth,\n      initialClientX: clientX,\n    };\n  };\n\n  window.addEventListener(\"mousemove\", windowMouseMoveHandler);\n  window.addEventListener(\"touchmove\", windowMouseMoveHandler);\n  window.addEventListener(\"mouseup\", windowMouseUpHandler);\n  window.addEventListener(\"touchend\", windowMouseUpHandler);\n  wrapper.addEventListener(\"mouseenter\", wrapperMouseEnterHandler);\n  wrapper.addEventListener(\"mouseleave\", wrapperMouseLeaveHandler);\n  leftResizeHandle.addEventListener(\n    \"mousedown\",\n    leftResizeHandleMouseDownHandler,\n  );\n  leftResizeHandle.addEventListener(\n    \"touchstart\",\n    leftResizeHandleMouseDownHandler,\n  );\n  rightResizeHandle.addEventListener(\n    \"mousedown\",\n    rightResizeHandleMouseDownHandler,\n  );\n  rightResizeHandle.addEventListener(\n    \"touchstart\",\n    rightResizeHandleMouseDownHandler,\n  );\n\n  return {\n    dom: wrapper,\n    destroy: () => {\n      destroy?.();\n      window.removeEventListener(\"mousemove\", windowMouseMoveHandler);\n      window.removeEventListener(\"touchmove\", windowMouseMoveHandler);\n      window.removeEventListener(\"mouseup\", windowMouseUpHandler);\n      window.removeEventListener(\"touchend\", windowMouseUpHandler);\n      wrapper.removeEventListener(\"mouseenter\", wrapperMouseEnterHandler);\n      wrapper.removeEventListener(\"mouseleave\", wrapperMouseLeaveHandler);\n      leftResizeHandle.removeEventListener(\n        \"mousedown\",\n        leftResizeHandleMouseDownHandler,\n      );\n      leftResizeHandle.removeEventListener(\n        \"touchstart\",\n        leftResizeHandleMouseDownHandler,\n      );\n      rightResizeHandle.removeEventListener(\n        \"mousedown\",\n        rightResizeHandleMouseDownHandler,\n      );\n      rightResizeHandle.removeEventListener(\n        \"touchstart\",\n        rightResizeHandleMouseDownHandler,\n      );\n    },\n  };\n};\n","export const parseImageElement = (imageElement: HTMLImageElement) => {\n  const url = imageElement.src || undefined;\n  const previewWidth = imageElement.width || undefined;\n  const name = imageElement.alt || undefined;\n\n  return { url, previewWidth, name };\n};\n","import { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport {\n  BlockFromConfig,\n  createBlockConfig,\n  createBlockSpec,\n} from \"../../schema/index.js\";\nimport { defaultProps, parseDefaultProps } from \"../defaultProps.js\";\nimport { parseFigureElement } from \"../File/helpers/parse/parseFigureElement.js\";\nimport { createResizableFileBlockWrapper } from \"../File/helpers/render/createResizableFileBlockWrapper.js\";\nimport { createFigureWithCaption } from \"../File/helpers/toExternalHTML/createFigureWithCaption.js\";\nimport { createLinkWithCaption } from \"../File/helpers/toExternalHTML/createLinkWithCaption.js\";\nimport { parseImageElement } from \"./parseImageElement.js\";\n\nexport const FILE_IMAGE_ICON_SVG =\n  '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\"><path d=\"M5 11.1005L7 9.1005L12.5 14.6005L16 11.1005L19 14.1005V5H5V11.1005ZM4 3H20C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3ZM15.5 10C14.6716 10 14 9.32843 14 8.5C14 7.67157 14.6716 7 15.5 7C16.3284 7 17 7.67157 17 8.5C17 9.32843 16.3284 10 15.5 10Z\"></path></svg>';\n\nexport interface ImageOptions {\n  icon?: string;\n}\n\nexport type ImageBlockConfig = ReturnType<typeof createImageBlockConfig>;\n\nexport const createImageBlockConfig = createBlockConfig(\n  (_ctx: ImageOptions = {}) =>\n    ({\n      type: \"image\" as const,\n      propSchema: {\n        textAlignment: defaultProps.textAlignment,\n        backgroundColor: defaultProps.backgroundColor,\n        // File name.\n        name: {\n          default: \"\" as const,\n        },\n        // File url.\n        url: {\n          default: \"\" as const,\n        },\n        // File caption.\n        caption: {\n          default: \"\" as const,\n        },\n\n        showPreview: {\n          default: true,\n        },\n        // File preview width in px.\n        previewWidth: {\n          default: undefined,\n          type: \"number\" as const,\n        },\n      },\n      content: \"none\" as const,\n    }) as const,\n);\n\nexport const imageParse =\n  (_config: ImageOptions = {}) =>\n  (element: HTMLElement) => {\n    if (element.tagName === \"IMG\") {\n      // Ignore if parent figure has already been parsed.\n      if (element.closest(\"figure\")) {\n        return undefined;\n      }\n\n      const { backgroundColor } = parseDefaultProps(element);\n\n      return {\n        ...parseImageElement(element as HTMLImageElement),\n        backgroundColor,\n      };\n    }\n\n    if (element.tagName === \"FIGURE\") {\n      const parsedFigure = parseFigureElement(element, \"img\");\n      if (!parsedFigure) {\n        return undefined;\n      }\n\n      const { targetElement, caption } = parsedFigure;\n\n      const { backgroundColor } = parseDefaultProps(element);\n\n      return {\n        ...parseImageElement(targetElement as HTMLImageElement),\n        backgroundColor,\n        caption,\n      };\n    }\n\n    return undefined;\n  };\n\nexport const imageRender =\n  (config: ImageOptions = {}) =>\n  (\n    block: BlockFromConfig<ReturnType<typeof createImageBlockConfig>, any, any>,\n    editor: BlockNoteEditor<\n      Record<\"image\", ReturnType<typeof createImageBlockConfig>>,\n      any,\n      any\n    >,\n  ) => {\n    const icon = document.createElement(\"div\");\n    icon.innerHTML = config.icon ?? FILE_IMAGE_ICON_SVG;\n\n    const imageWrapper = document.createElement(\"div\");\n    imageWrapper.className = \"bn-visual-media-wrapper\";\n\n    const image = document.createElement(\"img\");\n    image.className = \"bn-visual-media\";\n    if (editor.resolveFileUrl) {\n      editor.resolveFileUrl(block.props.url).then((downloadUrl) => {\n        image.src = downloadUrl;\n      });\n    } else {\n      image.src = block.props.url;\n    }\n\n    image.alt = block.props.name || block.props.caption || \"BlockNote image\";\n    image.contentEditable = \"false\";\n    image.draggable = false;\n    imageWrapper.appendChild(image);\n\n    return createResizableFileBlockWrapper(\n      block,\n      editor,\n      { dom: imageWrapper },\n      imageWrapper,\n      icon.firstElementChild as HTMLElement,\n    );\n  };\n\nexport const imageToExternalHTML =\n  (_config: ImageOptions = {}) =>\n  (\n    block: BlockFromConfig<ReturnType<typeof createImageBlockConfig>, any, any>,\n    _editor: BlockNoteEditor<\n      Record<\"image\", ReturnType<typeof createImageBlockConfig>>,\n      any,\n      any\n    >,\n  ) => {\n    if (!block.props.url) {\n      const div = document.createElement(\"p\");\n      div.textContent = \"Add image\";\n\n      return {\n        dom: div,\n      };\n    }\n\n    let image;\n    if (block.props.showPreview) {\n      image = document.createElement(\"img\");\n      image.src = block.props.url;\n      image.alt = block.props.name || block.props.caption || \"BlockNote image\";\n      if (block.props.previewWidth) {\n        image.width = block.props.previewWidth;\n      }\n    } else {\n      image = document.createElement(\"a\");\n      image.href = block.props.url;\n      image.textContent = block.props.name || block.props.url;\n    }\n\n    if (block.props.caption) {\n      if (block.props.showPreview) {\n        return createFigureWithCaption(image, block.props.caption);\n      } else {\n        return createLinkWithCaption(image, block.props.caption);\n      }\n    }\n\n    return {\n      dom: image,\n    };\n  };\n\nexport const createImageBlockSpec = createBlockSpec(\n  createImageBlockConfig,\n  (config) => ({\n    meta: {\n      fileBlockAccept: [\"image/*\"],\n    },\n    parse: imageParse(config),\n    render: imageRender(config),\n    toExternalHTML: imageToExternalHTML(config),\n    runsBefore: [\"file\"],\n  }),\n);\n","import { EditorState, Transaction } from \"prosemirror-state\";\n\nimport {\n  getBlockInfo,\n  getNearestBlockPos,\n} from \"../../../getBlockInfoFromPos.js\";\nimport { getPmSchema } from \"../../../pmUtil.js\";\n\nexport const splitBlockCommand = (\n  posInBlock: number,\n  keepType?: boolean,\n  keepProps?: boolean,\n) => {\n  return ({\n    state,\n    dispatch,\n  }: {\n    state: EditorState;\n    dispatch: ((args?: any) => any) | undefined;\n  }) => {\n    if (dispatch) {\n      return splitBlockTr(state.tr, posInBlock, keepType, keepProps);\n    }\n\n    return true;\n  };\n};\n\nexport const splitBlockTr = (\n  tr: Transaction,\n  posInBlock: number,\n  keepType?: boolean,\n  keepProps?: boolean,\n): boolean => {\n  const nearestBlockContainerPos = getNearestBlockPos(tr.doc, posInBlock);\n\n  const info = getBlockInfo(nearestBlockContainerPos);\n\n  if (!info.isBlockContainer) {\n    return false;\n  }\n  const schema = getPmSchema(tr);\n\n  const types = [\n    {\n      type: info.bnBlock.node.type, // always keep blockcontainer type\n      attrs: keepProps ? { ...info.bnBlock.node.attrs, id: undefined } : {},\n    },\n    {\n      type: keepType ? info.blockContent.node.type : schema.nodes[\"paragraph\"],\n      attrs: keepProps ? { ...info.blockContent.node.attrs } : {},\n    },\n  ];\n\n  tr.split(posInBlock, 2, types);\n\n  return true;\n};\n","import { splitBlockTr } from \"../../api/blockManipulation/commands/splitBlock/splitBlock.js\";\nimport { updateBlockTr } from \"../../api/blockManipulation/commands/updateBlock/updateBlock.js\";\nimport { getBlockInfoFromTransaction } from \"../../api/getBlockInfoFromPos.js\";\nimport { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\n\nexport const handleEnter = (\n  editor: BlockNoteEditor<any, any, any>,\n  listItemType: string,\n) => {\n  const { blockInfo, selectionEmpty } = editor.transact((tr) => {\n    return {\n      blockInfo: getBlockInfoFromTransaction(tr),\n      selectionEmpty: tr.selection.anchor === tr.selection.head,\n    };\n  });\n\n  if (!blockInfo.isBlockContainer) {\n    return false;\n  }\n  const { bnBlock: blockContainer, blockContent } = blockInfo;\n\n  if (!(blockContent.node.type.name === listItemType) || !selectionEmpty) {\n    return false;\n  }\n\n  if (blockContent.node.childCount === 0) {\n    editor.transact((tr) => {\n      updateBlockTr(tr, blockContainer.beforePos, {\n        type: \"paragraph\",\n        props: {},\n      });\n    });\n    return true;\n  } else if (blockContent.node.childCount > 0) {\n    return editor.transact((tr) => {\n      tr.deleteSelection();\n      return splitBlockTr(tr, tr.selection.from, true);\n    });\n  }\n\n  return false;\n};\n","import { DOMParser, Fragment, Schema } from \"prosemirror-model\";\n\n/**\n * This function is used to parse the content of a list item external HTML node.\n *\n * Due to a change in how prosemirror-model handles parsing elements, we have additional flexibility in how we can \"fit\" content into a list item.\n *\n * We've decided to take an approach that is similar to Notion. The core rules of the algorithm are:\n *\n *  - If the first child of an `li` has ONLY text content, take the text content, and flatten it into the list item. Subsequent siblings are carried over as is, as children of the list item.\n *    - e.g. `<li><h1>Hello</h1><p>World</p></li> -> <li>Hello<blockGroup><blockContainer><p>World</p></blockContainer></blockGroup></li>`\n *  - Else, take the content and insert it as children instead.\n *    - e.g. `<li><img src=\"url\" /></li> -> <li><p></p><blockGroup><blockContainer><img src=\"url\" /></blockContainer></blockGroup></li>`\n *\n * This ensures that a list item's content is always valid ProseMirror content. Smoothing over differences between how external HTML may be rendered, and how ProseMirror expects content to be structured.\n */\nexport function getListItemContent(\n  /**\n   * The `li` element to parse.\n   */\n  _node: Node,\n  /**\n   * The schema to use for parsing.\n   */\n  schema: Schema,\n  /**\n   * The name of the list item node.\n   */\n  name: string,\n): Fragment {\n  /**\n   * To actually implement this algorithm, we need to leverage ProseMirror's \"fitting\" algorithm.\n   * Where, if content is parsed which doesn't fit into the current node, it will be moved into the parent node.\n   *\n   * This allows us to parse multiple pieces of content from within the list item (even though it normally would not match the list item's schema) and \"throw\" the excess content into the list item's children.\n   *\n   * The expected return value is a `Fragment` which contains the list item's content as the first element, and the children wrapped in a blockGroup node. Like so:\n   * ```\n   * Fragment<[Node<Text>, Node<BlockGroup<Node<BlockContainer<any>>>>]>\n   * ```\n   */\n  const parser = DOMParser.fromSchema(schema);\n\n  // TODO: This will be unnecessary in the future: https://github.com/ProseMirror/prosemirror-model/commit/166188d4f9db96eb86fb7de62e72049c86c9dd79\n  const node = _node as HTMLElement;\n\n  // Move the `li` element's content into a new `div` element\n  // This is a hacky workaround to not re-trigger list item parsing,\n  // when we are looking to understand what the list item's content actually is, in terms of the schema.\n  const clonedNodeDiv = document.createElement(\"div\");\n  // Mark the `div` element as a `blockGroup` to make the parsing easier.\n  clonedNodeDiv.setAttribute(\"data-node-type\", \"blockGroup\");\n  // Clone all children of the `li` element into the new `div` element\n  for (const child of Array.from(node.childNodes)) {\n    clonedNodeDiv.appendChild(child.cloneNode(true));\n  }\n\n  // Parses children of the `li` element into a `blockGroup` with `blockContainer` node children\n  // This is the structure of list item children, so parsing into this structure allows for\n  // easy separation of list item content from child list item content.\n  let blockGroupNode = parser.parse(clonedNodeDiv, {\n    topNode: schema.nodes.blockGroup.create(),\n  });\n\n  // There is an edge case where a list item's content may contain a `<input>` element.\n  // Causing it to be recognized as a `checkListItem`.\n  // We want to skip this, and just parse the list item's content as is.\n  if (blockGroupNode.firstChild?.firstChild?.type.name === \"checkListItem\") {\n    // We skip the first child, by cutting it out of the `blockGroup` node.\n    // and continuing with the rest of the algorithm.\n    blockGroupNode = blockGroupNode.copy(\n      blockGroupNode.content.cut(\n        blockGroupNode.firstChild.firstChild.nodeSize + 2,\n      ),\n    );\n  }\n\n  // Structure above is `blockGroup<blockContainer<any>[]>`\n  // We want to extract the first `blockContainer` node's content, and see if it is a text block.\n  const listItemsFirstChild = blockGroupNode.firstChild?.firstChild;\n\n  // If the first node is not a text block, then it's first child is not compatible with the list item node.\n  if (!listItemsFirstChild?.isTextblock) {\n    // So, we do not try inserting anything into the list item, and instead return anything we found as children for the list item.\n    return Fragment.from(blockGroupNode);\n  }\n\n  // If it is a text block, then we know it only contains text content.\n  // So, we extract it, and insert its content into the `listItemNode`.\n  // The remaining nodes in the `blockGroup` stay in-place.\n  const listItemNode = schema.nodes[name].create(\n    {},\n    listItemsFirstChild.content,\n  );\n\n  // We have `blockGroup<listItemsFirstChild, ...blockContainer<any>[]>`\n  // We want to extract out the rest of the nodes as `<...blockContainer<any>[]>`\n  const remainingListItemChildren = blockGroupNode.content.cut(\n    // +2 for the `blockGroup` node's start and end markers\n    listItemsFirstChild.nodeSize + 2,\n  );\n  const hasRemainingListItemChildren = remainingListItemChildren.size > 0;\n\n  if (hasRemainingListItemChildren) {\n    // Copy the remaining list item children back into the `blockGroup` node.\n    // This will make it back into: `blockGroup<...blockContainer<any>[]>`\n    const listItemsChildren = blockGroupNode.copy(remainingListItemChildren);\n\n    // Return the `listItem` node's content, then add the parsed children after to be lifted out by ProseMirror \"fitting\" algorithm.\n    return listItemNode.content.addToEnd(listItemsChildren);\n  }\n\n  // Otherwise, just return the `listItem` node's content.\n  return listItemNode.content;\n}\n","import { getBlockInfoFromSelection } from \"../../../api/getBlockInfoFromPos.js\";\nimport { createBlockNoteExtension } from \"../../../editor/BlockNoteExtension.js\";\nimport { createBlockConfig, createBlockSpec } from \"../../../schema/index.js\";\nimport {\n  addDefaultPropsExternalHTML,\n  defaultProps,\n  parseDefaultProps,\n} from \"../../defaultProps.js\";\nimport { handleEnter } from \"../../utils/listItemEnterHandler.js\";\nimport { getListItemContent } from \"../getListItemContent.js\";\n\nexport type BulletListItemBlockConfig = ReturnType<\n  typeof createBulletListItemBlockConfig\n>;\n\nexport const createBulletListItemBlockConfig = createBlockConfig(\n  () =>\n    ({\n      type: \"bulletListItem\" as const,\n      propSchema: {\n        ...defaultProps,\n      },\n      content: \"inline\",\n    }) as const,\n);\n\nexport const createBulletListItemBlockSpec = createBlockSpec(\n  createBulletListItemBlockConfig,\n  {\n    meta: {\n      isolating: false,\n    },\n    parse(element) {\n      if (element.tagName !== \"LI\") {\n        return undefined;\n      }\n\n      const parent = element.parentElement;\n\n      if (parent === null) {\n        return undefined;\n      }\n\n      if (\n        parent.tagName === \"UL\" ||\n        (parent.tagName === \"DIV\" && parent.parentElement?.tagName === \"UL\")\n      ) {\n        return parseDefaultProps(element);\n      }\n\n      return undefined;\n    },\n    // As `li` elements can contain multiple paragraphs, we need to merge their contents\n    // into a single one so that ProseMirror can parse everything correctly.\n    parseContent: ({ el, schema }) =>\n      getListItemContent(el, schema, \"bulletListItem\"),\n    render() {\n      // We use a <p> tag, because for <li> tags we'd need a <ul> element to put\n      // them in to be semantically correct, which we can't have due to the\n      // schema.\n      const dom = document.createElement(\"p\");\n\n      return {\n        dom,\n        contentDOM: dom,\n      };\n    },\n    toExternalHTML(block) {\n      const li = document.createElement(\"li\");\n      const p = document.createElement(\"p\");\n      addDefaultPropsExternalHTML(block.props, li);\n      li.appendChild(p);\n\n      return {\n        dom: li,\n        contentDOM: p,\n      };\n    },\n  },\n  [\n    createBlockNoteExtension({\n      key: \"bullet-list-item-shortcuts\",\n      keyboardShortcuts: {\n        Enter: ({ editor }) => {\n          return handleEnter(editor, \"bulletListItem\");\n        },\n        \"Mod-Shift-8\": ({ editor }) => {\n          const cursorPosition = editor.getTextCursorPosition();\n\n          if (\n            editor.schema.blockSchema[cursorPosition.block.type].content !==\n            \"inline\"\n          ) {\n            return false;\n          }\n\n          editor.updateBlock(cursorPosition.block, {\n            type: \"bulletListItem\",\n            props: {},\n          });\n          return true;\n        },\n      },\n      inputRules: [\n        {\n          find: new RegExp(`^[-+*]\\\\s$`),\n          replace({ editor }) {\n            const blockInfo = getBlockInfoFromSelection(\n              editor.prosemirrorState,\n            );\n\n            if (blockInfo.blockNoteType === \"heading\") {\n              return;\n            }\n            return {\n              type: \"bulletListItem\",\n              props: {},\n            };\n          },\n        },\n      ],\n    }),\n  ],\n);\n","import { createBlockNoteExtension } from \"../../../editor/BlockNoteExtension.js\";\nimport { createBlockConfig, createBlockSpec } from \"../../../schema/index.js\";\nimport {\n  addDefaultPropsExternalHTML,\n  defaultProps,\n  parseDefaultProps,\n} from \"../../defaultProps.js\";\nimport { handleEnter } from \"../../utils/listItemEnterHandler.js\";\nimport { getListItemContent } from \"../getListItemContent.js\";\n\nexport type CheckListItemBlockConfig = ReturnType<\n  typeof createCheckListItemConfig\n>;\n\nexport const createCheckListItemConfig = createBlockConfig(\n  () =>\n    ({\n      type: \"checkListItem\" as const,\n      propSchema: {\n        ...defaultProps,\n        checked: { default: false, type: \"boolean\" },\n      },\n      content: \"inline\",\n    }) as const,\n);\n\nexport const createCheckListItemBlockSpec = createBlockSpec(\n  createCheckListItemConfig,\n  {\n    meta: {\n      isolating: false,\n    },\n    parse(element) {\n      if (element.tagName === \"input\") {\n        // Ignore if we already parsed an ancestor list item to avoid double-parsing.\n        if (element.closest(\"[data-content-type]\") || element.closest(\"li\")) {\n          return undefined;\n        }\n\n        if ((element as HTMLInputElement).type === \"checkbox\") {\n          return { checked: (element as HTMLInputElement).checked };\n        }\n        return undefined;\n      }\n      if (element.tagName !== \"LI\") {\n        return undefined;\n      }\n\n      const parent = element.parentElement;\n\n      if (parent === null) {\n        return undefined;\n      }\n\n      if (\n        parent.tagName === \"UL\" ||\n        (parent.tagName === \"DIV\" && parent.parentElement?.tagName === \"UL\")\n      ) {\n        const checkbox =\n          (element.querySelector(\"input[type=checkbox]\") as HTMLInputElement) ||\n          null;\n\n        if (checkbox === null) {\n          return undefined;\n        }\n\n        return { ...parseDefaultProps(element), checked: checkbox.checked };\n      }\n\n      return;\n    },\n    // As `li` elements can contain multiple paragraphs, we need to merge their contents\n    // into a single one so that ProseMirror can parse everything correctly.\n    parseContent: ({ el, schema }) =>\n      getListItemContent(el, schema, \"checkListItem\"),\n    render(block, editor) {\n      const dom = document.createDocumentFragment();\n\n      const checkbox = document.createElement(\"input\");\n      checkbox.type = \"checkbox\";\n      checkbox.checked = block.props.checked;\n      if (block.props.checked) {\n        checkbox.setAttribute(\"checked\", \"\");\n      }\n      checkbox.addEventListener(\"change\", () => {\n        editor.updateBlock(block, { props: { checked: !block.props.checked } });\n      });\n      // We use a <p> tag, because for <li> tags we'd need a <ul> element to put\n      // them in to be semantically correct, which we can't have due to the\n      // schema.\n      const paragraph = document.createElement(\"p\");\n\n      dom.appendChild(checkbox);\n      dom.appendChild(paragraph);\n\n      return {\n        dom,\n        contentDOM: paragraph,\n      };\n    },\n    toExternalHTML(block) {\n      const dom = document.createElement(\"li\");\n      const checkbox = document.createElement(\"input\");\n      checkbox.type = \"checkbox\";\n      checkbox.checked = block.props.checked;\n      if (block.props.checked) {\n        checkbox.setAttribute(\"checked\", \"\");\n      }\n      // We use a <p> tag, because for <li> tags we'd need a <ul> element to put\n      // them in to be semantically correct, which we can't have due to the\n      // schema.\n      const paragraph = document.createElement(\"p\");\n      addDefaultPropsExternalHTML(block.props, dom);\n\n      dom.appendChild(checkbox);\n      dom.appendChild(paragraph);\n\n      return {\n        dom,\n        contentDOM: paragraph,\n      };\n    },\n    runsBefore: [\"bulletListItem\"],\n  },\n  [\n    createBlockNoteExtension({\n      key: \"check-list-item-shortcuts\",\n      keyboardShortcuts: {\n        Enter: ({ editor }) => {\n          return handleEnter(editor, \"checkListItem\");\n        },\n        \"Mod-Shift-9\": ({ editor }) => {\n          const cursorPosition = editor.getTextCursorPosition();\n\n          if (\n            editor.schema.blockSchema[cursorPosition.block.type].content !==\n            \"inline\"\n          ) {\n            return false;\n          }\n\n          editor.updateBlock(cursorPosition.block, {\n            type: \"checkListItem\",\n            props: {},\n          });\n          return true;\n        },\n      },\n      inputRules: [\n        {\n          find: new RegExp(`\\\\[\\\\s*\\\\]\\\\s$`),\n          replace() {\n            return {\n              type: \"checkListItem\",\n              props: {\n                checked: false,\n              },\n              content: [],\n            };\n          },\n        },\n        {\n          find: new RegExp(`\\\\[[Xx]\\\\]\\\\s$`),\n          replace() {\n            return {\n              type: \"checkListItem\",\n              props: {\n                checked: true,\n              },\n            };\n          },\n        },\n      ],\n    }),\n  ],\n);\n","import type { Node } from \"@tiptap/pm/model\";\nimport type { Transaction } from \"@tiptap/pm/state\";\nimport { Plugin, PluginKey } from \"@tiptap/pm/state\";\nimport { Decoration, DecorationSet } from \"@tiptap/pm/view\";\n\nimport { getBlockInfo } from \"../../../api/getBlockInfoFromPos.js\";\n\n// Loosely based on https://github.com/ueberdosis/tiptap/blob/7ac01ef0b816a535e903b5ca92492bff110a71ae/packages/extension-mathematics/src/MathematicsPlugin.ts (MIT)\n\ntype DecoSpec = {\n  index: number;\n  isFirst: boolean;\n  hasStart: boolean;\n  side: number;\n};\n\ntype Deco = Omit<Decoration, \"spec\"> & { spec: DecoSpec };\n\n/**\n * Calculate the index for a numbered list item based on its position and previous siblings\n */\nfunction calculateListItemIndex(\n  node: Node,\n  pos: number,\n  tr: Transaction,\n  map: Map<Node, number>,\n): { index: number; isFirst: boolean; hasStart: boolean } {\n  let index: number = node.firstChild!.attrs[\"start\"] || 1;\n  let isFirst = true;\n  const hasStart = !!node.firstChild!.attrs[\"start\"];\n\n  const blockInfo = getBlockInfo({\n    posBeforeNode: pos,\n    node,\n  });\n\n  if (!blockInfo.isBlockContainer) {\n    throw new Error(\"impossible\");\n  }\n\n  // Check if this block is the start of a new ordered list\n  const prevBlock = tr.doc.resolve(blockInfo.bnBlock.beforePos).nodeBefore;\n  const prevBlockIndex = prevBlock ? map.get(prevBlock) : undefined;\n\n  if (prevBlockIndex !== undefined) {\n    index = prevBlockIndex + 1;\n    isFirst = false;\n  } else if (prevBlock) {\n    // Because we only check the affected ranges, we may need to walk backwards to find the previous block's index\n    // We can't just rely on the map, because the map is reset every `apply` call\n    const prevBlockInfo = getBlockInfo({\n      posBeforeNode: blockInfo.bnBlock.beforePos - prevBlock.nodeSize,\n      node: prevBlock,\n    });\n\n    const isPrevBlockOrderedListItem =\n      prevBlockInfo.blockNoteType === \"numberedListItem\";\n    if (isPrevBlockOrderedListItem) {\n      // recurse to get the index of the previous block\n      const itemIndex = calculateListItemIndex(\n        prevBlock,\n        blockInfo.bnBlock.beforePos - prevBlock.nodeSize,\n        tr,\n        map,\n      );\n      index = itemIndex.index + 1;\n      isFirst = false;\n    }\n  }\n  // Note: we set the map late, so that when we recurse, we can rely on the map to get the previous block's index in one lookup\n  map.set(node, index);\n\n  return { index, isFirst, hasStart };\n}\n\n/**\n * Get the decorations for the current state based on the previous state,\n * and the transaction that was applied to get to the current state\n */\nfunction getDecorations(\n  tr: Transaction,\n  previousPluginState: { decorations: DecorationSet },\n) {\n  const map = new Map<Node, number>();\n\n  const nextDecorationSet = previousPluginState.decorations.map(\n    tr.mapping,\n    tr.doc,\n  );\n  const decorationsToAdd = [] as Deco[];\n\n  tr.doc.nodesBetween(0, tr.doc.nodeSize - 2, (node, pos) => {\n    if (\n      node.type.name === \"blockContainer\" &&\n      node.firstChild!.type.name === \"numberedListItem\"\n    ) {\n      const { index, isFirst, hasStart } = calculateListItemIndex(\n        node,\n        pos,\n        tr,\n        map,\n      );\n\n      // Check if decoration already exists with the same properties (for perf reasons)\n      const existingDecorations = nextDecorationSet.find(\n        pos,\n        pos + node.nodeSize,\n        (deco: DecoSpec) =>\n          deco.index === index &&\n          deco.isFirst === isFirst &&\n          deco.hasStart === hasStart,\n      );\n\n      if (existingDecorations.length === 0) {\n        // Create a widget decoration to display the index\n        decorationsToAdd.push(\n          // move in by 1 to account for the block container\n          Decoration.node(pos + 1, pos + node.nodeSize - 1, {\n            \"data-index\": index.toString(),\n          }),\n        );\n      }\n    }\n  });\n\n  // Remove any decorations that exist at the same position, they will be replaced by the new decorations\n  const decorationsToRemove = decorationsToAdd.flatMap((deco) =>\n    nextDecorationSet.find(deco.from, deco.to),\n  );\n\n  return {\n    decorations: nextDecorationSet\n      // Remove existing decorations that are going to be replaced\n      .remove(decorationsToRemove)\n      // Add any new decorations\n      .add(tr.doc, decorationsToAdd),\n  };\n}\n\n/**\n * This plugin adds decorations to numbered list items to display their index.\n */\nexport const NumberedListIndexingDecorationPlugin = () => {\n  return new Plugin<{ decorations: DecorationSet }>({\n    key: new PluginKey(\"numbered-list-indexing-decorations\"),\n\n    state: {\n      init(_config, state) {\n        // We create an empty transaction to get the decorations for the initial state based on the initial content\n        return getDecorations(state.tr, {\n          decorations: DecorationSet.empty,\n        });\n      },\n      apply(tr, previousPluginState) {\n        if (\n          !tr.docChanged &&\n          !tr.selectionSet &&\n          previousPluginState.decorations\n        ) {\n          // Just reuse the existing decorations, since nothing should have changed\n          return previousPluginState;\n        }\n        return getDecorations(tr, previousPluginState);\n      },\n    },\n\n    props: {\n      decorations(state) {\n        return this.getState(state)?.decorations ?? DecorationSet.empty;\n      },\n    },\n  });\n};\n","import { getBlockInfoFromSelection } from \"../../../api/getBlockInfoFromPos.js\";\nimport { createBlockNoteExtension } from \"../../../editor/BlockNoteExtension.js\";\nimport { createBlockConfig, createBlockSpec } from \"../../../schema/index.js\";\nimport {\n  addDefaultPropsExternalHTML,\n  defaultProps,\n  parseDefaultProps,\n} from \"../../defaultProps.js\";\nimport { handleEnter } from \"../../utils/listItemEnterHandler.js\";\nimport { getListItemContent } from \"../getListItemContent.js\";\nimport { NumberedListIndexingDecorationPlugin } from \"./IndexingPlugin.js\";\n\nexport type NumberedListItemBlockConfig = ReturnType<\n  typeof createNumberedListItemBlockConfig\n>;\n\nexport const createNumberedListItemBlockConfig = createBlockConfig(\n  () =>\n    ({\n      type: \"numberedListItem\" as const,\n      propSchema: {\n        ...defaultProps,\n        start: { default: undefined, type: \"number\" } as const,\n      },\n      content: \"inline\",\n    }) as const,\n);\n\nexport const createNumberedListItemBlockSpec = createBlockSpec(\n  createNumberedListItemBlockConfig,\n  {\n    meta: {\n      isolating: false,\n    },\n    parse(element) {\n      if (element.tagName !== \"LI\") {\n        return undefined;\n      }\n\n      const parent = element.parentElement;\n\n      if (parent === null) {\n        return undefined;\n      }\n\n      if (\n        parent.tagName === \"OL\" ||\n        (parent.tagName === \"DIV\" && parent.parentElement?.tagName === \"OL\")\n      ) {\n        const startIndex = parseInt(parent.getAttribute(\"start\") || \"1\");\n\n        const defaultProps = parseDefaultProps(element);\n\n        if (element.previousElementSibling || startIndex === 1) {\n          return defaultProps;\n        }\n\n        return {\n          ...defaultProps,\n          start: startIndex,\n        };\n      }\n\n      return undefined;\n    },\n    // As `li` elements can contain multiple paragraphs, we need to merge their contents\n    // into a single one so that ProseMirror can parse everything correctly.\n    parseContent: ({ el, schema }) =>\n      getListItemContent(el, schema, \"numberedListItem\"),\n    render() {\n      // We use a <p> tag, because for <li> tags we'd need a <ul> element to put\n      // them in to be semantically correct, which we can't have due to the\n      // schema.\n      const dom = document.createElement(\"p\");\n\n      return {\n        dom,\n        contentDOM: dom,\n      };\n    },\n    toExternalHTML(block) {\n      const li = document.createElement(\"li\");\n      const p = document.createElement(\"p\");\n      addDefaultPropsExternalHTML(block.props, li);\n      li.appendChild(p);\n\n      return {\n        dom: li,\n        contentDOM: p,\n      };\n    },\n  },\n  [\n    createBlockNoteExtension({\n      key: \"numbered-list-item-shortcuts\",\n      inputRules: [\n        {\n          find: new RegExp(`^(\\\\d+)\\\\.\\\\s$`),\n          replace({ match, editor }) {\n            const blockInfo = getBlockInfoFromSelection(\n              editor.prosemirrorState,\n            );\n\n            if (blockInfo.blockNoteType === \"heading\") {\n              return;\n            }\n            const start = parseInt(match[1]);\n            return {\n              type: \"numberedListItem\",\n              props: {\n                start: start !== 1 ? start : undefined,\n              },\n            };\n          },\n        },\n      ],\n      keyboardShortcuts: {\n        Enter: ({ editor }) => {\n          return handleEnter(editor, \"numberedListItem\");\n        },\n        \"Mod-Shift-7\": ({ editor }) => {\n          const cursorPosition = editor.getTextCursorPosition();\n\n          if (\n            editor.schema.blockSchema[cursorPosition.block.type].content !==\n            \"inline\"\n          ) {\n            return false;\n          }\n\n          editor.updateBlock(cursorPosition.block, {\n            type: \"numberedListItem\",\n            props: {},\n          });\n          return true;\n        },\n      },\n      plugins: [NumberedListIndexingDecorationPlugin()],\n    }),\n  ],\n);\n","import { createBlockNoteExtension } from \"../../../editor/BlockNoteExtension.js\";\nimport { createBlockConfig, createBlockSpec } from \"../../../schema/index.js\";\nimport {\n  addDefaultPropsExternalHTML,\n  defaultProps,\n} from \"../../defaultProps.js\";\nimport { createToggleWrapper } from \"../../ToggleWrapper/createToggleWrapper.js\";\nimport { handleEnter } from \"../../utils/listItemEnterHandler.js\";\n\nexport type ToggleListItemBlockConfig = ReturnType<\n  typeof createToggleListItemBlockConfig\n>;\n\nexport const createToggleListItemBlockConfig = createBlockConfig(\n  () =>\n    ({\n      type: \"toggleListItem\" as const,\n      propSchema: {\n        ...defaultProps,\n      },\n      content: \"inline\" as const,\n    }) as const,\n);\n\nexport const createToggleListItemBlockSpec = createBlockSpec(\n  createToggleListItemBlockConfig,\n  {\n    meta: {\n      isolating: false,\n    },\n    render(block, editor) {\n      const paragraphEl = document.createElement(\"p\");\n      const toggleWrapper = createToggleWrapper(\n        block as any,\n        editor,\n        paragraphEl,\n      );\n      return { ...toggleWrapper, contentDOM: paragraphEl };\n    },\n    toExternalHTML(block) {\n      const li = document.createElement(\"li\");\n      const p = document.createElement(\"p\");\n      addDefaultPropsExternalHTML(block.props, li);\n      li.appendChild(p);\n\n      return {\n        dom: li,\n        contentDOM: p,\n      };\n    },\n  },\n  [\n    createBlockNoteExtension({\n      key: \"toggle-list-item-shortcuts\",\n      keyboardShortcuts: {\n        Enter: ({ editor }) => {\n          return handleEnter(editor, \"toggleListItem\");\n        },\n        \"Mod-Shift-6\": ({ editor }) => {\n          const cursorPosition = editor.getTextCursorPosition();\n\n          if (\n            editor.schema.blockSchema[cursorPosition.block.type].content !==\n            \"inline\"\n          ) {\n            return false;\n          }\n\n          editor.updateBlock(cursorPosition.block, {\n            type: \"toggleListItem\",\n            props: {},\n          });\n          return true;\n        },\n      },\n    }),\n  ],\n);\n","import {\n  BlockSchema,\n  createBlockConfig,\n  createBlockSpec,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\nimport { BlockNoteSchema } from \"../BlockNoteSchema.js\";\n\nexport type PageBreakBlockConfig = ReturnType<\n  typeof createPageBreakBlockConfig\n>;\n\nexport const createPageBreakBlockConfig = createBlockConfig(\n  () =>\n    ({\n      type: \"pageBreak\" as const,\n      propSchema: {},\n      content: \"none\",\n    }) as const,\n);\n\nexport const createPageBreakBlockSpec = createBlockSpec(\n  createPageBreakBlockConfig,\n  {\n    parse(element) {\n      if (\n        element.tagName === \"DIV\" &&\n        element.hasAttribute(\"data-page-break\")\n      ) {\n        return {};\n      }\n\n      return undefined;\n    },\n    render() {\n      const pageBreak = document.createElement(\"div\");\n\n      pageBreak.setAttribute(\"data-page-break\", \"\");\n\n      return {\n        dom: pageBreak,\n      };\n    },\n    toExternalHTML() {\n      const pageBreak = document.createElement(\"div\");\n\n      pageBreak.setAttribute(\"data-page-break\", \"\");\n\n      return {\n        dom: pageBreak,\n      };\n    },\n  },\n);\n\n/**\n * Adds page break support to the given schema.\n */\nexport const withPageBreak = <\n  B extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  schema: BlockNoteSchema<B, I, S>,\n) => {\n  return schema.extend({\n    blockSpecs: {\n      pageBreak: createPageBreakBlockSpec(),\n    },\n  });\n};\n","import { createBlockNoteExtension } from \"../../editor/BlockNoteExtension.js\";\nimport { createBlockConfig, createBlockSpec } from \"../../schema/index.js\";\nimport {\n  addDefaultPropsExternalHTML,\n  defaultProps,\n  parseDefaultProps,\n} from \"../defaultProps.js\";\n\nexport type ParagraphBlockConfig = ReturnType<\n  typeof createParagraphBlockConfig\n>;\n\nexport const createParagraphBlockConfig = createBlockConfig(\n  () =>\n    ({\n      type: \"paragraph\" as const,\n      propSchema: defaultProps,\n      content: \"inline\" as const,\n    }) as const,\n);\n\nexport const createParagraphBlockSpec = createBlockSpec(\n  createParagraphBlockConfig,\n  {\n    meta: {\n      isolating: false,\n    },\n    parse: (e) => {\n      if (e.tagName !== \"P\") {\n        return undefined;\n      }\n\n      // Edge case for things like images directly inside paragraph.\n      if (!e.textContent?.trim()) {\n        return undefined;\n      }\n\n      return parseDefaultProps(e);\n    },\n    render: () => {\n      const dom = document.createElement(\"p\");\n      return {\n        dom,\n        contentDOM: dom,\n      };\n    },\n    toExternalHTML: (block) => {\n      const dom = document.createElement(\"p\");\n      addDefaultPropsExternalHTML(block.props, dom);\n      return {\n        dom,\n        contentDOM: dom,\n      };\n    },\n    runsBefore: [\"default\"],\n  },\n  [\n    createBlockNoteExtension({\n      key: \"paragraph-shortcuts\",\n      keyboardShortcuts: {\n        \"Mod-Alt-0\": ({ editor }) => {\n          const cursorPosition = editor.getTextCursorPosition();\n\n          if (\n            editor.schema.blockSchema[cursorPosition.block.type].content !==\n            \"inline\"\n          ) {\n            return false;\n          }\n\n          editor.updateBlock(cursorPosition.block, {\n            type: \"paragraph\",\n            props: {},\n          });\n          return true;\n        },\n      },\n    }),\n  ],\n);\n","import { createBlockNoteExtension } from \"../../editor/BlockNoteExtension.js\";\nimport { createBlockConfig, createBlockSpec } from \"../../schema/index.js\";\nimport {\n  addDefaultPropsExternalHTML,\n  defaultProps,\n  parseDefaultProps,\n} from \"../defaultProps.js\";\n\nexport type QuoteBlockConfig = ReturnType<typeof createQuoteBlockConfig>;\n\nexport const createQuoteBlockConfig = createBlockConfig(\n  () =>\n    ({\n      type: \"quote\" as const,\n      propSchema: {\n        backgroundColor: defaultProps.backgroundColor,\n        textColor: defaultProps.textColor,\n      },\n      content: \"inline\" as const,\n    }) as const,\n);\n\nexport const createQuoteBlockSpec = createBlockSpec(\n  createQuoteBlockConfig,\n  {\n    meta: {\n      isolating: false,\n    },\n    parse(element) {\n      if (element.tagName === \"BLOCKQUOTE\") {\n        const { backgroundColor, textColor } = parseDefaultProps(element);\n\n        return { backgroundColor, textColor };\n      }\n\n      return undefined;\n    },\n    render() {\n      const quote = document.createElement(\"blockquote\");\n\n      return {\n        dom: quote,\n        contentDOM: quote,\n      };\n    },\n    toExternalHTML(block) {\n      const quote = document.createElement(\"blockquote\");\n      addDefaultPropsExternalHTML(block.props, quote);\n\n      return {\n        dom: quote,\n        contentDOM: quote,\n      };\n    },\n  },\n  [\n    createBlockNoteExtension({\n      key: \"quote-block-shortcuts\",\n      keyboardShortcuts: {\n        \"Mod-Alt-q\": ({ editor }) => {\n          const cursorPosition = editor.getTextCursorPosition();\n\n          if (\n            editor.schema.blockSchema[cursorPosition.block.type].content !==\n            \"inline\"\n          ) {\n            return false;\n          }\n\n          editor.updateBlock(cursorPosition.block, {\n            type: \"quote\",\n            props: {},\n          });\n          return true;\n        },\n      },\n      inputRules: [\n        {\n          find: new RegExp(`^>\\\\s$`),\n          replace() {\n            return {\n              type: \"quote\",\n              props: {},\n            };\n          },\n        },\n      ],\n    }),\n  ],\n);\n","import { callOrReturn, Extension, getExtensionField } from \"@tiptap/core\";\nimport { columnResizing, goToNextCell, tableEditing } from \"prosemirror-tables\";\n\nexport const RESIZE_MIN_WIDTH = 35;\nexport const EMPTY_CELL_WIDTH = 120;\nexport const EMPTY_CELL_HEIGHT = 31;\n\nexport const TableExtension = Extension.create({\n  name: \"BlockNoteTableExtension\",\n\n  addProseMirrorPlugins: () => {\n    return [\n      columnResizing({\n        cellMinWidth: RESIZE_MIN_WIDTH,\n        defaultCellMinWidth: EMPTY_CELL_WIDTH,\n        // We set this to null as we implement our own node view in the table\n        // block content. This node view is the same as what's used by default,\n        // but is wrapped in a `blockContent` HTML element.\n        View: null,\n      }),\n      tableEditing(),\n    ];\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      // Makes enter create a new line within the cell.\n      Enter: () => {\n        if (\n          this.editor.state.selection.empty &&\n          this.editor.state.selection.$head.parent.type.name ===\n            \"tableParagraph\"\n        ) {\n          this.editor.commands.insertContent({ type: \"hardBreak\" });\n\n          return true;\n        }\n\n        return false;\n      },\n      // Ensures that backspace won't delete the table if the text cursor is at\n      // the start of a cell and the selection is empty.\n      Backspace: () => {\n        const selection = this.editor.state.selection;\n        const selectionIsEmpty = selection.empty;\n        const selectionIsAtStartOfNode = selection.$head.parentOffset === 0;\n        const selectionIsInTableParagraphNode =\n          selection.$head.node().type.name === \"tableParagraph\";\n\n        return (\n          selectionIsEmpty &&\n          selectionIsAtStartOfNode &&\n          selectionIsInTableParagraphNode\n        );\n      },\n      // Enables navigating cells using the tab key.\n      Tab: () => {\n        return this.editor.commands.command(({ state, dispatch, view }) =>\n          goToNextCell(1)(state, dispatch, view),\n        );\n      },\n      \"Shift-Tab\": () => {\n        return this.editor.commands.command(({ state, dispatch, view }) =>\n          goToNextCell(-1)(state, dispatch, view),\n        );\n      },\n    };\n  },\n\n  extendNodeSchema(extension) {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n    };\n\n    return {\n      tableRole: callOrReturn(\n        getExtensionField(extension, \"tableRole\", context),\n      ),\n    };\n  },\n});\n","import { Node, mergeAttributes } from \"@tiptap/core\";\nimport { DOMParser, Fragment, Node as PMNode, Schema } from \"prosemirror-model\";\nimport { CellSelection, TableView } from \"prosemirror-tables\";\nimport { NodeView } from \"prosemirror-view\";\nimport { createBlockNoteExtension } from \"../../editor/BlockNoteExtension.js\";\nimport {\n  BlockConfig,\n  createBlockSpecFromTiptapNode,\n  TableContent,\n} from \"../../schema/index.js\";\nimport { mergeCSSClasses } from \"../../util/browser.js\";\nimport { createDefaultBlockDOMOutputSpec } from \"../defaultBlockHelpers.js\";\nimport { defaultProps } from \"../defaultProps.js\";\nimport { EMPTY_CELL_WIDTH, TableExtension } from \"./TableExtension.js\";\n\nexport const tablePropSchema = {\n  textColor: defaultProps.textColor,\n};\n\nconst TiptapTableHeader = Node.create<{\n  HTMLAttributes: Record<string, any>;\n}>({\n  name: \"tableHeader\",\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    };\n  },\n\n  /**\n   * We allow table headers and cells to have multiple tableContent nodes because\n   * when merging cells, prosemirror-tables will concat the contents of the cells naively.\n   * This would cause that content to overflow into other cells when prosemirror tries to enforce the cell structure.\n   *\n   * So, we manually fix this up when reading back in the `nodeToBlock` and only ever place a single tableContent back into the cell.\n   */\n  content: \"tableContent+\",\n\n  addAttributes() {\n    return {\n      colspan: {\n        default: 1,\n      },\n      rowspan: {\n        default: 1,\n      },\n      colwidth: {\n        default: null,\n        parseHTML: (element) => {\n          const colwidth = element.getAttribute(\"colwidth\");\n          const value = colwidth\n            ? colwidth.split(\",\").map((width) => parseInt(width, 10))\n            : null;\n\n          return value;\n        },\n      },\n    };\n  },\n\n  tableRole: \"header_cell\",\n\n  isolating: true,\n\n  parseHTML() {\n    return [\n      {\n        tag: \"th\",\n        // As `th` elements can contain multiple paragraphs, we need to merge their contents\n        // into a single one so that ProseMirror can parse everything correctly.\n        getContent: (node, schema) =>\n          parseTableContent(node as HTMLElement, schema),\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\n      \"th\",\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n      0,\n    ];\n  },\n});\n\nconst TiptapTableCell = Node.create<{\n  HTMLAttributes: Record<string, any>;\n}>({\n  name: \"tableCell\",\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    };\n  },\n\n  content: \"tableContent+\",\n\n  addAttributes() {\n    return {\n      colspan: {\n        default: 1,\n      },\n      rowspan: {\n        default: 1,\n      },\n      colwidth: {\n        default: null,\n        parseHTML: (element) => {\n          const colwidth = element.getAttribute(\"colwidth\");\n          const value = colwidth\n            ? colwidth.split(\",\").map((width) => parseInt(width, 10))\n            : null;\n\n          return value;\n        },\n      },\n    };\n  },\n\n  tableRole: \"cell\",\n\n  isolating: true,\n\n  parseHTML() {\n    return [\n      {\n        tag: \"td\",\n        // As `td` elements can contain multiple paragraphs, we need to merge their contents\n        // into a single one so that ProseMirror can parse everything correctly.\n        getContent: (node, schema) =>\n          parseTableContent(node as HTMLElement, schema),\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\n      \"td\",\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n      0,\n    ];\n  },\n});\n\nconst TiptapTableNode = Node.create({\n  name: \"table\",\n  content: \"tableRow+\",\n  group: \"blockContent\",\n  tableRole: \"table\",\n\n  marks: \"deletion insertion modification\",\n  isolating: true,\n\n  parseHTML() {\n    return [\n      {\n        tag: \"table\",\n      },\n    ];\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    const domOutputSpec = createDefaultBlockDOMOutputSpec(\n      this.name,\n      \"table\",\n      {\n        ...(this.options.domAttributes?.blockContent || {}),\n        ...HTMLAttributes,\n      },\n      this.options.domAttributes?.inlineContent || {},\n    );\n\n    // Need to manually add colgroup element\n    const colGroup = document.createElement(\"colgroup\");\n    for (const tableCell of node.children[0].children) {\n      const colWidths: null | (number | undefined)[] =\n        tableCell.attrs[\"colwidth\"];\n\n      if (colWidths) {\n        for (const colWidth of tableCell.attrs[\"colwidth\"]) {\n          const col = document.createElement(\"col\");\n          if (colWidth) {\n            col.style = `width: ${colWidth}px`;\n          }\n\n          colGroup.appendChild(col);\n        }\n      } else {\n        colGroup.appendChild(document.createElement(\"col\"));\n      }\n    }\n\n    domOutputSpec.dom.firstChild?.appendChild(colGroup);\n\n    return domOutputSpec;\n  },\n\n  // This node view is needed for the `columnResizing` plugin. By default, the\n  // plugin adds its own node view, which overrides how the node is rendered vs\n  // `renderHTML`. This means that the wrapping `blockContent` HTML element is\n  // no longer rendered. The `columnResizing` plugin uses the `TableView` as its\n  // default node view. `BlockNoteTableView` extends it by wrapping it in a\n  // `blockContent` element, so the DOM structure is consistent with other block\n  // types.\n  addNodeView() {\n    return ({ node, HTMLAttributes }) => {\n      class BlockNoteTableView extends TableView {\n        constructor(\n          public node: PMNode,\n          public cellMinWidth: number,\n          public blockContentHTMLAttributes: Record<string, string>,\n        ) {\n          super(node, cellMinWidth);\n\n          const blockContent = document.createElement(\"div\");\n          blockContent.className = mergeCSSClasses(\n            \"bn-block-content\",\n            blockContentHTMLAttributes.class,\n          );\n          blockContent.setAttribute(\"data-content-type\", \"table\");\n          for (const [attribute, value] of Object.entries(\n            blockContentHTMLAttributes,\n          )) {\n            if (attribute !== \"class\") {\n              blockContent.setAttribute(attribute, value);\n            }\n          }\n\n          const tableWrapper = this.dom;\n\n          const tableWrapperInner = document.createElement(\"div\");\n          tableWrapperInner.className = \"tableWrapper-inner\";\n          tableWrapperInner.appendChild(tableWrapper.firstChild!);\n\n          tableWrapper.appendChild(tableWrapperInner);\n\n          blockContent.appendChild(tableWrapper);\n          const floatingContainer = document.createElement(\"div\");\n          floatingContainer.className = \"table-widgets-container\";\n          floatingContainer.style.position = \"relative\";\n          tableWrapper.appendChild(floatingContainer);\n\n          this.dom = blockContent;\n        }\n\n        ignoreMutation(record: MutationRecord): boolean {\n          return (\n            !(record.target as HTMLElement).closest(\".tableWrapper-inner\") ||\n            super.ignoreMutation(record)\n          );\n        }\n      }\n\n      return new BlockNoteTableView(node, EMPTY_CELL_WIDTH, {\n        ...(this.options.domAttributes?.blockContent || {}),\n        ...HTMLAttributes,\n      }) as NodeView; // needs cast, tiptap types (wrongly) doesn't support return tableview here\n    };\n  },\n});\n\nconst TiptapTableParagraph = Node.create({\n  name: \"tableParagraph\",\n  group: \"tableContent\",\n  content: \"inline*\",\n\n  parseHTML() {\n    return [\n      {\n        tag: \"p\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\" || !element.textContent) {\n            return false;\n          }\n\n          // Only parse in internal HTML.\n          if (!element.closest(\"[data-content-type]\")) {\n            return false;\n          }\n\n          const parent = element.parentElement;\n\n          if (parent === null) {\n            return false;\n          }\n\n          if (parent.tagName === \"TD\" || parent.tagName === \"TH\") {\n            return {};\n          }\n\n          return false;\n        },\n        node: \"tableParagraph\",\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\"p\", HTMLAttributes, 0];\n  },\n});\n\n/**\n * This extension allows you to create table rows.\n * @see https://www.tiptap.dev/api/nodes/table-row\n */\nconst TiptapTableRow = Node.create<{\n  HTMLAttributes: Record<string, any>;\n}>({\n  name: \"tableRow\",\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    };\n  },\n\n  content: \"(tableCell | tableHeader)+\",\n\n  tableRole: \"row\",\n  marks: \"deletion insertion modification\",\n  parseHTML() {\n    return [{ tag: \"tr\" }];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\n      \"tr\",\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n      0,\n    ];\n  },\n});\n\n/*\n * This will flatten a node's content to fit into a table cell's paragraph.\n */\nfunction parseTableContent(node: HTMLElement, schema: Schema) {\n  const parser = DOMParser.fromSchema(schema);\n\n  // This will parse the content of the table paragraph as though it were a blockGroup.\n  // Resulting in a structure like:\n  // <blockGroup>\n  //   <blockContainer>\n  //     <p>Hello</p>\n  //   </blockContainer>\n  //   <blockContainer>\n  //     <p>Hello</p>\n  //   </blockContainer>\n  // </blockGroup>\n  const parsedContent = parser.parse(node, {\n    topNode: schema.nodes.blockGroup.create(),\n  });\n  const extractedContent: PMNode[] = [];\n\n  // Try to extract any content within the blockContainer.\n  parsedContent.content.descendants((child) => {\n    // As long as the child is an inline node, we can append it to the fragment.\n    if (child.isInline) {\n      // And append it to the fragment\n      extractedContent.push(child);\n      return false;\n    }\n\n    return undefined;\n  });\n\n  return Fragment.fromArray(extractedContent);\n}\n\nexport type TableBlockConfig = BlockConfig<\n  \"table\",\n  {\n    textColor: {\n      default: \"default\";\n    };\n  },\n  \"table\"\n>;\n\nexport const createTableBlockSpec = () =>\n  createBlockSpecFromTiptapNode(\n    { node: TiptapTableNode, type: \"table\", content: \"table\" },\n    tablePropSchema,\n    [\n      createBlockNoteExtension({\n        key: \"table-extensions\",\n        tiptapExtensions: [\n          TableExtension,\n          TiptapTableParagraph,\n          TiptapTableHeader,\n          TiptapTableCell,\n          TiptapTableRow,\n        ],\n      }),\n      // Extension for keyboard shortcut which deletes the table if it's empty\n      // and all cells are selected. Uses a separate extension as it needs\n      // priority over keyboard handlers in the `TableExtension`'s\n      // `tableEditing` plugin.\n      createBlockNoteExtension({\n        key: \"table-keyboard-delete\",\n        keyboardShortcuts: {\n          Backspace: ({ editor }) => {\n            if (!(editor.prosemirrorState.selection instanceof CellSelection)) {\n              return false;\n            }\n\n            const block = editor.getTextCursorPosition().block;\n            const content = block.content as TableContent<any, any>;\n\n            let numCells = 0;\n            for (const row of content.rows) {\n              for (const cell of row.cells) {\n                // Returns `false` if any cell isn't empty.\n                if (\n                  (\"type\" in cell && cell.content.length > 0) ||\n                  (!(\"type\" in cell) && cell.length > 0)\n                ) {\n                  return false;\n                }\n\n                numCells++;\n              }\n            }\n\n            // Need to use ProseMirror API to check number of selected cells.\n            let selectionNumCells = 0;\n            editor.prosemirrorState.selection.forEachCell(() => {\n              selectionNumCells++;\n            });\n\n            if (selectionNumCells < numCells) {\n              return false;\n            }\n\n            editor.transact(() => {\n              const selectionBlock =\n                editor.getPrevBlock(block) || editor.getNextBlock(block);\n              if (selectionBlock) {\n                editor.setTextCursorPosition(block);\n              }\n\n              editor.removeBlocks([block]);\n            });\n\n            return true;\n          },\n        },\n      }),\n    ],\n  );\n\n// We need to declare this here because we aren't using the table extensions from tiptap, so the types are not automatically inferred.\ndeclare module \"@tiptap/core\" {\n  interface NodeConfig {\n    tableRole?: string;\n  }\n}\n","export const parseVideoElement = (videoElement: HTMLVideoElement) => {\n  const url = videoElement.src || undefined;\n  const previewWidth = videoElement.width || undefined;\n\n  return { url, previewWidth };\n};\n","import { createBlockConfig, createBlockSpec } from \"../../schema/index.js\";\nimport { defaultProps, parseDefaultProps } from \"../defaultProps.js\";\nimport { parseFigureElement } from \"../File/helpers/parse/parseFigureElement.js\";\nimport { createResizableFileBlockWrapper } from \"../File/helpers/render/createResizableFileBlockWrapper.js\";\nimport { createFigureWithCaption } from \"../File/helpers/toExternalHTML/createFigureWithCaption.js\";\nimport { createLinkWithCaption } from \"../File/helpers/toExternalHTML/createLinkWithCaption.js\";\nimport { parseVideoElement } from \"./parseVideoElement.js\";\n\nexport const FILE_VIDEO_ICON_SVG =\n  '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\"><path d=\"M2 3.9934C2 3.44476 2.45531 3 2.9918 3H21.0082C21.556 3 22 3.44495 22 3.9934V20.0066C22 20.5552 21.5447 21 21.0082 21H2.9918C2.44405 21 2 20.5551 2 20.0066V3.9934ZM8 5V19H16V5H8ZM4 5V7H6V5H4ZM18 5V7H20V5H18ZM4 9V11H6V9H4ZM18 9V11H20V9H18ZM4 13V15H6V13H4ZM18 13V15H20V13H18ZM4 17V19H6V17H4ZM18 17V19H20V17H18Z\"></path></svg>';\n\nexport interface VideoOptions {\n  icon?: string;\n}\n\nexport type VideoBlockConfig = ReturnType<typeof createVideoBlockConfig>;\n\nexport const createVideoBlockConfig = createBlockConfig(\n  (_ctx: VideoOptions) => ({\n    type: \"video\" as const,\n    propSchema: {\n      textAlignment: defaultProps.textAlignment,\n      backgroundColor: defaultProps.backgroundColor,\n      name: { default: \"\" as const },\n      url: { default: \"\" as const },\n      caption: { default: \"\" as const },\n      showPreview: { default: true },\n      previewWidth: { default: undefined, type: \"number\" as const },\n    },\n    content: \"none\" as const,\n  }),\n);\n\nexport const videoParse = (_config: VideoOptions) => (element: HTMLElement) => {\n  if (element.tagName === \"VIDEO\") {\n    // Ignore if parent figure has already been parsed.\n    if (element.closest(\"figure\")) {\n      return undefined;\n    }\n\n    const { backgroundColor } = parseDefaultProps(element);\n\n    return {\n      ...parseVideoElement(element as HTMLVideoElement),\n      backgroundColor,\n    };\n  }\n\n  if (element.tagName === \"FIGURE\") {\n    const parsedFigure = parseFigureElement(element, \"video\");\n    if (!parsedFigure) {\n      return undefined;\n    }\n\n    const { targetElement, caption } = parsedFigure;\n\n    const { backgroundColor } = parseDefaultProps(element);\n\n    return {\n      ...parseVideoElement(targetElement as HTMLVideoElement),\n      backgroundColor,\n      caption,\n    };\n  }\n\n  return undefined;\n};\n\nexport const createVideoBlockSpec = createBlockSpec(\n  createVideoBlockConfig,\n  (config) => ({\n    meta: {\n      fileBlockAccept: [\"video/*\"],\n    },\n    parse: videoParse(config),\n    render(block, editor) {\n      const icon = document.createElement(\"div\");\n      icon.innerHTML = config.icon ?? FILE_VIDEO_ICON_SVG;\n\n      const videoWrapper = document.createElement(\"div\");\n      videoWrapper.className = \"bn-visual-media-wrapper\";\n\n      const video = document.createElement(\"video\");\n      video.className = \"bn-visual-media\";\n      if (editor.resolveFileUrl) {\n        editor.resolveFileUrl(block.props.url).then((downloadUrl) => {\n          video.src = downloadUrl;\n        });\n      } else {\n        video.src = block.props.url;\n      }\n      video.controls = true;\n      video.contentEditable = \"false\";\n      video.draggable = false;\n      video.width = block.props.previewWidth;\n      videoWrapper.appendChild(video);\n\n      return createResizableFileBlockWrapper(\n        block,\n        editor,\n        { dom: videoWrapper },\n        videoWrapper,\n        icon.firstElementChild as HTMLElement,\n      );\n    },\n    toExternalHTML(block) {\n      if (!block.props.url) {\n        const div = document.createElement(\"p\");\n        div.textContent = \"Add video\";\n\n        return {\n          dom: div,\n        };\n      }\n\n      let video;\n      if (block.props.showPreview) {\n        video = document.createElement(\"video\");\n        video.src = block.props.url;\n        if (block.props.previewWidth) {\n          video.width = block.props.previewWidth;\n        }\n      } else {\n        video = document.createElement(\"a\");\n        video.href = block.props.url;\n        video.textContent = block.props.name || block.props.url;\n      }\n\n      if (block.props.caption) {\n        if (block.props.showPreview) {\n          return createFigureWithCaption(video, block.props.caption);\n        } else {\n          return createLinkWithCaption(video, block.props.caption);\n        }\n      }\n\n      return {\n        dom: video,\n      };\n    },\n    runsBefore: [\"file\"],\n  }),\n);\n","/**\n * Uploads a file to tmpfiles.org and returns the URL to the uploaded file.\n *\n * @warning This function should only be used for development purposes, replace with your own backend!\n */\nexport const uploadToTmpFilesDotOrg_DEV_ONLY = async (\n  file: File,\n): Promise<string> => {\n  const body = new FormData();\n  body.append(\"file\", file);\n\n  const ret = await fetch(\"https://tmpfiles.org/api/v1/upload\", {\n    method: \"POST\",\n    body: body,\n  });\n  return (await ret.json()).data.url.replace(\n    \"tmpfiles.org/\",\n    \"tmpfiles.org/dl/\",\n  );\n};\n","import { CellSelection } from \"prosemirror-tables\";\nimport type { BlockNoteEditor } from \"../editor/BlockNoteEditor.js\";\nimport { BlockConfig, PropSchema, PropSpec } from \"../schema/index.js\";\nimport { Block } from \"./defaultBlocks.js\";\nimport { Selection } from \"prosemirror-state\";\n\nexport function editorHasBlockWithType<\n  BType extends string,\n  Props extends\n    | PropSchema\n    | Record<string, \"boolean\" | \"number\" | \"string\">\n    | undefined = undefined,\n>(\n  editor: BlockNoteEditor<any, any, any>,\n  blockType: BType,\n  props?: Props,\n): editor is BlockNoteEditor<\n  {\n    [BT in BType]: Props extends PropSchema\n      ? BlockConfig<BT, Props>\n      : Props extends Record<string, \"boolean\" | \"number\" | \"string\">\n        ? BlockConfig<\n            BT,\n            {\n              [PN in keyof Props]: {\n                default: undefined;\n                type: Props[PN];\n                values?: any[];\n              };\n            }\n          >\n        : BlockConfig<BT, PropSchema>;\n  },\n  any,\n  any\n> {\n  if (!(blockType in editor.schema.blockSpecs)) {\n    return false;\n  }\n\n  if (!props) {\n    return true;\n  }\n\n  for (const [propName, propSpec] of Object.entries(props)) {\n    if (!(propName in editor.schema.blockSpecs[blockType].config.propSchema)) {\n      return false;\n    }\n\n    if (typeof propSpec === \"string\") {\n      if (\n        editor.schema.blockSpecs[blockType].config.propSchema[propName]\n          .default &&\n        typeof editor.schema.blockSpecs[blockType].config.propSchema[propName]\n          .default !== propSpec\n      ) {\n        return false;\n      }\n\n      if (\n        editor.schema.blockSpecs[blockType].config.propSchema[propName].type &&\n        editor.schema.blockSpecs[blockType].config.propSchema[propName].type !==\n          propSpec\n      ) {\n        return false;\n      }\n    } else {\n      if (\n        editor.schema.blockSpecs[blockType].config.propSchema[propName]\n          .default !== propSpec.default\n      ) {\n        return false;\n      }\n\n      if (\n        editor.schema.blockSpecs[blockType].config.propSchema[propName]\n          .default === undefined &&\n        propSpec.default === undefined\n      ) {\n        if (\n          editor.schema.blockSpecs[blockType].config.propSchema[propName]\n            .type !== propSpec.type\n        ) {\n          return false;\n        }\n      }\n\n      if (\n        typeof editor.schema.blockSpecs[blockType].config.propSchema[propName]\n          .values !== typeof propSpec.values\n      ) {\n        return false;\n      }\n\n      if (\n        typeof editor.schema.blockSpecs[blockType].config.propSchema[propName]\n          .values === \"object\" &&\n        typeof propSpec.values === \"object\"\n      ) {\n        if (\n          editor.schema.blockSpecs[blockType].config.propSchema[propName].values\n            .length !== propSpec.values.length\n        ) {\n          return false;\n        }\n\n        for (\n          let i = 0;\n          i <\n          editor.schema.blockSpecs[blockType].config.propSchema[propName].values\n            .length;\n          i++\n        ) {\n          if (\n            editor.schema.blockSpecs[blockType].config.propSchema[propName]\n              .values[i] !== propSpec.values[i]\n          ) {\n            return false;\n          }\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\nexport function blockHasType<\n  BType extends string,\n  Props extends\n    | PropSchema\n    | Record<string, \"boolean\" | \"number\" | \"string\">\n    | undefined = undefined,\n>(\n  block: Block<any, any, any>,\n  editor: BlockNoteEditor<any, any, any>,\n  blockType: BType,\n  props?: Props,\n): block is Block<\n  {\n    [BT in BType]: Props extends PropSchema\n      ? BlockConfig<BT, Props>\n      : Props extends Record<string, \"boolean\" | \"number\" | \"string\">\n        ? BlockConfig<\n            BT,\n            {\n              [PN in keyof Props]: PropSpec<\n                Props[PN] extends \"boolean\"\n                  ? boolean\n                  : Props[PN] extends \"number\"\n                    ? number\n                    : Props[PN] extends \"string\"\n                      ? string\n                      : never\n              >;\n            }\n          >\n        : BlockConfig<BT, PropSchema>;\n  },\n  any,\n  any\n> {\n  return (\n    editorHasBlockWithType(editor, blockType, props) && block.type === blockType\n  );\n}\n\nexport function isTableCellSelection(\n  selection: Selection,\n): selection is CellSelection {\n  return selection instanceof CellSelection;\n}\n","import { Block, PartialBlock } from \"../../blocks/defaultBlocks.js\";\nimport type { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\n\nimport { editorHasBlockWithType } from \"../../blocks/defaultBlockTypeGuards.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n  isStyledTextInlineContent,\n} from \"../../schema/index.js\";\nimport { formatKeyboardShortcut } from \"../../util/browser.js\";\nimport { DefaultSuggestionItem } from \"./DefaultSuggestionItem.js\";\n\n// Sets the editor's text cursor position to the next content editable block,\n// so either a block with inline content or a table. The last block is always a\n// paragraph, so this function won't try to set the cursor position past the\n// last block.\nfunction setSelectionToNextContentEditableBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(editor: BlockNoteEditor<BSchema, I, S>) {\n  let block: Block<BSchema, I, S> | undefined =\n    editor.getTextCursorPosition().block;\n  let contentType = editor.schema.blockSchema[block.type].content;\n\n  while (contentType === \"none\") {\n    block = editor.getTextCursorPosition().nextBlock;\n    if (block === undefined) {\n      return;\n    }\n    contentType = editor.schema.blockSchema[block.type].content as\n      | \"inline\"\n      | \"table\"\n      | \"none\";\n    editor.setTextCursorPosition(block, \"end\");\n  }\n}\n\n// Checks if the current block is empty or only contains a slash, and if so,\n// updates the current block instead of inserting a new one below. If the new\n// block doesn't contain editable content, the cursor is moved to the next block\n// that does.\nexport function insertOrUpdateBlock<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<BSchema, I, S>,\n  block: PartialBlock<BSchema, I, S>,\n): Block<BSchema, I, S> {\n  const currentBlock = editor.getTextCursorPosition().block;\n\n  if (currentBlock.content === undefined) {\n    throw new Error(\"Slash Menu open in a block that doesn't contain content.\");\n  }\n\n  let newBlock: Block<BSchema, I, S>;\n\n  if (\n    Array.isArray(currentBlock.content) &&\n    ((currentBlock.content.length === 1 &&\n      isStyledTextInlineContent(currentBlock.content[0]) &&\n      currentBlock.content[0].type === \"text\" &&\n      currentBlock.content[0].text === \"/\") ||\n      currentBlock.content.length === 0)\n  ) {\n    newBlock = editor.updateBlock(currentBlock, block);\n    // We make sure to reset the cursor position to the new block as calling\n    // `updateBlock` may move it out. This generally happens when the content\n    // changes, or the update makes the block multi-column.\n    editor.setTextCursorPosition(newBlock);\n  } else {\n    newBlock = editor.insertBlocks([block], currentBlock, \"after\")[0];\n    editor.setTextCursorPosition(editor.getTextCursorPosition().nextBlock!);\n  }\n\n  setSelectionToNextContentEditableBlock(editor);\n\n  return newBlock;\n}\n\nexport function getDefaultSlashMenuItems<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(editor: BlockNoteEditor<BSchema, I, S>) {\n  const items: DefaultSuggestionItem[] = [];\n\n  if (editorHasBlockWithType(editor, \"heading\", { level: \"number\" })) {\n    items.push(\n      {\n        onItemClick: () => {\n          insertOrUpdateBlock(editor, {\n            type: \"heading\",\n            props: { level: 1 },\n          });\n        },\n        badge: formatKeyboardShortcut(\"Mod-Alt-1\"),\n        key: \"heading\",\n        ...editor.dictionary.slash_menu.heading,\n      },\n      {\n        onItemClick: () => {\n          insertOrUpdateBlock(editor, {\n            type: \"heading\",\n            props: { level: 2 },\n          });\n        },\n        badge: formatKeyboardShortcut(\"Mod-Alt-2\"),\n        key: \"heading_2\",\n        ...editor.dictionary.slash_menu.heading_2,\n      },\n      {\n        onItemClick: () => {\n          insertOrUpdateBlock(editor, {\n            type: \"heading\",\n            props: { level: 3 },\n          });\n        },\n        badge: formatKeyboardShortcut(\"Mod-Alt-3\"),\n        key: \"heading_3\",\n        ...editor.dictionary.slash_menu.heading_3,\n      },\n    );\n  }\n\n  if (editorHasBlockWithType(editor, \"quote\")) {\n    items.push({\n      onItemClick: () => {\n        insertOrUpdateBlock(editor, {\n          type: \"quote\",\n        });\n      },\n      key: \"quote\",\n      ...editor.dictionary.slash_menu.quote,\n    });\n  }\n\n  if (editorHasBlockWithType(editor, \"toggleListItem\")) {\n    items.push({\n      onItemClick: () => {\n        insertOrUpdateBlock(editor, {\n          type: \"toggleListItem\",\n        });\n      },\n      badge: formatKeyboardShortcut(\"Mod-Shift-6\"),\n      key: \"toggle_list\",\n      ...editor.dictionary.slash_menu.toggle_list,\n    });\n  }\n\n  if (editorHasBlockWithType(editor, \"numberedListItem\")) {\n    items.push({\n      onItemClick: () => {\n        insertOrUpdateBlock(editor, {\n          type: \"numberedListItem\",\n        });\n      },\n      badge: formatKeyboardShortcut(\"Mod-Shift-7\"),\n      key: \"numbered_list\",\n      ...editor.dictionary.slash_menu.numbered_list,\n    });\n  }\n\n  if (editorHasBlockWithType(editor, \"bulletListItem\")) {\n    items.push({\n      onItemClick: () => {\n        insertOrUpdateBlock(editor, {\n          type: \"bulletListItem\",\n        });\n      },\n      badge: formatKeyboardShortcut(\"Mod-Shift-8\"),\n      key: \"bullet_list\",\n      ...editor.dictionary.slash_menu.bullet_list,\n    });\n  }\n\n  if (editorHasBlockWithType(editor, \"checkListItem\")) {\n    items.push({\n      onItemClick: () => {\n        insertOrUpdateBlock(editor, {\n          type: \"checkListItem\",\n        });\n      },\n      badge: formatKeyboardShortcut(\"Mod-Shift-9\"),\n      key: \"check_list\",\n      ...editor.dictionary.slash_menu.check_list,\n    });\n  }\n\n  if (editorHasBlockWithType(editor, \"paragraph\")) {\n    items.push({\n      onItemClick: () => {\n        insertOrUpdateBlock(editor, {\n          type: \"paragraph\",\n        });\n      },\n      badge: formatKeyboardShortcut(\"Mod-Alt-0\"),\n      key: \"paragraph\",\n      ...editor.dictionary.slash_menu.paragraph,\n    });\n  }\n\n  if (editorHasBlockWithType(editor, \"codeBlock\")) {\n    items.push({\n      onItemClick: () => {\n        insertOrUpdateBlock(editor, {\n          type: \"codeBlock\",\n        });\n      },\n      badge: formatKeyboardShortcut(\"Mod-Alt-c\"),\n      key: \"code_block\",\n      ...editor.dictionary.slash_menu.code_block,\n    });\n  }\n\n  if (editorHasBlockWithType(editor, \"divider\")) {\n    items.push({\n      onItemClick: () => {\n        insertOrUpdateBlock(editor, { type: \"divider\" });\n      },\n      key: \"divider\",\n      ...editor.dictionary.slash_menu.divider,\n    });\n  }\n\n  if (editorHasBlockWithType(editor, \"table\")) {\n    items.push({\n      onItemClick: () => {\n        insertOrUpdateBlock(editor, {\n          type: \"table\",\n          content: {\n            type: \"tableContent\",\n            rows: [\n              {\n                cells: [\"\", \"\", \"\"],\n              },\n              {\n                cells: [\"\", \"\", \"\"],\n              },\n            ],\n          } as any,\n        });\n      },\n      badge: undefined,\n      key: \"table\",\n      ...editor.dictionary.slash_menu.table,\n    });\n  }\n\n  if (editorHasBlockWithType(editor, \"image\", { url: \"string\" })) {\n    items.push({\n      onItemClick: () => {\n        const insertedBlock = insertOrUpdateBlock(editor, {\n          type: \"image\",\n        });\n\n        // Immediately open the file toolbar\n        editor.transact((tr) =>\n          tr.setMeta(editor.filePanel!.plugins[0], {\n            block: insertedBlock,\n          }),\n        );\n      },\n      key: \"image\",\n      ...editor.dictionary.slash_menu.image,\n    });\n  }\n\n  if (editorHasBlockWithType(editor, \"video\", { url: \"string\" })) {\n    items.push({\n      onItemClick: () => {\n        const insertedBlock = insertOrUpdateBlock(editor, {\n          type: \"video\",\n        });\n\n        // Immediately open the file toolbar\n        editor.transact((tr) =>\n          tr.setMeta(editor.filePanel!.plugins[0], {\n            block: insertedBlock,\n          }),\n        );\n      },\n      key: \"video\",\n      ...editor.dictionary.slash_menu.video,\n    });\n  }\n\n  if (editorHasBlockWithType(editor, \"audio\", { url: \"string\" })) {\n    items.push({\n      onItemClick: () => {\n        const insertedBlock = insertOrUpdateBlock(editor, {\n          type: \"audio\",\n        });\n\n        // Immediately open the file toolbar\n        editor.transact((tr) =>\n          tr.setMeta(editor.filePanel!.plugins[0], {\n            block: insertedBlock,\n          }),\n        );\n      },\n      key: \"audio\",\n      ...editor.dictionary.slash_menu.audio,\n    });\n  }\n\n  if (editorHasBlockWithType(editor, \"file\", { url: \"string\" })) {\n    items.push({\n      onItemClick: () => {\n        const insertedBlock = insertOrUpdateBlock(editor, {\n          type: \"file\",\n        });\n\n        // Immediately open the file toolbar\n        editor.transact((tr) =>\n          tr.setMeta(editor.filePanel!.plugins[0], {\n            block: insertedBlock,\n          }),\n        );\n      },\n      key: \"file\",\n      ...editor.dictionary.slash_menu.file,\n    });\n  }\n\n  if (\n    editorHasBlockWithType(editor, \"heading\", {\n      level: \"number\",\n      isToggleable: \"boolean\",\n    })\n  ) {\n    items.push(\n      {\n        onItemClick: () => {\n          insertOrUpdateBlock(editor, {\n            type: \"heading\",\n            props: { level: 1, isToggleable: true },\n          });\n        },\n        key: \"toggle_heading\",\n        ...editor.dictionary.slash_menu.toggle_heading,\n      },\n      {\n        onItemClick: () => {\n          insertOrUpdateBlock(editor, {\n            type: \"heading\",\n            props: { level: 2, isToggleable: true },\n          });\n        },\n\n        key: \"toggle_heading_2\",\n        ...editor.dictionary.slash_menu.toggle_heading_2,\n      },\n      {\n        onItemClick: () => {\n          insertOrUpdateBlock(editor, {\n            type: \"heading\",\n            props: { level: 3, isToggleable: true },\n          });\n        },\n        key: \"toggle_heading_3\",\n        ...editor.dictionary.slash_menu.toggle_heading_3,\n      },\n    );\n  }\n\n  if (editorHasBlockWithType(editor, \"heading\", { level: \"number\" })) {\n    (editor.schema.blockSchema.heading.propSchema.level.values || [])\n      .filter((level): level is 4 | 5 | 6 => level > 3)\n      .forEach((level) => {\n        items.push({\n          onItemClick: () => {\n            insertOrUpdateBlock(editor, {\n              type: \"heading\",\n              props: { level: level },\n            });\n          },\n          key: `heading_${level}`,\n          ...editor.dictionary.slash_menu[`heading_${level}`],\n        });\n      });\n  }\n\n  items.push({\n    onItemClick: () => {\n      editor.openSuggestionMenu(\":\", {\n        deleteTriggerCharacter: true,\n        ignoreQueryLength: true,\n      });\n    },\n    key: \"emoji\",\n    ...editor.dictionary.slash_menu.emoji,\n  });\n\n  return items;\n}\n\nexport function filterSuggestionItems<\n  T extends { title: string; aliases?: readonly string[] },\n>(items: T[], query: string) {\n  return items.filter(\n    ({ title, aliases }) =>\n      title.toLowerCase().includes(query.toLowerCase()) ||\n      (aliases &&\n        aliases.filter((alias) =>\n          alias.toLowerCase().includes(query.toLowerCase()),\n        ).length !== 0),\n  );\n}\n","import { BlockNoteEditor } from \"../../editor/BlockNoteEditor.js\";\nimport { DefaultSuggestionItem } from \"../../extensions/SuggestionMenu/DefaultSuggestionItem.js\";\nimport { insertOrUpdateBlock } from \"../../extensions/SuggestionMenu/getDefaultSlashMenuItems.js\";\nimport {\n  BlockSchema,\n  InlineContentSchema,\n  StyleSchema,\n} from \"../../schema/index.js\";\nimport { createPageBreakBlockConfig } from \"./block.js\";\n\nexport function checkPageBreakBlocksInSchema<\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(\n  editor: BlockNoteEditor<any, I, S>,\n): editor is BlockNoteEditor<\n  {\n    pageBreak: ReturnType<typeof createPageBreakBlockConfig>;\n  },\n  I,\n  S\n> {\n  return \"pageBreak\" in editor.schema.blockSchema;\n}\n\nexport function getPageBreakSlashMenuItems<\n  BSchema extends BlockSchema,\n  I extends InlineContentSchema,\n  S extends StyleSchema,\n>(editor: BlockNoteEditor<BSchema, I, S>) {\n  const items: (Omit<DefaultSuggestionItem, \"key\"> & { key: \"page_break\" })[] =\n    [];\n\n  if (checkPageBreakBlocksInSchema(editor)) {\n    items.push({\n      ...editor.dictionary.slash_menu.page_break,\n      onItemClick: () => {\n        insertOrUpdateBlock(editor, {\n          type: \"pageBreak\",\n        });\n      },\n      key: \"page_break\",\n    });\n  }\n\n  return items;\n}\n","import Bold from \"@tiptap/extension-bold\";\nimport Code from \"@tiptap/extension-code\";\nimport Italic from \"@tiptap/extension-italic\";\nimport Strike from \"@tiptap/extension-strike\";\nimport Underline from \"@tiptap/extension-underline\";\nimport { COLORS_DEFAULT } from \"../editor/defaultColors.js\";\nimport {\n  BlockNoDefaults,\n  BlockSchema,\n  InlineContentSchema,\n  InlineContentSpecs,\n  PartialBlockNoDefaults,\n  StyleSchema,\n  StyleSpecs,\n  createStyleSpec,\n  createStyleSpecFromTipTapMark,\n  getInlineContentSchemaFromSpecs,\n  getStyleSchemaFromSpecs,\n} from \"../schema/index.js\";\nimport {\n  createAudioBlockSpec,\n  createBulletListItemBlockSpec,\n  createCheckListItemBlockSpec,\n  createCodeBlockSpec,\n  createDividerBlockSpec,\n  createFileBlockSpec,\n  createHeadingBlockSpec,\n  createImageBlockSpec,\n  createNumberedListItemBlockSpec,\n  createParagraphBlockSpec,\n  createQuoteBlockSpec,\n  createToggleListItemBlockSpec,\n  createVideoBlockSpec,\n  defaultProps,\n} from \"./index.js\";\nimport { createTableBlockSpec } from \"./Table/block.js\";\n\nexport const defaultBlockSpecs = {\n  audio: createAudioBlockSpec(),\n  bulletListItem: createBulletListItemBlockSpec(),\n  checkListItem: createCheckListItemBlockSpec(),\n  codeBlock: createCodeBlockSpec(),\n  divider: createDividerBlockSpec(),\n  file: createFileBlockSpec(),\n  heading: createHeadingBlockSpec(),\n  image: createImageBlockSpec(),\n  numberedListItem: createNumberedListItemBlockSpec(),\n  paragraph: createParagraphBlockSpec(),\n  quote: createQuoteBlockSpec(),\n  table: createTableBlockSpec(),\n  toggleListItem: createToggleListItemBlockSpec(),\n  video: createVideoBlockSpec(),\n} as const;\n\n// underscore is used that in case a user overrides DefaultBlockSchema,\n// they can still access the original default block schema\nexport type _DefaultBlockSchema = {\n  [K in keyof typeof defaultBlockSpecs]: (typeof defaultBlockSpecs)[K][\"config\"];\n};\nexport type DefaultBlockSchema = _DefaultBlockSchema;\n\nconst TextColor = createStyleSpec(\n  {\n    type: \"textColor\",\n    propSchema: \"string\",\n  },\n  {\n    render: () => {\n      const span = document.createElement(\"span\");\n\n      return {\n        dom: span,\n        contentDOM: span,\n      };\n    },\n    toExternalHTML: (value) => {\n      const span = document.createElement(\"span\");\n      if (value !== defaultProps.textColor.default) {\n        span.style.color =\n          value in COLORS_DEFAULT ? COLORS_DEFAULT[value].text : value;\n      }\n\n      return {\n        dom: span,\n        contentDOM: span,\n      };\n    },\n    parse: (element) => {\n      if (element.tagName === \"SPAN\" && element.style.color) {\n        return element.style.color;\n      }\n\n      return undefined;\n    },\n  },\n);\n\nconst BackgroundColor = createStyleSpec(\n  {\n    type: \"backgroundColor\",\n    propSchema: \"string\",\n  },\n  {\n    render: () => {\n      const span = document.createElement(\"span\");\n\n      return {\n        dom: span,\n        contentDOM: span,\n      };\n    },\n    toExternalHTML: (value) => {\n      const span = document.createElement(\"span\");\n      if (value !== defaultProps.backgroundColor.default) {\n        span.style.backgroundColor =\n          value in COLORS_DEFAULT ? COLORS_DEFAULT[value].background : value;\n      }\n\n      return {\n        dom: span,\n        contentDOM: span,\n      };\n    },\n    parse: (element) => {\n      if (element.tagName === \"SPAN\" && element.style.backgroundColor) {\n        return element.style.backgroundColor;\n      }\n\n      return undefined;\n    },\n  },\n);\n\nexport const defaultStyleSpecs = {\n  bold: createStyleSpecFromTipTapMark(Bold, \"boolean\"),\n  italic: createStyleSpecFromTipTapMark(Italic, \"boolean\"),\n  underline: createStyleSpecFromTipTapMark(Underline, \"boolean\"),\n  strike: createStyleSpecFromTipTapMark(Strike, \"boolean\"),\n  code: createStyleSpecFromTipTapMark(Code, \"boolean\"),\n  textColor: TextColor,\n  backgroundColor: BackgroundColor,\n} satisfies StyleSpecs;\n\nexport const defaultStyleSchema = getStyleSchemaFromSpecs(defaultStyleSpecs);\n\n// underscore is used that in case a user overrides DefaultStyleSchema,\n// they can still access the original default style schema\nexport type _DefaultStyleSchema = typeof defaultStyleSchema;\nexport type DefaultStyleSchema = _DefaultStyleSchema;\n\nexport const defaultInlineContentSpecs = {\n  text: { config: \"text\", implementation: {} as any },\n  link: { config: \"link\", implementation: {} as any },\n} satisfies InlineContentSpecs;\n\nexport const defaultInlineContentSchema = getInlineContentSchemaFromSpecs(\n  defaultInlineContentSpecs,\n);\n\n// underscore is used that in case a user overrides DefaultInlineContentSchema,\n// they can still access the original default inline content schema\nexport type _DefaultInlineContentSchema = typeof defaultInlineContentSchema;\nexport type DefaultInlineContentSchema = _DefaultInlineContentSchema;\n\nexport type PartialBlock<\n  BSchema extends BlockSchema = DefaultBlockSchema,\n  I extends InlineContentSchema = DefaultInlineContentSchema,\n  S extends StyleSchema = DefaultStyleSchema,\n> = PartialBlockNoDefaults<BSchema, I, S>;\n\nexport type Block<\n  BSchema extends BlockSchema = DefaultBlockSchema,\n  I extends InlineContentSchema = DefaultInlineContentSchema,\n  S extends StyleSchema = DefaultStyleSchema,\n> = BlockNoDefaults<BSchema, I, S>;\n","import {\n  BlockSchema,\n  BlockSchemaFromSpecs,\n  BlockSpecs,\n  CustomBlockNoteSchema,\n  InlineContentSchema,\n  InlineContentSchemaFromSpecs,\n  InlineContentSpecs,\n  StyleSchema,\n  StyleSchemaFromSpecs,\n  StyleSpecs,\n} from \"../schema/index.js\";\nimport {\n  defaultBlockSpecs,\n  defaultInlineContentSpecs,\n  defaultStyleSpecs,\n} from \"./defaultBlocks.js\";\n\nexport class BlockNoteSchema<\n  BSchema extends BlockSchema,\n  ISchema extends InlineContentSchema,\n  SSchema extends StyleSchema,\n> extends CustomBlockNoteSchema<BSchema, ISchema, SSchema> {\n  public static create<\n    BSpecs extends BlockSpecs | undefined = undefined,\n    ISpecs extends InlineContentSpecs | undefined = undefined,\n    SSpecs extends StyleSpecs | undefined = undefined,\n  >(options?: {\n    /**\n     * A list of custom block types that should be available in the editor.\n     */\n    blockSpecs?: BSpecs;\n    /**\n     * A list of custom InlineContent types that should be available in the editor.\n     */\n    inlineContentSpecs?: ISpecs;\n    /**\n     * A list of custom Styles that should be available in the editor.\n     */\n    styleSpecs?: SSpecs;\n  }): BlockNoteSchema<\n    BSpecs extends undefined\n      ? BlockSchemaFromSpecs<typeof defaultBlockSpecs>\n      : BlockSchemaFromSpecs<NonNullable<BSpecs>>,\n    ISpecs extends undefined\n      ? InlineContentSchemaFromSpecs<typeof defaultInlineContentSpecs>\n      : InlineContentSchemaFromSpecs<NonNullable<ISpecs>>,\n    SSpecs extends undefined\n      ? StyleSchemaFromSpecs<typeof defaultStyleSpecs>\n      : StyleSchemaFromSpecs<NonNullable<SSpecs>>\n  > {\n    return new BlockNoteSchema<any, any, any>({\n      blockSpecs: options?.blockSpecs ?? defaultBlockSpecs,\n      inlineContentSpecs:\n        options?.inlineContentSpecs ?? defaultInlineContentSpecs,\n      styleSpecs: options?.styleSpecs ?? defaultStyleSpecs,\n    });\n  }\n}\n"],"names":["removeDuplicates","array","by","seen","item","key","findDuplicates","items","filtered","el","index","UniqueID","Extension","testOptions","v4","element","attributes","defaultIdAttributes","dragSourceElement","transformPasted","Plugin","PluginKey","transactions","oldState","newState","docChanges","transaction","filterTransactions","tr","_b","_a","types","attributeName","generateID","transform","combineTransactionSteps","mapping","getChangedRanges","newRange","newNodes","findChildrenInRange","node","newIds","id","duplicatedNewIds","pos","initialDoc","jsonNode","deleted","view","handleDragstart","event","slice","removeId","fragment","list","nodeWithoutId","Fragment","Slice","isLinkInlineContent","content","isPartialLinkInlineContent","isStyledTextInlineContent","mapTableCell","isTableCell","isPartialTableCell","_c","_d","_e","getColspan","cell","getRowspan","UnreachableCaseError","val","assertEmpty","obj","throwError","dataTest","rest","isAppleOS","formatKeyboardShortcut","shortcut","ctrlText","mergeCSSClasses","classes","c","isSafari","createDefaultBlockDOMOutputSpec","blockName","htmlTag","blockContentHTMLAttributes","inlineContentHTMLAttributes","blockContent","attribute","value","inlineContent","defaultBlockToHTML","block","editor","blockToNode","toDOM","renderSpec","mergeParagraphs","separator","paragraphs","firstParagraph","i","paragraph","camelToDataKebab","str","filenameFromURL","url","parts","isVideoUrl","videoExtensions","ext","propsToAttributes","propSchema","tiptapAttributes","name","spec","asNumber","getBlockFromPos","getPos","tipTapEditor","type","blockIdentifier","wrapInBlockStructure","blockType","blockProps","isFileBlock","domAttributes","attr","prop","defaultValue","createBlockSpecFromTiptapNode","config","extensions","applyNonSelectableBlockFix","nodeView","getParseRules","implementation","rules","props","schema","clone","DOMParser","addNodeAndExtensionsToSpec","blockConfig","blockImplementation","priority","Node","HTMLAttributes","div","blockContentDOMAttributes","createBlockConfig","callback","createBlockSpec","blockConfigOrCreator","blockImplementationOrCreator","extensionsOrCreator","options","output","getNearestBlockPos","doc","$pos","depth","allBlockContainerPositions","resolvedPos","position","getBlockInfoWithManualOffset","bnBlockBeforePosOffset","bnBlockNode","bnBlockBeforePos","bnBlockAfterPos","bnBlock","blockGroup","offset","blockContentNode","blockContentBeforePos","blockContentAfterPos","blockGroupNode","blockGroupBeforePos","blockGroupAfterPos","getBlockInfo","posInfo","getBlockInfoFromResolvedPos","getBlockInfoFromSelection","state","getBlockInfoFromTransaction","getPmSchema","trOrNode","getBlockNoteEditor","getBlockNoteSchema","getBlockSchema","getInlineContentSchema","getStyleSchema","getBlockCache","contentNodeToTableContent","contentNode","inlineContentSchema","styleSchema","ret","headerMatrix","rowNode","_offset","rowIndex","row","cellNode","colWidth","cellIndex","child","contentNodeToInlineContent","acc","contentPartial","last","first","isHeader","currentContent","nodeToCustomInlineContent","styles","linkMark","mark","icConfig","nodeToBlock","blockSchema","blockCache","cachedBlock","blockInfo","blockSpec","children","docToBlocks","blocks","prosemirrorSliceToSlicedBlocks","processNode","openStart","openEnd","blockCutAtStart","blockCutAtEnd","blockContainer","isFirstBlock","isLastBlock","childGroup","childBlocks","addInlineContentAttributes","inlineContentType","inlineContentProps","addInlineContentKeyboardShortcuts","createInternalInlineContentSpec","createInlineContentSpecFromTipTapNode","getInlineContentSchemaFromSpecs","specs","stylePropsToAttributes","addStyleAttributes","styleType","styleValue","createInternalStyleSpec","createStyleSpecFromTipTapMark","markInstance","DOMSerializer","getStyleSchemaFromSpecs","getStyleParseRules","customParseFunction","htmlElement","stringValue","createStyleSpec","styleConfig","styleImplementation","Mark","renderResult","toposort","dag","inDegrees","countInDegrees","roots","nonRoots","getRootsAndNonRoots","sorted","newRoots","root","dependents","dependent","currentDegree","newDegree","toposortReverse","deps","reverse","counts","vx","currentCount","deg","reversedDeps","dependsOn","dependsOnName","createDependencyGraph","removeUndefined","CustomBlockNoteSchema","opts","__publicField","blockSpecs","inlineContentSpecs","styleSpecs","defaultSet","specDef","sortedSpecs","defaultIndex","set","getPriority","blockDef","getTableCellOccupancyGrid","height","width","getDimensionsOfTable","grid","findNextAvailable","col","j","rowspan","colspan","startRow","startCol","getTableRowsFromOccupancyGrid","occupancyGrid","getAbsoluteTableCells","relativeCellIndices","r","rowWidth","getRelativeTableCells","absoluteCellIndices","occupancyCell","getCellsAtRowHandle","relativeRowIndex","absoluteRow","cells","_v","a","getCellsAtColumnHandle","relativeColumnIndex","absoluteCol","moveColumn","fromColIndex","toColIndex","absoluteSourceCol","absoluteTargetCol","sourceCell","moveRow","fromRowIndex","toRowIndex","absoluteSourceRow","absoluteTargetRow","sourceRow","isCellEmpty","s","cropEmptyRowsOrColumns","removeEmpty","emptyColsOnRight","cellsToRemove","emptyRowsOnBottom","rowsToRemove","addRowsOrColumns","addType","numToAdd","newRow","_","colIndex","canRowBeDraggedInto","draggingIndex","targetRowIndex","targetCells","endRowIndex","startRowIndex","canColumnBeDraggedInto","targetColumnIndex","endColumnIndex","startColumnIndex","areInSameColumn","from","to","anchorAbsoluteCellIndices","headAbsoluteCellIndices","styledTextToNodes","styledText","marks","style","text","linkToNodes","link","styledTextArrayToNodes","nodes","inlineContentToNodes","blockOrInlineContentToContentNode","tableContentToNodes","tableContent","rowNodes","headerRows","headerCols","columnWidths","columnNodes","isHeaderRow","isHeaderCol","attrs","absoluteCellIndex","colwidth","groupNode","getNodeById","targetNode","posBeforeNode","isNodeBlock","updateBlockCommand","posBeforeBlock","dispatch","updateBlockTr","replaceFromPos","replaceToPos","cellAnchor","captureCellAnchor","pmSchema","oldNodeType","newNodeType","newBnBlockNodeType","replaceFromOffset","replaceToOffset","updateChildren","updateBlockContentNode","existingBlock","restoreCellAnchor","start","end","contentDepth","startDepth","endDepth","childNodes","ReplaceStep","updateBlock","blockToUpdate","update","blockContainerNode","sel","TextSelection","$head","cellDepth","tableDepth","d","cellPos","tablePos","table","map","TableMap","rel","idx","textStart","relCellPos","textPos","textNode","max","head","COLORS_DEFAULT","COLORS_DARK_MODE_DEFAULT","defaultProps","parseDefaultProps","addDefaultPropsExternalHTML","getBackgroundColorAttribute","getTextColorAttribute","getTextAlignmentAttribute","parseFigureElement","figureElement","targetTag","targetElement","captionElement","caption","createAddFileButton","buttonIcon","addFileButton","addFileButtonIcon","addFileButtonText","addFileButtonMouseDownHandler","addFileButtonClickHandler","FILE_ICON_SVG","createFileNameWithIcon","file","icon","fileName","createFileBlockWrapper","wrapper","destroyUploadStartHandler","blockId","loading","fileNameWithIcon","createFigureWithCaption","figure","createLinkWithCaption","fileCaption","parseAudioElement","audioElement","FILE_AUDIO_ICON_SVG","createAudioBlockConfig","_ctx","audioParse","_config","backgroundColor","parsedFigure","audioRender","audio","downloadUrl","audioToExternalHTML","_editor","createAudioBlockSpec","EventEmitter","fn","args","callbacks","BlockNoteExtension","_args","plugin","createBlockNoteExtension","x","shikiParserSymbol","shikiHighlighterPromiseSymbol","lazyShikiPlugin","globalThisForShiki","highlighter","parser","hasWarned","lazyParser","parserOptions","createdHighlighter","language","getLanguageId","createParser","createHighlightPlugin","createCodeBlockConfig","defaultLanguage","createCodeBlockSpec","e","code","pre","removeSelectChangeListener","select","option","handleLanguageChange","selectWrapper","$from","nextBlock","isAtEnd","endsWithDoubleNewline","newBlock","match","languageName","aliases","createDividerBlockConfig","createDividerBlockSpec","parseEmbedElement","embedElement","createFileBlockConfig","fileParse","createFileBlockSpec","fileSrcLink","defaultToggledState","isToggled","createToggleWrapper","renderedElement","toggledState","dom","toggleWrapper","toggleButton","toggleButtonMouseDown","toggleButtonOnClick","toggleAddBlockButton","toggleAddBlockButtonMouseDown","toggleAddBlockButtonOnClick","updatedBlock","childCount","onEditorChange","newChildCount","mutation","HEADING_LEVELS","createHeadingBlockConfig","defaultLevel","levels","allowToggleHeadings","createHeadingBlockSpec","level","cursorPosition","createResizableFileBlockWrapper","resizeHandlesContainerElement","destroy","leftResizeHandle","rightResizeHandle","eventCaptureElement","resizeParams","windowMouseMoveHandler","newWidth","clientX","windowMouseUpHandler","wrapperMouseEnterHandler","wrapperMouseLeaveHandler","leftResizeHandleMouseDownHandler","rightResizeHandleMouseDownHandler","parseImageElement","imageElement","previewWidth","FILE_IMAGE_ICON_SVG","createImageBlockConfig","imageParse","imageRender","imageWrapper","image","imageToExternalHTML","createImageBlockSpec","splitBlockCommand","posInBlock","keepType","keepProps","splitBlockTr","nearestBlockContainerPos","info","handleEnter","listItemType","selectionEmpty","getListItemContent","_node","clonedNodeDiv","listItemsFirstChild","listItemNode","remainingListItemChildren","listItemsChildren","createBulletListItemBlockConfig","createBulletListItemBlockSpec","parent","li","p","createCheckListItemConfig","createCheckListItemBlockSpec","checkbox","calculateListItemIndex","isFirst","hasStart","prevBlock","prevBlockIndex","getDecorations","previousPluginState","nextDecorationSet","decorationsToAdd","deco","Decoration","decorationsToRemove","NumberedListIndexingDecorationPlugin","DecorationSet","createNumberedListItemBlockConfig","createNumberedListItemBlockSpec","startIndex","createToggleListItemBlockConfig","createToggleListItemBlockSpec","paragraphEl","createPageBreakBlockConfig","createPageBreakBlockSpec","pageBreak","withPageBreak","createParagraphBlockConfig","createParagraphBlockSpec","createQuoteBlockConfig","createQuoteBlockSpec","textColor","quote","RESIZE_MIN_WIDTH","EMPTY_CELL_WIDTH","EMPTY_CELL_HEIGHT","TableExtension","columnResizing","tableEditing","selection","selectionIsEmpty","selectionIsAtStartOfNode","selectionIsInTableParagraphNode","goToNextCell","extension","context","callOrReturn","getExtensionField","tablePropSchema","TiptapTableHeader","parseTableContent","mergeAttributes","TiptapTableCell","TiptapTableNode","domOutputSpec","colGroup","tableCell","BlockNoteTableView","TableView","cellMinWidth","tableWrapper","tableWrapperInner","floatingContainer","record","TiptapTableParagraph","TiptapTableRow","parsedContent","extractedContent","createTableBlockSpec","CellSelection","numCells","selectionNumCells","parseVideoElement","videoElement","FILE_VIDEO_ICON_SVG","createVideoBlockConfig","videoParse","createVideoBlockSpec","videoWrapper","video","uploadToTmpFilesDotOrg_DEV_ONLY","body","editorHasBlockWithType","propName","propSpec","blockHasType","isTableCellSelection","setSelectionToNextContentEditableBlock","contentType","insertOrUpdateBlock","currentBlock","getDefaultSlashMenuItems","insertedBlock","filterSuggestionItems","query","title","alias","checkPageBreakBlocksInSchema","getPageBreakSlashMenuItems","defaultBlockSpecs","TextColor","span","BackgroundColor","defaultStyleSpecs","Bold","Italic","Underline","Strike","Code","defaultStyleSchema","defaultInlineContentSpecs","defaultInlineContentSchema","BlockNoteSchema"],"mappings":"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"}