import {
  AllSelection,
  DOMParser as DOMParser2,
  DOMSerializer,
  Decoration,
  DecorationSet,
  EditorState,
  EditorView,
  Fragment,
  Mapping,
  Node as Node2,
  NodeSelection,
  Plugin,
  PluginKey,
  RemoveMarkStep,
  ReplaceAroundStep,
  ReplaceStep,
  Schema,
  Selection,
  SelectionRange,
  Slice,
  TextSelection,
  Transform,
  canJoin,
  canSplit,
  createParagraphNear,
  deleteSelection,
  dropCursor,
  exitCode,
  find,
  gapCursor,
  history,
  joinBackward,
  joinDown,
  joinForward,
  joinPoint,
  joinTextblockBackward,
  joinTextblockForward,
  joinUp,
  keydownHandler,
  keymap,
  lift,
  liftEmptyBlock,
  liftListItem,
  liftTarget,
  newlineInCode,
  redo,
  registerCustomProtocol,
  require_shim,
  require_with_selector,
  reset,
  selectNodeBackward,
  selectNodeForward,
  selectParentNode,
  selectTextblockEnd,
  selectTextblockStart,
  setBlockType,
  sinkListItem,
  tokenize,
  undo,
  wrapIn,
  wrapInList
} from "./chunk-I5I57JM6.js";
import {
  require_jsx_runtime
} from "./chunk-RZL7LBKR.js";
import {
  require_client
} from "./chunk-K6GQZKHR.js";
import {
  require_react_dom
} from "./chunk-IX53SOFO.js";
import {
  require_react
} from "./chunk-NBJ4KYHW.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-G3PMV62Z.js";

// ../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal(a2, b2) {
      if (a2 === b2) return true;
      if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
        if (a2.constructor !== b2.constructor) return false;
        var length3, i2, keys3;
        if (Array.isArray(a2)) {
          length3 = a2.length;
          if (length3 != b2.length) return false;
          for (i2 = length3; i2-- !== 0; )
            if (!equal(a2[i2], b2[i2])) return false;
          return true;
        }
        if (a2.constructor === RegExp) return a2.source === b2.source && a2.flags === b2.flags;
        if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b2.valueOf();
        if (a2.toString !== Object.prototype.toString) return a2.toString() === b2.toString();
        keys3 = Object.keys(a2);
        length3 = keys3.length;
        if (length3 !== Object.keys(b2).length) return false;
        for (i2 = length3; i2-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b2, keys3[i2])) return false;
        for (i2 = length3; i2-- !== 0; ) {
          var key2 = keys3[i2];
          if (!equal(a2[key2], b2[key2])) return false;
        }
        return true;
      }
      return a2 !== a2 && b2 !== b2;
    };
  }
});

// ../node_modules/.pnpm/extend@3.0.2/node_modules/extend/index.js
var require_extend = __commonJS({
  "../node_modules/.pnpm/extend@3.0.2/node_modules/extend/index.js"(exports, module) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray2 = function isArray3(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject3 = function isPlainObject4(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key2;
      for (key2 in obj) {
      }
      return typeof key2 === "undefined" || hasOwn.call(obj, key2);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name) {
      if (name === "__proto__") {
        if (!hasOwn.call(obj, name)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name).value;
        }
      }
      return obj[name];
    };
    module.exports = function extend2() {
      var options, name, src, copy2, copyIsArray, clone;
      var target = arguments[0];
      var i2 = 1;
      var length3 = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i2 = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i2 < length3; ++i2) {
        options = arguments[i2];
        if (options != null) {
          for (name in options) {
            src = getProperty(target, name);
            copy2 = getProperty(options, name);
            if (target !== copy2) {
              if (deep && copy2 && (isPlainObject3(copy2) || (copyIsArray = isArray2(copy2)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone = src && isArray2(src) ? src : [];
                } else {
                  clone = src && isPlainObject3(src) ? src : {};
                }
                setProperty(target, { name, newValue: extend2(deep, clone, copy2) });
              } else if (typeof copy2 !== "undefined") {
                setProperty(target, { name, newValue: copy2 });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// ../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
var require_ms = __commonJS({
  "../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js"(exports, module) {
    var s2 = 1e3;
    var m = s2 * 60;
    var h4 = m * 60;
    var d = h4 * 24;
    var w3 = d * 7;
    var y2 = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse6(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse6(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y2;
        case "weeks":
        case "week":
        case "w":
          return n * w3;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h4;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d) {
        return Math.round(ms2 / d) + "d";
      }
      if (msAbs >= h4) {
        return Math.round(ms2 / h4) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms2 / m) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms2 / s2) + "s";
      }
      return ms2 + "ms";
    }
    function fmtLong(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d) {
        return plural(ms2, msAbs, d, "day");
      }
      if (msAbs >= h4) {
        return plural(ms2, msAbs, h4, "hour");
      }
      if (msAbs >= m) {
        return plural(ms2, msAbs, m, "minute");
      }
      if (msAbs >= s2) {
        return plural(ms2, msAbs, s2, "second");
      }
      return ms2 + " ms";
    }
    function plural(ms2, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/common.js
var require_common = __commonJS({
  "../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/common.js"(exports, module) {
    function setup(env2) {
      createDebug2.debug = createDebug2;
      createDebug2.default = createDebug2;
      createDebug2.coerce = coerce;
      createDebug2.disable = disable2;
      createDebug2.enable = enable;
      createDebug2.enabled = enabled;
      createDebug2.humanize = require_ms();
      createDebug2.destroy = destroy;
      Object.keys(env2).forEach((key2) => {
        createDebug2[key2] = env2[key2];
      });
      createDebug2.names = [];
      createDebug2.skips = [];
      createDebug2.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i2 = 0; i2 < namespace.length; i2++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i2);
          hash |= 0;
        }
        return createDebug2.colors[Math.abs(hash) % createDebug2.colors.length];
      }
      createDebug2.selectColor = selectColor;
      function createDebug2(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args2) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms2 = curr - (prevTime || curr);
          self2.diff = ms2;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args2[0] = createDebug2.coerce(args2[0]);
          if (typeof args2[0] !== "string") {
            args2.unshift("%O");
          }
          let index4 = 0;
          args2[0] = args2[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index4++;
            const formatter = createDebug2.formatters[format];
            if (typeof formatter === "function") {
              const val = args2[index4];
              match = formatter.call(self2, val);
              args2.splice(index4, 1);
              index4--;
            }
            return match;
          });
          createDebug2.formatArgs.call(self2, args2);
          const logFn = self2.log || createDebug2.log;
          logFn.apply(self2, args2);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug2.useColors();
        debug2.color = createDebug2.selectColor(namespace);
        debug2.extend = extend2;
        debug2.destroy = createDebug2.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug2.namespaces) {
              namespacesCache = createDebug2.namespaces;
              enabledCache = createDebug2.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v2) => {
            enableOverride = v2;
          }
        });
        if (typeof createDebug2.init === "function") {
          createDebug2.init(debug2);
        }
        return debug2;
      }
      function extend2(namespace, delimiter) {
        const newDebug = createDebug2(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug2.save(namespaces);
        createDebug2.namespaces = namespaces;
        createDebug2.names = [];
        createDebug2.skips = [];
        const split2 = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns2 of split2) {
          if (ns2[0] === "-") {
            createDebug2.skips.push(ns2.slice(1));
          } else {
            createDebug2.names.push(ns2);
          }
        }
      }
      function matchesTemplate(search3, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search3.length) {
          if (templateIndex < template.length && (template[templateIndex] === search3[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable2() {
        const namespaces = [
          ...createDebug2.names,
          ...createDebug2.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug2.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug2.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns2 of createDebug2.names) {
          if (matchesTemplate(name, ns2)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug2.enable(createDebug2.load());
      return createDebug2;
    }
    module.exports = setup;
  }
});

// ../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args2) {
      args2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args2[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args2.splice(1, 0, c, "color: inherit");
      let index4 = 0;
      let lastC = 0;
      args2[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index4++;
        if (match === "%c") {
          lastC = index4;
        }
      });
      args2.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error2) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  }
});

// ../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/es6/react.js
var require_react2 = __commonJS({
  "../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/es6/react.js"(exports, module) {
    "use strict";
    module.exports = function equal(a2, b2) {
      if (a2 === b2) return true;
      if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
        if (a2.constructor !== b2.constructor) return false;
        var length3, i2, keys3;
        if (Array.isArray(a2)) {
          length3 = a2.length;
          if (length3 != b2.length) return false;
          for (i2 = length3; i2-- !== 0; )
            if (!equal(a2[i2], b2[i2])) return false;
          return true;
        }
        if (a2 instanceof Map && b2 instanceof Map) {
          if (a2.size !== b2.size) return false;
          for (i2 of a2.entries())
            if (!b2.has(i2[0])) return false;
          for (i2 of a2.entries())
            if (!equal(i2[1], b2.get(i2[0]))) return false;
          return true;
        }
        if (a2 instanceof Set && b2 instanceof Set) {
          if (a2.size !== b2.size) return false;
          for (i2 of a2.entries())
            if (!b2.has(i2[0])) return false;
          return true;
        }
        if (ArrayBuffer.isView(a2) && ArrayBuffer.isView(b2)) {
          length3 = a2.length;
          if (length3 != b2.length) return false;
          for (i2 = length3; i2-- !== 0; )
            if (a2[i2] !== b2[i2]) return false;
          return true;
        }
        if (a2.constructor === RegExp) return a2.source === b2.source && a2.flags === b2.flags;
        if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b2.valueOf();
        if (a2.toString !== Object.prototype.toString) return a2.toString() === b2.toString();
        keys3 = Object.keys(a2);
        length3 = keys3.length;
        if (length3 !== Object.keys(b2).length) return false;
        for (i2 = length3; i2-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b2, keys3[i2])) return false;
        for (i2 = length3; i2-- !== 0; ) {
          var key2 = keys3[i2];
          if (key2 === "_owner" && a2.$$typeof) {
            continue;
          }
          if (!equal(a2[key2], b2[key2])) return false;
        }
        return true;
      }
      return a2 !== a2 && b2 !== b2;
    };
  }
});

// ../node_modules/.pnpm/@blocknote+react@0.41.1_@fl_ddc1412596b7ba85ddc96cb299de0146/node_modules/@blocknote/react/dist/blocknote-react.js
var import_react13 = __toESM(require_react());
var import_jsx_runtime10 = __toESM(require_jsx_runtime());

// ../node_modules/.pnpm/@floating-ui+react@0.27.16__5eb07d2e43bfe8aeb9e3f2dad3b25394/node_modules/@floating-ui/react/dist/floating-ui.react.mjs
var React3 = __toESM(require_react(), 1);

// ../node_modules/.pnpm/@floating-ui+utils@0.2.10/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node2) {
  if (isNode(node2)) {
    return (node2.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node2) {
  var _node$ownerDocument;
  return (node2 == null || (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node2) {
  var _ref;
  return (_ref = (isNode(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element7) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element7);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
var tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element7) {
  return tableElements.has(getNodeName(element7));
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element7) {
  return topLayerSelectors.some((selector) => {
    try {
      return element7.matches(selector);
    } catch (_e3) {
      return false;
    }
  });
}
var transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
var willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
var containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element7) {
  let currentNode = getParentNode(element7);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
var lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node2) {
  return lastTraversableNodeNames.has(getNodeName(node2));
}
function getComputedStyle2(element7) {
  return getWindow(element7).getComputedStyle(element7);
}
function getNodeScroll(element7) {
  if (isElement(element7)) {
    return {
      scrollLeft: element7.scrollLeft,
      scrollTop: element7.scrollTop
    };
  }
  return {
    scrollLeft: element7.scrollX,
    scrollTop: element7.scrollY
  };
}
function getParentNode(node2) {
  if (getNodeName(node2) === "html") {
    return node2;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node2.assignedSlot || // DOM Element detected.
    node2.parentNode || // ShadowRoot detected.
    isShadowRoot(node2) && node2.host || // Fallback.
    getDocumentElement(node2)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node2) {
  const parentNode = getParentNode(node2);
  if (isLastTraversableNode(parentNode)) {
    return node2.ownerDocument ? node2.ownerDocument.body : node2.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node2, list7, traverseIframes) {
  var _node$ownerDocument2;
  if (list7 === void 0) {
    list7 = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node2);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list7.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list7.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// ../node_modules/.pnpm/@floating-ui+react@0.27.16__5eb07d2e43bfe8aeb9e3f2dad3b25394/node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs
var React = __toESM(require_react(), 1);
var import_react = __toESM(require_react(), 1);

// ../node_modules/.pnpm/@floating-ui+utils@0.2.10/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v2) => ({
  x: v2,
  y: v2
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length3 = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length3] > rects.floating[length3]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
var lrPlacement = ["left", "right"];
var rlPlacement = ["right", "left"];
var tbPlacement = ["top", "bottom"];
var btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list7 = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list7 = list7.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list7 = list7.concat(list7.map(getOppositeAlignmentPlacement));
    }
  }
  return list7;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x4,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x4,
    right: x4 + width,
    bottom: y2 + height,
    x: x4,
    y: y2
  };
}

// ../node_modules/.pnpm/tabbable@6.3.0/node_modules/tabbable/dist/index.esm.js
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
var candidateSelector = candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element7) {
  var _element$getRootNode;
  return element7 === null || element7 === void 0 ? void 0 : (_element$getRootNode = element7.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element7);
} : function(element7) {
  return element7 === null || element7 === void 0 ? void 0 : element7.ownerDocument;
};
var _isInert = function isInert(node2, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  var inertAtt = node2 === null || node2 === void 0 ? void 0 : (_node$getAttribute = node2.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node2, "inert");
  var inert = inertAtt === "" || inertAtt === "true";
  var result = inert || lookUp && node2 && _isInert(node2.parentNode);
  return result;
};
var isContentEditable = function isContentEditable2(node2) {
  var _node$getAttribute2;
  var attValue = node2 === null || node2 === void 0 ? void 0 : (_node$getAttribute2 = node2.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node2, "contenteditable");
  return attValue === "" || attValue === "true";
};
var getCandidates = function getCandidates2(el2, includeContainer, filter) {
  if (_isInert(el2)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el2.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el2, candidateSelector)) {
    candidates.unshift(el2);
  }
  candidates = candidates.filter(filter);
  return candidates;
};
var _getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element7 = elementsToCheck.shift();
    if (_isInert(element7, false)) {
      continue;
    }
    if (element7.tagName === "SLOT") {
      var assigned = element7.assignedElements();
      var content5 = assigned.length ? assigned : element7.children;
      var nestedCandidates = _getCandidatesIteratively(content5, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element7,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches.call(element7, candidateSelector);
      if (validCandidate && options.filter(element7) && (includeContainer || !elements.includes(element7))) {
        candidates.push(element7);
      }
      var shadowRoot = element7.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element7);
      var validShadowRoot = !_isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element7));
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = _getCandidatesIteratively(shadowRoot === true ? element7.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element7,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element7.children);
      }
    }
  }
  return candidates;
};
var hasTabIndex = function hasTabIndex2(node2) {
  return !isNaN(parseInt(node2.getAttribute("tabindex"), 10));
};
var getTabIndex = function getTabIndex2(node2) {
  if (!node2) {
    throw new Error("No node provided");
  }
  if (node2.tabIndex < 0) {
    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node2.tagName) || isContentEditable(node2)) && !hasTabIndex(node2)) {
      return 0;
    }
  }
  return node2.tabIndex;
};
var getSortOrderTabIndex = function getSortOrderTabIndex2(node2, isScope) {
  var tabIndex = getTabIndex(node2);
  if (tabIndex < 0 && isScope && !hasTabIndex(node2)) {
    return 0;
  }
  return tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a2, b2) {
  return a2.tabIndex === b2.tabIndex ? a2.documentOrder - b2.documentOrder : a2.tabIndex - b2.tabIndex;
};
var isInput = function isInput2(node2) {
  return node2.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node2) {
  return isInput(node2) && node2.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node2) {
  var r = node2.tagName === "DETAILS" && Array.prototype.slice.apply(node2.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i2 = 0; i2 < nodes.length; i2++) {
    if (nodes[i2].checked && nodes[i2].form === form) {
      return nodes[i2];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node2) {
  if (!node2.name) {
    return true;
  }
  var radioScope = node2.form || getRootNode(node2);
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node2.name));
  } else {
    try {
      radioSet = queryRadios(node2.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node2.form);
  return !checked || checked === node2;
};
var isRadio = function isRadio2(node2) {
  return isInput(node2) && node2.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node2) {
  return isRadio(node2) && !isTabbableRadio(node2);
};
var isNodeAttached = function isNodeAttached2(node2) {
  var _nodeRoot;
  var nodeRoot = node2 && getRootNode(node2);
  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
  var attached = false;
  if (nodeRoot && nodeRoot !== node2) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node2 !== null && node2 !== void 0 && (_node$ownerDocument = node2.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node2));
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      nodeRoot = getRootNode(nodeRootHost);
      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea2(node2) {
  var _node$getBoundingClie = node2.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node2, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (displayCheck === "full-native") {
    if ("checkVisibility" in node2) {
      var visible = node2.checkVisibility({
        // Checking opacity might be desirable for some use cases, but natively,
        // opacity zero elements _are_ focusable and tabbable.
        checkOpacity: false,
        opacityProperty: false,
        contentVisibilityAuto: true,
        visibilityProperty: true,
        // This is an alias for `visibilityProperty`. Contemporary browsers
        // support both. However, this alias has wider browser support (Chrome
        // >= 105 and Firefox >= 106, vs. Chrome >= 121 and Firefox >= 122), so
        // we include it anyway.
        checkVisibilityCSS: true
      });
      return !visible;
    }
  }
  if (getComputedStyle(node2).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node2, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node2.parentElement : node2;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  if (!displayCheck || displayCheck === "full" || // full-native can run this branch when it falls through in case
  // Element#checkVisibility is unsupported
  displayCheck === "full-native" || displayCheck === "legacy-full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node2;
      while (node2) {
        var parentElement = node2.parentElement;
        var rootNode = getRootNode(node2);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node2);
        } else if (node2.assignedSlot) {
          node2 = node2.assignedSlot;
        } else if (!parentElement && rootNode !== node2.ownerDocument) {
          node2 = rootNode.host;
        } else {
          node2 = parentElement;
        }
      }
      node2 = originalNode;
    }
    if (isNodeAttached(node2)) {
      return !node2.getClientRects().length;
    }
    if (displayCheck !== "legacy-full") {
      return true;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node2);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node2) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node2.tagName)) {
    var parentNode = node2.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i2 = 0; i2 < parentNode.children.length; i2++) {
          var child = parentNode.children.item(i2);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node2);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node2) {
  if (node2.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  _isInert(node2) || isHiddenInput(node2) || isHidden(node2, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node2) || isDisabledFromFieldset(node2)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node2) {
  if (isNonTabbableRadio(node2) || getTabIndex(node2) < 0 || !isNodeMatchingSelectorFocusable(options, node2)) {
    return false;
  }
  return true;
};
var isShadowRootTabbable = function isShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var _sortByOrder = function sortByOrder(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i2) {
    var isScope = !!item.scopeParent;
    var element7 = isScope ? item.scopeParent : item;
    var candidateTabindex = getSortOrderTabIndex(element7, isScope);
    var elements = isScope ? _sortByOrder(item.candidates) : element7;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element7);
    } else {
      orderedTabbables.push({
        documentOrder: i2,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = _getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isShadowRootTabbable
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return _sortByOrder(candidates);
};
var focusableCandidateSelector = candidateSelectors.concat("iframe").join(",");

// ../node_modules/.pnpm/@floating-ui+react@0.27.16__5eb07d2e43bfe8aeb9e3f2dad3b25394/node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs
function getPlatform() {
  const uaData = navigator.userAgentData;
  if (uaData != null && uaData.platform) {
    return uaData.platform;
  }
  return navigator.platform;
}
function getUserAgent() {
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    return uaData.brands.map((_ref) => {
      let {
        brand,
        version
      } = _ref;
      return brand + "/" + version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isSafari() {
  return /apple/i.test(navigator.vendor);
}
function isMac() {
  return getPlatform().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints;
}
function isJSDOM() {
  return getUserAgent().includes("jsdom/");
}
var FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable";
var TYPEABLE_SELECTOR = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
var ARROW_LEFT = "ArrowLeft";
var ARROW_RIGHT = "ArrowRight";
var ARROW_UP = "ArrowUp";
var ARROW_DOWN = "ArrowDown";
function activeElement(doc2) {
  let activeElement2 = doc2.activeElement;
  while (((_activeElement = activeElement2) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null) {
    var _activeElement;
    activeElement2 = activeElement2.shadowRoot.activeElement;
  }
  return activeElement2;
}
function contains(parent, child) {
  if (!parent || !child) {
    return false;
  }
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent.contains(child)) {
    return true;
  }
  if (rootNode && isShadowRoot(rootNode)) {
    let next2 = child;
    while (next2) {
      if (parent === next2) {
        return true;
      }
      next2 = next2.parentNode || next2.host;
    }
  }
  return false;
}
function getTarget(event) {
  if ("composedPath" in event) {
    return event.composedPath()[0];
  }
  return event.target;
}
function isEventTargetWithin(event, node2) {
  if (node2 == null) {
    return false;
  }
  if ("composedPath" in event) {
    return event.composedPath().includes(node2);
  }
  const e = event;
  return e.target != null && node2.contains(e.target);
}
function isRootElement(element7) {
  return element7.matches("html,body");
}
function getDocument(node2) {
  return (node2 == null ? void 0 : node2.ownerDocument) || document;
}
function isTypeableElement(element7) {
  return isHTMLElement(element7) && element7.matches(TYPEABLE_SELECTOR);
}
function matchesFocusVisible(element7) {
  if (!element7 || isJSDOM()) return true;
  try {
    return element7.matches(":focus-visible");
  } catch (_e3) {
    return true;
  }
}
function getFloatingFocusElement(floatingElement) {
  if (!floatingElement) {
    return null;
  }
  return floatingElement.hasAttribute(FOCUSABLE_ATTRIBUTE) ? floatingElement : floatingElement.querySelector("[" + FOCUSABLE_ATTRIBUTE + "]") || floatingElement;
}
function getNodeChildren(nodes, id2, onlyOpenChildren) {
  if (onlyOpenChildren === void 0) {
    onlyOpenChildren = true;
  }
  const directChildren = nodes.filter((node2) => {
    var _node$context;
    return node2.parentId === id2 && (!onlyOpenChildren || ((_node$context = node2.context) == null ? void 0 : _node$context.open));
  });
  return directChildren.flatMap((child) => [child, ...getNodeChildren(nodes, child.id, onlyOpenChildren)]);
}
function stopEvent(event) {
  event.preventDefault();
  event.stopPropagation();
}
function isReactEvent(event) {
  return "nativeEvent" in event;
}
function isMouseLikePointerType(pointerType, strict) {
  const values2 = ["mouse", "pen"];
  if (!strict) {
    values2.push("", void 0);
  }
  return values2.includes(pointerType);
}
var isClient = typeof document !== "undefined";
var noop = function noop2() {
};
var index = isClient ? import_react.useLayoutEffect : noop;
var SafeReact = {
  ...React
};
function useLatestRef(value) {
  const ref = React.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
var useInsertionEffect = SafeReact.useInsertionEffect;
var useSafeInsertionEffect = useInsertionEffect || ((fn3) => fn3());
function useEffectEvent(callback) {
  const ref = React.useRef(() => {
    if (true) {
      throw new Error("Cannot call an event handler while rendering.");
    }
  });
  useSafeInsertionEffect(() => {
    ref.current = callback;
  });
  return React.useCallback(function() {
    for (var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++) {
      args2[_key] = arguments[_key];
    }
    return ref.current == null ? void 0 : ref.current(...args2);
  }, []);
}
function isDifferentGridRow(index4, cols, prevRow) {
  return Math.floor(index4 / cols) !== prevRow;
}
function isIndexOutOfListBounds(listRef, index4) {
  return index4 < 0 || index4 >= listRef.current.length;
}
function getMinListIndex(listRef, disabledIndices) {
  return findNonDisabledListIndex(listRef, {
    disabledIndices
  });
}
function getMaxListIndex(listRef, disabledIndices) {
  return findNonDisabledListIndex(listRef, {
    decrement: true,
    startingIndex: listRef.current.length,
    disabledIndices
  });
}
function findNonDisabledListIndex(listRef, _temp) {
  let {
    startingIndex = -1,
    decrement = false,
    disabledIndices,
    amount = 1
  } = _temp === void 0 ? {} : _temp;
  let index4 = startingIndex;
  do {
    index4 += decrement ? -amount : amount;
  } while (index4 >= 0 && index4 <= listRef.current.length - 1 && isListIndexDisabled(listRef, index4, disabledIndices));
  return index4;
}
function getGridNavigatedIndex(listRef, _ref) {
  let {
    event,
    orientation,
    loop,
    rtl,
    cols,
    disabledIndices,
    minIndex,
    maxIndex,
    prevIndex,
    stopEvent: stop = false
  } = _ref;
  let nextIndex = prevIndex;
  if (event.key === ARROW_UP) {
    stop && stopEvent(event);
    if (prevIndex === -1) {
      nextIndex = maxIndex;
    } else {
      nextIndex = findNonDisabledListIndex(listRef, {
        startingIndex: nextIndex,
        amount: cols,
        decrement: true,
        disabledIndices
      });
      if (loop && (prevIndex - cols < minIndex || nextIndex < 0)) {
        const col = prevIndex % cols;
        const maxCol = maxIndex % cols;
        const offset4 = maxIndex - (maxCol - col);
        if (maxCol === col) {
          nextIndex = maxIndex;
        } else {
          nextIndex = maxCol > col ? offset4 : offset4 - cols;
        }
      }
    }
    if (isIndexOutOfListBounds(listRef, nextIndex)) {
      nextIndex = prevIndex;
    }
  }
  if (event.key === ARROW_DOWN) {
    stop && stopEvent(event);
    if (prevIndex === -1) {
      nextIndex = minIndex;
    } else {
      nextIndex = findNonDisabledListIndex(listRef, {
        startingIndex: prevIndex,
        amount: cols,
        disabledIndices
      });
      if (loop && prevIndex + cols > maxIndex) {
        nextIndex = findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex % cols - cols,
          amount: cols,
          disabledIndices
        });
      }
    }
    if (isIndexOutOfListBounds(listRef, nextIndex)) {
      nextIndex = prevIndex;
    }
  }
  if (orientation === "both") {
    const prevRow = floor(prevIndex / cols);
    if (event.key === (rtl ? ARROW_LEFT : ARROW_RIGHT)) {
      stop && stopEvent(event);
      if (prevIndex % cols !== cols - 1) {
        nextIndex = findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex,
          disabledIndices
        });
        if (loop && isDifferentGridRow(nextIndex, cols, prevRow)) {
          nextIndex = findNonDisabledListIndex(listRef, {
            startingIndex: prevIndex - prevIndex % cols - 1,
            disabledIndices
          });
        }
      } else if (loop) {
        nextIndex = findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex - prevIndex % cols - 1,
          disabledIndices
        });
      }
      if (isDifferentGridRow(nextIndex, cols, prevRow)) {
        nextIndex = prevIndex;
      }
    }
    if (event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT)) {
      stop && stopEvent(event);
      if (prevIndex % cols !== 0) {
        nextIndex = findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex,
          decrement: true,
          disabledIndices
        });
        if (loop && isDifferentGridRow(nextIndex, cols, prevRow)) {
          nextIndex = findNonDisabledListIndex(listRef, {
            startingIndex: prevIndex + (cols - prevIndex % cols),
            decrement: true,
            disabledIndices
          });
        }
      } else if (loop) {
        nextIndex = findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex + (cols - prevIndex % cols),
          decrement: true,
          disabledIndices
        });
      }
      if (isDifferentGridRow(nextIndex, cols, prevRow)) {
        nextIndex = prevIndex;
      }
    }
    const lastRow = floor(maxIndex / cols) === prevRow;
    if (isIndexOutOfListBounds(listRef, nextIndex)) {
      if (loop && lastRow) {
        nextIndex = event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT) ? maxIndex : findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex - prevIndex % cols - 1,
          disabledIndices
        });
      } else {
        nextIndex = prevIndex;
      }
    }
  }
  return nextIndex;
}
function createGridCellMap(sizes, cols, dense) {
  const cellMap = [];
  let startIndex = 0;
  sizes.forEach((_ref2, index4) => {
    let {
      width,
      height
    } = _ref2;
    if (width > cols) {
      if (true) {
        throw new Error("[Floating UI]: Invalid grid - item width at index " + index4 + " is greater than grid columns");
      }
    }
    let itemPlaced = false;
    if (dense) {
      startIndex = 0;
    }
    while (!itemPlaced) {
      const targetCells = [];
      for (let i2 = 0; i2 < width; i2++) {
        for (let j5 = 0; j5 < height; j5++) {
          targetCells.push(startIndex + i2 + j5 * cols);
        }
      }
      if (startIndex % cols + width <= cols && targetCells.every((cell2) => cellMap[cell2] == null)) {
        targetCells.forEach((cell2) => {
          cellMap[cell2] = index4;
        });
        itemPlaced = true;
      } else {
        startIndex++;
      }
    }
  });
  return [...cellMap];
}
function getGridCellIndexOfCorner(index4, sizes, cellMap, cols, corner) {
  if (index4 === -1) return -1;
  const firstCellIndex = cellMap.indexOf(index4);
  const sizeItem = sizes[index4];
  switch (corner) {
    case "tl":
      return firstCellIndex;
    case "tr":
      if (!sizeItem) {
        return firstCellIndex;
      }
      return firstCellIndex + sizeItem.width - 1;
    case "bl":
      if (!sizeItem) {
        return firstCellIndex;
      }
      return firstCellIndex + (sizeItem.height - 1) * cols;
    case "br":
      return cellMap.lastIndexOf(index4);
  }
}
function getGridCellIndices(indices, cellMap) {
  return cellMap.flatMap((index4, cellIndex) => indices.includes(index4) ? [cellIndex] : []);
}
function isListIndexDisabled(listRef, index4, disabledIndices) {
  if (typeof disabledIndices === "function") {
    return disabledIndices(index4);
  } else if (disabledIndices) {
    return disabledIndices.includes(index4);
  }
  const element7 = listRef.current[index4];
  return element7 == null || element7.hasAttribute("disabled") || element7.getAttribute("aria-disabled") === "true";
}
var getTabbableOptions = () => ({
  getShadowRoot: true,
  displayCheck: (
    // JSDOM does not support the `tabbable` library. To solve this we can
    // check if `ResizeObserver` is a real function (not polyfilled), which
    // determines if the current environment is JSDOM-like.
    typeof ResizeObserver === "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
  )
});
function getTabbableIn(container, dir) {
  const list7 = tabbable(container, getTabbableOptions());
  const len = list7.length;
  if (len === 0) return;
  const active = activeElement(getDocument(container));
  const index4 = list7.indexOf(active);
  const nextIndex = index4 === -1 ? dir === 1 ? 0 : len - 1 : index4 + dir;
  return list7[nextIndex];
}
function getNextTabbable(referenceElement) {
  return getTabbableIn(getDocument(referenceElement).body, 1) || referenceElement;
}
function getPreviousTabbable(referenceElement) {
  return getTabbableIn(getDocument(referenceElement).body, -1) || referenceElement;
}
function isOutsideEvent(event, container) {
  const containerElement = container || event.currentTarget;
  const relatedTarget = event.relatedTarget;
  return !relatedTarget || !contains(containerElement, relatedTarget);
}
function disableFocusInside(container) {
  const tabbableElements = tabbable(container, getTabbableOptions());
  tabbableElements.forEach((element7) => {
    element7.dataset.tabindex = element7.getAttribute("tabindex") || "";
    element7.setAttribute("tabindex", "-1");
  });
}
function enableFocusInside(container) {
  const elements = container.querySelectorAll("[data-tabindex]");
  elements.forEach((element7) => {
    const tabindex = element7.dataset.tabindex;
    delete element7.dataset.tabindex;
    if (tabindex) {
      element7.setAttribute("tabindex", tabindex);
    } else {
      element7.removeAttribute("tabindex");
    }
  });
}

// ../node_modules/.pnpm/@floating-ui+react@0.27.16__5eb07d2e43bfe8aeb9e3f2dad3b25394/node_modules/@floating-ui/react/dist/floating-ui.react.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var ReactDOM2 = __toESM(require_react_dom(), 1);

// ../node_modules/.pnpm/@floating-ui+core@1.7.3/node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x4,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name,
      fn: fn3
    } = validMiddleware[i2];
    const {
      x: nextX,
      y: nextY,
      data,
      reset: reset2
    } = await fn3({
      x: x4,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x4 = nextX != null ? nextX : x4;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset2 && resetCount <= 50) {
      resetCount++;
      if (typeof reset2 === "object") {
        if (reset2.placement) {
          statefulPlacement = reset2.placement;
        }
        if (reset2.rects) {
          rects = reset2.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset2.rects;
        }
        ({
          x: x4,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
    }
  }
  return {
    x: x4,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x4,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element7 = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element7))) != null ? _await$platform$isEle : true) ? element7 : element7.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x4,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x4,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element: element7,
      padding = 0
    } = evaluate(options, state) || {};
    if (element7 == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x4,
      y: y2
    };
    const axis = getAlignmentAxis(placement);
    const length3 = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element7);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length3] + rects.reference[axis] - coords[axis] - rects.floating[length3];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element7));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length3];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length3] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max3 = clientSize - arrowDimensions[length3] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length3] / 2 + centerToReference;
    const offset4 = clamp(min$1, center, max3);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset4 && rects.reference[length3] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length3] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max3 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset4,
        centerOffset: center - offset4 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
function getBoundingRect(rects) {
  const minX = min(...rects.map((rect) => rect.left));
  const minY = min(...rects.map((rect) => rect.top));
  const maxX = max(...rects.map((rect) => rect.right));
  const maxY = max(...rects.map((rect) => rect.bottom));
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getRectsByLine(rects) {
  const sortedRects = rects.slice().sort((a2, b2) => a2.y - b2.y);
  const groups = [];
  let prevRect = null;
  for (let i2 = 0; i2 < sortedRects.length; i2++) {
    const rect = sortedRects[i2];
    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {
      groups.push([rect]);
    } else {
      groups[groups.length - 1].push(rect);
    }
    prevRect = rect;
  }
  return groups.map((rect) => rectToClientRect(getBoundingRect(rect)));
}
var inline = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "inline",
    options,
    async fn(state) {
      const {
        placement,
        elements,
        rects,
        platform: platform2,
        strategy
      } = state;
      const {
        padding = 2,
        x: x4,
        y: y2
      } = evaluate(options, state);
      const nativeClientRects = Array.from(await (platform2.getClientRects == null ? void 0 : platform2.getClientRects(elements.reference)) || []);
      const clientRects = getRectsByLine(nativeClientRects);
      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));
      const paddingObject = getPaddingObject(padding);
      function getBoundingClientRect2() {
        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x4 != null && y2 != null) {
          return clientRects.find((rect) => x4 > rect.left - paddingObject.left && x4 < rect.right + paddingObject.right && y2 > rect.top - paddingObject.top && y2 < rect.bottom + paddingObject.bottom) || fallback;
        }
        if (clientRects.length >= 2) {
          if (getSideAxis(placement) === "y") {
            const firstRect = clientRects[0];
            const lastRect = clientRects[clientRects.length - 1];
            const isTop = getSide(placement) === "top";
            const top2 = firstRect.top;
            const bottom2 = lastRect.bottom;
            const left2 = isTop ? firstRect.left : lastRect.left;
            const right2 = isTop ? firstRect.right : lastRect.right;
            const width2 = right2 - left2;
            const height2 = bottom2 - top2;
            return {
              top: top2,
              bottom: bottom2,
              left: left2,
              right: right2,
              width: width2,
              height: height2,
              x: left2,
              y: top2
            };
          }
          const isLeftSide = getSide(placement) === "left";
          const maxRight = max(...clientRects.map((rect) => rect.right));
          const minLeft = min(...clientRects.map((rect) => rect.left));
          const measureRects = clientRects.filter((rect) => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
          const top = measureRects[0].top;
          const bottom = measureRects[measureRects.length - 1].bottom;
          const left = minLeft;
          const right = maxRight;
          const width = right - left;
          const height = bottom - top;
          return {
            top,
            bottom,
            left,
            right,
            width,
            height,
            x: left,
            y: top
          };
        }
        return fallback;
      }
      const resetRects = await platform2.getElementRects({
        reference: {
          getBoundingClientRect: getBoundingClientRect2
        },
        floating: elements.floating,
        strategy
      });
      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
        return {
          reset: {
            rects: resetRects
          }
        };
      }
      return {};
    }
  };
};
var originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x4,
        y: y2,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x4 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x4,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x5,
              y: y3
            } = _ref;
            return {
              x: x5,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x4,
        y: y2
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min3 = mainAxisCoord + overflow[minSide];
        const max3 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min3, mainAxisCoord, max3);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min3 = crossAxisCoord + overflow[minSide];
        const max3 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min3, crossAxisCoord, max3);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x4,
          y: limitedCoords.y - y2,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x: x4,
        y: y2,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset4 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x: x4,
        y: y2
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset4, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = originSides.has(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// ../node_modules/.pnpm/@floating-ui+dom@1.7.4/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element7) {
  const css = getComputedStyle2(element7);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element7);
  const offsetWidth = hasOffset ? element7.offsetWidth : width;
  const offsetHeight = hasOffset ? element7.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element7) {
  return !isElement(element7) ? element7.contextElement : element7;
}
function getScale(element7) {
  const domElement = unwrapElement(element7);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $3
  } = getCssDimensions(domElement);
  let x4 = ($3 ? round(rect.width) : rect.width) / width;
  let y2 = ($3 ? round(rect.height) : rect.height) / height;
  if (!x4 || !Number.isFinite(x4)) {
    x4 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x4,
    y: y2
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element7) {
  const win = getWindow(element7);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element7, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element7)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element7, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element7.getBoundingClientRect();
  const domElement = unwrapElement(element7);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element7);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x4 = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x4 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x4 += left;
      y2 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x4,
    y: y2
  });
}
function getWindowScrollBarX(element7, rect) {
  const leftScroll = getNodeScroll(element7).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element7)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x4 = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y2 = htmlRect.top + scroll.scrollTop;
  return {
    x: x4,
    y: y2
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element7) {
  return Array.from(element7.getClientRects());
}
function getDocumentRect(element7) {
  const html7 = getDocumentElement(element7);
  const scroll = getNodeScroll(element7);
  const body3 = element7.ownerDocument.body;
  const width = max(html7.scrollWidth, html7.clientWidth, body3.scrollWidth, body3.clientWidth);
  const height = max(html7.scrollHeight, html7.clientHeight, body3.scrollHeight, body3.clientHeight);
  let x4 = -scroll.scrollLeft + getWindowScrollBarX(element7);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle2(body3).direction === "rtl") {
    x4 += max(html7.clientWidth, body3.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x4,
    y: y2
  };
}
var SCROLLBAR_MAX = 25;
function getViewportRect(element7, strategy) {
  const win = getWindow(element7);
  const html7 = getDocumentElement(element7);
  const visualViewport = win.visualViewport;
  let width = html7.clientWidth;
  let height = html7.clientHeight;
  let x4 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x4 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html7);
  if (windowScrollbarX <= 0) {
    const doc2 = html7.ownerDocument;
    const body3 = doc2.body;
    const bodyStyles = getComputedStyle(body3);
    const bodyMarginInline = doc2.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html7.clientWidth - body3.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x: x4,
    y: y2
  };
}
var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element7, strategy) {
  const clientRect = getBoundingClientRect(element7, true, strategy === "fixed");
  const top = clientRect.top + element7.clientTop;
  const left = clientRect.left + element7.clientLeft;
  const scale = isHTMLElement(element7) ? getScale(element7) : createCoords(1);
  const width = element7.clientWidth * scale.x;
  const height = element7.clientHeight * scale.y;
  const x4 = left * scale.x;
  const y2 = top * scale.y;
  return {
    width,
    height,
    x: x4,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element7, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element7, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element7));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element7);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element7, stopNode) {
  const parentNode = getParentNode(element7);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element7, cache) {
  const cachedResult = cache.get(element7);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element7, [], false).filter((el2) => isElement(el2) && getNodeName(el2) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element7).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element7) : element7;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element7, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element7, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element: element7,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element7) ? [] : getClippingElementAncestors(element7, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element7, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element7, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element7) {
  const {
    width,
    height
  } = getCssDimensions(element7);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element7, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element7, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x4 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x4,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element7) {
  return getComputedStyle2(element7).position === "static";
}
function getTrueOffsetParent(element7, polyfill) {
  if (!isHTMLElement(element7) || getComputedStyle2(element7).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element7);
  }
  let rawOffsetParent = element7.offsetParent;
  if (getDocumentElement(element7) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element7, polyfill) {
  const win = getWindow(element7);
  if (isTopLayer(element7)) {
    return win;
  }
  if (!isHTMLElement(element7)) {
    let svgOffsetParent = getParentNode(element7);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element7, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element7) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element7) {
  return getComputedStyle2(element7).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a2, b2) {
  return a2.x === b2.x && a2.y === b2.y && a2.width === b2.width && a2.height === b2.height;
}
function observeMove(element7, onMove) {
  let io3 = null;
  let timeoutId;
  const root6 = getDocumentElement(element7);
  function cleanup2() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io3) == null || _io.disconnect();
    io3 = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup2();
    const elementRectForRootMargin = element7.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root6.clientWidth - (left + width));
    const insetBottom = floor(root6.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element7.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io3 = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root6.ownerDocument
      });
    } catch (_e3) {
      io3 = new IntersectionObserver(handleObserve, options);
    }
    io3.observe(element7);
  }
  refresh(true);
  return cleanup2;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var inline2 = inline;
var limitShift2 = limitShift;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// ../node_modules/.pnpm/@floating-ui+react-dom@2.1._8a39921f1d32f8ffc80bbadacb347503/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React2 = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);
var isClient2 = typeof document !== "undefined";
var noop3 = function noop4() {
};
var index2 = isClient2 ? import_react2.useLayoutEffect : noop3;
function deepEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (typeof a2 === "function" && a2.toString() === b2.toString()) {
    return true;
  }
  let length3;
  let i2;
  let keys3;
  if (a2 && b2 && typeof a2 === "object") {
    if (Array.isArray(a2)) {
      length3 = a2.length;
      if (length3 !== b2.length) return false;
      for (i2 = length3; i2-- !== 0; ) {
        if (!deepEqual(a2[i2], b2[i2])) {
          return false;
        }
      }
      return true;
    }
    keys3 = Object.keys(a2);
    length3 = keys3.length;
    if (length3 !== Object.keys(b2).length) {
      return false;
    }
    for (i2 = length3; i2-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b2, keys3[i2])) {
        return false;
      }
    }
    for (i2 = length3; i2-- !== 0; ) {
      const key2 = keys3[i2];
      if (key2 === "_owner" && a2.$$typeof) {
        continue;
      }
      if (!deepEqual(a2[key2], b2[key2])) {
        return false;
      }
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
function getDPR(element7) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element7.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element7, value) {
  const dpr = getDPR(element7);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef2(value) {
  const ref = React2.useRef(value);
  index2(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform: transform2 = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React2.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React2.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React2.useState(null);
  const [_floating, _setFloating] = React2.useState(null);
  const setReference = React2.useCallback((node2) => {
    if (node2 !== referenceRef.current) {
      referenceRef.current = node2;
      _setReference(node2);
    }
  }, []);
  const setFloating = React2.useCallback((node2) => {
    if (node2 !== floatingRef.current) {
      floatingRef.current = node2;
      _setFloating(node2);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React2.useRef(null);
  const floatingRef = React2.useRef(null);
  const dataRef = React2.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef2(whileElementsMounted);
  const platformRef = useLatestRef2(platform2);
  const openRef = useLatestRef2(open);
  const update = React2.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index2(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React2.useRef(false);
  index2(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index2(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React2.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React2.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React2.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x4 = roundByDPR(elements.floating, data.x);
    const y2 = roundByDPR(elements.floating, data.y);
    if (transform2) {
      return {
        ...initialStyles,
        transform: "translate(" + x4 + "px, " + y2 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x4,
      top: y2
    };
  }, [strategy, transform2, elements.floating, data.x, data.y]);
  return React2.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
var arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element: element7,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element7 && isRef(element7)) {
        if (element7.current != null) {
          return arrow2({
            element: element7.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element7) {
        return arrow2({
          element: element7,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var offset3 = (options, deps) => ({
  ...offset2(options),
  options: [options, deps]
});
var shift3 = (options, deps) => ({
  ...shift2(options),
  options: [options, deps]
});
var limitShift3 = (options, deps) => ({
  ...limitShift2(options),
  options: [options, deps]
});
var flip3 = (options, deps) => ({
  ...flip2(options),
  options: [options, deps]
});
var size3 = (options, deps) => ({
  ...size2(options),
  options: [options, deps]
});
var hide3 = (options, deps) => ({
  ...hide2(options),
  options: [options, deps]
});
var inline3 = (options, deps) => ({
  ...inline2(options),
  options: [options, deps]
});
var arrow3 = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});

// ../node_modules/.pnpm/@floating-ui+react@0.27.16__5eb07d2e43bfe8aeb9e3f2dad3b25394/node_modules/@floating-ui/react/dist/floating-ui.react.mjs
function useMergeRefs(refs) {
  const cleanupRef = React3.useRef(void 0);
  const refEffect = React3.useCallback((instance) => {
    const cleanups = refs.map((ref) => {
      if (ref == null) {
        return;
      }
      if (typeof ref === "function") {
        const refCallback = ref;
        const refCleanup = refCallback(instance);
        return typeof refCleanup === "function" ? refCleanup : () => {
          refCallback(null);
        };
      }
      ref.current = instance;
      return () => {
        ref.current = null;
      };
    });
    return () => {
      cleanups.forEach((refCleanup) => refCleanup == null ? void 0 : refCleanup());
    };
  }, refs);
  return React3.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (value) => {
      if (cleanupRef.current) {
        cleanupRef.current();
        cleanupRef.current = void 0;
      }
      if (value != null) {
        cleanupRef.current = refEffect(value);
      }
    };
  }, refs);
}
function sortByDocumentPosition(a2, b2) {
  const position4 = a2.compareDocumentPosition(b2);
  if (position4 & Node.DOCUMENT_POSITION_FOLLOWING || position4 & Node.DOCUMENT_POSITION_CONTAINED_BY) {
    return -1;
  }
  if (position4 & Node.DOCUMENT_POSITION_PRECEDING || position4 & Node.DOCUMENT_POSITION_CONTAINS) {
    return 1;
  }
  return 0;
}
var FloatingListContext = React3.createContext({
  register: () => {
  },
  unregister: () => {
  },
  map: /* @__PURE__ */ new Map(),
  elementsRef: {
    current: []
  }
});
function FloatingList(props) {
  const {
    children,
    elementsRef,
    labelsRef
  } = props;
  const [nodes, setNodes] = React3.useState(() => /* @__PURE__ */ new Set());
  const register = React3.useCallback((node2) => {
    setNodes((prevSet) => new Set(prevSet).add(node2));
  }, []);
  const unregister = React3.useCallback((node2) => {
    setNodes((prevSet) => {
      const set = new Set(prevSet);
      set.delete(node2);
      return set;
    });
  }, []);
  const map6 = React3.useMemo(() => {
    const newMap = /* @__PURE__ */ new Map();
    const sortedNodes = Array.from(nodes.keys()).sort(sortByDocumentPosition);
    sortedNodes.forEach((node2, index4) => {
      newMap.set(node2, index4);
    });
    return newMap;
  }, [nodes]);
  return (0, import_jsx_runtime.jsx)(FloatingListContext.Provider, {
    value: React3.useMemo(() => ({
      register,
      unregister,
      map: map6,
      elementsRef,
      labelsRef
    }), [register, unregister, map6, elementsRef, labelsRef]),
    children
  });
}
function useListItem(props) {
  if (props === void 0) {
    props = {};
  }
  const {
    label
  } = props;
  const {
    register,
    unregister,
    map: map6,
    elementsRef,
    labelsRef
  } = React3.useContext(FloatingListContext);
  const [index4, setIndex] = React3.useState(null);
  const componentRef = React3.useRef(null);
  const ref = React3.useCallback((node2) => {
    componentRef.current = node2;
    if (index4 !== null) {
      elementsRef.current[index4] = node2;
      if (labelsRef) {
        var _node$textContent;
        const isLabelDefined = label !== void 0;
        labelsRef.current[index4] = isLabelDefined ? label : (_node$textContent = node2 == null ? void 0 : node2.textContent) != null ? _node$textContent : null;
      }
    }
  }, [index4, elementsRef, labelsRef, label]);
  index(() => {
    const node2 = componentRef.current;
    if (node2) {
      register(node2);
      return () => {
        unregister(node2);
      };
    }
  }, [register, unregister]);
  index(() => {
    const index5 = componentRef.current ? map6.get(componentRef.current) : null;
    if (index5 != null) {
      setIndex(index5);
    }
  }, [map6]);
  return React3.useMemo(() => ({
    ref,
    index: index4 == null ? -1 : index4
  }), [index4, ref]);
}
var FOCUSABLE_ATTRIBUTE2 = "data-floating-ui-focusable";
var ACTIVE_KEY = "active";
var SELECTED_KEY = "selected";
var ARROW_LEFT2 = "ArrowLeft";
var ARROW_RIGHT2 = "ArrowRight";
var ARROW_UP2 = "ArrowUp";
var ARROW_DOWN2 = "ArrowDown";
function renderJsx(render, computedProps) {
  if (typeof render === "function") {
    return render(computedProps);
  }
  if (render) {
    return React3.cloneElement(render, computedProps);
  }
  return (0, import_jsx_runtime.jsx)("div", {
    ...computedProps
  });
}
var CompositeContext = React3.createContext({
  activeIndex: 0,
  onNavigate: () => {
  }
});
var horizontalKeys = [ARROW_LEFT2, ARROW_RIGHT2];
var verticalKeys = [ARROW_UP2, ARROW_DOWN2];
var allKeys = [...horizontalKeys, ...verticalKeys];
var Composite = React3.forwardRef(function Composite2(props, forwardedRef) {
  const {
    render,
    orientation = "both",
    loop = true,
    rtl = false,
    cols = 1,
    disabledIndices,
    activeIndex: externalActiveIndex,
    onNavigate: externalSetActiveIndex,
    itemSizes,
    dense = false,
    ...domProps
  } = props;
  const [internalActiveIndex, internalSetActiveIndex] = React3.useState(0);
  const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;
  const onNavigate = useEffectEvent(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);
  const elementsRef = React3.useRef([]);
  const renderElementProps = render && typeof render !== "function" ? render.props : {};
  const contextValue = React3.useMemo(() => ({
    activeIndex,
    onNavigate
  }), [activeIndex, onNavigate]);
  const isGrid = cols > 1;
  function handleKeyDown2(event) {
    if (!allKeys.includes(event.key)) return;
    let nextIndex = activeIndex;
    const minIndex = getMinListIndex(elementsRef, disabledIndices);
    const maxIndex = getMaxListIndex(elementsRef, disabledIndices);
    const horizontalEndKey = rtl ? ARROW_LEFT2 : ARROW_RIGHT2;
    const horizontalStartKey = rtl ? ARROW_RIGHT2 : ARROW_LEFT2;
    if (isGrid) {
      const sizes = itemSizes || Array.from({
        length: elementsRef.current.length
      }, () => ({
        width: 1,
        height: 1
      }));
      const cellMap = createGridCellMap(sizes, cols, dense);
      const minGridIndex = cellMap.findIndex((index4) => index4 != null && !isListIndexDisabled(elementsRef, index4, disabledIndices));
      const maxGridIndex = cellMap.reduce((foundIndex, index4, cellIndex) => index4 != null && !isListIndexDisabled(elementsRef, index4, disabledIndices) ? cellIndex : foundIndex, -1);
      const maybeNextIndex = cellMap[getGridNavigatedIndex({
        current: cellMap.map((itemIndex) => itemIndex ? elementsRef.current[itemIndex] : null)
      }, {
        event,
        orientation,
        loop,
        rtl,
        cols,
        // treat undefined (empty grid spaces) as disabled indices so we
        // don't end up in them
        disabledIndices: getGridCellIndices([...(typeof disabledIndices !== "function" ? disabledIndices : null) || elementsRef.current.map((_, index4) => isListIndexDisabled(elementsRef, index4, disabledIndices) ? index4 : void 0), void 0], cellMap),
        minIndex: minGridIndex,
        maxIndex: maxGridIndex,
        prevIndex: getGridCellIndexOfCorner(
          activeIndex > maxIndex ? minIndex : activeIndex,
          sizes,
          cellMap,
          cols,
          // use a corner matching the edge closest to the direction we're
          // moving in so we don't end up in the same item. Prefer
          // top/left over bottom/right.
          event.key === ARROW_DOWN2 ? "bl" : event.key === horizontalEndKey ? "tr" : "tl"
        )
      })];
      if (maybeNextIndex != null) {
        nextIndex = maybeNextIndex;
      }
    }
    const toEndKeys = {
      horizontal: [horizontalEndKey],
      vertical: [ARROW_DOWN2],
      both: [horizontalEndKey, ARROW_DOWN2]
    }[orientation];
    const toStartKeys = {
      horizontal: [horizontalStartKey],
      vertical: [ARROW_UP2],
      both: [horizontalStartKey, ARROW_UP2]
    }[orientation];
    const preventedKeys = isGrid ? allKeys : {
      horizontal: horizontalKeys,
      vertical: verticalKeys,
      both: allKeys
    }[orientation];
    if (nextIndex === activeIndex && [...toEndKeys, ...toStartKeys].includes(event.key)) {
      if (loop && nextIndex === maxIndex && toEndKeys.includes(event.key)) {
        nextIndex = minIndex;
      } else if (loop && nextIndex === minIndex && toStartKeys.includes(event.key)) {
        nextIndex = maxIndex;
      } else {
        nextIndex = findNonDisabledListIndex(elementsRef, {
          startingIndex: nextIndex,
          decrement: toStartKeys.includes(event.key),
          disabledIndices
        });
      }
    }
    if (nextIndex !== activeIndex && !isIndexOutOfListBounds(elementsRef, nextIndex)) {
      var _elementsRef$current$;
      event.stopPropagation();
      if (preventedKeys.includes(event.key)) {
        event.preventDefault();
      }
      onNavigate(nextIndex);
      (_elementsRef$current$ = elementsRef.current[nextIndex]) == null || _elementsRef$current$.focus();
    }
  }
  const computedProps = {
    ...domProps,
    ...renderElementProps,
    ref: forwardedRef,
    "aria-orientation": orientation === "both" ? void 0 : orientation,
    onKeyDown(e) {
      domProps.onKeyDown == null || domProps.onKeyDown(e);
      renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e);
      handleKeyDown2(e);
    }
  };
  return (0, import_jsx_runtime.jsx)(CompositeContext.Provider, {
    value: contextValue,
    children: (0, import_jsx_runtime.jsx)(FloatingList, {
      elementsRef,
      children: renderJsx(render, computedProps)
    })
  });
});
var CompositeItem = React3.forwardRef(function CompositeItem2(props, forwardedRef) {
  const {
    render,
    ...domProps
  } = props;
  const renderElementProps = render && typeof render !== "function" ? render.props : {};
  const {
    activeIndex,
    onNavigate
  } = React3.useContext(CompositeContext);
  const {
    ref,
    index: index4
  } = useListItem();
  const mergedRef = useMergeRefs([ref, forwardedRef, renderElementProps.ref]);
  const isActive2 = activeIndex === index4;
  const computedProps = {
    ...domProps,
    ...renderElementProps,
    ref: mergedRef,
    tabIndex: isActive2 ? 0 : -1,
    "data-active": isActive2 ? "" : void 0,
    onFocus(e) {
      domProps.onFocus == null || domProps.onFocus(e);
      renderElementProps.onFocus == null || renderElementProps.onFocus(e);
      onNavigate(index4);
    }
  };
  return renderJsx(render, computedProps);
});
var SafeReact2 = {
  ...React3
};
var serverHandoffComplete = false;
var count = 0;
var genId = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++
);
function useFloatingId() {
  const [id2, setId] = React3.useState(() => serverHandoffComplete ? genId() : void 0);
  index(() => {
    if (id2 == null) {
      setId(genId());
    }
  }, []);
  React3.useEffect(() => {
    serverHandoffComplete = true;
  }, []);
  return id2;
}
var useReactId = SafeReact2.useId;
var useId = useReactId || useFloatingId;
var devMessageSet;
if (true) {
  devMessageSet = /* @__PURE__ */ new Set();
}
function warn() {
  var _devMessageSet;
  for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {
    messages[_key] = arguments[_key];
  }
  const message = "Floating UI: " + messages.join(" ");
  if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(message))) {
    var _devMessageSet2;
    (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(message);
    console.warn(message);
  }
}
function error() {
  var _devMessageSet3;
  for (var _len2 = arguments.length, messages = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    messages[_key2] = arguments[_key2];
  }
  const message = "Floating UI: " + messages.join(" ");
  if (!((_devMessageSet3 = devMessageSet) != null && _devMessageSet3.has(message))) {
    var _devMessageSet4;
    (_devMessageSet4 = devMessageSet) == null || _devMessageSet4.add(message);
    console.error(message);
  }
}
var FloatingArrow = React3.forwardRef(function FloatingArrow2(props, ref) {
  const {
    context: {
      placement,
      elements: {
        floating
      },
      middlewareData: {
        arrow: arrow5,
        shift: shift4
      }
    },
    width = 14,
    height = 7,
    tipRadius = 0,
    strokeWidth = 0,
    staticOffset,
    stroke,
    d,
    style: {
      transform: transform2,
      ...restStyle
    } = {},
    ...rest
  } = props;
  if (true) {
    if (!ref) {
      warn("The `ref` prop is required for `FloatingArrow`.");
    }
  }
  const clipPathId = useId();
  const [isRTL2, setIsRTL] = React3.useState(false);
  index(() => {
    if (!floating) return;
    const isRTL3 = getComputedStyle2(floating).direction === "rtl";
    if (isRTL3) {
      setIsRTL(true);
    }
  }, [floating]);
  if (!floating) {
    return null;
  }
  const [side, alignment] = placement.split("-");
  const isVerticalSide = side === "top" || side === "bottom";
  let computedStaticOffset = staticOffset;
  if (isVerticalSide && shift4 != null && shift4.x || !isVerticalSide && shift4 != null && shift4.y) {
    computedStaticOffset = null;
  }
  const computedStrokeWidth = strokeWidth * 2;
  const halfStrokeWidth = computedStrokeWidth / 2;
  const svgX = width / 2 * (tipRadius / -8 + 1);
  const svgY = height / 2 * tipRadius / 4;
  const isCustomShape = !!d;
  const yOffsetProp = computedStaticOffset && alignment === "end" ? "bottom" : "top";
  let xOffsetProp = computedStaticOffset && alignment === "end" ? "right" : "left";
  if (computedStaticOffset && isRTL2) {
    xOffsetProp = alignment === "end" ? "left" : "right";
  }
  const arrowX = (arrow5 == null ? void 0 : arrow5.x) != null ? computedStaticOffset || arrow5.x : "";
  const arrowY = (arrow5 == null ? void 0 : arrow5.y) != null ? computedStaticOffset || arrow5.y : "";
  const dValue = d || "M0,0" + (" H" + width) + (" L" + (width - svgX) + "," + (height - svgY)) + (" Q" + width / 2 + "," + height + " " + svgX + "," + (height - svgY)) + " Z";
  const rotation = {
    top: isCustomShape ? "rotate(180deg)" : "",
    left: isCustomShape ? "rotate(90deg)" : "rotate(-90deg)",
    bottom: isCustomShape ? "" : "rotate(180deg)",
    right: isCustomShape ? "rotate(-90deg)" : "rotate(90deg)"
  }[side];
  return (0, import_jsx_runtime.jsxs)("svg", {
    ...rest,
    "aria-hidden": true,
    ref,
    width: isCustomShape ? width : width + computedStrokeWidth,
    height: width,
    viewBox: "0 0 " + width + " " + (height > width ? height : width),
    style: {
      position: "absolute",
      pointerEvents: "none",
      [xOffsetProp]: arrowX,
      [yOffsetProp]: arrowY,
      [side]: isVerticalSide || isCustomShape ? "100%" : "calc(100% - " + computedStrokeWidth / 2 + "px)",
      transform: [rotation, transform2].filter((t) => !!t).join(" "),
      ...restStyle
    },
    children: [computedStrokeWidth > 0 && (0, import_jsx_runtime.jsx)("path", {
      clipPath: "url(#" + clipPathId + ")",
      fill: "none",
      stroke,
      strokeWidth: computedStrokeWidth + (d ? 0 : 1),
      d: dValue
    }), (0, import_jsx_runtime.jsx)("path", {
      stroke: computedStrokeWidth && !d ? rest.fill : "none",
      d: dValue
    }), (0, import_jsx_runtime.jsx)("clipPath", {
      id: clipPathId,
      children: (0, import_jsx_runtime.jsx)("rect", {
        x: -halfStrokeWidth,
        y: halfStrokeWidth * (isCustomShape ? -1 : 1),
        width: width + computedStrokeWidth,
        height: width
      })
    })]
  });
});
function createEventEmitter() {
  const map6 = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map6.get(event)) == null || _map$get.forEach((listener) => listener(data));
    },
    on(event, listener) {
      if (!map6.has(event)) {
        map6.set(event, /* @__PURE__ */ new Set());
      }
      map6.get(event).add(listener);
    },
    off(event, listener) {
      var _map$get2;
      (_map$get2 = map6.get(event)) == null || _map$get2.delete(listener);
    }
  };
}
var FloatingNodeContext = React3.createContext(null);
var FloatingTreeContext = React3.createContext(null);
var useFloatingParentNodeId = () => {
  var _React$useContext;
  return ((_React$useContext = React3.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
};
var useFloatingTree = () => React3.useContext(FloatingTreeContext);
function createAttribute(name) {
  return "data-floating-ui-" + name;
}
function clearTimeoutIfSet(timeoutRef) {
  if (timeoutRef.current !== -1) {
    clearTimeout(timeoutRef.current);
    timeoutRef.current = -1;
  }
}
var safePolygonIdentifier = createAttribute("safe-polygon");
function getDelay(value, prop, pointerType) {
  if (pointerType && !isMouseLikePointerType(pointerType)) {
    return 0;
  }
  if (typeof value === "number") {
    return value;
  }
  if (typeof value === "function") {
    const result = value();
    if (typeof result === "number") {
      return result;
    }
    return result == null ? void 0 : result[prop];
  }
  return value == null ? void 0 : value[prop];
}
function getRestMs(value) {
  if (typeof value === "function") {
    return value();
  }
  return value;
}
function useHover(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    dataRef,
    events,
    elements
  } = context;
  const {
    enabled = true,
    delay = 0,
    handleClose = null,
    mouseOnly = false,
    restMs = 0,
    move = true
  } = props;
  const tree = useFloatingTree();
  const parentId = useFloatingParentNodeId();
  const handleCloseRef = useLatestRef(handleClose);
  const delayRef = useLatestRef(delay);
  const openRef = useLatestRef(open);
  const restMsRef = useLatestRef(restMs);
  const pointerTypeRef = React3.useRef();
  const timeoutRef = React3.useRef(-1);
  const handlerRef = React3.useRef();
  const restTimeoutRef = React3.useRef(-1);
  const blockMouseMoveRef = React3.useRef(true);
  const performedPointerEventsMutationRef = React3.useRef(false);
  const unbindMouseMoveRef = React3.useRef(() => {
  });
  const restTimeoutPendingRef = React3.useRef(false);
  const isHoverOpen = useEffectEvent(() => {
    var _dataRef$current$open;
    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;
    return (type == null ? void 0 : type.includes("mouse")) && type !== "mousedown";
  });
  React3.useEffect(() => {
    if (!enabled) return;
    function onOpenChange2(_ref) {
      let {
        open: open2
      } = _ref;
      if (!open2) {
        clearTimeoutIfSet(timeoutRef);
        clearTimeoutIfSet(restTimeoutRef);
        blockMouseMoveRef.current = true;
        restTimeoutPendingRef.current = false;
      }
    }
    events.on("openchange", onOpenChange2);
    return () => {
      events.off("openchange", onOpenChange2);
    };
  }, [enabled, events]);
  React3.useEffect(() => {
    if (!enabled) return;
    if (!handleCloseRef.current) return;
    if (!open) return;
    function onLeave(event) {
      if (isHoverOpen()) {
        onOpenChange(false, event, "hover");
      }
    }
    const html7 = getDocument(elements.floating).documentElement;
    html7.addEventListener("mouseleave", onLeave);
    return () => {
      html7.removeEventListener("mouseleave", onLeave);
    };
  }, [elements.floating, open, onOpenChange, enabled, handleCloseRef, isHoverOpen]);
  const closeWithDelay = React3.useCallback(function(event, runElseBranch, reason) {
    if (runElseBranch === void 0) {
      runElseBranch = true;
    }
    if (reason === void 0) {
      reason = "hover";
    }
    const closeDelay = getDelay(delayRef.current, "close", pointerTypeRef.current);
    if (closeDelay && !handlerRef.current) {
      clearTimeoutIfSet(timeoutRef);
      timeoutRef.current = window.setTimeout(() => onOpenChange(false, event, reason), closeDelay);
    } else if (runElseBranch) {
      clearTimeoutIfSet(timeoutRef);
      onOpenChange(false, event, reason);
    }
  }, [delayRef, onOpenChange]);
  const cleanupMouseMoveHandler = useEffectEvent(() => {
    unbindMouseMoveRef.current();
    handlerRef.current = void 0;
  });
  const clearPointerEvents = useEffectEvent(() => {
    if (performedPointerEventsMutationRef.current) {
      const body3 = getDocument(elements.floating).body;
      body3.style.pointerEvents = "";
      body3.removeAttribute(safePolygonIdentifier);
      performedPointerEventsMutationRef.current = false;
    }
  });
  const isClickLikeOpenEvent = useEffectEvent(() => {
    return dataRef.current.openEvent ? ["click", "mousedown"].includes(dataRef.current.openEvent.type) : false;
  });
  React3.useEffect(() => {
    if (!enabled) return;
    function onReferenceMouseEnter(event) {
      clearTimeoutIfSet(timeoutRef);
      blockMouseMoveRef.current = false;
      if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || getRestMs(restMsRef.current) > 0 && !getDelay(delayRef.current, "open")) {
        return;
      }
      const openDelay = getDelay(delayRef.current, "open", pointerTypeRef.current);
      if (openDelay) {
        timeoutRef.current = window.setTimeout(() => {
          if (!openRef.current) {
            onOpenChange(true, event, "hover");
          }
        }, openDelay);
      } else if (!open) {
        onOpenChange(true, event, "hover");
      }
    }
    function onReferenceMouseLeave(event) {
      if (isClickLikeOpenEvent()) {
        clearPointerEvents();
        return;
      }
      unbindMouseMoveRef.current();
      const doc2 = getDocument(elements.floating);
      clearTimeoutIfSet(restTimeoutRef);
      restTimeoutPendingRef.current = false;
      if (handleCloseRef.current && dataRef.current.floatingContext) {
        if (!open) {
          clearTimeoutIfSet(timeoutRef);
        }
        handlerRef.current = handleCloseRef.current({
          ...dataRef.current.floatingContext,
          tree,
          x: event.clientX,
          y: event.clientY,
          onClose() {
            clearPointerEvents();
            cleanupMouseMoveHandler();
            if (!isClickLikeOpenEvent()) {
              closeWithDelay(event, true, "safe-polygon");
            }
          }
        });
        const handler = handlerRef.current;
        doc2.addEventListener("mousemove", handler);
        unbindMouseMoveRef.current = () => {
          doc2.removeEventListener("mousemove", handler);
        };
        return;
      }
      const shouldClose = pointerTypeRef.current === "touch" ? !contains(elements.floating, event.relatedTarget) : true;
      if (shouldClose) {
        closeWithDelay(event);
      }
    }
    function onScrollMouseLeave(event) {
      if (isClickLikeOpenEvent()) return;
      if (!dataRef.current.floatingContext) return;
      handleCloseRef.current == null || handleCloseRef.current({
        ...dataRef.current.floatingContext,
        tree,
        x: event.clientX,
        y: event.clientY,
        onClose() {
          clearPointerEvents();
          cleanupMouseMoveHandler();
          if (!isClickLikeOpenEvent()) {
            closeWithDelay(event);
          }
        }
      })(event);
    }
    function onFloatingMouseEnter() {
      clearTimeoutIfSet(timeoutRef);
    }
    function onFloatingMouseLeave(event) {
      if (!isClickLikeOpenEvent()) {
        closeWithDelay(event, false);
      }
    }
    if (isElement(elements.domReference)) {
      const reference2 = elements.domReference;
      const floating = elements.floating;
      if (open) {
        reference2.addEventListener("mouseleave", onScrollMouseLeave);
      }
      if (move) {
        reference2.addEventListener("mousemove", onReferenceMouseEnter, {
          once: true
        });
      }
      reference2.addEventListener("mouseenter", onReferenceMouseEnter);
      reference2.addEventListener("mouseleave", onReferenceMouseLeave);
      if (floating) {
        floating.addEventListener("mouseleave", onScrollMouseLeave);
        floating.addEventListener("mouseenter", onFloatingMouseEnter);
        floating.addEventListener("mouseleave", onFloatingMouseLeave);
      }
      return () => {
        if (open) {
          reference2.removeEventListener("mouseleave", onScrollMouseLeave);
        }
        if (move) {
          reference2.removeEventListener("mousemove", onReferenceMouseEnter);
        }
        reference2.removeEventListener("mouseenter", onReferenceMouseEnter);
        reference2.removeEventListener("mouseleave", onReferenceMouseLeave);
        if (floating) {
          floating.removeEventListener("mouseleave", onScrollMouseLeave);
          floating.removeEventListener("mouseenter", onFloatingMouseEnter);
          floating.removeEventListener("mouseleave", onFloatingMouseLeave);
        }
      };
    }
  }, [elements, enabled, context, mouseOnly, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, openRef, tree, delayRef, handleCloseRef, dataRef, isClickLikeOpenEvent, restMsRef]);
  index(() => {
    var _handleCloseRef$curre;
    if (!enabled) return;
    if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && (_handleCloseRef$curre = _handleCloseRef$curre.__options) != null && _handleCloseRef$curre.blockPointerEvents && isHoverOpen()) {
      performedPointerEventsMutationRef.current = true;
      const floatingEl = elements.floating;
      if (isElement(elements.domReference) && floatingEl) {
        var _tree$nodesRef$curren;
        const body3 = getDocument(elements.floating).body;
        body3.setAttribute(safePolygonIdentifier, "");
        const ref = elements.domReference;
        const parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find((node2) => node2.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;
        if (parentFloating) {
          parentFloating.style.pointerEvents = "";
        }
        body3.style.pointerEvents = "none";
        ref.style.pointerEvents = "auto";
        floatingEl.style.pointerEvents = "auto";
        return () => {
          body3.style.pointerEvents = "";
          ref.style.pointerEvents = "";
          floatingEl.style.pointerEvents = "";
        };
      }
    }
  }, [enabled, open, parentId, elements, tree, handleCloseRef, isHoverOpen]);
  index(() => {
    if (!open) {
      pointerTypeRef.current = void 0;
      restTimeoutPendingRef.current = false;
      cleanupMouseMoveHandler();
      clearPointerEvents();
    }
  }, [open, cleanupMouseMoveHandler, clearPointerEvents]);
  React3.useEffect(() => {
    return () => {
      cleanupMouseMoveHandler();
      clearTimeoutIfSet(timeoutRef);
      clearTimeoutIfSet(restTimeoutRef);
      clearPointerEvents();
    };
  }, [enabled, elements.domReference, cleanupMouseMoveHandler, clearPointerEvents]);
  const reference = React3.useMemo(() => {
    function setPointerRef(event) {
      pointerTypeRef.current = event.pointerType;
    }
    return {
      onPointerDown: setPointerRef,
      onPointerEnter: setPointerRef,
      onMouseMove(event) {
        const {
          nativeEvent
        } = event;
        function handleMouseMove2() {
          if (!blockMouseMoveRef.current && !openRef.current) {
            onOpenChange(true, nativeEvent, "hover");
          }
        }
        if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current)) {
          return;
        }
        if (open || getRestMs(restMsRef.current) === 0) {
          return;
        }
        if (restTimeoutPendingRef.current && event.movementX ** 2 + event.movementY ** 2 < 2) {
          return;
        }
        clearTimeoutIfSet(restTimeoutRef);
        if (pointerTypeRef.current === "touch") {
          handleMouseMove2();
        } else {
          restTimeoutPendingRef.current = true;
          restTimeoutRef.current = window.setTimeout(handleMouseMove2, getRestMs(restMsRef.current));
        }
      }
    };
  }, [mouseOnly, onOpenChange, open, openRef, restMsRef]);
  return React3.useMemo(() => enabled ? {
    reference
  } : {}, [enabled, reference]);
}
var NOOP = () => {
};
var FloatingDelayGroupContext = React3.createContext({
  delay: 0,
  initialDelay: 0,
  timeoutMs: 0,
  currentId: null,
  setCurrentId: NOOP,
  setState: NOOP,
  isInstantPhase: false
});
var useDelayGroupContext = () => React3.useContext(FloatingDelayGroupContext);
function FloatingDelayGroup(props) {
  const {
    children,
    delay,
    timeoutMs = 0
  } = props;
  const [state, setState] = React3.useReducer((prev, next2) => ({
    ...prev,
    ...next2
  }), {
    delay,
    timeoutMs,
    initialDelay: delay,
    currentId: null,
    isInstantPhase: false
  });
  const initialCurrentIdRef = React3.useRef(null);
  const setCurrentId = React3.useCallback((currentId) => {
    setState({
      currentId
    });
  }, []);
  index(() => {
    if (state.currentId) {
      if (initialCurrentIdRef.current === null) {
        initialCurrentIdRef.current = state.currentId;
      } else if (!state.isInstantPhase) {
        setState({
          isInstantPhase: true
        });
      }
    } else {
      if (state.isInstantPhase) {
        setState({
          isInstantPhase: false
        });
      }
      initialCurrentIdRef.current = null;
    }
  }, [state.currentId, state.isInstantPhase]);
  return (0, import_jsx_runtime.jsx)(FloatingDelayGroupContext.Provider, {
    value: React3.useMemo(() => ({
      ...state,
      setState,
      setCurrentId
    }), [state, setCurrentId]),
    children
  });
}
function useDelayGroup(context, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    open,
    onOpenChange,
    floatingId
  } = context;
  const {
    id: optionId,
    enabled = true
  } = options;
  const id2 = optionId != null ? optionId : floatingId;
  const groupContext = useDelayGroupContext();
  const {
    currentId,
    setCurrentId,
    initialDelay,
    setState,
    timeoutMs
  } = groupContext;
  index(() => {
    if (!enabled) return;
    if (!currentId) return;
    setState({
      delay: {
        open: 1,
        close: getDelay(initialDelay, "close")
      }
    });
    if (currentId !== id2) {
      onOpenChange(false);
    }
  }, [enabled, id2, onOpenChange, setState, currentId, initialDelay]);
  index(() => {
    function unset() {
      onOpenChange(false);
      setState({
        delay: initialDelay,
        currentId: null
      });
    }
    if (!enabled) return;
    if (!currentId) return;
    if (!open && currentId === id2) {
      if (timeoutMs) {
        const timeout2 = window.setTimeout(unset, timeoutMs);
        return () => {
          clearTimeout(timeout2);
        };
      }
      unset();
    }
  }, [enabled, open, setState, currentId, id2, onOpenChange, initialDelay, timeoutMs]);
  index(() => {
    if (!enabled) return;
    if (setCurrentId === NOOP || !open) return;
    setCurrentId(id2);
  }, [enabled, open, setCurrentId, id2]);
  return groupContext;
}
var NextFloatingDelayGroupContext = React3.createContext({
  hasProvider: false,
  timeoutMs: 0,
  delayRef: {
    current: 0
  },
  initialDelayRef: {
    current: 0
  },
  timeoutIdRef: {
    current: -1
  },
  currentIdRef: {
    current: null
  },
  currentContextRef: {
    current: null
  }
});
var HIDDEN_STYLES = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "fixed",
  whiteSpace: "nowrap",
  width: "1px",
  top: 0,
  left: 0
};
var FocusGuard = React3.forwardRef(function FocusGuard2(props, ref) {
  const [role, setRole] = React3.useState();
  index(() => {
    if (isSafari()) {
      setRole("button");
    }
  }, []);
  const restProps = {
    ref,
    tabIndex: 0,
    // Role is only for VoiceOver
    role,
    "aria-hidden": role ? void 0 : true,
    [createAttribute("focus-guard")]: "",
    style: HIDDEN_STYLES
  };
  return (0, import_jsx_runtime.jsx)("span", {
    ...props,
    ...restProps
  });
});
var PortalContext = React3.createContext(null);
var attr = createAttribute("portal");
function useFloatingPortalNode(props) {
  if (props === void 0) {
    props = {};
  }
  const {
    id: id2,
    root: root6
  } = props;
  const uniqueId = useId();
  const portalContext = usePortalContext();
  const [portalNode, setPortalNode] = React3.useState(null);
  const portalNodeRef = React3.useRef(null);
  index(() => {
    return () => {
      portalNode == null || portalNode.remove();
      queueMicrotask(() => {
        portalNodeRef.current = null;
      });
    };
  }, [portalNode]);
  index(() => {
    if (!uniqueId) return;
    if (portalNodeRef.current) return;
    const existingIdRoot = id2 ? document.getElementById(id2) : null;
    if (!existingIdRoot) return;
    const subRoot = document.createElement("div");
    subRoot.id = uniqueId;
    subRoot.setAttribute(attr, "");
    existingIdRoot.appendChild(subRoot);
    portalNodeRef.current = subRoot;
    setPortalNode(subRoot);
  }, [id2, uniqueId]);
  index(() => {
    if (root6 === null) return;
    if (!uniqueId) return;
    if (portalNodeRef.current) return;
    let container = root6 || (portalContext == null ? void 0 : portalContext.portalNode);
    if (container && !isNode(container)) container = container.current;
    container = container || document.body;
    let idWrapper = null;
    if (id2) {
      idWrapper = document.createElement("div");
      idWrapper.id = id2;
      container.appendChild(idWrapper);
    }
    const subRoot = document.createElement("div");
    subRoot.id = uniqueId;
    subRoot.setAttribute(attr, "");
    container = idWrapper || container;
    container.appendChild(subRoot);
    portalNodeRef.current = subRoot;
    setPortalNode(subRoot);
  }, [id2, root6, uniqueId, portalContext]);
  return portalNode;
}
function FloatingPortal(props) {
  const {
    children,
    id: id2,
    root: root6,
    preserveTabOrder = true
  } = props;
  const portalNode = useFloatingPortalNode({
    id: id2,
    root: root6
  });
  const [focusManagerState, setFocusManagerState] = React3.useState(null);
  const beforeOutsideRef = React3.useRef(null);
  const afterOutsideRef = React3.useRef(null);
  const beforeInsideRef = React3.useRef(null);
  const afterInsideRef = React3.useRef(null);
  const modal = focusManagerState == null ? void 0 : focusManagerState.modal;
  const open = focusManagerState == null ? void 0 : focusManagerState.open;
  const shouldRenderGuards = (
    // The FocusManager and therefore floating element are currently open/
    // rendered.
    !!focusManagerState && // Guards are only for non-modal focus management.
    !focusManagerState.modal && // Don't render if unmount is transitioning.
    focusManagerState.open && preserveTabOrder && !!(root6 || portalNode)
  );
  React3.useEffect(() => {
    if (!portalNode || !preserveTabOrder || modal) {
      return;
    }
    function onFocus(event) {
      if (portalNode && isOutsideEvent(event)) {
        const focusing = event.type === "focusin";
        const manageFocus = focusing ? enableFocusInside : disableFocusInside;
        manageFocus(portalNode);
      }
    }
    portalNode.addEventListener("focusin", onFocus, true);
    portalNode.addEventListener("focusout", onFocus, true);
    return () => {
      portalNode.removeEventListener("focusin", onFocus, true);
      portalNode.removeEventListener("focusout", onFocus, true);
    };
  }, [portalNode, preserveTabOrder, modal]);
  React3.useEffect(() => {
    if (!portalNode) return;
    if (open) return;
    enableFocusInside(portalNode);
  }, [open, portalNode]);
  return (0, import_jsx_runtime.jsxs)(PortalContext.Provider, {
    value: React3.useMemo(() => ({
      preserveTabOrder,
      beforeOutsideRef,
      afterOutsideRef,
      beforeInsideRef,
      afterInsideRef,
      portalNode,
      setFocusManagerState
    }), [preserveTabOrder, portalNode]),
    children: [shouldRenderGuards && portalNode && (0, import_jsx_runtime.jsx)(FocusGuard, {
      "data-type": "outside",
      ref: beforeOutsideRef,
      onFocus: (event) => {
        if (isOutsideEvent(event, portalNode)) {
          var _beforeInsideRef$curr;
          (_beforeInsideRef$curr = beforeInsideRef.current) == null || _beforeInsideRef$curr.focus();
        } else {
          const domReference = focusManagerState ? focusManagerState.domReference : null;
          const prevTabbable = getPreviousTabbable(domReference);
          prevTabbable == null || prevTabbable.focus();
        }
      }
    }), shouldRenderGuards && portalNode && (0, import_jsx_runtime.jsx)("span", {
      "aria-owns": portalNode.id,
      style: HIDDEN_STYLES
    }), portalNode && ReactDOM2.createPortal(children, portalNode), shouldRenderGuards && portalNode && (0, import_jsx_runtime.jsx)(FocusGuard, {
      "data-type": "outside",
      ref: afterOutsideRef,
      onFocus: (event) => {
        if (isOutsideEvent(event, portalNode)) {
          var _afterInsideRef$curre;
          (_afterInsideRef$curre = afterInsideRef.current) == null || _afterInsideRef$curre.focus();
        } else {
          const domReference = focusManagerState ? focusManagerState.domReference : null;
          const nextTabbable = getNextTabbable(domReference);
          nextTabbable == null || nextTabbable.focus();
          (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent, "focus-out"));
        }
      }
    })]
  });
}
var usePortalContext = () => React3.useContext(PortalContext);
var VisuallyHiddenDismiss = React3.forwardRef(function VisuallyHiddenDismiss2(props, ref) {
  return (0, import_jsx_runtime.jsx)("button", {
    ...props,
    type: "button",
    ref,
    tabIndex: -1,
    style: HIDDEN_STYLES
  });
});
var lockCount = 0;
var scrollbarProperty = "--floating-ui-scrollbar-width";
function enableScrollLock() {
  const platform2 = getPlatform();
  const isIOS = /iP(hone|ad|od)|iOS/.test(platform2) || // iPads can claim to be MacIntel
  platform2 === "MacIntel" && navigator.maxTouchPoints > 1;
  const bodyStyle = document.body.style;
  const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;
  const paddingProp = scrollbarX ? "paddingLeft" : "paddingRight";
  const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
  const scrollX = bodyStyle.left ? parseFloat(bodyStyle.left) : window.scrollX;
  const scrollY = bodyStyle.top ? parseFloat(bodyStyle.top) : window.scrollY;
  bodyStyle.overflow = "hidden";
  bodyStyle.setProperty(scrollbarProperty, scrollbarWidth + "px");
  if (scrollbarWidth) {
    bodyStyle[paddingProp] = scrollbarWidth + "px";
  }
  if (isIOS) {
    var _window$visualViewpor, _window$visualViewpor2;
    const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;
    const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;
    Object.assign(bodyStyle, {
      position: "fixed",
      top: -(scrollY - Math.floor(offsetTop)) + "px",
      left: -(scrollX - Math.floor(offsetLeft)) + "px",
      right: "0"
    });
  }
  return () => {
    Object.assign(bodyStyle, {
      overflow: "",
      [paddingProp]: ""
    });
    bodyStyle.removeProperty(scrollbarProperty);
    if (isIOS) {
      Object.assign(bodyStyle, {
        position: "",
        top: "",
        left: "",
        right: ""
      });
      window.scrollTo(scrollX, scrollY);
    }
  };
}
var cleanup = () => {
};
var FloatingOverlay = React3.forwardRef(function FloatingOverlay2(props, ref) {
  const {
    lockScroll = false,
    ...rest
  } = props;
  index(() => {
    if (!lockScroll) return;
    lockCount++;
    if (lockCount === 1) {
      cleanup = enableScrollLock();
    }
    return () => {
      lockCount--;
      if (lockCount === 0) {
        cleanup();
      }
    };
  }, [lockScroll]);
  return (0, import_jsx_runtime.jsx)("div", {
    ref,
    ...rest,
    style: {
      position: "fixed",
      overflow: "auto",
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...rest.style
    }
  });
});
var bubbleHandlerKeys = {
  pointerdown: "onPointerDown",
  mousedown: "onMouseDown",
  click: "onClick"
};
var captureHandlerKeys = {
  pointerdown: "onPointerDownCapture",
  mousedown: "onMouseDownCapture",
  click: "onClickCapture"
};
var normalizeProp = (normalizable) => {
  var _normalizable$escapeK, _normalizable$outside;
  return {
    escapeKey: typeof normalizable === "boolean" ? normalizable : (_normalizable$escapeK = normalizable == null ? void 0 : normalizable.escapeKey) != null ? _normalizable$escapeK : false,
    outsidePress: typeof normalizable === "boolean" ? normalizable : (_normalizable$outside = normalizable == null ? void 0 : normalizable.outsidePress) != null ? _normalizable$outside : true
  };
};
function useDismiss(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    elements,
    dataRef
  } = context;
  const {
    enabled = true,
    escapeKey = true,
    outsidePress: unstable_outsidePress = true,
    outsidePressEvent = "pointerdown",
    referencePress = false,
    referencePressEvent = "pointerdown",
    ancestorScroll = false,
    bubbles,
    capture
  } = props;
  const tree = useFloatingTree();
  const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === "function" ? unstable_outsidePress : () => false);
  const outsidePress = typeof unstable_outsidePress === "function" ? outsidePressFn : unstable_outsidePress;
  const endedOrStartedInsideRef = React3.useRef(false);
  const {
    escapeKey: escapeKeyBubbles,
    outsidePress: outsidePressBubbles
  } = normalizeProp(bubbles);
  const {
    escapeKey: escapeKeyCapture,
    outsidePress: outsidePressCapture
  } = normalizeProp(capture);
  const isComposingRef = React3.useRef(false);
  const closeOnEscapeKeyDown = useEffectEvent((event) => {
    var _dataRef$current$floa;
    if (!open || !enabled || !escapeKey || event.key !== "Escape") {
      return;
    }
    if (isComposingRef.current) {
      return;
    }
    const nodeId = (_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.nodeId;
    const children = tree ? getNodeChildren(tree.nodesRef.current, nodeId) : [];
    if (!escapeKeyBubbles) {
      event.stopPropagation();
      if (children.length > 0) {
        let shouldDismiss = true;
        children.forEach((child) => {
          var _child$context;
          if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {
            shouldDismiss = false;
            return;
          }
        });
        if (!shouldDismiss) {
          return;
        }
      }
    }
    onOpenChange(false, isReactEvent(event) ? event.nativeEvent : event, "escape-key");
  });
  const closeOnEscapeKeyDownCapture = useEffectEvent((event) => {
    var _getTarget2;
    const callback = () => {
      var _getTarget;
      closeOnEscapeKeyDown(event);
      (_getTarget = getTarget(event)) == null || _getTarget.removeEventListener("keydown", callback);
    };
    (_getTarget2 = getTarget(event)) == null || _getTarget2.addEventListener("keydown", callback);
  });
  const closeOnPressOutside = useEffectEvent((event) => {
    var _dataRef$current$floa2;
    const insideReactTree = dataRef.current.insideReactTree;
    dataRef.current.insideReactTree = false;
    const endedOrStartedInside = endedOrStartedInsideRef.current;
    endedOrStartedInsideRef.current = false;
    if (outsidePressEvent === "click" && endedOrStartedInside) {
      return;
    }
    if (insideReactTree) {
      return;
    }
    if (typeof outsidePress === "function" && !outsidePress(event)) {
      return;
    }
    const target = getTarget(event);
    const inertSelector = "[" + createAttribute("inert") + "]";
    const markers = getDocument(elements.floating).querySelectorAll(inertSelector);
    let targetRootAncestor = isElement(target) ? target : null;
    while (targetRootAncestor && !isLastTraversableNode(targetRootAncestor)) {
      const nextParent = getParentNode(targetRootAncestor);
      if (isLastTraversableNode(nextParent) || !isElement(nextParent)) {
        break;
      }
      targetRootAncestor = nextParent;
    }
    if (markers.length && isElement(target) && !isRootElement(target) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
    !contains(target, elements.floating) && // If the target root element contains none of the markers, then the
    // element was injected after the floating element rendered.
    Array.from(markers).every((marker) => !contains(targetRootAncestor, marker))) {
      return;
    }
    if (isHTMLElement(target) && floating) {
      const lastTraversableNode = isLastTraversableNode(target);
      const style3 = getComputedStyle2(target);
      const scrollRe = /auto|scroll/;
      const isScrollableX = lastTraversableNode || scrollRe.test(style3.overflowX);
      const isScrollableY = lastTraversableNode || scrollRe.test(style3.overflowY);
      const canScrollX = isScrollableX && target.clientWidth > 0 && target.scrollWidth > target.clientWidth;
      const canScrollY = isScrollableY && target.clientHeight > 0 && target.scrollHeight > target.clientHeight;
      const isRTL2 = style3.direction === "rtl";
      const pressedVerticalScrollbar = canScrollY && (isRTL2 ? event.offsetX <= target.offsetWidth - target.clientWidth : event.offsetX > target.clientWidth);
      const pressedHorizontalScrollbar = canScrollX && event.offsetY > target.clientHeight;
      if (pressedVerticalScrollbar || pressedHorizontalScrollbar) {
        return;
      }
    }
    const nodeId = (_dataRef$current$floa2 = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa2.nodeId;
    const targetIsInsideChildren = tree && getNodeChildren(tree.nodesRef.current, nodeId).some((node2) => {
      var _node$context;
      return isEventTargetWithin(event, (_node$context = node2.context) == null ? void 0 : _node$context.elements.floating);
    });
    if (isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference) || targetIsInsideChildren) {
      return;
    }
    const children = tree ? getNodeChildren(tree.nodesRef.current, nodeId) : [];
    if (children.length > 0) {
      let shouldDismiss = true;
      children.forEach((child) => {
        var _child$context2;
        if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {
          shouldDismiss = false;
          return;
        }
      });
      if (!shouldDismiss) {
        return;
      }
    }
    onOpenChange(false, event, "outside-press");
  });
  const closeOnPressOutsideCapture = useEffectEvent((event) => {
    var _getTarget4;
    const callback = () => {
      var _getTarget3;
      closeOnPressOutside(event);
      (_getTarget3 = getTarget(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);
    };
    (_getTarget4 = getTarget(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);
  });
  React3.useEffect(() => {
    if (!open || !enabled) {
      return;
    }
    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;
    dataRef.current.__outsidePressBubbles = outsidePressBubbles;
    let compositionTimeout = -1;
    function onScroll(event) {
      onOpenChange(false, event, "ancestor-scroll");
    }
    function handleCompositionStart() {
      window.clearTimeout(compositionTimeout);
      isComposingRef.current = true;
    }
    function handleCompositionEnd() {
      compositionTimeout = window.setTimeout(
        () => {
          isComposingRef.current = false;
        },
        // 0ms or 1ms don't work in Safari. 5ms appears to consistently work.
        // Only apply to WebKit for the test to remain 0ms.
        isWebKit() ? 5 : 0
      );
    }
    const doc2 = getDocument(elements.floating);
    if (escapeKey) {
      doc2.addEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);
      doc2.addEventListener("compositionstart", handleCompositionStart);
      doc2.addEventListener("compositionend", handleCompositionEnd);
    }
    outsidePress && doc2.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);
    let ancestors = [];
    if (ancestorScroll) {
      if (isElement(elements.domReference)) {
        ancestors = getOverflowAncestors(elements.domReference);
      }
      if (isElement(elements.floating)) {
        ancestors = ancestors.concat(getOverflowAncestors(elements.floating));
      }
      if (!isElement(elements.reference) && elements.reference && elements.reference.contextElement) {
        ancestors = ancestors.concat(getOverflowAncestors(elements.reference.contextElement));
      }
    }
    ancestors = ancestors.filter((ancestor) => {
      var _doc$defaultView;
      return ancestor !== ((_doc$defaultView = doc2.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);
    });
    ancestors.forEach((ancestor) => {
      ancestor.addEventListener("scroll", onScroll, {
        passive: true
      });
    });
    return () => {
      if (escapeKey) {
        doc2.removeEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);
        doc2.removeEventListener("compositionstart", handleCompositionStart);
        doc2.removeEventListener("compositionend", handleCompositionEnd);
      }
      outsidePress && doc2.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);
      ancestors.forEach((ancestor) => {
        ancestor.removeEventListener("scroll", onScroll);
      });
      window.clearTimeout(compositionTimeout);
    };
  }, [dataRef, elements, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture]);
  React3.useEffect(() => {
    dataRef.current.insideReactTree = false;
  }, [dataRef, outsidePress, outsidePressEvent]);
  const reference = React3.useMemo(() => ({
    onKeyDown: closeOnEscapeKeyDown,
    ...referencePress && {
      [bubbleHandlerKeys[referencePressEvent]]: (event) => {
        onOpenChange(false, event.nativeEvent, "reference-press");
      },
      ...referencePressEvent !== "click" && {
        onClick(event) {
          onOpenChange(false, event.nativeEvent, "reference-press");
        }
      }
    }
  }), [closeOnEscapeKeyDown, onOpenChange, referencePress, referencePressEvent]);
  const floating = React3.useMemo(() => ({
    onKeyDown: closeOnEscapeKeyDown,
    onMouseDown() {
      endedOrStartedInsideRef.current = true;
    },
    onMouseUp() {
      endedOrStartedInsideRef.current = true;
    },
    [captureHandlerKeys[outsidePressEvent]]: () => {
      dataRef.current.insideReactTree = true;
    }
  }), [closeOnEscapeKeyDown, outsidePressEvent, dataRef]);
  return React3.useMemo(() => enabled ? {
    reference,
    floating
  } : {}, [enabled, reference, floating]);
}
function useFloatingRootContext(options) {
  const {
    open = false,
    onOpenChange: onOpenChangeProp,
    elements: elementsProp
  } = options;
  const floatingId = useId();
  const dataRef = React3.useRef({});
  const [events] = React3.useState(() => createEventEmitter());
  const nested = useFloatingParentNodeId() != null;
  if (true) {
    const optionDomReference = elementsProp.reference;
    if (optionDomReference && !isElement(optionDomReference)) {
      error("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
    }
  }
  const [positionReference, setPositionReference] = React3.useState(elementsProp.reference);
  const onOpenChange = useEffectEvent((open2, event, reason) => {
    dataRef.current.openEvent = open2 ? event : void 0;
    events.emit("openchange", {
      open: open2,
      event,
      reason,
      nested
    });
    onOpenChangeProp == null || onOpenChangeProp(open2, event, reason);
  });
  const refs = React3.useMemo(() => ({
    setPositionReference
  }), []);
  const elements = React3.useMemo(() => ({
    reference: positionReference || elementsProp.reference || null,
    floating: elementsProp.floating || null,
    domReference: elementsProp.reference
  }), [positionReference, elementsProp.reference, elementsProp.floating]);
  return React3.useMemo(() => ({
    dataRef,
    open,
    onOpenChange,
    elements,
    events,
    floatingId,
    refs
  }), [open, onOpenChange, elements, events, floatingId, refs]);
}
function useFloating2(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    nodeId
  } = options;
  const internalRootContext = useFloatingRootContext({
    ...options,
    elements: {
      reference: null,
      floating: null,
      ...options.elements
    }
  });
  const rootContext = options.rootContext || internalRootContext;
  const computedElements = rootContext.elements;
  const [_domReference, setDomReference] = React3.useState(null);
  const [positionReference, _setPositionReference] = React3.useState(null);
  const optionDomReference = computedElements == null ? void 0 : computedElements.domReference;
  const domReference = optionDomReference || _domReference;
  const domReferenceRef = React3.useRef(null);
  const tree = useFloatingTree();
  index(() => {
    if (domReference) {
      domReferenceRef.current = domReference;
    }
  }, [domReference]);
  const position4 = useFloating({
    ...options,
    elements: {
      ...computedElements,
      ...positionReference && {
        reference: positionReference
      }
    }
  });
  const setPositionReference = React3.useCallback((node2) => {
    const computedPositionReference = isElement(node2) ? {
      getBoundingClientRect: () => node2.getBoundingClientRect(),
      getClientRects: () => node2.getClientRects(),
      contextElement: node2
    } : node2;
    _setPositionReference(computedPositionReference);
    position4.refs.setReference(computedPositionReference);
  }, [position4.refs]);
  const setReference = React3.useCallback((node2) => {
    if (isElement(node2) || node2 === null) {
      domReferenceRef.current = node2;
      setDomReference(node2);
    }
    if (isElement(position4.refs.reference.current) || position4.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node2 !== null && !isElement(node2)) {
      position4.refs.setReference(node2);
    }
  }, [position4.refs]);
  const refs = React3.useMemo(() => ({
    ...position4.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position4.refs, setReference, setPositionReference]);
  const elements = React3.useMemo(() => ({
    ...position4.elements,
    domReference
  }), [position4.elements, domReference]);
  const context = React3.useMemo(() => ({
    ...position4,
    ...rootContext,
    refs,
    elements,
    nodeId
  }), [position4, refs, elements, nodeId, rootContext]);
  index(() => {
    rootContext.dataRef.current.floatingContext = context;
    const node2 = tree == null ? void 0 : tree.nodesRef.current.find((node3) => node3.id === nodeId);
    if (node2) {
      node2.context = context;
    }
  });
  return React3.useMemo(() => ({
    ...position4,
    context,
    refs,
    elements
  }), [position4, refs, elements, context]);
}
function isMacSafari() {
  return isMac() && isSafari();
}
function useFocus(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    events,
    dataRef,
    elements
  } = context;
  const {
    enabled = true,
    visibleOnly = true
  } = props;
  const blockFocusRef = React3.useRef(false);
  const timeoutRef = React3.useRef(-1);
  const keyboardModalityRef = React3.useRef(true);
  React3.useEffect(() => {
    if (!enabled) return;
    const win = getWindow(elements.domReference);
    function onBlur() {
      if (!open && isHTMLElement(elements.domReference) && elements.domReference === activeElement(getDocument(elements.domReference))) {
        blockFocusRef.current = true;
      }
    }
    function onKeyDown() {
      keyboardModalityRef.current = true;
    }
    function onPointerDown() {
      keyboardModalityRef.current = false;
    }
    win.addEventListener("blur", onBlur);
    if (isMacSafari()) {
      win.addEventListener("keydown", onKeyDown, true);
      win.addEventListener("pointerdown", onPointerDown, true);
    }
    return () => {
      win.removeEventListener("blur", onBlur);
      if (isMacSafari()) {
        win.removeEventListener("keydown", onKeyDown, true);
        win.removeEventListener("pointerdown", onPointerDown, true);
      }
    };
  }, [elements.domReference, open, enabled]);
  React3.useEffect(() => {
    if (!enabled) return;
    function onOpenChange2(_ref) {
      let {
        reason
      } = _ref;
      if (reason === "reference-press" || reason === "escape-key") {
        blockFocusRef.current = true;
      }
    }
    events.on("openchange", onOpenChange2);
    return () => {
      events.off("openchange", onOpenChange2);
    };
  }, [events, enabled]);
  React3.useEffect(() => {
    return () => {
      clearTimeoutIfSet(timeoutRef);
    };
  }, []);
  const reference = React3.useMemo(() => ({
    onMouseLeave() {
      blockFocusRef.current = false;
    },
    onFocus(event) {
      if (blockFocusRef.current) return;
      const target = getTarget(event.nativeEvent);
      if (visibleOnly && isElement(target)) {
        if (isMacSafari() && !event.relatedTarget) {
          if (!keyboardModalityRef.current && !isTypeableElement(target)) {
            return;
          }
        } else if (!matchesFocusVisible(target)) {
          return;
        }
      }
      onOpenChange(true, event.nativeEvent, "focus");
    },
    onBlur(event) {
      blockFocusRef.current = false;
      const relatedTarget = event.relatedTarget;
      const nativeEvent = event.nativeEvent;
      const movedToFocusGuard = isElement(relatedTarget) && relatedTarget.hasAttribute(createAttribute("focus-guard")) && relatedTarget.getAttribute("data-type") === "outside";
      timeoutRef.current = window.setTimeout(() => {
        var _dataRef$current$floa;
        const activeEl = activeElement(elements.domReference ? elements.domReference.ownerDocument : document);
        if (!relatedTarget && activeEl === elements.domReference) return;
        if (contains((_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.refs.floating.current, activeEl) || contains(elements.domReference, activeEl) || movedToFocusGuard) {
          return;
        }
        onOpenChange(false, nativeEvent, "focus");
      });
    }
  }), [dataRef, elements.domReference, onOpenChange, visibleOnly]);
  return React3.useMemo(() => enabled ? {
    reference
  } : {}, [enabled, reference]);
}
function mergeProps(userProps, propsList, elementKey) {
  const map6 = /* @__PURE__ */ new Map();
  const isItem = elementKey === "item";
  let domUserProps = userProps;
  if (isItem && userProps) {
    const {
      [ACTIVE_KEY]: _,
      [SELECTED_KEY]: __,
      ...validProps
    } = userProps;
    domUserProps = validProps;
  }
  return {
    ...elementKey === "floating" && {
      tabIndex: -1,
      [FOCUSABLE_ATTRIBUTE2]: ""
    },
    ...domUserProps,
    ...propsList.map((value) => {
      const propsOrGetProps = value ? value[elementKey] : null;
      if (typeof propsOrGetProps === "function") {
        return userProps ? propsOrGetProps(userProps) : null;
      }
      return propsOrGetProps;
    }).concat(userProps).reduce((acc, props) => {
      if (!props) {
        return acc;
      }
      Object.entries(props).forEach((_ref) => {
        let [key2, value] = _ref;
        if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key2)) {
          return;
        }
        if (key2.indexOf("on") === 0) {
          if (!map6.has(key2)) {
            map6.set(key2, []);
          }
          if (typeof value === "function") {
            var _map$get;
            (_map$get = map6.get(key2)) == null || _map$get.push(value);
            acc[key2] = function() {
              var _map$get2;
              for (var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++) {
                args2[_key] = arguments[_key];
              }
              return (_map$get2 = map6.get(key2)) == null ? void 0 : _map$get2.map((fn3) => fn3(...args2)).find((val) => val !== void 0);
            };
          }
        } else {
          acc[key2] = value;
        }
      });
      return acc;
    }, {})
  };
}
function useInteractions(propsList) {
  if (propsList === void 0) {
    propsList = [];
  }
  const referenceDeps = propsList.map((key2) => key2 == null ? void 0 : key2.reference);
  const floatingDeps = propsList.map((key2) => key2 == null ? void 0 : key2.floating);
  const itemDeps = propsList.map((key2) => key2 == null ? void 0 : key2.item);
  const getReferenceProps = React3.useCallback(
    (userProps) => mergeProps(userProps, propsList, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    referenceDeps
  );
  const getFloatingProps = React3.useCallback(
    (userProps) => mergeProps(userProps, propsList, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    floatingDeps
  );
  const getItemProps = React3.useCallback(
    (userProps) => mergeProps(userProps, propsList, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    itemDeps
  );
  return React3.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
}
var componentRoleToAriaRoleMap = /* @__PURE__ */ new Map([["select", "listbox"], ["combobox", "listbox"], ["label", false]]);
function useRole(context, props) {
  var _elements$domReferenc, _componentRoleToAriaR;
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    elements,
    floatingId: defaultFloatingId
  } = context;
  const {
    enabled = true,
    role = "dialog"
  } = props;
  const defaultReferenceId = useId();
  const referenceId = ((_elements$domReferenc = elements.domReference) == null ? void 0 : _elements$domReferenc.id) || defaultReferenceId;
  const floatingId = React3.useMemo(() => {
    var _getFloatingFocusElem;
    return ((_getFloatingFocusElem = getFloatingFocusElement(elements.floating)) == null ? void 0 : _getFloatingFocusElem.id) || defaultFloatingId;
  }, [elements.floating, defaultFloatingId]);
  const ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role;
  const parentId = useFloatingParentNodeId();
  const isNested = parentId != null;
  const reference = React3.useMemo(() => {
    if (ariaRole === "tooltip" || role === "label") {
      return {
        ["aria-" + (role === "label" ? "labelledby" : "describedby")]: open ? floatingId : void 0
      };
    }
    return {
      "aria-expanded": open ? "true" : "false",
      "aria-haspopup": ariaRole === "alertdialog" ? "dialog" : ariaRole,
      "aria-controls": open ? floatingId : void 0,
      ...ariaRole === "listbox" && {
        role: "combobox"
      },
      ...ariaRole === "menu" && {
        id: referenceId
      },
      ...ariaRole === "menu" && isNested && {
        role: "menuitem"
      },
      ...role === "select" && {
        "aria-autocomplete": "none"
      },
      ...role === "combobox" && {
        "aria-autocomplete": "list"
      }
    };
  }, [ariaRole, floatingId, isNested, open, referenceId, role]);
  const floating = React3.useMemo(() => {
    const floatingProps = {
      id: floatingId,
      ...ariaRole && {
        role: ariaRole
      }
    };
    if (ariaRole === "tooltip" || role === "label") {
      return floatingProps;
    }
    return {
      ...floatingProps,
      ...ariaRole === "menu" && {
        "aria-labelledby": referenceId
      }
    };
  }, [ariaRole, floatingId, referenceId, role]);
  const item = React3.useCallback((_ref) => {
    let {
      active,
      selected
    } = _ref;
    const commonProps = {
      role: "option",
      ...active && {
        id: floatingId + "-fui-option"
      }
    };
    switch (role) {
      case "select":
      case "combobox":
        return {
          ...commonProps,
          "aria-selected": selected
        };
    }
    return {};
  }, [floatingId, role]);
  return React3.useMemo(() => enabled ? {
    reference,
    floating,
    item
  } : {}, [enabled, reference, floating, item]);
}
var camelCaseToKebabCase = (str) => str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($3, ofs) => (ofs ? "-" : "") + $3.toLowerCase());
function execWithArgsOrReturn(valueOrFn, args2) {
  return typeof valueOrFn === "function" ? valueOrFn(args2) : valueOrFn;
}
function useDelayUnmount(open, durationMs) {
  const [isMounted, setIsMounted] = React3.useState(open);
  if (open && !isMounted) {
    setIsMounted(true);
  }
  React3.useEffect(() => {
    if (!open && isMounted) {
      const timeout2 = setTimeout(() => setIsMounted(false), durationMs);
      return () => clearTimeout(timeout2);
    }
  }, [open, isMounted, durationMs]);
  return isMounted;
}
function useTransitionStatus(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    elements: {
      floating
    }
  } = context;
  const {
    duration = 250
  } = props;
  const isNumberDuration = typeof duration === "number";
  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;
  const [status, setStatus] = React3.useState("unmounted");
  const isMounted = useDelayUnmount(open, closeDuration);
  if (!isMounted && status === "close") {
    setStatus("unmounted");
  }
  index(() => {
    if (!floating) return;
    if (open) {
      setStatus("initial");
      const frame = requestAnimationFrame(() => {
        ReactDOM2.flushSync(() => {
          setStatus("open");
        });
      });
      return () => {
        cancelAnimationFrame(frame);
      };
    }
    setStatus("close");
  }, [open, floating]);
  return {
    isMounted,
    status
  };
}
function useTransitionStyles(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    initial: unstable_initial = {
      opacity: 0
    },
    open: unstable_open,
    close: unstable_close,
    common: unstable_common,
    duration = 250
  } = props;
  const placement = context.placement;
  const side = placement.split("-")[0];
  const fnArgs = React3.useMemo(() => ({
    side,
    placement
  }), [side, placement]);
  const isNumberDuration = typeof duration === "number";
  const openDuration = (isNumberDuration ? duration : duration.open) || 0;
  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;
  const [styles, setStyles] = React3.useState(() => ({
    ...execWithArgsOrReturn(unstable_common, fnArgs),
    ...execWithArgsOrReturn(unstable_initial, fnArgs)
  }));
  const {
    isMounted,
    status
  } = useTransitionStatus(context, {
    duration
  });
  const initialRef = useLatestRef(unstable_initial);
  const openRef = useLatestRef(unstable_open);
  const closeRef = useLatestRef(unstable_close);
  const commonRef = useLatestRef(unstable_common);
  index(() => {
    const initialStyles = execWithArgsOrReturn(initialRef.current, fnArgs);
    const closeStyles = execWithArgsOrReturn(closeRef.current, fnArgs);
    const commonStyles = execWithArgsOrReturn(commonRef.current, fnArgs);
    const openStyles = execWithArgsOrReturn(openRef.current, fnArgs) || Object.keys(initialStyles).reduce((acc, key2) => {
      acc[key2] = "";
      return acc;
    }, {});
    if (status === "initial") {
      setStyles((styles2) => ({
        transitionProperty: styles2.transitionProperty,
        ...commonStyles,
        ...initialStyles
      }));
    }
    if (status === "open") {
      setStyles({
        transitionProperty: Object.keys(openStyles).map(camelCaseToKebabCase).join(","),
        transitionDuration: openDuration + "ms",
        ...commonStyles,
        ...openStyles
      });
    }
    if (status === "close") {
      const styles2 = closeStyles || initialStyles;
      setStyles({
        transitionProperty: Object.keys(styles2).map(camelCaseToKebabCase).join(","),
        transitionDuration: closeDuration + "ms",
        ...commonStyles,
        ...styles2
      });
    }
  }, [closeDuration, closeRef, initialRef, openRef, commonRef, openDuration, status, fnArgs]);
  return {
    isMounted,
    styles
  };
}

// ../node_modules/.pnpm/prosemirror-tables@1.8.1/node_modules/prosemirror-tables/dist/index.js
var readFromCache;
var addToCache;
if (typeof WeakMap != "undefined") {
  let cache = /* @__PURE__ */ new WeakMap();
  readFromCache = (key2) => cache.get(key2);
  addToCache = (key2, value) => {
    cache.set(key2, value);
    return value;
  };
} else {
  const cache = [];
  const cacheSize = 10;
  let cachePos = 0;
  readFromCache = (key2) => {
    for (let i2 = 0; i2 < cache.length; i2 += 2)
      if (cache[i2] == key2) return cache[i2 + 1];
  };
  addToCache = (key2, value) => {
    if (cachePos == cacheSize) cachePos = 0;
    cache[cachePos++] = key2;
    return cache[cachePos++] = value;
  };
}
var TableMap = class {
  constructor(width, height, map6, problems) {
    this.width = width;
    this.height = height;
    this.map = map6;
    this.problems = problems;
  }
  // Find the dimensions of the cell at the given position.
  findCell(pos) {
    for (let i2 = 0; i2 < this.map.length; i2++) {
      const curPos = this.map[i2];
      if (curPos != pos) continue;
      const left = i2 % this.width;
      const top = i2 / this.width | 0;
      let right = left + 1;
      let bottom = top + 1;
      for (let j5 = 1; right < this.width && this.map[i2 + j5] == curPos; j5++) {
        right++;
      }
      for (let j5 = 1; bottom < this.height && this.map[i2 + this.width * j5] == curPos; j5++) {
        bottom++;
      }
      return { left, top, right, bottom };
    }
    throw new RangeError(`No cell with offset ${pos} found`);
  }
  // Find the left side of the cell at the given position.
  colCount(pos) {
    for (let i2 = 0; i2 < this.map.length; i2++) {
      if (this.map[i2] == pos) {
        return i2 % this.width;
      }
    }
    throw new RangeError(`No cell with offset ${pos} found`);
  }
  // Find the next cell in the given direction, starting from the cell
  // at `pos`, if any.
  nextCell(pos, axis, dir) {
    const { left, right, top, bottom } = this.findCell(pos);
    if (axis == "horiz") {
      if (dir < 0 ? left == 0 : right == this.width) return null;
      return this.map[top * this.width + (dir < 0 ? left - 1 : right)];
    } else {
      if (dir < 0 ? top == 0 : bottom == this.height) return null;
      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];
    }
  }
  // Get the rectangle spanning the two given cells.
  rectBetween(a2, b2) {
    const {
      left: leftA,
      right: rightA,
      top: topA,
      bottom: bottomA
    } = this.findCell(a2);
    const {
      left: leftB,
      right: rightB,
      top: topB,
      bottom: bottomB
    } = this.findCell(b2);
    return {
      left: Math.min(leftA, leftB),
      top: Math.min(topA, topB),
      right: Math.max(rightA, rightB),
      bottom: Math.max(bottomA, bottomB)
    };
  }
  // Return the position of all cells that have the top left corner in
  // the given rectangle.
  cellsInRect(rect) {
    const result = [];
    const seen = {};
    for (let row2 = rect.top; row2 < rect.bottom; row2++) {
      for (let col = rect.left; col < rect.right; col++) {
        const index4 = row2 * this.width + col;
        const pos = this.map[index4];
        if (seen[pos]) continue;
        seen[pos] = true;
        if (col == rect.left && col && this.map[index4 - 1] == pos || row2 == rect.top && row2 && this.map[index4 - this.width] == pos) {
          continue;
        }
        result.push(pos);
      }
    }
    return result;
  }
  // Return the position at which the cell at the given row and column
  // starts, or would start, if a cell started there.
  positionAt(row2, col, table3) {
    for (let i2 = 0, rowStart = 0; ; i2++) {
      const rowEnd = rowStart + table3.child(i2).nodeSize;
      if (i2 == row2) {
        let index4 = col + row2 * this.width;
        const rowEndIndex = (row2 + 1) * this.width;
        while (index4 < rowEndIndex && this.map[index4] < rowStart) index4++;
        return index4 == rowEndIndex ? rowEnd - 1 : this.map[index4];
      }
      rowStart = rowEnd;
    }
  }
  // Find the table map for the given table node.
  static get(table3) {
    return readFromCache(table3) || addToCache(table3, computeMap(table3));
  }
};
function computeMap(table3) {
  if (table3.type.spec.tableRole != "table")
    throw new RangeError("Not a table node: " + table3.type.name);
  const width = findWidth(table3), height = table3.childCount;
  const map6 = [];
  let mapPos = 0;
  let problems = null;
  const colWidths = [];
  for (let i2 = 0, e = width * height; i2 < e; i2++) map6[i2] = 0;
  for (let row2 = 0, pos = 0; row2 < height; row2++) {
    const rowNode = table3.child(row2);
    pos++;
    for (let i2 = 0; ; i2++) {
      while (mapPos < map6.length && map6[mapPos] != 0) mapPos++;
      if (i2 == rowNode.childCount) break;
      const cellNode = rowNode.child(i2);
      const { colspan, rowspan, colwidth } = cellNode.attrs;
      for (let h4 = 0; h4 < rowspan; h4++) {
        if (h4 + row2 >= height) {
          (problems || (problems = [])).push({
            type: "overlong_rowspan",
            pos,
            n: rowspan - h4
          });
          break;
        }
        const start = mapPos + h4 * width;
        for (let w3 = 0; w3 < colspan; w3++) {
          if (map6[start + w3] == 0) map6[start + w3] = pos;
          else
            (problems || (problems = [])).push({
              type: "collision",
              row: row2,
              pos,
              n: colspan - w3
            });
          const colW = colwidth && colwidth[w3];
          if (colW) {
            const widthIndex = (start + w3) % width * 2, prev = colWidths[widthIndex];
            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {
              colWidths[widthIndex] = colW;
              colWidths[widthIndex + 1] = 1;
            } else if (prev == colW) {
              colWidths[widthIndex + 1]++;
            }
          }
        }
      }
      mapPos += colspan;
      pos += cellNode.nodeSize;
    }
    const expectedPos = (row2 + 1) * width;
    let missing = 0;
    while (mapPos < expectedPos) if (map6[mapPos++] == 0) missing++;
    if (missing)
      (problems || (problems = [])).push({ type: "missing", row: row2, n: missing });
    pos++;
  }
  if (width === 0 || height === 0)
    (problems || (problems = [])).push({ type: "zero_sized" });
  const tableMap = new TableMap(width, height, map6, problems);
  let badWidths = false;
  for (let i2 = 0; !badWidths && i2 < colWidths.length; i2 += 2)
    if (colWidths[i2] != null && colWidths[i2 + 1] < height) badWidths = true;
  if (badWidths) findBadColWidths(tableMap, colWidths, table3);
  return tableMap;
}
function findWidth(table3) {
  let width = -1;
  let hasRowSpan = false;
  for (let row2 = 0; row2 < table3.childCount; row2++) {
    const rowNode = table3.child(row2);
    let rowWidth = 0;
    if (hasRowSpan)
      for (let j5 = 0; j5 < row2; j5++) {
        const prevRow = table3.child(j5);
        for (let i2 = 0; i2 < prevRow.childCount; i2++) {
          const cell2 = prevRow.child(i2);
          if (j5 + cell2.attrs.rowspan > row2) rowWidth += cell2.attrs.colspan;
        }
      }
    for (let i2 = 0; i2 < rowNode.childCount; i2++) {
      const cell2 = rowNode.child(i2);
      rowWidth += cell2.attrs.colspan;
      if (cell2.attrs.rowspan > 1) hasRowSpan = true;
    }
    if (width == -1) width = rowWidth;
    else if (width != rowWidth) width = Math.max(width, rowWidth);
  }
  return width;
}
function findBadColWidths(map6, colWidths, table3) {
  if (!map6.problems) map6.problems = [];
  const seen = {};
  for (let i2 = 0; i2 < map6.map.length; i2++) {
    const pos = map6.map[i2];
    if (seen[pos]) continue;
    seen[pos] = true;
    const node2 = table3.nodeAt(pos);
    if (!node2) {
      throw new RangeError(`No cell with offset ${pos} found`);
    }
    let updated = null;
    const attrs = node2.attrs;
    for (let j5 = 0; j5 < attrs.colspan; j5++) {
      const col = (i2 + j5) % map6.width;
      const colWidth = colWidths[col * 2];
      if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j5] != colWidth))
        (updated || (updated = freshColWidth(attrs)))[j5] = colWidth;
    }
    if (updated)
      map6.problems.unshift({
        type: "colwidth mismatch",
        pos,
        colwidth: updated
      });
  }
}
function freshColWidth(attrs) {
  if (attrs.colwidth) return attrs.colwidth.slice();
  const result = [];
  for (let i2 = 0; i2 < attrs.colspan; i2++) result.push(0);
  return result;
}
function tableNodeTypes(schema) {
  let result = schema.cached.tableNodeTypes;
  if (!result) {
    result = schema.cached.tableNodeTypes = {};
    for (const name in schema.nodes) {
      const type = schema.nodes[name], role = type.spec.tableRole;
      if (role) result[role] = type;
    }
  }
  return result;
}
var tableEditingKey = new PluginKey("selectingCells");
function cellAround($pos) {
  for (let d = $pos.depth - 1; d > 0; d--)
    if ($pos.node(d).type.spec.tableRole == "row")
      return $pos.node(0).resolve($pos.before(d + 1));
  return null;
}
function cellWrapping($pos) {
  for (let d = $pos.depth; d > 0; d--) {
    const role = $pos.node(d).type.spec.tableRole;
    if (role === "cell" || role === "header_cell") return $pos.node(d);
  }
  return null;
}
function isInTable(state) {
  const $head = state.selection.$head;
  for (let d = $head.depth; d > 0; d--)
    if ($head.node(d).type.spec.tableRole == "row") return true;
  return false;
}
function selectionCell(state) {
  const sel = state.selection;
  if ("$anchorCell" in sel && sel.$anchorCell) {
    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;
  } else if ("node" in sel && sel.node && sel.node.type.spec.tableRole == "cell") {
    return sel.$anchor;
  }
  const $cell = cellAround(sel.$head) || cellNear(sel.$head);
  if ($cell) {
    return $cell;
  }
  throw new RangeError(`No cell found around position ${sel.head}`);
}
function cellNear($pos) {
  for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {
    const role = after.type.spec.tableRole;
    if (role == "cell" || role == "header_cell") return $pos.doc.resolve(pos);
  }
  for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {
    const role = before.type.spec.tableRole;
    if (role == "cell" || role == "header_cell")
      return $pos.doc.resolve(pos - before.nodeSize);
  }
}
function pointsAtCell($pos) {
  return $pos.parent.type.spec.tableRole == "row" && !!$pos.nodeAfter;
}
function moveCellForward($pos) {
  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);
}
function inSameTable($cellA, $cellB) {
  return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);
}
function nextCell($pos, axis, dir) {
  const table3 = $pos.node(-1);
  const map6 = TableMap.get(table3);
  const tableStart = $pos.start(-1);
  const moved = map6.nextCell($pos.pos - tableStart, axis, dir);
  return moved == null ? null : $pos.node(0).resolve(tableStart + moved);
}
function removeColSpan(attrs, pos, n = 1) {
  const result = { ...attrs, colspan: attrs.colspan - n };
  if (result.colwidth) {
    result.colwidth = result.colwidth.slice();
    result.colwidth.splice(pos, n);
    if (!result.colwidth.some((w3) => w3 > 0)) result.colwidth = null;
  }
  return result;
}
function addColSpan(attrs, pos, n = 1) {
  const result = { ...attrs, colspan: attrs.colspan + n };
  if (result.colwidth) {
    result.colwidth = result.colwidth.slice();
    for (let i2 = 0; i2 < n; i2++) result.colwidth.splice(pos, 0, 0);
  }
  return result;
}
function columnIsHeader(map6, table3, col) {
  const headerCell = tableNodeTypes(table3.type.schema).header_cell;
  for (let row2 = 0; row2 < map6.height; row2++)
    if (table3.nodeAt(map6.map[col + row2 * map6.width]).type != headerCell)
      return false;
  return true;
}
var CellSelection = class _CellSelection extends Selection {
  // A table selection is identified by its anchor and head cells. The
  // positions given to this constructor should point _before_ two
  // cells in the same table. They may be the same, to select a single
  // cell.
  constructor($anchorCell, $headCell = $anchorCell) {
    const table3 = $anchorCell.node(-1);
    const map6 = TableMap.get(table3);
    const tableStart = $anchorCell.start(-1);
    const rect = map6.rectBetween(
      $anchorCell.pos - tableStart,
      $headCell.pos - tableStart
    );
    const doc2 = $anchorCell.node(0);
    const cells2 = map6.cellsInRect(rect).filter((p5) => p5 != $headCell.pos - tableStart);
    cells2.unshift($headCell.pos - tableStart);
    const ranges = cells2.map((pos) => {
      const cell2 = table3.nodeAt(pos);
      if (!cell2) {
        throw RangeError(`No cell with offset ${pos} found`);
      }
      const from3 = tableStart + pos + 1;
      return new SelectionRange(
        doc2.resolve(from3),
        doc2.resolve(from3 + cell2.content.size)
      );
    });
    super(ranges[0].$from, ranges[0].$to, ranges);
    this.$anchorCell = $anchorCell;
    this.$headCell = $headCell;
  }
  map(doc2, mapping) {
    const $anchorCell = doc2.resolve(mapping.map(this.$anchorCell.pos));
    const $headCell = doc2.resolve(mapping.map(this.$headCell.pos));
    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {
      const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);
      if (tableChanged && this.isRowSelection())
        return _CellSelection.rowSelection($anchorCell, $headCell);
      else if (tableChanged && this.isColSelection())
        return _CellSelection.colSelection($anchorCell, $headCell);
      else return new _CellSelection($anchorCell, $headCell);
    }
    return TextSelection.between($anchorCell, $headCell);
  }
  // Returns a rectangular slice of table rows containing the selected
  // cells.
  content() {
    const table3 = this.$anchorCell.node(-1);
    const map6 = TableMap.get(table3);
    const tableStart = this.$anchorCell.start(-1);
    const rect = map6.rectBetween(
      this.$anchorCell.pos - tableStart,
      this.$headCell.pos - tableStart
    );
    const seen = {};
    const rows = [];
    for (let row2 = rect.top; row2 < rect.bottom; row2++) {
      const rowContent = [];
      for (let index4 = row2 * map6.width + rect.left, col = rect.left; col < rect.right; col++, index4++) {
        const pos = map6.map[index4];
        if (seen[pos]) continue;
        seen[pos] = true;
        const cellRect = map6.findCell(pos);
        let cell2 = table3.nodeAt(pos);
        if (!cell2) {
          throw RangeError(`No cell with offset ${pos} found`);
        }
        const extraLeft = rect.left - cellRect.left;
        const extraRight = cellRect.right - rect.right;
        if (extraLeft > 0 || extraRight > 0) {
          let attrs = cell2.attrs;
          if (extraLeft > 0) {
            attrs = removeColSpan(attrs, 0, extraLeft);
          }
          if (extraRight > 0) {
            attrs = removeColSpan(
              attrs,
              attrs.colspan - extraRight,
              extraRight
            );
          }
          if (cellRect.left < rect.left) {
            cell2 = cell2.type.createAndFill(attrs);
            if (!cell2) {
              throw RangeError(
                `Could not create cell with attrs ${JSON.stringify(attrs)}`
              );
            }
          } else {
            cell2 = cell2.type.create(attrs, cell2.content);
          }
        }
        if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {
          const attrs = {
            ...cell2.attrs,
            rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)
          };
          if (cellRect.top < rect.top) {
            cell2 = cell2.type.createAndFill(attrs);
          } else {
            cell2 = cell2.type.create(attrs, cell2.content);
          }
        }
        rowContent.push(cell2);
      }
      rows.push(table3.child(row2).copy(Fragment.from(rowContent)));
    }
    const fragment = this.isColSelection() && this.isRowSelection() ? table3 : rows;
    return new Slice(Fragment.from(fragment), 1, 1);
  }
  replace(tr5, content5 = Slice.empty) {
    const mapFrom = tr5.steps.length, ranges = this.ranges;
    for (let i2 = 0; i2 < ranges.length; i2++) {
      const { $from, $to } = ranges[i2], mapping = tr5.mapping.slice(mapFrom);
      tr5.replace(
        mapping.map($from.pos),
        mapping.map($to.pos),
        i2 ? Slice.empty : content5
      );
    }
    const sel = Selection.findFrom(
      tr5.doc.resolve(tr5.mapping.slice(mapFrom).map(this.to)),
      -1
    );
    if (sel) tr5.setSelection(sel);
  }
  replaceWith(tr5, node2) {
    this.replace(tr5, new Slice(Fragment.from(node2), 0, 0));
  }
  forEachCell(f2) {
    const table3 = this.$anchorCell.node(-1);
    const map6 = TableMap.get(table3);
    const tableStart = this.$anchorCell.start(-1);
    const cells2 = map6.cellsInRect(
      map6.rectBetween(
        this.$anchorCell.pos - tableStart,
        this.$headCell.pos - tableStart
      )
    );
    for (let i2 = 0; i2 < cells2.length; i2++) {
      f2(table3.nodeAt(cells2[i2]), tableStart + cells2[i2]);
    }
  }
  // True if this selection goes all the way from the top to the
  // bottom of the table.
  isColSelection() {
    const anchorTop = this.$anchorCell.index(-1);
    const headTop = this.$headCell.index(-1);
    if (Math.min(anchorTop, headTop) > 0) return false;
    const anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;
    const headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;
  }
  // Returns the smallest column selection that covers the given anchor
  // and head cell.
  static colSelection($anchorCell, $headCell = $anchorCell) {
    const table3 = $anchorCell.node(-1);
    const map6 = TableMap.get(table3);
    const tableStart = $anchorCell.start(-1);
    const anchorRect = map6.findCell($anchorCell.pos - tableStart);
    const headRect = map6.findCell($headCell.pos - tableStart);
    const doc2 = $anchorCell.node(0);
    if (anchorRect.top <= headRect.top) {
      if (anchorRect.top > 0)
        $anchorCell = doc2.resolve(tableStart + map6.map[anchorRect.left]);
      if (headRect.bottom < map6.height)
        $headCell = doc2.resolve(
          tableStart + map6.map[map6.width * (map6.height - 1) + headRect.right - 1]
        );
    } else {
      if (headRect.top > 0)
        $headCell = doc2.resolve(tableStart + map6.map[headRect.left]);
      if (anchorRect.bottom < map6.height)
        $anchorCell = doc2.resolve(
          tableStart + map6.map[map6.width * (map6.height - 1) + anchorRect.right - 1]
        );
    }
    return new _CellSelection($anchorCell, $headCell);
  }
  // True if this selection goes all the way from the left to the
  // right of the table.
  isRowSelection() {
    const table3 = this.$anchorCell.node(-1);
    const map6 = TableMap.get(table3);
    const tableStart = this.$anchorCell.start(-1);
    const anchorLeft = map6.colCount(this.$anchorCell.pos - tableStart);
    const headLeft = map6.colCount(this.$headCell.pos - tableStart);
    if (Math.min(anchorLeft, headLeft) > 0) return false;
    const anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;
    const headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(anchorRight, headRight) == map6.width;
  }
  eq(other) {
    return other instanceof _CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;
  }
  // Returns the smallest row selection that covers the given anchor
  // and head cell.
  static rowSelection($anchorCell, $headCell = $anchorCell) {
    const table3 = $anchorCell.node(-1);
    const map6 = TableMap.get(table3);
    const tableStart = $anchorCell.start(-1);
    const anchorRect = map6.findCell($anchorCell.pos - tableStart);
    const headRect = map6.findCell($headCell.pos - tableStart);
    const doc2 = $anchorCell.node(0);
    if (anchorRect.left <= headRect.left) {
      if (anchorRect.left > 0)
        $anchorCell = doc2.resolve(
          tableStart + map6.map[anchorRect.top * map6.width]
        );
      if (headRect.right < map6.width)
        $headCell = doc2.resolve(
          tableStart + map6.map[map6.width * (headRect.top + 1) - 1]
        );
    } else {
      if (headRect.left > 0)
        $headCell = doc2.resolve(tableStart + map6.map[headRect.top * map6.width]);
      if (anchorRect.right < map6.width)
        $anchorCell = doc2.resolve(
          tableStart + map6.map[map6.width * (anchorRect.top + 1) - 1]
        );
    }
    return new _CellSelection($anchorCell, $headCell);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(doc2, json) {
    return new _CellSelection(doc2.resolve(json.anchor), doc2.resolve(json.head));
  }
  static create(doc2, anchorCell, headCell = anchorCell) {
    return new _CellSelection(doc2.resolve(anchorCell), doc2.resolve(headCell));
  }
  getBookmark() {
    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);
  }
};
CellSelection.prototype.visible = false;
Selection.jsonID("cell", CellSelection);
var CellBookmark = class _CellBookmark {
  constructor(anchor, head2) {
    this.anchor = anchor;
    this.head = head2;
  }
  map(mapping) {
    return new _CellBookmark(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc2) {
    const $anchorCell = doc2.resolve(this.anchor), $headCell = doc2.resolve(this.head);
    if ($anchorCell.parent.type.spec.tableRole == "row" && $headCell.parent.type.spec.tableRole == "row" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell))
      return new CellSelection($anchorCell, $headCell);
    else return Selection.near($headCell, 1);
  }
};
function drawCellSelection(state) {
  if (!(state.selection instanceof CellSelection)) return null;
  const cells2 = [];
  state.selection.forEachCell((node2, pos) => {
    cells2.push(
      Decoration.node(pos, pos + node2.nodeSize, { class: "selectedCell" })
    );
  });
  return DecorationSet.create(state.doc, cells2);
}
function isCellBoundarySelection({ $from, $to }) {
  if ($from.pos == $to.pos || $from.pos < $to.pos - 6) return false;
  let afterFrom = $from.pos;
  let beforeTo = $to.pos;
  let depth = $from.depth;
  for (; depth >= 0; depth--, afterFrom++)
    if ($from.after(depth + 1) < $from.end(depth)) break;
  for (let d = $to.depth; d >= 0; d--, beforeTo--)
    if ($to.before(d + 1) > $to.start(d)) break;
  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);
}
function isTextSelectionAcrossCells({ $from, $to }) {
  let fromCellBoundaryNode;
  let toCellBoundaryNode;
  for (let i2 = $from.depth; i2 > 0; i2--) {
    const node2 = $from.node(i2);
    if (node2.type.spec.tableRole === "cell" || node2.type.spec.tableRole === "header_cell") {
      fromCellBoundaryNode = node2;
      break;
    }
  }
  for (let i2 = $to.depth; i2 > 0; i2--) {
    const node2 = $to.node(i2);
    if (node2.type.spec.tableRole === "cell" || node2.type.spec.tableRole === "header_cell") {
      toCellBoundaryNode = node2;
      break;
    }
  }
  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;
}
function normalizeSelection(state, tr5, allowTableNodeSelection) {
  const sel = (tr5 || state).selection;
  const doc2 = (tr5 || state).doc;
  let normalize3;
  let role;
  if (sel instanceof NodeSelection && (role = sel.node.type.spec.tableRole)) {
    if (role == "cell" || role == "header_cell") {
      normalize3 = CellSelection.create(doc2, sel.from);
    } else if (role == "row") {
      const $cell = doc2.resolve(sel.from + 1);
      normalize3 = CellSelection.rowSelection($cell, $cell);
    } else if (!allowTableNodeSelection) {
      const map6 = TableMap.get(sel.node);
      const start = sel.from + 1;
      const lastCell = start + map6.map[map6.width * map6.height - 1];
      normalize3 = CellSelection.create(doc2, start + 1, lastCell);
    }
  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {
    normalize3 = TextSelection.create(doc2, sel.from);
  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {
    normalize3 = TextSelection.create(doc2, sel.$from.start(), sel.$from.end());
  }
  if (normalize3) (tr5 || (tr5 = state.tr)).setSelection(normalize3);
  return tr5;
}
var fixTablesKey = new PluginKey("fix-tables");
function changedDescendants(old, cur, offset4, f2) {
  const oldSize = old.childCount, curSize = cur.childCount;
  outer: for (let i2 = 0, j5 = 0; i2 < curSize; i2++) {
    const child = cur.child(i2);
    for (let scan = j5, e = Math.min(oldSize, i2 + 3); scan < e; scan++) {
      if (old.child(scan) == child) {
        j5 = scan + 1;
        offset4 += child.nodeSize;
        continue outer;
      }
    }
    f2(child, offset4);
    if (j5 < oldSize && old.child(j5).sameMarkup(child))
      changedDescendants(old.child(j5), child, offset4 + 1, f2);
    else child.nodesBetween(0, child.content.size, f2, offset4 + 1);
    offset4 += child.nodeSize;
  }
}
function fixTables(state, oldState) {
  let tr5;
  const check = (node2, pos) => {
    if (node2.type.spec.tableRole == "table")
      tr5 = fixTable(state, node2, pos, tr5);
  };
  if (!oldState) state.doc.descendants(check);
  else if (oldState.doc != state.doc)
    changedDescendants(oldState.doc, state.doc, 0, check);
  return tr5;
}
function fixTable(state, table3, tablePos, tr5) {
  const map6 = TableMap.get(table3);
  if (!map6.problems) return tr5;
  if (!tr5) tr5 = state.tr;
  const mustAdd = [];
  for (let i2 = 0; i2 < map6.height; i2++) mustAdd.push(0);
  for (let i2 = 0; i2 < map6.problems.length; i2++) {
    const prob = map6.problems[i2];
    if (prob.type == "collision") {
      const cell2 = table3.nodeAt(prob.pos);
      if (!cell2) continue;
      const attrs = cell2.attrs;
      for (let j5 = 0; j5 < attrs.rowspan; j5++) mustAdd[prob.row + j5] += prob.n;
      tr5.setNodeMarkup(
        tr5.mapping.map(tablePos + 1 + prob.pos),
        null,
        removeColSpan(attrs, attrs.colspan - prob.n, prob.n)
      );
    } else if (prob.type == "missing") {
      mustAdd[prob.row] += prob.n;
    } else if (prob.type == "overlong_rowspan") {
      const cell2 = table3.nodeAt(prob.pos);
      if (!cell2) continue;
      tr5.setNodeMarkup(tr5.mapping.map(tablePos + 1 + prob.pos), null, {
        ...cell2.attrs,
        rowspan: cell2.attrs.rowspan - prob.n
      });
    } else if (prob.type == "colwidth mismatch") {
      const cell2 = table3.nodeAt(prob.pos);
      if (!cell2) continue;
      tr5.setNodeMarkup(tr5.mapping.map(tablePos + 1 + prob.pos), null, {
        ...cell2.attrs,
        colwidth: prob.colwidth
      });
    } else if (prob.type == "zero_sized") {
      const pos = tr5.mapping.map(tablePos);
      tr5.delete(pos, pos + table3.nodeSize);
    }
  }
  let first2, last2;
  for (let i2 = 0; i2 < mustAdd.length; i2++)
    if (mustAdd[i2]) {
      if (first2 == null) first2 = i2;
      last2 = i2;
    }
  for (let i2 = 0, pos = tablePos + 1; i2 < map6.height; i2++) {
    const row2 = table3.child(i2);
    const end = pos + row2.nodeSize;
    const add = mustAdd[i2];
    if (add > 0) {
      let role = "cell";
      if (row2.firstChild) {
        role = row2.firstChild.type.spec.tableRole;
      }
      const nodes = [];
      for (let j5 = 0; j5 < add; j5++) {
        const node2 = tableNodeTypes(state.schema)[role].createAndFill();
        if (node2) nodes.push(node2);
      }
      const side = (i2 == 0 || first2 == i2 - 1) && last2 == i2 ? pos + 1 : end - 1;
      tr5.insert(tr5.mapping.map(side), nodes);
    }
    pos = end;
  }
  return tr5.setMeta(fixTablesKey, { fixTables: true });
}
function selectedRect(state) {
  const sel = state.selection;
  const $pos = selectionCell(state);
  const table3 = $pos.node(-1);
  const tableStart = $pos.start(-1);
  const map6 = TableMap.get(table3);
  const rect = sel instanceof CellSelection ? map6.rectBetween(
    sel.$anchorCell.pos - tableStart,
    sel.$headCell.pos - tableStart
  ) : map6.findCell($pos.pos - tableStart);
  return { ...rect, tableStart, map: map6, table: table3 };
}
function addColumn(tr5, { map: map6, tableStart, table: table3 }, col) {
  let refColumn = col > 0 ? -1 : 0;
  if (columnIsHeader(map6, table3, col + refColumn)) {
    refColumn = col == 0 || col == map6.width ? null : 0;
  }
  for (let row2 = 0; row2 < map6.height; row2++) {
    const index4 = row2 * map6.width + col;
    if (col > 0 && col < map6.width && map6.map[index4 - 1] == map6.map[index4]) {
      const pos = map6.map[index4];
      const cell2 = table3.nodeAt(pos);
      tr5.setNodeMarkup(
        tr5.mapping.map(tableStart + pos),
        null,
        addColSpan(cell2.attrs, col - map6.colCount(pos))
      );
      row2 += cell2.attrs.rowspan - 1;
    } else {
      const type = refColumn == null ? tableNodeTypes(table3.type.schema).cell : table3.nodeAt(map6.map[index4 + refColumn]).type;
      const pos = map6.positionAt(row2, col, table3);
      tr5.insert(tr5.mapping.map(tableStart + pos), type.createAndFill());
    }
  }
  return tr5;
}
function addColumnBefore(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state);
    dispatch(addColumn(state.tr, rect, rect.left));
  }
  return true;
}
function addColumnAfter(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state);
    dispatch(addColumn(state.tr, rect, rect.right));
  }
  return true;
}
function removeColumn(tr5, { map: map6, table: table3, tableStart }, col) {
  const mapStart = tr5.mapping.maps.length;
  for (let row2 = 0; row2 < map6.height; ) {
    const index4 = row2 * map6.width + col;
    const pos = map6.map[index4];
    const cell2 = table3.nodeAt(pos);
    const attrs = cell2.attrs;
    if (col > 0 && map6.map[index4 - 1] == pos || col < map6.width - 1 && map6.map[index4 + 1] == pos) {
      tr5.setNodeMarkup(
        tr5.mapping.slice(mapStart).map(tableStart + pos),
        null,
        removeColSpan(attrs, col - map6.colCount(pos))
      );
    } else {
      const start = tr5.mapping.slice(mapStart).map(tableStart + pos);
      tr5.delete(start, start + cell2.nodeSize);
    }
    row2 += attrs.rowspan;
  }
}
function deleteColumn(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state);
    const tr5 = state.tr;
    if (rect.left == 0 && rect.right == rect.map.width) return false;
    for (let i2 = rect.right - 1; ; i2--) {
      removeColumn(tr5, rect, i2);
      if (i2 == rect.left) break;
      const table3 = rect.tableStart ? tr5.doc.nodeAt(rect.tableStart - 1) : tr5.doc;
      if (!table3) {
        throw RangeError("No table found");
      }
      rect.table = table3;
      rect.map = TableMap.get(table3);
    }
    dispatch(tr5);
  }
  return true;
}
function rowIsHeader(map6, table3, row2) {
  var _a2;
  const headerCell = tableNodeTypes(table3.type.schema).header_cell;
  for (let col = 0; col < map6.width; col++)
    if (((_a2 = table3.nodeAt(map6.map[col + row2 * map6.width])) == null ? void 0 : _a2.type) != headerCell)
      return false;
  return true;
}
function addRow(tr5, { map: map6, tableStart, table: table3 }, row2) {
  var _a2;
  let rowPos = tableStart;
  for (let i2 = 0; i2 < row2; i2++) rowPos += table3.child(i2).nodeSize;
  const cells2 = [];
  let refRow = row2 > 0 ? -1 : 0;
  if (rowIsHeader(map6, table3, row2 + refRow))
    refRow = row2 == 0 || row2 == map6.height ? null : 0;
  for (let col = 0, index4 = map6.width * row2; col < map6.width; col++, index4++) {
    if (row2 > 0 && row2 < map6.height && map6.map[index4] == map6.map[index4 - map6.width]) {
      const pos = map6.map[index4];
      const attrs = table3.nodeAt(pos).attrs;
      tr5.setNodeMarkup(tableStart + pos, null, {
        ...attrs,
        rowspan: attrs.rowspan + 1
      });
      col += attrs.colspan - 1;
    } else {
      const type = refRow == null ? tableNodeTypes(table3.type.schema).cell : (_a2 = table3.nodeAt(map6.map[index4 + refRow * map6.width])) == null ? void 0 : _a2.type;
      const node2 = type == null ? void 0 : type.createAndFill();
      if (node2) cells2.push(node2);
    }
  }
  tr5.insert(rowPos, tableNodeTypes(table3.type.schema).row.create(null, cells2));
  return tr5;
}
function addRowBefore(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state);
    dispatch(addRow(state.tr, rect, rect.top));
  }
  return true;
}
function addRowAfter(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state);
    dispatch(addRow(state.tr, rect, rect.bottom));
  }
  return true;
}
function removeRow(tr5, { map: map6, table: table3, tableStart }, row2) {
  let rowPos = 0;
  for (let i2 = 0; i2 < row2; i2++) rowPos += table3.child(i2).nodeSize;
  const nextRow = rowPos + table3.child(row2).nodeSize;
  const mapFrom = tr5.mapping.maps.length;
  tr5.delete(rowPos + tableStart, nextRow + tableStart);
  const seen = /* @__PURE__ */ new Set();
  for (let col = 0, index4 = row2 * map6.width; col < map6.width; col++, index4++) {
    const pos = map6.map[index4];
    if (seen.has(pos)) continue;
    seen.add(pos);
    if (row2 > 0 && pos == map6.map[index4 - map6.width]) {
      const attrs = table3.nodeAt(pos).attrs;
      tr5.setNodeMarkup(tr5.mapping.slice(mapFrom).map(pos + tableStart), null, {
        ...attrs,
        rowspan: attrs.rowspan - 1
      });
      col += attrs.colspan - 1;
    } else if (row2 < map6.height && pos == map6.map[index4 + map6.width]) {
      const cell2 = table3.nodeAt(pos);
      const attrs = cell2.attrs;
      const copy2 = cell2.type.create(
        { ...attrs, rowspan: cell2.attrs.rowspan - 1 },
        cell2.content
      );
      const newPos = map6.positionAt(row2 + 1, col, table3);
      tr5.insert(tr5.mapping.slice(mapFrom).map(tableStart + newPos), copy2);
      col += attrs.colspan - 1;
    }
  }
}
function deleteRow(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state), tr5 = state.tr;
    if (rect.top == 0 && rect.bottom == rect.map.height) return false;
    for (let i2 = rect.bottom - 1; ; i2--) {
      removeRow(tr5, rect, i2);
      if (i2 == rect.top) break;
      const table3 = rect.tableStart ? tr5.doc.nodeAt(rect.tableStart - 1) : tr5.doc;
      if (!table3) {
        throw RangeError("No table found");
      }
      rect.table = table3;
      rect.map = TableMap.get(rect.table);
    }
    dispatch(tr5);
  }
  return true;
}
function isEmpty(cell2) {
  const c = cell2.content;
  return c.childCount == 1 && c.child(0).isTextblock && c.child(0).childCount == 0;
}
function cellsOverlapRectangle({ width, height, map: map6 }, rect) {
  let indexTop = rect.top * width + rect.left, indexLeft = indexTop;
  let indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);
  for (let i2 = rect.top; i2 < rect.bottom; i2++) {
    if (rect.left > 0 && map6[indexLeft] == map6[indexLeft - 1] || rect.right < width && map6[indexRight] == map6[indexRight + 1])
      return true;
    indexLeft += width;
    indexRight += width;
  }
  for (let i2 = rect.left; i2 < rect.right; i2++) {
    if (rect.top > 0 && map6[indexTop] == map6[indexTop - width] || rect.bottom < height && map6[indexBottom] == map6[indexBottom + width])
      return true;
    indexTop++;
    indexBottom++;
  }
  return false;
}
function mergeCells(state, dispatch) {
  const sel = state.selection;
  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos)
    return false;
  const rect = selectedRect(state), { map: map6 } = rect;
  if (cellsOverlapRectangle(map6, rect)) return false;
  if (dispatch) {
    const tr5 = state.tr;
    const seen = {};
    let content5 = Fragment.empty;
    let mergedPos;
    let mergedCell;
    for (let row2 = rect.top; row2 < rect.bottom; row2++) {
      for (let col = rect.left; col < rect.right; col++) {
        const cellPos = map6.map[row2 * map6.width + col];
        const cell2 = rect.table.nodeAt(cellPos);
        if (seen[cellPos] || !cell2) continue;
        seen[cellPos] = true;
        if (mergedPos == null) {
          mergedPos = cellPos;
          mergedCell = cell2;
        } else {
          if (!isEmpty(cell2)) content5 = content5.append(cell2.content);
          const mapped = tr5.mapping.map(cellPos + rect.tableStart);
          tr5.delete(mapped, mapped + cell2.nodeSize);
        }
      }
    }
    if (mergedPos == null || mergedCell == null) {
      return true;
    }
    tr5.setNodeMarkup(mergedPos + rect.tableStart, null, {
      ...addColSpan(
        mergedCell.attrs,
        mergedCell.attrs.colspan,
        rect.right - rect.left - mergedCell.attrs.colspan
      ),
      rowspan: rect.bottom - rect.top
    });
    if (content5.size) {
      const end = mergedPos + 1 + mergedCell.content.size;
      const start = isEmpty(mergedCell) ? mergedPos + 1 : end;
      tr5.replaceWith(start + rect.tableStart, end + rect.tableStart, content5);
    }
    tr5.setSelection(
      new CellSelection(tr5.doc.resolve(mergedPos + rect.tableStart))
    );
    dispatch(tr5);
  }
  return true;
}
function splitCell(state, dispatch) {
  const nodeTypes = tableNodeTypes(state.schema);
  return splitCellWithType(({ node: node2 }) => {
    return nodeTypes[node2.type.spec.tableRole];
  })(state, dispatch);
}
function splitCellWithType(getCellType) {
  return (state, dispatch) => {
    var _a2;
    const sel = state.selection;
    let cellNode;
    let cellPos;
    if (!(sel instanceof CellSelection)) {
      cellNode = cellWrapping(sel.$from);
      if (!cellNode) return false;
      cellPos = (_a2 = cellAround(sel.$from)) == null ? void 0 : _a2.pos;
    } else {
      if (sel.$anchorCell.pos != sel.$headCell.pos) return false;
      cellNode = sel.$anchorCell.nodeAfter;
      cellPos = sel.$anchorCell.pos;
    }
    if (cellNode == null || cellPos == null) {
      return false;
    }
    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {
      return false;
    }
    if (dispatch) {
      let baseAttrs = cellNode.attrs;
      const attrs = [];
      const colwidth = baseAttrs.colwidth;
      if (baseAttrs.rowspan > 1) baseAttrs = { ...baseAttrs, rowspan: 1 };
      if (baseAttrs.colspan > 1) baseAttrs = { ...baseAttrs, colspan: 1 };
      const rect = selectedRect(state), tr5 = state.tr;
      for (let i2 = 0; i2 < rect.right - rect.left; i2++)
        attrs.push(
          colwidth ? {
            ...baseAttrs,
            colwidth: colwidth && colwidth[i2] ? [colwidth[i2]] : null
          } : baseAttrs
        );
      let lastCell;
      for (let row2 = rect.top; row2 < rect.bottom; row2++) {
        let pos = rect.map.positionAt(row2, rect.left, rect.table);
        if (row2 == rect.top) pos += cellNode.nodeSize;
        for (let col = rect.left, i2 = 0; col < rect.right; col++, i2++) {
          if (col == rect.left && row2 == rect.top) continue;
          tr5.insert(
            lastCell = tr5.mapping.map(pos + rect.tableStart, 1),
            getCellType({ node: cellNode, row: row2, col }).createAndFill(attrs[i2])
          );
        }
      }
      tr5.setNodeMarkup(
        cellPos,
        getCellType({ node: cellNode, row: rect.top, col: rect.left }),
        attrs[0]
      );
      if (sel instanceof CellSelection)
        tr5.setSelection(
          new CellSelection(
            tr5.doc.resolve(sel.$anchorCell.pos),
            lastCell ? tr5.doc.resolve(lastCell) : void 0
          )
        );
      dispatch(tr5);
    }
    return true;
  };
}
function deprecated_toggleHeader(type) {
  return function(state, dispatch) {
    if (!isInTable(state)) return false;
    if (dispatch) {
      const types2 = tableNodeTypes(state.schema);
      const rect = selectedRect(state), tr5 = state.tr;
      const cells2 = rect.map.cellsInRect(
        type == "column" ? {
          left: rect.left,
          top: 0,
          right: rect.right,
          bottom: rect.map.height
        } : type == "row" ? {
          left: 0,
          top: rect.top,
          right: rect.map.width,
          bottom: rect.bottom
        } : rect
      );
      const nodes = cells2.map((pos) => rect.table.nodeAt(pos));
      for (let i2 = 0; i2 < cells2.length; i2++)
        if (nodes[i2].type == types2.header_cell)
          tr5.setNodeMarkup(
            rect.tableStart + cells2[i2],
            types2.cell,
            nodes[i2].attrs
          );
      if (tr5.steps.length == 0)
        for (let i2 = 0; i2 < cells2.length; i2++)
          tr5.setNodeMarkup(
            rect.tableStart + cells2[i2],
            types2.header_cell,
            nodes[i2].attrs
          );
      dispatch(tr5);
    }
    return true;
  };
}
function isHeaderEnabledByType(type, rect, types2) {
  const cellPositions = rect.map.cellsInRect({
    left: 0,
    top: 0,
    right: type == "row" ? rect.map.width : 1,
    bottom: type == "column" ? rect.map.height : 1
  });
  for (let i2 = 0; i2 < cellPositions.length; i2++) {
    const cell2 = rect.table.nodeAt(cellPositions[i2]);
    if (cell2 && cell2.type !== types2.header_cell) {
      return false;
    }
  }
  return true;
}
function toggleHeader(type, options) {
  options = options || { useDeprecatedLogic: false };
  if (options.useDeprecatedLogic) return deprecated_toggleHeader(type);
  return function(state, dispatch) {
    if (!isInTable(state)) return false;
    if (dispatch) {
      const types2 = tableNodeTypes(state.schema);
      const rect = selectedRect(state), tr5 = state.tr;
      const isHeaderRowEnabled = isHeaderEnabledByType("row", rect, types2);
      const isHeaderColumnEnabled = isHeaderEnabledByType(
        "column",
        rect,
        types2
      );
      const isHeaderEnabled = type === "column" ? isHeaderRowEnabled : type === "row" ? isHeaderColumnEnabled : false;
      const selectionStartsAt = isHeaderEnabled ? 1 : 0;
      const cellsRect = type == "column" ? {
        left: 0,
        top: selectionStartsAt,
        right: 1,
        bottom: rect.map.height
      } : type == "row" ? {
        left: selectionStartsAt,
        top: 0,
        right: rect.map.width,
        bottom: 1
      } : rect;
      const newType = type == "column" ? isHeaderColumnEnabled ? types2.cell : types2.header_cell : type == "row" ? isHeaderRowEnabled ? types2.cell : types2.header_cell : types2.cell;
      rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {
        const cellPos = relativeCellPos + rect.tableStart;
        const cell2 = tr5.doc.nodeAt(cellPos);
        if (cell2) {
          tr5.setNodeMarkup(cellPos, newType, cell2.attrs);
        }
      });
      dispatch(tr5);
    }
    return true;
  };
}
var toggleHeaderRow = toggleHeader("row", {
  useDeprecatedLogic: true
});
var toggleHeaderColumn = toggleHeader("column", {
  useDeprecatedLogic: true
});
var toggleHeaderCell = toggleHeader("cell", {
  useDeprecatedLogic: true
});
function findNextCell($cell, dir) {
  if (dir < 0) {
    const before = $cell.nodeBefore;
    if (before) return $cell.pos - before.nodeSize;
    for (let row2 = $cell.index(-1) - 1, rowEnd = $cell.before(); row2 >= 0; row2--) {
      const rowNode = $cell.node(-1).child(row2);
      const lastChild = rowNode.lastChild;
      if (lastChild) {
        return rowEnd - 1 - lastChild.nodeSize;
      }
      rowEnd -= rowNode.nodeSize;
    }
  } else {
    if ($cell.index() < $cell.parent.childCount - 1) {
      return $cell.pos + $cell.nodeAfter.nodeSize;
    }
    const table3 = $cell.node(-1);
    for (let row2 = $cell.indexAfter(-1), rowStart = $cell.after(); row2 < table3.childCount; row2++) {
      const rowNode = table3.child(row2);
      if (rowNode.childCount) return rowStart + 1;
      rowStart += rowNode.nodeSize;
    }
  }
  return null;
}
function goToNextCell(direction) {
  return function(state, dispatch) {
    if (!isInTable(state)) return false;
    const cell2 = findNextCell(selectionCell(state), direction);
    if (cell2 == null) return false;
    if (dispatch) {
      const $cell = state.doc.resolve(cell2);
      dispatch(
        state.tr.setSelection(TextSelection.between($cell, moveCellForward($cell))).scrollIntoView()
      );
    }
    return true;
  };
}
function deleteCellSelection(state, dispatch) {
  const sel = state.selection;
  if (!(sel instanceof CellSelection)) return false;
  if (dispatch) {
    const tr5 = state.tr;
    const baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;
    sel.forEachCell((cell2, pos) => {
      if (!cell2.content.eq(baseContent))
        tr5.replace(
          tr5.mapping.map(pos + 1),
          tr5.mapping.map(pos + cell2.nodeSize - 1),
          new Slice(baseContent, 0, 0)
        );
    });
    if (tr5.docChanged) dispatch(tr5);
  }
  return true;
}
function pastedCells(slice) {
  if (!slice.size) return null;
  let { content: content5, openStart, openEnd } = slice;
  while (content5.childCount == 1 && (openStart > 0 && openEnd > 0 || content5.child(0).type.spec.tableRole == "table")) {
    openStart--;
    openEnd--;
    content5 = content5.child(0).content;
  }
  const first2 = content5.child(0);
  const role = first2.type.spec.tableRole;
  const schema = first2.type.schema, rows = [];
  if (role == "row") {
    for (let i2 = 0; i2 < content5.childCount; i2++) {
      let cells2 = content5.child(i2).content;
      const left = i2 ? 0 : Math.max(0, openStart - 1);
      const right = i2 < content5.childCount - 1 ? 0 : Math.max(0, openEnd - 1);
      if (left || right)
        cells2 = fitSlice(
          tableNodeTypes(schema).row,
          new Slice(cells2, left, right)
        ).content;
      rows.push(cells2);
    }
  } else if (role == "cell" || role == "header_cell") {
    rows.push(
      openStart || openEnd ? fitSlice(
        tableNodeTypes(schema).row,
        new Slice(content5, openStart, openEnd)
      ).content : content5
    );
  } else {
    return null;
  }
  return ensureRectangular(schema, rows);
}
function ensureRectangular(schema, rows) {
  const widths = [];
  for (let i2 = 0; i2 < rows.length; i2++) {
    const row2 = rows[i2];
    for (let j5 = row2.childCount - 1; j5 >= 0; j5--) {
      const { rowspan, colspan } = row2.child(j5).attrs;
      for (let r = i2; r < i2 + rowspan; r++)
        widths[r] = (widths[r] || 0) + colspan;
    }
  }
  let width = 0;
  for (let r = 0; r < widths.length; r++) width = Math.max(width, widths[r]);
  for (let r = 0; r < widths.length; r++) {
    if (r >= rows.length) rows.push(Fragment.empty);
    if (widths[r] < width) {
      const empty3 = tableNodeTypes(schema).cell.createAndFill();
      const cells2 = [];
      for (let i2 = widths[r]; i2 < width; i2++) {
        cells2.push(empty3);
      }
      rows[r] = rows[r].append(Fragment.from(cells2));
    }
  }
  return { height: rows.length, width, rows };
}
function fitSlice(nodeType, slice) {
  const node2 = nodeType.createAndFill();
  const tr5 = new Transform(node2).replace(0, node2.content.size, slice);
  return tr5.doc;
}
function clipCells({ width, height, rows }, newWidth, newHeight) {
  if (width != newWidth) {
    const added = [];
    const newRows = [];
    for (let row2 = 0; row2 < rows.length; row2++) {
      const frag = rows[row2], cells2 = [];
      for (let col = added[row2] || 0, i2 = 0; col < newWidth; i2++) {
        let cell2 = frag.child(i2 % frag.childCount);
        if (col + cell2.attrs.colspan > newWidth)
          cell2 = cell2.type.createChecked(
            removeColSpan(
              cell2.attrs,
              cell2.attrs.colspan,
              col + cell2.attrs.colspan - newWidth
            ),
            cell2.content
          );
        cells2.push(cell2);
        col += cell2.attrs.colspan;
        for (let j5 = 1; j5 < cell2.attrs.rowspan; j5++)
          added[row2 + j5] = (added[row2 + j5] || 0) + cell2.attrs.colspan;
      }
      newRows.push(Fragment.from(cells2));
    }
    rows = newRows;
    width = newWidth;
  }
  if (height != newHeight) {
    const newRows = [];
    for (let row2 = 0, i2 = 0; row2 < newHeight; row2++, i2++) {
      const cells2 = [], source = rows[i2 % height];
      for (let j5 = 0; j5 < source.childCount; j5++) {
        let cell2 = source.child(j5);
        if (row2 + cell2.attrs.rowspan > newHeight)
          cell2 = cell2.type.create(
            {
              ...cell2.attrs,
              rowspan: Math.max(1, newHeight - cell2.attrs.rowspan)
            },
            cell2.content
          );
        cells2.push(cell2);
      }
      newRows.push(Fragment.from(cells2));
    }
    rows = newRows;
    height = newHeight;
  }
  return { width, height, rows };
}
function growTable(tr5, map6, table3, start, width, height, mapFrom) {
  const schema = tr5.doc.type.schema;
  const types2 = tableNodeTypes(schema);
  let empty3;
  let emptyHead;
  if (width > map6.width) {
    for (let row2 = 0, rowEnd = 0; row2 < map6.height; row2++) {
      const rowNode = table3.child(row2);
      rowEnd += rowNode.nodeSize;
      const cells2 = [];
      let add;
      if (rowNode.lastChild == null || rowNode.lastChild.type == types2.cell)
        add = empty3 || (empty3 = types2.cell.createAndFill());
      else add = emptyHead || (emptyHead = types2.header_cell.createAndFill());
      for (let i2 = map6.width; i2 < width; i2++) cells2.push(add);
      tr5.insert(tr5.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells2);
    }
  }
  if (height > map6.height) {
    const cells2 = [];
    for (let i2 = 0, start2 = (map6.height - 1) * map6.width; i2 < Math.max(map6.width, width); i2++) {
      const header = i2 >= map6.width ? false : table3.nodeAt(map6.map[start2 + i2]).type == types2.header_cell;
      cells2.push(
        header ? emptyHead || (emptyHead = types2.header_cell.createAndFill()) : empty3 || (empty3 = types2.cell.createAndFill())
      );
    }
    const emptyRow = types2.row.create(null, Fragment.from(cells2)), rows = [];
    for (let i2 = map6.height; i2 < height; i2++) rows.push(emptyRow);
    tr5.insert(tr5.mapping.slice(mapFrom).map(start + table3.nodeSize - 2), rows);
  }
  return !!(empty3 || emptyHead);
}
function isolateHorizontal(tr5, map6, table3, start, left, right, top, mapFrom) {
  if (top == 0 || top == map6.height) return false;
  let found = false;
  for (let col = left; col < right; col++) {
    const index4 = top * map6.width + col, pos = map6.map[index4];
    if (map6.map[index4 - map6.width] == pos) {
      found = true;
      const cell2 = table3.nodeAt(pos);
      const { top: cellTop, left: cellLeft } = map6.findCell(pos);
      tr5.setNodeMarkup(tr5.mapping.slice(mapFrom).map(pos + start), null, {
        ...cell2.attrs,
        rowspan: top - cellTop
      });
      tr5.insert(
        tr5.mapping.slice(mapFrom).map(map6.positionAt(top, cellLeft, table3)),
        cell2.type.createAndFill({
          ...cell2.attrs,
          rowspan: cellTop + cell2.attrs.rowspan - top
        })
      );
      col += cell2.attrs.colspan - 1;
    }
  }
  return found;
}
function isolateVertical(tr5, map6, table3, start, top, bottom, left, mapFrom) {
  if (left == 0 || left == map6.width) return false;
  let found = false;
  for (let row2 = top; row2 < bottom; row2++) {
    const index4 = row2 * map6.width + left, pos = map6.map[index4];
    if (map6.map[index4 - 1] == pos) {
      found = true;
      const cell2 = table3.nodeAt(pos);
      const cellLeft = map6.colCount(pos);
      const updatePos = tr5.mapping.slice(mapFrom).map(pos + start);
      tr5.setNodeMarkup(
        updatePos,
        null,
        removeColSpan(
          cell2.attrs,
          left - cellLeft,
          cell2.attrs.colspan - (left - cellLeft)
        )
      );
      tr5.insert(
        updatePos + cell2.nodeSize,
        cell2.type.createAndFill(
          removeColSpan(cell2.attrs, 0, left - cellLeft)
        )
      );
      row2 += cell2.attrs.rowspan - 1;
    }
  }
  return found;
}
function insertCells(state, dispatch, tableStart, rect, cells2) {
  let table3 = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;
  if (!table3) {
    throw new Error("No table found");
  }
  let map6 = TableMap.get(table3);
  const { top, left } = rect;
  const right = left + cells2.width, bottom = top + cells2.height;
  const tr5 = state.tr;
  let mapFrom = 0;
  function recomp() {
    table3 = tableStart ? tr5.doc.nodeAt(tableStart - 1) : tr5.doc;
    if (!table3) {
      throw new Error("No table found");
    }
    map6 = TableMap.get(table3);
    mapFrom = tr5.mapping.maps.length;
  }
  if (growTable(tr5, map6, table3, tableStart, right, bottom, mapFrom)) recomp();
  if (isolateHorizontal(tr5, map6, table3, tableStart, left, right, top, mapFrom))
    recomp();
  if (isolateHorizontal(tr5, map6, table3, tableStart, left, right, bottom, mapFrom))
    recomp();
  if (isolateVertical(tr5, map6, table3, tableStart, top, bottom, left, mapFrom))
    recomp();
  if (isolateVertical(tr5, map6, table3, tableStart, top, bottom, right, mapFrom))
    recomp();
  for (let row2 = top; row2 < bottom; row2++) {
    const from3 = map6.positionAt(row2, left, table3), to3 = map6.positionAt(row2, right, table3);
    tr5.replace(
      tr5.mapping.slice(mapFrom).map(from3 + tableStart),
      tr5.mapping.slice(mapFrom).map(to3 + tableStart),
      new Slice(cells2.rows[row2 - top], 0, 0)
    );
  }
  recomp();
  tr5.setSelection(
    new CellSelection(
      tr5.doc.resolve(tableStart + map6.positionAt(top, left, table3)),
      tr5.doc.resolve(tableStart + map6.positionAt(bottom - 1, right - 1, table3))
    )
  );
  dispatch(tr5);
}
var handleKeyDown = keydownHandler({
  ArrowLeft: arrow4("horiz", -1),
  ArrowRight: arrow4("horiz", 1),
  ArrowUp: arrow4("vert", -1),
  ArrowDown: arrow4("vert", 1),
  "Shift-ArrowLeft": shiftArrow("horiz", -1),
  "Shift-ArrowRight": shiftArrow("horiz", 1),
  "Shift-ArrowUp": shiftArrow("vert", -1),
  "Shift-ArrowDown": shiftArrow("vert", 1),
  Backspace: deleteCellSelection,
  "Mod-Backspace": deleteCellSelection,
  Delete: deleteCellSelection,
  "Mod-Delete": deleteCellSelection
});
function maybeSetSelection(state, dispatch, selection) {
  if (selection.eq(state.selection)) return false;
  if (dispatch) dispatch(state.tr.setSelection(selection).scrollIntoView());
  return true;
}
function arrow4(axis, dir) {
  return (state, dispatch, view) => {
    if (!view) return false;
    const sel = state.selection;
    if (sel instanceof CellSelection) {
      return maybeSetSelection(
        state,
        dispatch,
        Selection.near(sel.$headCell, dir)
      );
    }
    if (axis != "horiz" && !sel.empty) return false;
    const end = atEndOfCell(view, axis, dir);
    if (end == null) return false;
    if (axis == "horiz") {
      return maybeSetSelection(
        state,
        dispatch,
        Selection.near(state.doc.resolve(sel.head + dir), dir)
      );
    } else {
      const $cell = state.doc.resolve(end);
      const $next = nextCell($cell, axis, dir);
      let newSel;
      if ($next) newSel = Selection.near($next, 1);
      else if (dir < 0)
        newSel = Selection.near(state.doc.resolve($cell.before(-1)), -1);
      else newSel = Selection.near(state.doc.resolve($cell.after(-1)), 1);
      return maybeSetSelection(state, dispatch, newSel);
    }
  };
}
function shiftArrow(axis, dir) {
  return (state, dispatch, view) => {
    if (!view) return false;
    const sel = state.selection;
    let cellSel;
    if (sel instanceof CellSelection) {
      cellSel = sel;
    } else {
      const end = atEndOfCell(view, axis, dir);
      if (end == null) return false;
      cellSel = new CellSelection(state.doc.resolve(end));
    }
    const $head = nextCell(cellSel.$headCell, axis, dir);
    if (!$head) return false;
    return maybeSetSelection(
      state,
      dispatch,
      new CellSelection(cellSel.$anchorCell, $head)
    );
  };
}
function handleTripleClick(view, pos) {
  const doc2 = view.state.doc, $cell = cellAround(doc2.resolve(pos));
  if (!$cell) return false;
  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));
  return true;
}
function handlePaste(view, _, slice) {
  if (!isInTable(view.state)) return false;
  let cells2 = pastedCells(slice);
  const sel = view.state.selection;
  if (sel instanceof CellSelection) {
    if (!cells2)
      cells2 = {
        width: 1,
        height: 1,
        rows: [
          Fragment.from(
            fitSlice(tableNodeTypes(view.state.schema).cell, slice)
          )
        ]
      };
    const table3 = sel.$anchorCell.node(-1);
    const start = sel.$anchorCell.start(-1);
    const rect = TableMap.get(table3).rectBetween(
      sel.$anchorCell.pos - start,
      sel.$headCell.pos - start
    );
    cells2 = clipCells(cells2, rect.right - rect.left, rect.bottom - rect.top);
    insertCells(view.state, view.dispatch, start, rect, cells2);
    return true;
  } else if (cells2) {
    const $cell = selectionCell(view.state);
    const start = $cell.start(-1);
    insertCells(
      view.state,
      view.dispatch,
      start,
      TableMap.get($cell.node(-1)).findCell($cell.pos - start),
      cells2
    );
    return true;
  } else {
    return false;
  }
}
function handleMouseDown(view, startEvent) {
  var _a2;
  if (startEvent.ctrlKey || startEvent.metaKey) return;
  const startDOMCell = domInCell(view, startEvent.target);
  let $anchor;
  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {
    setCellSelection(view.state.selection.$anchorCell, startEvent);
    startEvent.preventDefault();
  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && ((_a2 = cellUnderMouse(view, startEvent)) == null ? void 0 : _a2.pos) != $anchor.pos) {
    setCellSelection($anchor, startEvent);
    startEvent.preventDefault();
  } else if (!startDOMCell) {
    return;
  }
  function setCellSelection($anchor2, event) {
    let $head = cellUnderMouse(view, event);
    const starting = tableEditingKey.getState(view.state) == null;
    if (!$head || !inSameTable($anchor2, $head)) {
      if (starting) $head = $anchor2;
      else return;
    }
    const selection = new CellSelection($anchor2, $head);
    if (starting || !view.state.selection.eq(selection)) {
      const tr5 = view.state.tr.setSelection(selection);
      if (starting) tr5.setMeta(tableEditingKey, $anchor2.pos);
      view.dispatch(tr5);
    }
  }
  function stop() {
    view.root.removeEventListener("mouseup", stop);
    view.root.removeEventListener("dragstart", stop);
    view.root.removeEventListener("mousemove", move);
    if (tableEditingKey.getState(view.state) != null)
      view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));
  }
  function move(_event) {
    const event = _event;
    const anchor = tableEditingKey.getState(view.state);
    let $anchor2;
    if (anchor != null) {
      $anchor2 = view.state.doc.resolve(anchor);
    } else if (domInCell(view, event.target) != startDOMCell) {
      $anchor2 = cellUnderMouse(view, startEvent);
      if (!$anchor2) return stop();
    }
    if ($anchor2) setCellSelection($anchor2, event);
  }
  view.root.addEventListener("mouseup", stop);
  view.root.addEventListener("dragstart", stop);
  view.root.addEventListener("mousemove", move);
}
function atEndOfCell(view, axis, dir) {
  if (!(view.state.selection instanceof TextSelection)) return null;
  const { $head } = view.state.selection;
  for (let d = $head.depth - 1; d >= 0; d--) {
    const parent = $head.node(d), index4 = dir < 0 ? $head.index(d) : $head.indexAfter(d);
    if (index4 != (dir < 0 ? 0 : parent.childCount)) return null;
    if (parent.type.spec.tableRole == "cell" || parent.type.spec.tableRole == "header_cell") {
      const cellPos = $head.before(d);
      const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
      return view.endOfTextblock(dirStr) ? cellPos : null;
    }
  }
  return null;
}
function domInCell(view, dom) {
  for (; dom && dom != view.dom; dom = dom.parentNode) {
    if (dom.nodeName == "TD" || dom.nodeName == "TH") {
      return dom;
    }
  }
  return null;
}
function cellUnderMouse(view, event) {
  const mousePos = view.posAtCoords({
    left: event.clientX,
    top: event.clientY
  });
  if (!mousePos) return null;
  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;
}
var TableView = class {
  constructor(node2, defaultCellMinWidth) {
    this.node = node2;
    this.defaultCellMinWidth = defaultCellMinWidth;
    this.dom = document.createElement("div");
    this.dom.className = "tableWrapper";
    this.table = this.dom.appendChild(document.createElement("table"));
    this.table.style.setProperty(
      "--default-cell-min-width",
      `${defaultCellMinWidth}px`
    );
    this.colgroup = this.table.appendChild(document.createElement("colgroup"));
    updateColumnsOnResize(node2, this.colgroup, this.table, defaultCellMinWidth);
    this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(node2) {
    if (node2.type != this.node.type) return false;
    this.node = node2;
    updateColumnsOnResize(
      node2,
      this.colgroup,
      this.table,
      this.defaultCellMinWidth
    );
    return true;
  }
  ignoreMutation(record) {
    return record.type == "attributes" && (record.target == this.table || this.colgroup.contains(record.target));
  }
};
function updateColumnsOnResize(node2, colgroup2, table3, defaultCellMinWidth, overrideCol, overrideValue) {
  var _a2;
  let totalWidth = 0;
  let fixedWidth = true;
  let nextDOM = colgroup2.firstChild;
  const row2 = node2.firstChild;
  if (!row2) return;
  for (let i2 = 0, col = 0; i2 < row2.childCount; i2++) {
    const { colspan, colwidth } = row2.child(i2).attrs;
    for (let j5 = 0; j5 < colspan; j5++, col++) {
      const hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j5];
      const cssWidth = hasWidth ? hasWidth + "px" : "";
      totalWidth += hasWidth || defaultCellMinWidth;
      if (!hasWidth) fixedWidth = false;
      if (!nextDOM) {
        const col2 = document.createElement("col");
        col2.style.width = cssWidth;
        colgroup2.appendChild(col2);
      } else {
        if (nextDOM.style.width != cssWidth) {
          nextDOM.style.width = cssWidth;
        }
        nextDOM = nextDOM.nextSibling;
      }
    }
  }
  while (nextDOM) {
    const after = nextDOM.nextSibling;
    (_a2 = nextDOM.parentNode) == null ? void 0 : _a2.removeChild(nextDOM);
    nextDOM = after;
  }
  if (fixedWidth) {
    table3.style.width = totalWidth + "px";
    table3.style.minWidth = "";
  } else {
    table3.style.width = "";
    table3.style.minWidth = totalWidth + "px";
  }
}
var columnResizingPluginKey = new PluginKey(
  "tableColumnResizing"
);
function columnResizing({
  handleWidth = 5,
  cellMinWidth = 25,
  defaultCellMinWidth = 100,
  View = TableView,
  lastColumnResizable = true
} = {}) {
  const plugin = new Plugin({
    key: columnResizingPluginKey,
    state: {
      init(_, state) {
        var _a2, _b;
        const nodeViews = (_b = (_a2 = plugin.spec) == null ? void 0 : _a2.props) == null ? void 0 : _b.nodeViews;
        const tableName = tableNodeTypes(state.schema).table.name;
        if (View && nodeViews) {
          nodeViews[tableName] = (node2, view) => {
            return new View(node2, defaultCellMinWidth, view);
          };
        }
        return new ResizeState(-1, false);
      },
      apply(tr5, prev) {
        return prev.apply(tr5);
      }
    },
    props: {
      attributes: (state) => {
        const pluginState = columnResizingPluginKey.getState(state);
        return pluginState && pluginState.activeHandle > -1 ? { class: "resize-cursor" } : {};
      },
      handleDOMEvents: {
        mousemove: (view, event) => {
          handleMouseMove(view, event, handleWidth, lastColumnResizable);
        },
        mouseleave: (view) => {
          handleMouseLeave(view);
        },
        mousedown: (view, event) => {
          handleMouseDown2(view, event, cellMinWidth, defaultCellMinWidth);
        }
      },
      decorations: (state) => {
        const pluginState = columnResizingPluginKey.getState(state);
        if (pluginState && pluginState.activeHandle > -1) {
          return handleDecorations(state, pluginState.activeHandle);
        }
      },
      nodeViews: {}
    }
  });
  return plugin;
}
var ResizeState = class _ResizeState {
  constructor(activeHandle, dragging) {
    this.activeHandle = activeHandle;
    this.dragging = dragging;
  }
  apply(tr5) {
    const state = this;
    const action = tr5.getMeta(columnResizingPluginKey);
    if (action && action.setHandle != null)
      return new _ResizeState(action.setHandle, false);
    if (action && action.setDragging !== void 0)
      return new _ResizeState(state.activeHandle, action.setDragging);
    if (state.activeHandle > -1 && tr5.docChanged) {
      let handle4 = tr5.mapping.map(state.activeHandle, -1);
      if (!pointsAtCell(tr5.doc.resolve(handle4))) {
        handle4 = -1;
      }
      return new _ResizeState(handle4, state.dragging);
    }
    return state;
  }
};
function handleMouseMove(view, event, handleWidth, lastColumnResizable) {
  if (!view.editable) return;
  const pluginState = columnResizingPluginKey.getState(view.state);
  if (!pluginState) return;
  if (!pluginState.dragging) {
    const target = domCellAround(event.target);
    let cell2 = -1;
    if (target) {
      const { left, right } = target.getBoundingClientRect();
      if (event.clientX - left <= handleWidth)
        cell2 = edgeCell(view, event, "left", handleWidth);
      else if (right - event.clientX <= handleWidth)
        cell2 = edgeCell(view, event, "right", handleWidth);
    }
    if (cell2 != pluginState.activeHandle) {
      if (!lastColumnResizable && cell2 !== -1) {
        const $cell = view.state.doc.resolve(cell2);
        const table3 = $cell.node(-1);
        const map6 = TableMap.get(table3);
        const tableStart = $cell.start(-1);
        const col = map6.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1;
        if (col == map6.width - 1) {
          return;
        }
      }
      updateHandle(view, cell2);
    }
  }
}
function handleMouseLeave(view) {
  if (!view.editable) return;
  const pluginState = columnResizingPluginKey.getState(view.state);
  if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging)
    updateHandle(view, -1);
}
function handleMouseDown2(view, event, cellMinWidth, defaultCellMinWidth) {
  var _a2;
  if (!view.editable) return false;
  const win = (_a2 = view.dom.ownerDocument.defaultView) != null ? _a2 : window;
  const pluginState = columnResizingPluginKey.getState(view.state);
  if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging)
    return false;
  const cell2 = view.state.doc.nodeAt(pluginState.activeHandle);
  const width = currentColWidth(view, pluginState.activeHandle, cell2.attrs);
  view.dispatch(
    view.state.tr.setMeta(columnResizingPluginKey, {
      setDragging: { startX: event.clientX, startWidth: width }
    })
  );
  function finish(event2) {
    win.removeEventListener("mouseup", finish);
    win.removeEventListener("mousemove", move);
    const pluginState2 = columnResizingPluginKey.getState(view.state);
    if (pluginState2 == null ? void 0 : pluginState2.dragging) {
      updateColumnWidth(
        view,
        pluginState2.activeHandle,
        draggedWidth(pluginState2.dragging, event2, cellMinWidth)
      );
      view.dispatch(
        view.state.tr.setMeta(columnResizingPluginKey, { setDragging: null })
      );
    }
  }
  function move(event2) {
    if (!event2.which) return finish(event2);
    const pluginState2 = columnResizingPluginKey.getState(view.state);
    if (!pluginState2) return;
    if (pluginState2.dragging) {
      const dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);
      displayColumnWidth(
        view,
        pluginState2.activeHandle,
        dragged,
        defaultCellMinWidth
      );
    }
  }
  displayColumnWidth(
    view,
    pluginState.activeHandle,
    width,
    defaultCellMinWidth
  );
  win.addEventListener("mouseup", finish);
  win.addEventListener("mousemove", move);
  event.preventDefault();
  return true;
}
function currentColWidth(view, cellPos, { colspan, colwidth }) {
  const width = colwidth && colwidth[colwidth.length - 1];
  if (width) return width;
  const dom = view.domAtPos(cellPos);
  const node2 = dom.node.childNodes[dom.offset];
  let domWidth = node2.offsetWidth, parts = colspan;
  if (colwidth) {
    for (let i2 = 0; i2 < colspan; i2++)
      if (colwidth[i2]) {
        domWidth -= colwidth[i2];
        parts--;
      }
  }
  return domWidth / parts;
}
function domCellAround(target) {
  while (target && target.nodeName != "TD" && target.nodeName != "TH")
    target = target.classList && target.classList.contains("ProseMirror") ? null : target.parentNode;
  return target;
}
function edgeCell(view, event, side, handleWidth) {
  const offset4 = side == "right" ? -handleWidth : handleWidth;
  const found = view.posAtCoords({
    left: event.clientX + offset4,
    top: event.clientY
  });
  if (!found) return -1;
  const { pos } = found;
  const $cell = cellAround(view.state.doc.resolve(pos));
  if (!$cell) return -1;
  if (side == "right") return $cell.pos;
  const map6 = TableMap.get($cell.node(-1)), start = $cell.start(-1);
  const index4 = map6.map.indexOf($cell.pos - start);
  return index4 % map6.width == 0 ? -1 : start + map6.map[index4 - 1];
}
function draggedWidth(dragging, event, resizeMinWidth) {
  const offset4 = event.clientX - dragging.startX;
  return Math.max(resizeMinWidth, dragging.startWidth + offset4);
}
function updateHandle(view, value) {
  view.dispatch(
    view.state.tr.setMeta(columnResizingPluginKey, { setHandle: value })
  );
}
function updateColumnWidth(view, cell2, width) {
  const $cell = view.state.doc.resolve(cell2);
  const table3 = $cell.node(-1), map6 = TableMap.get(table3), start = $cell.start(-1);
  const col = map6.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;
  const tr5 = view.state.tr;
  for (let row2 = 0; row2 < map6.height; row2++) {
    const mapIndex = row2 * map6.width + col;
    if (row2 && map6.map[mapIndex] == map6.map[mapIndex - map6.width]) continue;
    const pos = map6.map[mapIndex];
    const attrs = table3.nodeAt(pos).attrs;
    const index4 = attrs.colspan == 1 ? 0 : col - map6.colCount(pos);
    if (attrs.colwidth && attrs.colwidth[index4] == width) continue;
    const colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);
    colwidth[index4] = width;
    tr5.setNodeMarkup(start + pos, null, { ...attrs, colwidth });
  }
  if (tr5.docChanged) view.dispatch(tr5);
}
function displayColumnWidth(view, cell2, width, defaultCellMinWidth) {
  const $cell = view.state.doc.resolve(cell2);
  const table3 = $cell.node(-1), start = $cell.start(-1);
  const col = TableMap.get(table3).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;
  let dom = view.domAtPos($cell.start(-1)).node;
  while (dom && dom.nodeName != "TABLE") {
    dom = dom.parentNode;
  }
  if (!dom) return;
  updateColumnsOnResize(
    table3,
    dom.firstChild,
    dom,
    defaultCellMinWidth,
    col,
    width
  );
}
function zeroes(n) {
  return Array(n).fill(0);
}
function handleDecorations(state, cell2) {
  var _a2;
  const decorations = [];
  const $cell = state.doc.resolve(cell2);
  const table3 = $cell.node(-1);
  if (!table3) {
    return DecorationSet.empty;
  }
  const map6 = TableMap.get(table3);
  const start = $cell.start(-1);
  const col = map6.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;
  for (let row2 = 0; row2 < map6.height; row2++) {
    const index4 = col + row2 * map6.width;
    if ((col == map6.width - 1 || map6.map[index4] != map6.map[index4 + 1]) && (row2 == 0 || map6.map[index4] != map6.map[index4 - map6.width])) {
      const cellPos = map6.map[index4];
      const pos = start + cellPos + table3.nodeAt(cellPos).nodeSize - 1;
      const dom = document.createElement("div");
      dom.className = "column-resize-handle";
      if ((_a2 = columnResizingPluginKey.getState(state)) == null ? void 0 : _a2.dragging) {
        decorations.push(
          Decoration.node(
            start + cellPos,
            start + cellPos + table3.nodeAt(cellPos).nodeSize,
            {
              class: "column-resize-dragging"
            }
          )
        );
      }
      decorations.push(Decoration.widget(pos, dom));
    }
  }
  return DecorationSet.create(state.doc, decorations);
}
function tableEditing({
  allowTableNodeSelection = false
} = {}) {
  return new Plugin({
    key: tableEditingKey,
    // This piece of state is used to remember when a mouse-drag
    // cell-selection is happening, so that it can continue even as
    // transactions (which might move its anchor cell) come in.
    state: {
      init() {
        return null;
      },
      apply(tr5, cur) {
        const set = tr5.getMeta(tableEditingKey);
        if (set != null) return set == -1 ? null : set;
        if (cur == null || !tr5.docChanged) return cur;
        const { deleted, pos } = tr5.mapping.mapResult(cur);
        return deleted ? null : pos;
      }
    },
    props: {
      decorations: drawCellSelection,
      handleDOMEvents: {
        mousedown: handleMouseDown
      },
      createSelectionBetween(view) {
        return tableEditingKey.getState(view.state) != null ? view.state.selection : null;
      },
      handleTripleClick,
      handleKeyDown,
      handlePaste
    },
    appendTransaction(_, oldState, state) {
      return normalizeSelection(
        state,
        fixTables(state, oldState),
        allowTableNodeSelection
      );
    }
  });
}

// ../node_modules/.pnpm/@tiptap+core@3.8.0_@tiptap+pm@3.8.0/node_modules/@tiptap/core/dist/index.js
var __defProp = Object.defineProperty;
var __export2 = (target, all9) => {
  for (var name in all9)
    __defProp(target, name, { get: all9[name], enumerable: true });
};
function createChainableState(config) {
  const { state, transaction } = config;
  let { selection } = transaction;
  let { doc: doc2 } = transaction;
  let { storedMarks } = transaction;
  return {
    ...state,
    apply: state.apply.bind(state),
    applyTransaction: state.applyTransaction.bind(state),
    plugins: state.plugins,
    schema: state.schema,
    reconfigure: state.reconfigure.bind(state),
    toJSON: state.toJSON.bind(state),
    get storedMarks() {
      return storedMarks;
    },
    get selection() {
      return selection;
    },
    get doc() {
      return doc2;
    },
    get tr() {
      selection = transaction.selection;
      doc2 = transaction.doc;
      storedMarks = transaction.storedMarks;
      return transaction;
    }
  };
}
var CommandManager = class {
  constructor(props) {
    this.editor = props.editor;
    this.rawCommands = this.editor.extensionManager.commands;
    this.customState = props.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const { tr: tr5 } = state;
    const props = this.buildProps(tr5);
    return Object.fromEntries(
      Object.entries(rawCommands).map(([name, command2]) => {
        const method = (...args2) => {
          const callback = command2(...args2)(props);
          if (!tr5.getMeta("preventDispatch") && !this.hasCustomState) {
            view.dispatch(tr5);
          }
          return callback;
        };
        return [name, method];
      })
    );
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(startTr, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const callbacks = [];
    const hasStartTransaction = !!startTr;
    const tr5 = startTr || state.tr;
    const run3 = () => {
      if (!hasStartTransaction && shouldDispatch && !tr5.getMeta("preventDispatch") && !this.hasCustomState) {
        view.dispatch(tr5);
      }
      return callbacks.every((callback) => callback === true);
    };
    const chain = {
      ...Object.fromEntries(
        Object.entries(rawCommands).map(([name, command2]) => {
          const chainedCommand = (...args2) => {
            const props = this.buildProps(tr5, shouldDispatch);
            const callback = command2(...args2)(props);
            callbacks.push(callback);
            return chain;
          };
          return [name, chainedCommand];
        })
      ),
      run: run3
    };
    return chain;
  }
  createCan(startTr) {
    const { rawCommands, state } = this;
    const dispatch = false;
    const tr5 = startTr || state.tr;
    const props = this.buildProps(tr5, dispatch);
    const formattedCommands = Object.fromEntries(
      Object.entries(rawCommands).map(([name, command2]) => {
        return [name, (...args2) => command2(...args2)({ ...props, dispatch: void 0 })];
      })
    );
    return {
      ...formattedCommands,
      chain: () => this.createChain(tr5, dispatch)
    };
  }
  buildProps(tr5, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const props = {
      tr: tr5,
      editor,
      view,
      state: createChainableState({
        state,
        transaction: tr5
      }),
      dispatch: shouldDispatch ? () => void 0 : void 0,
      chain: () => this.createChain(tr5, shouldDispatch),
      can: () => this.createCan(tr5),
      get commands() {
        return Object.fromEntries(
          Object.entries(rawCommands).map(([name, command2]) => {
            return [name, (...args2) => command2(...args2)(props)];
          })
        );
      }
    };
    return props;
  }
};
var commands_exports = {};
__export2(commands_exports, {
  blur: () => blur,
  clearContent: () => clearContent,
  clearNodes: () => clearNodes,
  command: () => command,
  createParagraphNear: () => createParagraphNear2,
  cut: () => cut,
  deleteCurrentNode: () => deleteCurrentNode,
  deleteNode: () => deleteNode,
  deleteRange: () => deleteRange,
  deleteSelection: () => deleteSelection2,
  enter: () => enter,
  exitCode: () => exitCode2,
  extendMarkRange: () => extendMarkRange,
  first: () => first,
  focus: () => focus,
  forEach: () => forEach,
  insertContent: () => insertContent,
  insertContentAt: () => insertContentAt,
  joinBackward: () => joinBackward2,
  joinDown: () => joinDown2,
  joinForward: () => joinForward2,
  joinItemBackward: () => joinItemBackward,
  joinItemForward: () => joinItemForward,
  joinTextblockBackward: () => joinTextblockBackward2,
  joinTextblockForward: () => joinTextblockForward2,
  joinUp: () => joinUp2,
  keyboardShortcut: () => keyboardShortcut,
  lift: () => lift2,
  liftEmptyBlock: () => liftEmptyBlock2,
  liftListItem: () => liftListItem2,
  newlineInCode: () => newlineInCode2,
  resetAttributes: () => resetAttributes,
  scrollIntoView: () => scrollIntoView,
  selectAll: () => selectAll,
  selectNodeBackward: () => selectNodeBackward2,
  selectNodeForward: () => selectNodeForward2,
  selectParentNode: () => selectParentNode2,
  selectTextblockEnd: () => selectTextblockEnd2,
  selectTextblockStart: () => selectTextblockStart2,
  setContent: () => setContent,
  setMark: () => setMark,
  setMeta: () => setMeta,
  setNode: () => setNode,
  setNodeSelection: () => setNodeSelection,
  setTextSelection: () => setTextSelection,
  sinkListItem: () => sinkListItem2,
  splitBlock: () => splitBlock,
  splitListItem: () => splitListItem,
  toggleList: () => toggleList,
  toggleMark: () => toggleMark,
  toggleNode: () => toggleNode,
  toggleWrap: () => toggleWrap,
  undoInputRule: () => undoInputRule,
  unsetAllMarks: () => unsetAllMarks,
  unsetMark: () => unsetMark,
  updateAttributes: () => updateAttributes,
  wrapIn: () => wrapIn2,
  wrapInList: () => wrapInList2
});
var blur = () => ({ editor, view }) => {
  requestAnimationFrame(() => {
    var _a2;
    if (!editor.isDestroyed) {
      ;
      view.dom.blur();
      (_a2 = window == null ? void 0 : window.getSelection()) == null ? void 0 : _a2.removeAllRanges();
    }
  });
  return true;
};
var clearContent = (emitUpdate = true) => ({ commands }) => {
  return commands.setContent("", { emitUpdate });
};
var clearNodes = () => ({ state, tr: tr5, dispatch }) => {
  const { selection } = tr5;
  const { ranges } = selection;
  if (!dispatch) {
    return true;
  }
  ranges.forEach(({ $from, $to }) => {
    state.doc.nodesBetween($from.pos, $to.pos, (node2, pos) => {
      if (node2.type.isText) {
        return;
      }
      const { doc: doc2, mapping } = tr5;
      const $mappedFrom = doc2.resolve(mapping.map(pos));
      const $mappedTo = doc2.resolve(mapping.map(pos + node2.nodeSize));
      const nodeRange = $mappedFrom.blockRange($mappedTo);
      if (!nodeRange) {
        return;
      }
      const targetLiftDepth = liftTarget(nodeRange);
      if (node2.type.isTextblock) {
        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
        tr5.setNodeMarkup(nodeRange.start, defaultType);
      }
      if (targetLiftDepth || targetLiftDepth === 0) {
        tr5.lift(nodeRange, targetLiftDepth);
      }
    });
  });
  return true;
};
var command = (fn3) => (props) => {
  return fn3(props);
};
var createParagraphNear2 = () => ({ state, dispatch }) => {
  return createParagraphNear(state, dispatch);
};
var cut = (originRange, targetPos) => ({ editor, tr: tr5 }) => {
  const { state } = editor;
  const contentSlice = state.doc.slice(originRange.from, originRange.to);
  tr5.deleteRange(originRange.from, originRange.to);
  const newPos = tr5.mapping.map(targetPos);
  tr5.insert(newPos, contentSlice.content);
  tr5.setSelection(new TextSelection(tr5.doc.resolve(Math.max(newPos - 1, 0))));
  return true;
};
var deleteCurrentNode = () => ({ tr: tr5, dispatch }) => {
  const { selection } = tr5;
  const currentNode = selection.$anchor.node();
  if (currentNode.content.size > 0) {
    return false;
  }
  const $pos = tr5.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node2 = $pos.node(depth);
    if (node2.type === currentNode.type) {
      if (dispatch) {
        const from3 = $pos.before(depth);
        const to3 = $pos.after(depth);
        tr5.delete(from3, to3).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
function getNodeType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.nodes[nameOrType]) {
      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.nodes[nameOrType];
  }
  return nameOrType;
}
var deleteNode = (typeOrName) => ({ tr: tr5, state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  const $pos = tr5.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node2 = $pos.node(depth);
    if (node2.type === type) {
      if (dispatch) {
        const from3 = $pos.before(depth);
        const to3 = $pos.after(depth);
        tr5.delete(from3, to3).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteRange = (range) => ({ tr: tr5, dispatch }) => {
  const { from: from3, to: to3 } = range;
  if (dispatch) {
    tr5.delete(from3, to3);
  }
  return true;
};
var deleteSelection2 = () => ({ state, dispatch }) => {
  return deleteSelection(state, dispatch);
};
var enter = () => ({ commands }) => {
  return commands.keyboardShortcut("Enter");
};
var exitCode2 = () => ({ state, dispatch }) => {
  return exitCode(state, dispatch);
};
function isRegExp(value) {
  return Object.prototype.toString.call(value) === "[object RegExp]";
}
function objectIncludes(object1, object2, options = { strict: true }) {
  const keys3 = Object.keys(object2);
  if (!keys3.length) {
    return true;
  }
  return keys3.every((key2) => {
    if (options.strict) {
      return object2[key2] === object1[key2];
    }
    if (isRegExp(object2[key2])) {
      return object2[key2].test(object1[key2]);
    }
    return object2[key2] === object1[key2];
  });
}
function findMarkInSet(marks, type, attributes = {}) {
  return marks.find((item) => {
    return item.type === type && objectIncludes(
      // Only check equality for the attributes that are provided
      Object.fromEntries(Object.keys(attributes).map((k2) => [k2, item.attrs[k2]])),
      attributes
    );
  });
}
function isMarkInSet(marks, type, attributes = {}) {
  return !!findMarkInSet(marks, type, attributes);
}
function getMarkRange($pos, type, attributes) {
  var _a2;
  if (!$pos || !type) {
    return;
  }
  let start = $pos.parent.childAfter($pos.parentOffset);
  if (!start.node || !start.node.marks.some((mark22) => mark22.type === type)) {
    start = $pos.parent.childBefore($pos.parentOffset);
  }
  if (!start.node || !start.node.marks.some((mark22) => mark22.type === type)) {
    return;
  }
  attributes = attributes || ((_a2 = start.node.marks[0]) == null ? void 0 : _a2.attrs);
  const mark2 = findMarkInSet([...start.node.marks], type, attributes);
  if (!mark2) {
    return;
  }
  let startIndex = start.index;
  let startPos = $pos.start() + start.offset;
  let endIndex = startIndex + 1;
  let endPos = startPos + start.node.nodeSize;
  while (startIndex > 0 && isMarkInSet([...$pos.parent.child(startIndex - 1).marks], type, attributes)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }
  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }
  return {
    from: startPos,
    to: endPos
  };
}
function getMarkType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.marks[nameOrType]) {
      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.marks[nameOrType];
  }
  return nameOrType;
}
var extendMarkRange = (typeOrName, attributes = {}) => ({ tr: tr5, state, dispatch }) => {
  const type = getMarkType(typeOrName, state.schema);
  const { doc: doc2, selection } = tr5;
  const { $from, from: from3, to: to3 } = selection;
  if (dispatch) {
    const range = getMarkRange($from, type, attributes);
    if (range && range.from <= from3 && range.to >= to3) {
      const newSelection = TextSelection.create(doc2, range.from, range.to);
      tr5.setSelection(newSelection);
    }
  }
  return true;
};
var first = (commands) => (props) => {
  const items = typeof commands === "function" ? commands(props) : commands;
  for (let i2 = 0; i2 < items.length; i2 += 1) {
    if (items[i2](props)) {
      return true;
    }
  }
  return false;
};
function isTextSelection(value) {
  return value instanceof TextSelection;
}
function minMax(value = 0, min3 = 0, max3 = 0) {
  return Math.min(Math.max(value, min3), max3);
}
function resolveFocusPosition(doc2, position4 = null) {
  if (!position4) {
    return null;
  }
  const selectionAtStart = Selection.atStart(doc2);
  const selectionAtEnd = Selection.atEnd(doc2);
  if (position4 === "start" || position4 === true) {
    return selectionAtStart;
  }
  if (position4 === "end") {
    return selectionAtEnd;
  }
  const minPos = selectionAtStart.from;
  const maxPos = selectionAtEnd.to;
  if (position4 === "all") {
    return TextSelection.create(doc2, minMax(0, minPos, maxPos), minMax(doc2.content.size, minPos, maxPos));
  }
  return TextSelection.create(doc2, minMax(position4, minPos, maxPos), minMax(position4, minPos, maxPos));
}
function isAndroid() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function isiOS() {
  return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || // iPad on iOS 13 detection
  navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
var focus = (position4 = null, options = {}) => ({ editor, view, tr: tr5, dispatch }) => {
  options = {
    scrollIntoView: true,
    ...options
  };
  const delayedFocus = () => {
    if (isiOS() || isAndroid()) {
      ;
      view.dom.focus();
    }
    requestAnimationFrame(() => {
      if (!editor.isDestroyed) {
        view.focus();
        if (options == null ? void 0 : options.scrollIntoView) {
          editor.commands.scrollIntoView();
        }
      }
    });
  };
  if (view.hasFocus() && position4 === null || position4 === false) {
    return true;
  }
  if (dispatch && position4 === null && !isTextSelection(editor.state.selection)) {
    delayedFocus();
    return true;
  }
  const selection = resolveFocusPosition(tr5.doc, position4) || editor.state.selection;
  const isSameSelection = editor.state.selection.eq(selection);
  if (dispatch) {
    if (!isSameSelection) {
      tr5.setSelection(selection);
    }
    if (isSameSelection && tr5.storedMarks) {
      tr5.setStoredMarks(tr5.storedMarks);
    }
    delayedFocus();
  }
  return true;
};
var forEach = (items, fn3) => (props) => {
  return items.every((item, index4) => fn3(item, { ...props, index: index4 }));
};
var insertContent = (value, options) => ({ tr: tr5, commands }) => {
  return commands.insertContentAt({ from: tr5.selection.from, to: tr5.selection.to }, value, options);
};
var removeWhitespaces = (node2) => {
  const children = node2.childNodes;
  for (let i2 = children.length - 1; i2 >= 0; i2 -= 1) {
    const child = children[i2];
    if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
      node2.removeChild(child);
    } else if (child.nodeType === 1) {
      removeWhitespaces(child);
    }
  }
  return node2;
};
function elementFromString(value) {
  if (typeof window === "undefined") {
    throw new Error("[tiptap error]: there is no window object available, so this function cannot be used");
  }
  const wrappedValue = `<body>${value}</body>`;
  const html7 = new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
  return removeWhitespaces(html7);
}
function createNodeFromContent(content5, schema, options) {
  if (content5 instanceof Node2 || content5 instanceof Fragment) {
    return content5;
  }
  options = {
    slice: true,
    parseOptions: {},
    ...options
  };
  const isJSONContent = typeof content5 === "object" && content5 !== null;
  const isTextContent = typeof content5 === "string";
  if (isJSONContent) {
    try {
      const isArrayContent = Array.isArray(content5) && content5.length > 0;
      if (isArrayContent) {
        return Fragment.fromArray(content5.map((item) => schema.nodeFromJSON(item)));
      }
      const node2 = schema.nodeFromJSON(content5);
      if (options.errorOnInvalidContent) {
        node2.check();
      }
      return node2;
    } catch (error2) {
      if (options.errorOnInvalidContent) {
        throw new Error("[tiptap error]: Invalid JSON content", { cause: error2 });
      }
      console.warn("[tiptap warn]: Invalid content.", "Passed value:", content5, "Error:", error2);
      return createNodeFromContent("", schema, options);
    }
  }
  if (isTextContent) {
    if (options.errorOnInvalidContent) {
      let hasInvalidContent = false;
      let invalidContent = "";
      const contentCheckSchema = new Schema({
        topNode: schema.spec.topNode,
        marks: schema.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: schema.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (e) => {
                  hasInvalidContent = true;
                  invalidContent = typeof e === "string" ? e : e.outerHTML;
                  return null;
                }
              }
            ]
          }
        })
      });
      if (options.slice) {
        DOMParser2.fromSchema(contentCheckSchema).parseSlice(elementFromString(content5), options.parseOptions);
      } else {
        DOMParser2.fromSchema(contentCheckSchema).parse(elementFromString(content5), options.parseOptions);
      }
      if (options.errorOnInvalidContent && hasInvalidContent) {
        throw new Error("[tiptap error]: Invalid HTML content", {
          cause: new Error(`Invalid element found: ${invalidContent}`)
        });
      }
    }
    const parser = DOMParser2.fromSchema(schema);
    if (options.slice) {
      return parser.parseSlice(elementFromString(content5), options.parseOptions).content;
    }
    return parser.parse(elementFromString(content5), options.parseOptions);
  }
  return createNodeFromContent("", schema, options);
}
function selectionToInsertionEnd(tr5, startLen, bias) {
  const last2 = tr5.steps.length - 1;
  if (last2 < startLen) {
    return;
  }
  const step = tr5.steps[last2];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
    return;
  }
  const map6 = tr5.mapping.maps[last2];
  let end = 0;
  map6.forEach((_from, _to, _newFrom, newTo) => {
    if (end === 0) {
      end = newTo;
    }
  });
  tr5.setSelection(Selection.near(tr5.doc.resolve(end), bias));
}
var isFragment = (nodeOrFragment) => {
  return !("type" in nodeOrFragment);
};
var insertContentAt = (position4, value, options) => ({ tr: tr5, dispatch, editor }) => {
  var _a2;
  if (dispatch) {
    options = {
      parseOptions: editor.options.parseOptions,
      updateSelection: true,
      applyInputRules: false,
      applyPasteRules: false,
      ...options
    };
    let content5;
    const emitContentError = (error2) => {
      editor.emit("contentError", {
        editor,
        error: error2,
        disableCollaboration: () => {
          if ("collaboration" in editor.storage && typeof editor.storage.collaboration === "object" && editor.storage.collaboration) {
            ;
            editor.storage.collaboration.isDisabled = true;
          }
        }
      });
    };
    const parseOptions = {
      preserveWhitespace: "full",
      ...options.parseOptions
    };
    if (!options.errorOnInvalidContent && !editor.options.enableContentCheck && editor.options.emitContentError) {
      try {
        createNodeFromContent(value, editor.schema, {
          parseOptions,
          errorOnInvalidContent: true
        });
      } catch (e) {
        emitContentError(e);
      }
    }
    try {
      content5 = createNodeFromContent(value, editor.schema, {
        parseOptions,
        errorOnInvalidContent: (_a2 = options.errorOnInvalidContent) != null ? _a2 : editor.options.enableContentCheck
      });
    } catch (e) {
      emitContentError(e);
      return false;
    }
    let { from: from3, to: to3 } = typeof position4 === "number" ? { from: position4, to: position4 } : { from: position4.from, to: position4.to };
    let isOnlyTextContent = true;
    let isOnlyBlockContent = true;
    const nodes = isFragment(content5) ? content5 : [content5];
    nodes.forEach((node2) => {
      node2.check();
      isOnlyTextContent = isOnlyTextContent ? node2.isText && node2.marks.length === 0 : false;
      isOnlyBlockContent = isOnlyBlockContent ? node2.isBlock : false;
    });
    if (from3 === to3 && isOnlyBlockContent) {
      const { parent } = tr5.doc.resolve(from3);
      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
      if (isEmptyTextBlock) {
        from3 -= 1;
        to3 += 1;
      }
    }
    let newContent;
    if (isOnlyTextContent) {
      if (Array.isArray(value)) {
        newContent = value.map((v2) => v2.text || "").join("");
      } else if (value instanceof Fragment) {
        let text10 = "";
        value.forEach((node2) => {
          if (node2.text) {
            text10 += node2.text;
          }
        });
        newContent = text10;
      } else if (typeof value === "object" && !!value && !!value.text) {
        newContent = value.text;
      } else {
        newContent = value;
      }
      tr5.insertText(newContent, from3, to3);
    } else {
      newContent = content5;
      const $from = tr5.doc.resolve(from3);
      const $fromNode = $from.node();
      const fromSelectionAtStart = $from.parentOffset === 0;
      const isTextSelection2 = $fromNode.isText || $fromNode.isTextblock;
      const hasContent2 = $fromNode.content.size > 0;
      if (fromSelectionAtStart && isTextSelection2 && hasContent2) {
        from3 = Math.max(0, from3 - 1);
      }
      tr5.replaceWith(from3, to3, newContent);
    }
    if (options.updateSelection) {
      selectionToInsertionEnd(tr5, tr5.steps.length - 1, -1);
    }
    if (options.applyInputRules) {
      tr5.setMeta("applyInputRules", { from: from3, text: newContent });
    }
    if (options.applyPasteRules) {
      tr5.setMeta("applyPasteRules", { from: from3, text: newContent });
    }
  }
  return true;
};
var joinUp2 = () => ({ state, dispatch }) => {
  return joinUp(state, dispatch);
};
var joinDown2 = () => ({ state, dispatch }) => {
  return joinDown(state, dispatch);
};
var joinBackward2 = () => ({ state, dispatch }) => {
  return joinBackward(state, dispatch);
};
var joinForward2 = () => ({ state, dispatch }) => {
  return joinForward(state, dispatch);
};
var joinItemBackward = () => ({ state, dispatch, tr: tr5 }) => {
  try {
    const point5 = joinPoint(state.doc, state.selection.$from.pos, -1);
    if (point5 === null || point5 === void 0) {
      return false;
    }
    tr5.join(point5, 2);
    if (dispatch) {
      dispatch(tr5);
    }
    return true;
  } catch {
    return false;
  }
};
var joinItemForward = () => ({ state, dispatch, tr: tr5 }) => {
  try {
    const point5 = joinPoint(state.doc, state.selection.$from.pos, 1);
    if (point5 === null || point5 === void 0) {
      return false;
    }
    tr5.join(point5, 2);
    if (dispatch) {
      dispatch(tr5);
    }
    return true;
  } catch {
    return false;
  }
};
var joinTextblockBackward2 = () => ({ state, dispatch }) => {
  return joinTextblockBackward(state, dispatch);
};
var joinTextblockForward2 = () => ({ state, dispatch }) => {
  return joinTextblockForward(state, dispatch);
};
function isMacOS() {
  return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
}
function normalizeKeyName(name) {
  const parts = name.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result === "Space") {
    result = " ";
  }
  let alt;
  let ctrl;
  let shift4;
  let meta2;
  for (let i2 = 0; i2 < parts.length - 1; i2 += 1) {
    const mod = parts[i2];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta2 = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift4 = true;
    } else if (/^mod$/i.test(mod)) {
      if (isiOS() || isMacOS()) {
        meta2 = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error(`Unrecognized modifier name: ${mod}`);
    }
  }
  if (alt) {
    result = `Alt-${result}`;
  }
  if (ctrl) {
    result = `Ctrl-${result}`;
  }
  if (meta2) {
    result = `Meta-${result}`;
  }
  if (shift4) {
    result = `Shift-${result}`;
  }
  return result;
}
var keyboardShortcut = (name) => ({ editor, view, tr: tr5, dispatch }) => {
  const keys3 = normalizeKeyName(name).split(/-(?!$)/);
  const key2 = keys3.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
  const event = new KeyboardEvent("keydown", {
    key: key2 === "Space" ? " " : key2,
    altKey: keys3.includes("Alt"),
    ctrlKey: keys3.includes("Ctrl"),
    metaKey: keys3.includes("Meta"),
    shiftKey: keys3.includes("Shift"),
    bubbles: true,
    cancelable: true
  });
  const capturedTransaction = editor.captureTransaction(() => {
    view.someProp("handleKeyDown", (f2) => f2(view, event));
  });
  capturedTransaction == null ? void 0 : capturedTransaction.steps.forEach((step) => {
    const newStep = step.map(tr5.mapping);
    if (newStep && dispatch) {
      tr5.maybeStep(newStep);
    }
  });
  return true;
};
function isNodeActive(state, typeOrName, attributes = {}) {
  const { from: from3, to: to3, empty: empty3 } = state.selection;
  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
  const nodeRanges = [];
  state.doc.nodesBetween(from3, to3, (node2, pos) => {
    if (node2.isText) {
      return;
    }
    const relativeFrom = Math.max(from3, pos);
    const relativeTo = Math.min(to3, pos + node2.nodeSize);
    nodeRanges.push({
      node: node2,
      from: relativeFrom,
      to: relativeTo
    });
  });
  const selectionRange = to3 - from3;
  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
    if (!type) {
      return true;
    }
    return type.name === nodeRange.node.type.name;
  }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
  if (empty3) {
    return !!matchedNodeRanges.length;
  }
  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
  return range >= selectionRange;
}
var lift2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (!isActive2) {
    return false;
  }
  return lift(state, dispatch);
};
var liftEmptyBlock2 = () => ({ state, dispatch }) => {
  return liftEmptyBlock(state, dispatch);
};
var liftListItem2 = (typeOrName) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return liftListItem(type)(state, dispatch);
};
var newlineInCode2 = () => ({ state, dispatch }) => {
  return newlineInCode(state, dispatch);
};
function getSchemaTypeNameByName(name, schema) {
  if (schema.nodes[name]) {
    return "node";
  }
  if (schema.marks[name]) {
    return "mark";
  }
  return null;
}
function deleteProps(obj, propOrProps) {
  const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
  return Object.keys(obj).reduce((newObj, prop) => {
    if (!props.includes(prop)) {
      newObj[prop] = obj[prop];
    }
    return newObj;
  }, {});
}
var resetAttributes = (typeOrName, attributes) => ({ tr: tr5, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(
    typeof typeOrName === "string" ? typeOrName : typeOrName.name,
    state.schema
  );
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch) {
    tr5.selection.ranges.forEach((range) => {
      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node2, pos) => {
        if (nodeType && nodeType === node2.type) {
          tr5.setNodeMarkup(pos, void 0, deleteProps(node2.attrs, attributes));
        }
        if (markType && node2.marks.length) {
          node2.marks.forEach((mark2) => {
            if (markType === mark2.type) {
              tr5.addMark(pos, pos + node2.nodeSize, markType.create(deleteProps(mark2.attrs, attributes)));
            }
          });
        }
      });
    });
  }
  return true;
};
var scrollIntoView = () => ({ tr: tr5, dispatch }) => {
  if (dispatch) {
    tr5.scrollIntoView();
  }
  return true;
};
var selectAll = () => ({ tr: tr5, dispatch }) => {
  if (dispatch) {
    const selection = new AllSelection(tr5.doc);
    tr5.setSelection(selection);
  }
  return true;
};
var selectNodeBackward2 = () => ({ state, dispatch }) => {
  return selectNodeBackward(state, dispatch);
};
var selectNodeForward2 = () => ({ state, dispatch }) => {
  return selectNodeForward(state, dispatch);
};
var selectParentNode2 = () => ({ state, dispatch }) => {
  return selectParentNode(state, dispatch);
};
var selectTextblockEnd2 = () => ({ state, dispatch }) => {
  return selectTextblockEnd(state, dispatch);
};
var selectTextblockStart2 = () => ({ state, dispatch }) => {
  return selectTextblockStart(state, dispatch);
};
function createDocument(content5, schema, parseOptions = {}, options = {}) {
  return createNodeFromContent(content5, schema, {
    slice: false,
    parseOptions,
    errorOnInvalidContent: options.errorOnInvalidContent
  });
}
var setContent = (content5, { errorOnInvalidContent, emitUpdate = true, parseOptions = {} } = {}) => ({ editor, tr: tr5, dispatch, commands }) => {
  const { doc: doc2 } = tr5;
  if (parseOptions.preserveWhitespace !== "full") {
    const document22 = createDocument(content5, editor.schema, parseOptions, {
      errorOnInvalidContent: errorOnInvalidContent != null ? errorOnInvalidContent : editor.options.enableContentCheck
    });
    if (dispatch) {
      tr5.replaceWith(0, doc2.content.size, document22).setMeta("preventUpdate", !emitUpdate);
    }
    return true;
  }
  if (dispatch) {
    tr5.setMeta("preventUpdate", !emitUpdate);
  }
  return commands.insertContentAt({ from: 0, to: doc2.content.size }, content5, {
    parseOptions,
    errorOnInvalidContent: errorOnInvalidContent != null ? errorOnInvalidContent : editor.options.enableContentCheck
  });
};
function getMarkAttributes(state, typeOrName) {
  const type = getMarkType(typeOrName, state.schema);
  const { from: from3, to: to3, empty: empty3 } = state.selection;
  const marks = [];
  if (empty3) {
    if (state.storedMarks) {
      marks.push(...state.storedMarks);
    }
    marks.push(...state.selection.$head.marks());
  } else {
    state.doc.nodesBetween(from3, to3, (node2) => {
      marks.push(...node2.marks);
    });
  }
  const mark2 = marks.find((markItem) => markItem.type.name === type.name);
  if (!mark2) {
    return {};
  }
  return { ...mark2.attrs };
}
function combineTransactionSteps(oldDoc, transactions) {
  const transform2 = new Transform(oldDoc);
  transactions.forEach((transaction) => {
    transaction.steps.forEach((step) => {
      transform2.step(step);
    });
  });
  return transform2;
}
function defaultBlockAt(match) {
  for (let i2 = 0; i2 < match.edgeCount; i2 += 1) {
    const { type } = match.edge(i2);
    if (type.isTextblock && !type.hasRequiredAttrs()) {
      return type;
    }
  }
  return null;
}
function findChildren(node2, predicate) {
  const nodesWithPos = [];
  node2.descendants((child, pos) => {
    if (predicate(child)) {
      nodesWithPos.push({
        node: child,
        pos
      });
    }
  });
  return nodesWithPos;
}
function findChildrenInRange(node2, range, predicate) {
  const nodesWithPos = [];
  node2.nodesBetween(range.from, range.to, (child, pos) => {
    if (predicate(child)) {
      nodesWithPos.push({
        node: child,
        pos
      });
    }
  });
  return nodesWithPos;
}
function findParentNodeClosestToPos($pos, predicate) {
  for (let i2 = $pos.depth; i2 > 0; i2 -= 1) {
    const node2 = $pos.node(i2);
    if (predicate(node2)) {
      return {
        pos: i2 > 0 ? $pos.before(i2) : 0,
        start: $pos.start(i2),
        depth: i2,
        node: node2
      };
    }
  }
}
function findParentNode(predicate) {
  return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
}
function getExtensionField(extension2, field, context) {
  if (extension2.config[field] === void 0 && extension2.parent) {
    return getExtensionField(extension2.parent, field, context);
  }
  if (typeof extension2.config[field] === "function") {
    const value = extension2.config[field].bind({
      ...context,
      parent: extension2.parent ? getExtensionField(extension2.parent, field, context) : null
    });
    return value;
  }
  return extension2.config[field];
}
function flattenExtensions(extensions) {
  return extensions.map((extension2) => {
    const context = {
      name: extension2.name,
      options: extension2.options,
      storage: extension2.storage
    };
    const addExtensions = getExtensionField(extension2, "addExtensions", context);
    if (addExtensions) {
      return [extension2, ...flattenExtensions(addExtensions())];
    }
    return extension2;
  }).flat(10);
}
function getHTMLFromFragment(fragment, schema) {
  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);
  const temporaryDocument = document.implementation.createHTMLDocument();
  const container = temporaryDocument.createElement("div");
  container.appendChild(documentFragment);
  return container.innerHTML;
}
function isFunction(value) {
  return typeof value === "function";
}
function callOrReturn(value, context = void 0, ...props) {
  if (isFunction(value)) {
    if (context) {
      return value.bind(context)(...props);
    }
    return value(...props);
  }
  return value;
}
function isEmptyObject(value = {}) {
  return Object.keys(value).length === 0 && value.constructor === Object;
}
function splitExtensions(extensions) {
  const baseExtensions = extensions.filter((extension2) => extension2.type === "extension");
  const nodeExtensions = extensions.filter((extension2) => extension2.type === "node");
  const markExtensions = extensions.filter((extension2) => extension2.type === "mark");
  return {
    baseExtensions,
    nodeExtensions,
    markExtensions
  };
}
function getAttributesFromExtensions(extensions) {
  const extensionAttributes = [];
  const { nodeExtensions, markExtensions } = splitExtensions(extensions);
  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
  const defaultAttribute = {
    default: null,
    validate: void 0,
    rendered: true,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: true,
    isRequired: false
  };
  extensions.forEach((extension2) => {
    const context = {
      name: extension2.name,
      options: extension2.options,
      storage: extension2.storage,
      extensions: nodeAndMarkExtensions
    };
    const addGlobalAttributes = getExtensionField(
      extension2,
      "addGlobalAttributes",
      context
    );
    if (!addGlobalAttributes) {
      return;
    }
    const globalAttributes = addGlobalAttributes();
    globalAttributes.forEach((globalAttribute) => {
      globalAttribute.types.forEach((type) => {
        Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
          extensionAttributes.push({
            type,
            name,
            attribute: {
              ...defaultAttribute,
              ...attribute
            }
          });
        });
      });
    });
  });
  nodeAndMarkExtensions.forEach((extension2) => {
    const context = {
      name: extension2.name,
      options: extension2.options,
      storage: extension2.storage
    };
    const addAttributes = getExtensionField(
      extension2,
      "addAttributes",
      context
    );
    if (!addAttributes) {
      return;
    }
    const attributes = addAttributes();
    Object.entries(attributes).forEach(([name, attribute]) => {
      const mergedAttr = {
        ...defaultAttribute,
        ...attribute
      };
      if (typeof (mergedAttr == null ? void 0 : mergedAttr.default) === "function") {
        mergedAttr.default = mergedAttr.default();
      }
      if ((mergedAttr == null ? void 0 : mergedAttr.isRequired) && (mergedAttr == null ? void 0 : mergedAttr.default) === void 0) {
        delete mergedAttr.default;
      }
      extensionAttributes.push({
        type: extension2.name,
        name,
        attribute: mergedAttr
      });
    });
  });
  return extensionAttributes;
}
function mergeAttributes(...objects) {
  return objects.filter((item) => !!item).reduce((items, item) => {
    const mergedAttributes = { ...items };
    Object.entries(item).forEach(([key2, value]) => {
      const exists = mergedAttributes[key2];
      if (!exists) {
        mergedAttributes[key2] = value;
        return;
      }
      if (key2 === "class") {
        const valueClasses = value ? String(value).split(" ") : [];
        const existingClasses = mergedAttributes[key2] ? mergedAttributes[key2].split(" ") : [];
        const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));
        mergedAttributes[key2] = [...existingClasses, ...insertClasses].join(" ");
      } else if (key2 === "style") {
        const newStyles = value ? value.split(";").map((style22) => style22.trim()).filter(Boolean) : [];
        const existingStyles = mergedAttributes[key2] ? mergedAttributes[key2].split(";").map((style22) => style22.trim()).filter(Boolean) : [];
        const styleMap = /* @__PURE__ */ new Map();
        existingStyles.forEach((style22) => {
          const [property, val] = style22.split(":").map((part) => part.trim());
          styleMap.set(property, val);
        });
        newStyles.forEach((style22) => {
          const [property, val] = style22.split(":").map((part) => part.trim());
          styleMap.set(property, val);
        });
        mergedAttributes[key2] = Array.from(styleMap.entries()).map(([property, val]) => `${property}: ${val}`).join("; ");
      } else {
        mergedAttributes[key2] = value;
      }
    });
    return mergedAttributes;
  }, {});
}
function getRenderedAttributes(nodeOrMark, extensionAttributes) {
  return extensionAttributes.filter((attribute) => attribute.type === nodeOrMark.type.name).filter((item) => item.attribute.rendered).map((item) => {
    if (!item.attribute.renderHTML) {
      return {
        [item.name]: nodeOrMark.attrs[item.name]
      };
    }
    return item.attribute.renderHTML(nodeOrMark.attrs) || {};
  }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});
}
function fromString(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
    return Number(value);
  }
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  return value;
}
function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
  if ("style" in parseRule) {
    return parseRule;
  }
  return {
    ...parseRule,
    getAttrs: (node2) => {
      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node2) : parseRule.attrs;
      if (oldAttributes === false) {
        return false;
      }
      const newAttributes = extensionAttributes.reduce((items, item) => {
        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node2) : fromString(node2.getAttribute(item.name));
        if (value === null || value === void 0) {
          return items;
        }
        return {
          ...items,
          [item.name]: value
        };
      }, {});
      return { ...oldAttributes, ...newAttributes };
    }
  };
}
function cleanUpSchemaItem(data) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(data).filter(([key2, value]) => {
      if (key2 === "attrs" && isEmptyObject(value)) {
        return false;
      }
      return value !== null && value !== void 0;
    })
  );
}
function getSchemaByResolvedExtensions(extensions, editor) {
  var _a2;
  const allAttributes = getAttributesFromExtensions(extensions);
  const { nodeExtensions, markExtensions } = splitExtensions(extensions);
  const topNode = (_a2 = nodeExtensions.find((extension2) => getExtensionField(extension2, "topNode"))) == null ? void 0 : _a2.name;
  const nodes = Object.fromEntries(
    nodeExtensions.map((extension2) => {
      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension2.name);
      const context = {
        name: extension2.name,
        options: extension2.options,
        storage: extension2.storage,
        editor
      };
      const extraNodeFields = extensions.reduce((fields, e) => {
        const extendNodeSchema = getExtensionField(e, "extendNodeSchema", context);
        return {
          ...fields,
          ...extendNodeSchema ? extendNodeSchema(extension2) : {}
        };
      }, {});
      const schema = cleanUpSchemaItem({
        ...extraNodeFields,
        content: callOrReturn(getExtensionField(extension2, "content", context)),
        marks: callOrReturn(getExtensionField(extension2, "marks", context)),
        group: callOrReturn(getExtensionField(extension2, "group", context)),
        inline: callOrReturn(getExtensionField(extension2, "inline", context)),
        atom: callOrReturn(getExtensionField(extension2, "atom", context)),
        selectable: callOrReturn(getExtensionField(extension2, "selectable", context)),
        draggable: callOrReturn(getExtensionField(extension2, "draggable", context)),
        code: callOrReturn(getExtensionField(extension2, "code", context)),
        whitespace: callOrReturn(getExtensionField(extension2, "whitespace", context)),
        linebreakReplacement: callOrReturn(
          getExtensionField(extension2, "linebreakReplacement", context)
        ),
        defining: callOrReturn(getExtensionField(extension2, "defining", context)),
        isolating: callOrReturn(getExtensionField(extension2, "isolating", context)),
        attrs: Object.fromEntries(
          extensionAttributes.map((extensionAttribute) => {
            var _a22, _b;
            return [
              extensionAttribute.name,
              { default: (_a22 = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _a22.default, validate: (_b = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _b.validate }
            ];
          })
        )
      });
      const parseHTML = callOrReturn(getExtensionField(extension2, "parseHTML", context));
      if (parseHTML) {
        schema.parseDOM = parseHTML.map(
          (parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes)
        );
      }
      const renderHTML = getExtensionField(extension2, "renderHTML", context);
      if (renderHTML) {
        schema.toDOM = (node2) => renderHTML({
          node: node2,
          HTMLAttributes: getRenderedAttributes(node2, extensionAttributes)
        });
      }
      const renderText = getExtensionField(extension2, "renderText", context);
      if (renderText) {
        schema.toText = renderText;
      }
      return [extension2.name, schema];
    })
  );
  const marks = Object.fromEntries(
    markExtensions.map((extension2) => {
      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension2.name);
      const context = {
        name: extension2.name,
        options: extension2.options,
        storage: extension2.storage,
        editor
      };
      const extraMarkFields = extensions.reduce((fields, e) => {
        const extendMarkSchema = getExtensionField(e, "extendMarkSchema", context);
        return {
          ...fields,
          ...extendMarkSchema ? extendMarkSchema(extension2) : {}
        };
      }, {});
      const schema = cleanUpSchemaItem({
        ...extraMarkFields,
        inclusive: callOrReturn(getExtensionField(extension2, "inclusive", context)),
        excludes: callOrReturn(getExtensionField(extension2, "excludes", context)),
        group: callOrReturn(getExtensionField(extension2, "group", context)),
        spanning: callOrReturn(getExtensionField(extension2, "spanning", context)),
        code: callOrReturn(getExtensionField(extension2, "code", context)),
        attrs: Object.fromEntries(
          extensionAttributes.map((extensionAttribute) => {
            var _a22, _b;
            return [
              extensionAttribute.name,
              { default: (_a22 = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _a22.default, validate: (_b = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _b.validate }
            ];
          })
        )
      });
      const parseHTML = callOrReturn(getExtensionField(extension2, "parseHTML", context));
      if (parseHTML) {
        schema.parseDOM = parseHTML.map(
          (parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes)
        );
      }
      const renderHTML = getExtensionField(extension2, "renderHTML", context);
      if (renderHTML) {
        schema.toDOM = (mark2) => renderHTML({
          mark: mark2,
          HTMLAttributes: getRenderedAttributes(mark2, extensionAttributes)
        });
      }
      return [extension2.name, schema];
    })
  );
  return new Schema({
    topNode,
    nodes,
    marks
  });
}
function findDuplicates(items) {
  const filtered = items.filter((el2, index4) => items.indexOf(el2) !== index4);
  return Array.from(new Set(filtered));
}
function sortExtensions(extensions) {
  const defaultPriority = 100;
  return extensions.sort((a2, b2) => {
    const priorityA = getExtensionField(a2, "priority") || defaultPriority;
    const priorityB = getExtensionField(b2, "priority") || defaultPriority;
    if (priorityA > priorityB) {
      return -1;
    }
    if (priorityA < priorityB) {
      return 1;
    }
    return 0;
  });
}
function resolveExtensions(extensions) {
  const resolvedExtensions = sortExtensions(flattenExtensions(extensions));
  const duplicatedNames = findDuplicates(resolvedExtensions.map((extension2) => extension2.name));
  if (duplicatedNames.length) {
    console.warn(
      `[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`
    );
  }
  return resolvedExtensions;
}
function getSchema(extensions, editor) {
  const resolvedExtensions = resolveExtensions(extensions);
  return getSchemaByResolvedExtensions(resolvedExtensions, editor);
}
function getTextBetween(startNode, range, options) {
  const { from: from3, to: to3 } = range;
  const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
  let text10 = "";
  startNode.nodesBetween(from3, to3, (node2, pos, parent, index4) => {
    var _a2;
    if (node2.isBlock && pos > from3) {
      text10 += blockSeparator;
    }
    const textSerializer = textSerializers == null ? void 0 : textSerializers[node2.type.name];
    if (textSerializer) {
      if (parent) {
        text10 += textSerializer({
          node: node2,
          pos,
          parent,
          index: index4,
          range
        });
      }
      return false;
    }
    if (node2.isText) {
      text10 += (_a2 = node2 == null ? void 0 : node2.text) == null ? void 0 : _a2.slice(Math.max(from3, pos) - pos, to3 - pos);
    }
  });
  return text10;
}
function getText(node2, options) {
  const range = {
    from: 0,
    to: node2.content.size
  };
  return getTextBetween(node2, range, options);
}
function getTextSerializersFromSchema(schema) {
  return Object.fromEntries(
    Object.entries(schema.nodes).filter(([, node2]) => node2.spec.toText).map(([name, node2]) => [name, node2.spec.toText])
  );
}
function getNodeAttributes(state, typeOrName) {
  const type = getNodeType(typeOrName, state.schema);
  const { from: from3, to: to3 } = state.selection;
  const nodes = [];
  state.doc.nodesBetween(from3, to3, (node22) => {
    nodes.push(node22);
  });
  const node2 = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
  if (!node2) {
    return {};
  }
  return { ...node2.attrs };
}
function getAttributes(state, typeOrName) {
  const schemaType = getSchemaTypeNameByName(
    typeof typeOrName === "string" ? typeOrName : typeOrName.name,
    state.schema
  );
  if (schemaType === "node") {
    return getNodeAttributes(state, typeOrName);
  }
  if (schemaType === "mark") {
    return getMarkAttributes(state, typeOrName);
  }
  return {};
}
function removeDuplicates(array, by = JSON.stringify) {
  const seen = {};
  return array.filter((item) => {
    const key2 = by(item);
    return Object.prototype.hasOwnProperty.call(seen, key2) ? false : seen[key2] = true;
  });
}
function simplifyChangedRanges(changes) {
  const uniqueChanges = removeDuplicates(changes);
  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index4) => {
    const rest = uniqueChanges.filter((_, i2) => i2 !== index4);
    return !rest.some((otherChange) => {
      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;
    });
  });
}
function getChangedRanges(transform2) {
  const { mapping, steps } = transform2;
  const changes = [];
  mapping.maps.forEach((stepMap, index4) => {
    const ranges = [];
    if (!stepMap.ranges.length) {
      const { from: from3, to: to3 } = steps[index4];
      if (from3 === void 0 || to3 === void 0) {
        return;
      }
      ranges.push({ from: from3, to: to3 });
    } else {
      stepMap.forEach((from3, to3) => {
        ranges.push({ from: from3, to: to3 });
      });
    }
    ranges.forEach(({ from: from3, to: to3 }) => {
      const newStart = mapping.slice(index4).map(from3, -1);
      const newEnd = mapping.slice(index4).map(to3);
      const oldStart = mapping.invert().map(newStart, -1);
      const oldEnd = mapping.invert().map(newEnd);
      changes.push({
        oldRange: {
          from: oldStart,
          to: oldEnd
        },
        newRange: {
          from: newStart,
          to: newEnd
        }
      });
    });
  });
  return simplifyChangedRanges(changes);
}
function getMarksBetween(from3, to3, doc2) {
  const marks = [];
  if (from3 === to3) {
    doc2.resolve(from3).marks().forEach((mark2) => {
      const $pos = doc2.resolve(from3);
      const range = getMarkRange($pos, mark2.type);
      if (!range) {
        return;
      }
      marks.push({
        mark: mark2,
        ...range
      });
    });
  } else {
    doc2.nodesBetween(from3, to3, (node2, pos) => {
      if (!node2 || (node2 == null ? void 0 : node2.nodeSize) === void 0) {
        return;
      }
      marks.push(
        ...node2.marks.map((mark2) => ({
          from: pos,
          to: pos + node2.nodeSize,
          mark: mark2
        }))
      );
    });
  }
  return marks;
}
function getSchemaTypeByName(name, schema) {
  return schema.nodes[name] || schema.marks[name] || null;
}
function getSplittedAttributes(extensionAttributes, typeName, attributes) {
  return Object.fromEntries(
    Object.entries(attributes).filter(([name]) => {
      const extensionAttribute = extensionAttributes.find((item) => {
        return item.type === typeName && item.name === name;
      });
      if (!extensionAttribute) {
        return false;
      }
      return extensionAttribute.attribute.keepOnSplit;
    })
  );
}
var getTextContentFromNodes = ($from, maxMatch = 500) => {
  let textBefore = "";
  const sliceEndPos = $from.parentOffset;
  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node2, pos, parent, index4) => {
    var _a2, _b;
    const chunk = ((_b = (_a2 = node2.type.spec).toText) == null ? void 0 : _b.call(_a2, {
      node: node2,
      pos,
      parent,
      index: index4
    })) || node2.textContent || "%leaf%";
    textBefore += node2.isAtom && !node2.isText ? chunk : chunk.slice(0, Math.max(0, sliceEndPos - pos));
  });
  return textBefore;
};
function isMarkActive(state, typeOrName, attributes = {}) {
  const { empty: empty3, ranges } = state.selection;
  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
  if (empty3) {
    return !!(state.storedMarks || state.selection.$from.marks()).filter((mark2) => {
      if (!type) {
        return true;
      }
      return type.name === mark2.type.name;
    }).find((mark2) => objectIncludes(mark2.attrs, attributes, { strict: false }));
  }
  let selectionRange = 0;
  const markRanges = [];
  ranges.forEach(({ $from, $to }) => {
    const from3 = $from.pos;
    const to3 = $to.pos;
    state.doc.nodesBetween(from3, to3, (node2, pos) => {
      if (!node2.isText && !node2.marks.length) {
        return;
      }
      const relativeFrom = Math.max(from3, pos);
      const relativeTo = Math.min(to3, pos + node2.nodeSize);
      const range2 = relativeTo - relativeFrom;
      selectionRange += range2;
      markRanges.push(
        ...node2.marks.map((mark2) => ({
          mark: mark2,
          from: relativeFrom,
          to: relativeTo
        }))
      );
    });
  });
  if (selectionRange === 0) {
    return false;
  }
  const matchedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return type.name === markRange.mark.type.name;
  }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const excludedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return markRange.mark.type !== type && markRange.mark.type.excludes(type);
  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range >= selectionRange;
}
function isActive(state, name, attributes = {}) {
  if (!name) {
    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
  }
  const schemaType = getSchemaTypeNameByName(name, state.schema);
  if (schemaType === "node") {
    return isNodeActive(state, name, attributes);
  }
  if (schemaType === "mark") {
    return isMarkActive(state, name, attributes);
  }
  return false;
}
function isExtensionRulesEnabled(extension2, enabled) {
  if (Array.isArray(enabled)) {
    return enabled.some((enabledExtension) => {
      const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
      return name === extension2.name;
    });
  }
  return enabled;
}
function isList(name, extensions) {
  const { nodeExtensions } = splitExtensions(extensions);
  const extension2 = nodeExtensions.find((item) => item.name === name);
  if (!extension2) {
    return false;
  }
  const context = {
    name: extension2.name,
    options: extension2.options,
    storage: extension2.storage
  };
  const group = callOrReturn(getExtensionField(extension2, "group", context));
  if (typeof group !== "string") {
    return false;
  }
  return group.split(" ").includes("list");
}
function isNodeEmpty(node2, {
  checkChildren = true,
  ignoreWhitespace = false
} = {}) {
  var _a2;
  if (ignoreWhitespace) {
    if (node2.type.name === "hardBreak") {
      return true;
    }
    if (node2.isText) {
      return /^\s*$/m.test((_a2 = node2.text) != null ? _a2 : "");
    }
  }
  if (node2.isText) {
    return !node2.text;
  }
  if (node2.isAtom || node2.isLeaf) {
    return false;
  }
  if (node2.content.childCount === 0) {
    return true;
  }
  if (checkChildren) {
    let isContentEmpty = true;
    node2.content.forEach((childNode) => {
      if (isContentEmpty === false) {
        return;
      }
      if (!isNodeEmpty(childNode, { ignoreWhitespace, checkChildren })) {
        isContentEmpty = false;
      }
    });
    return isContentEmpty;
  }
  return false;
}
function isNodeSelection(value) {
  return value instanceof NodeSelection;
}
function posToDOMRect(view, from3, to3) {
  const minPos = 0;
  const maxPos = view.state.doc.content.size;
  const resolvedFrom = minMax(from3, minPos, maxPos);
  const resolvedEnd = minMax(to3, minPos, maxPos);
  const start = view.coordsAtPos(resolvedFrom);
  const end = view.coordsAtPos(resolvedEnd, -1);
  const top = Math.min(start.top, end.top);
  const bottom = Math.max(start.bottom, end.bottom);
  const left = Math.min(start.left, end.left);
  const right = Math.max(start.right, end.right);
  const width = right - left;
  const height = bottom - top;
  const x4 = left;
  const y2 = top;
  const data = {
    top,
    bottom,
    left,
    right,
    width,
    height,
    x: x4,
    y: y2
  };
  return {
    ...data,
    toJSON: () => data
  };
}
function canSetMark(state, tr5, newMarkType) {
  var _a2;
  const { selection } = tr5;
  let cursor = null;
  if (isTextSelection(selection)) {
    cursor = selection.$cursor;
  }
  if (cursor) {
    const currentMarks = (_a2 = state.storedMarks) != null ? _a2 : cursor.marks();
    const parentAllowsMarkType = cursor.parent.type.allowsMarkType(newMarkType);
    return parentAllowsMarkType && (!!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark2) => mark2.type.excludes(newMarkType)));
  }
  const { ranges } = selection;
  return ranges.some(({ $from, $to }) => {
    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
    state.doc.nodesBetween($from.pos, $to.pos, (node2, _pos, parent) => {
      if (someNodeSupportsMark) {
        return false;
      }
      if (node2.isInline) {
        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
        const currentMarksAllowMarkType = !!newMarkType.isInSet(node2.marks) || !node2.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
      }
      return !someNodeSupportsMark;
    });
    return someNodeSupportsMark;
  });
}
var setMark = (typeOrName, attributes = {}) => ({ tr: tr5, state, dispatch }) => {
  const { selection } = tr5;
  const { empty: empty3, ranges } = selection;
  const type = getMarkType(typeOrName, state.schema);
  if (dispatch) {
    if (empty3) {
      const oldAttributes = getMarkAttributes(state, type);
      tr5.addStoredMark(
        type.create({
          ...oldAttributes,
          ...attributes
        })
      );
    } else {
      ranges.forEach((range) => {
        const from3 = range.$from.pos;
        const to3 = range.$to.pos;
        state.doc.nodesBetween(from3, to3, (node2, pos) => {
          const trimmedFrom = Math.max(pos, from3);
          const trimmedTo = Math.min(pos + node2.nodeSize, to3);
          const someHasMark = node2.marks.find((mark2) => mark2.type === type);
          if (someHasMark) {
            node2.marks.forEach((mark2) => {
              if (type === mark2.type) {
                tr5.addMark(
                  trimmedFrom,
                  trimmedTo,
                  type.create({
                    ...mark2.attrs,
                    ...attributes
                  })
                );
              }
            });
          } else {
            tr5.addMark(trimmedFrom, trimmedTo, type.create(attributes));
          }
        });
      });
    }
  }
  return canSetMark(state, tr5, type);
};
var setMeta = (key2, value) => ({ tr: tr5 }) => {
  tr5.setMeta(key2, value);
  return true;
};
var setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {
  const type = getNodeType(typeOrName, state.schema);
  let attributesToCopy;
  if (state.selection.$anchor.sameParent(state.selection.$head)) {
    attributesToCopy = state.selection.$anchor.parent.attrs;
  }
  if (!type.isTextblock) {
    console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
    return false;
  }
  return chain().command(({ commands }) => {
    const canSetBlock = setBlockType(type, { ...attributesToCopy, ...attributes })(state);
    if (canSetBlock) {
      return true;
    }
    return commands.clearNodes();
  }).command(({ state: updatedState }) => {
    return setBlockType(type, { ...attributesToCopy, ...attributes })(updatedState, dispatch);
  }).run();
};
var setNodeSelection = (position4) => ({ tr: tr5, dispatch }) => {
  if (dispatch) {
    const { doc: doc2 } = tr5;
    const from3 = minMax(position4, 0, doc2.content.size);
    const selection = NodeSelection.create(doc2, from3);
    tr5.setSelection(selection);
  }
  return true;
};
var setTextSelection = (position4) => ({ tr: tr5, dispatch }) => {
  if (dispatch) {
    const { doc: doc2 } = tr5;
    const { from: from3, to: to3 } = typeof position4 === "number" ? { from: position4, to: position4 } : position4;
    const minPos = TextSelection.atStart(doc2).from;
    const maxPos = TextSelection.atEnd(doc2).to;
    const resolvedFrom = minMax(from3, minPos, maxPos);
    const resolvedEnd = minMax(to3, minPos, maxPos);
    const selection = TextSelection.create(doc2, resolvedFrom, resolvedEnd);
    tr5.setSelection(selection);
  }
  return true;
};
var sinkListItem2 = (typeOrName) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return sinkListItem(type)(state, dispatch);
};
function ensureMarks(state, splittableMarks) {
  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
  if (marks) {
    const filteredMarks = marks.filter((mark2) => splittableMarks == null ? void 0 : splittableMarks.includes(mark2.type.name));
    state.tr.ensureMarks(filteredMarks);
  }
}
var splitBlock = ({ keepMarks = true } = {}) => ({ tr: tr5, state, dispatch, editor }) => {
  const { selection, doc: doc2 } = tr5;
  const { $from, $to } = selection;
  const extensionAttributes = editor.extensionManager.attributes;
  const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
  if (selection instanceof NodeSelection && selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(doc2, $from.pos)) {
      return false;
    }
    if (dispatch) {
      if (keepMarks) {
        ensureMarks(state, editor.extensionManager.splittableMarks);
      }
      tr5.split($from.pos).scrollIntoView();
    }
    return true;
  }
  if (!$from.parent.isBlock) {
    return false;
  }
  const atEnd = $to.parentOffset === $to.parent.content.size;
  const deflt = $from.depth === 0 ? void 0 : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
  let types2 = atEnd && deflt ? [
    {
      type: deflt,
      attrs: newAttributes
    }
  ] : void 0;
  let can = canSplit(tr5.doc, tr5.mapping.map($from.pos), 1, types2);
  if (!types2 && !can && canSplit(tr5.doc, tr5.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
    can = true;
    types2 = deflt ? [
      {
        type: deflt,
        attrs: newAttributes
      }
    ] : void 0;
  }
  if (dispatch) {
    if (can) {
      if (selection instanceof TextSelection) {
        tr5.deleteSelection();
      }
      tr5.split(tr5.mapping.map($from.pos), 1, types2);
      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
        const first2 = tr5.mapping.map($from.before());
        const $first = tr5.doc.resolve(first2);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr5.setNodeMarkup(tr5.mapping.map($from.before()), deflt);
        }
      }
    }
    if (keepMarks) {
      ensureMarks(state, editor.extensionManager.splittableMarks);
    }
    tr5.scrollIntoView();
  }
  return can;
};
var splitListItem = (typeOrName, overrideAttrs = {}) => ({ tr: tr5, state, dispatch, editor }) => {
  var _a2;
  const type = getNodeType(typeOrName, state.schema);
  const { $from, $to } = state.selection;
  const node2 = state.selection.node;
  if (node2 && node2.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
    return false;
  }
  const grandParent = $from.node(-1);
  if (grandParent.type !== type) {
    return false;
  }
  const extensionAttributes = editor.extensionManager.attributes;
  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
      return false;
    }
    if (dispatch) {
      let wrap4 = Fragment.empty;
      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
        wrap4 = Fragment.from($from.node(d).copy(wrap4));
      }
      const depthAfter = (
        // eslint-disable-next-line no-nested-ternary
        $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3
      );
      const newNextTypeAttributes2 = {
        ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),
        ...overrideAttrs
      };
      const nextType2 = ((_a2 = type.contentMatch.defaultType) == null ? void 0 : _a2.createAndFill(newNextTypeAttributes2)) || void 0;
      wrap4 = wrap4.append(Fragment.from(type.createAndFill(null, nextType2) || void 0));
      const start = $from.before($from.depth - (depthBefore - 1));
      tr5.replace(start, $from.after(-depthAfter), new Slice(wrap4, 4 - depthBefore, 0));
      let sel = -1;
      tr5.doc.nodesBetween(start, tr5.doc.content.size, (n, pos) => {
        if (sel > -1) {
          return false;
        }
        if (n.isTextblock && n.content.size === 0) {
          sel = pos + 1;
        }
      });
      if (sel > -1) {
        tr5.setSelection(TextSelection.near(tr5.doc.resolve(sel)));
      }
      tr5.scrollIntoView();
    }
    return true;
  }
  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
  const newTypeAttributes = {
    ...getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs),
    ...overrideAttrs
  };
  const newNextTypeAttributes = {
    ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),
    ...overrideAttrs
  };
  tr5.delete($from.pos, $to.pos);
  const types2 = nextType ? [
    { type, attrs: newTypeAttributes },
    { type: nextType, attrs: newNextTypeAttributes }
  ] : [{ type, attrs: newTypeAttributes }];
  if (!canSplit(tr5.doc, $from.pos, 2)) {
    return false;
  }
  if (dispatch) {
    const { selection, storedMarks } = state;
    const { splittableMarks } = editor.extensionManager;
    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
    tr5.split($from.pos, 2, types2).scrollIntoView();
    if (!marks || !dispatch) {
      return true;
    }
    const filteredMarks = marks.filter((mark2) => splittableMarks.includes(mark2.type.name));
    tr5.ensureMarks(filteredMarks);
  }
  return true;
};
var joinListBackwards = (tr5, listType) => {
  const list7 = findParentNode((node2) => node2.type === listType)(tr5.selection);
  if (!list7) {
    return true;
  }
  const before = tr5.doc.resolve(Math.max(0, list7.pos - 1)).before(list7.depth);
  if (before === void 0) {
    return true;
  }
  const nodeBefore = tr5.doc.nodeAt(before);
  const canJoinBackwards = list7.node.type === (nodeBefore == null ? void 0 : nodeBefore.type) && canJoin(tr5.doc, list7.pos);
  if (!canJoinBackwards) {
    return true;
  }
  tr5.join(list7.pos);
  return true;
};
var joinListForwards = (tr5, listType) => {
  const list7 = findParentNode((node2) => node2.type === listType)(tr5.selection);
  if (!list7) {
    return true;
  }
  const after = tr5.doc.resolve(list7.start).after(list7.depth);
  if (after === void 0) {
    return true;
  }
  const nodeAfter = tr5.doc.nodeAt(after);
  const canJoinForwards = list7.node.type === (nodeAfter == null ? void 0 : nodeAfter.type) && canJoin(tr5.doc, after);
  if (!canJoinForwards) {
    return true;
  }
  tr5.join(after);
  return true;
};
var toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr: tr5, state, dispatch, chain, commands, can }) => {
  const { extensions, splittableMarks } = editor.extensionManager;
  const listType = getNodeType(listTypeOrName, state.schema);
  const itemType = getNodeType(itemTypeOrName, state.schema);
  const { selection, storedMarks } = state;
  const { $from, $to } = selection;
  const range = $from.blockRange($to);
  const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
  if (!range) {
    return false;
  }
  const parentList = findParentNode((node2) => isList(node2.type.name, extensions))(selection);
  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
    if (parentList.node.type === listType) {
      return commands.liftListItem(itemType);
    }
    if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {
      return chain().command(() => {
        tr5.setNodeMarkup(parentList.pos, listType);
        return true;
      }).command(() => joinListBackwards(tr5, listType)).command(() => joinListForwards(tr5, listType)).run();
    }
  }
  if (!keepMarks || !marks || !dispatch) {
    return chain().command(() => {
      const canWrapInList = can().wrapInList(listType, attributes);
      if (canWrapInList) {
        return true;
      }
      return commands.clearNodes();
    }).wrapInList(listType, attributes).command(() => joinListBackwards(tr5, listType)).command(() => joinListForwards(tr5, listType)).run();
  }
  return chain().command(() => {
    const canWrapInList = can().wrapInList(listType, attributes);
    const filteredMarks = marks.filter((mark2) => splittableMarks.includes(mark2.type.name));
    tr5.ensureMarks(filteredMarks);
    if (canWrapInList) {
      return true;
    }
    return commands.clearNodes();
  }).wrapInList(listType, attributes).command(() => joinListBackwards(tr5, listType)).command(() => joinListForwards(tr5, listType)).run();
};
var toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands }) => {
  const { extendEmptyMarkRange = false } = options;
  const type = getMarkType(typeOrName, state.schema);
  const isActive2 = isMarkActive(state, type, attributes);
  if (isActive2) {
    return commands.unsetMark(type, { extendEmptyMarkRange });
  }
  return commands.setMark(type, attributes);
};
var toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {
  const type = getNodeType(typeOrName, state.schema);
  const toggleType = getNodeType(toggleTypeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  let attributesToCopy;
  if (state.selection.$anchor.sameParent(state.selection.$head)) {
    attributesToCopy = state.selection.$anchor.parent.attrs;
  }
  if (isActive2) {
    return commands.setNode(toggleType, attributesToCopy);
  }
  return commands.setNode(type, { ...attributesToCopy, ...attributes });
};
var toggleWrap = (typeOrName, attributes = {}) => ({ state, commands }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (isActive2) {
    return commands.lift(type);
  }
  return commands.wrapIn(type, attributes);
};
var undoInputRule = () => ({ state, dispatch }) => {
  const plugins = state.plugins;
  for (let i2 = 0; i2 < plugins.length; i2 += 1) {
    const plugin = plugins[i2];
    let undoable;
    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch) {
        const tr5 = state.tr;
        const toUndo = undoable.transform;
        for (let j5 = toUndo.steps.length - 1; j5 >= 0; j5 -= 1) {
          tr5.step(toUndo.steps[j5].invert(toUndo.docs[j5]));
        }
        if (undoable.text) {
          const marks = tr5.doc.resolve(undoable.from).marks();
          tr5.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
        } else {
          tr5.delete(undoable.from, undoable.to);
        }
      }
      return true;
    }
  }
  return false;
};
var unsetAllMarks = () => ({ tr: tr5, dispatch }) => {
  const { selection } = tr5;
  const { empty: empty3, ranges } = selection;
  if (empty3) {
    return true;
  }
  if (dispatch) {
    ranges.forEach((range) => {
      tr5.removeMark(range.$from.pos, range.$to.pos);
    });
  }
  return true;
};
var unsetMark = (typeOrName, options = {}) => ({ tr: tr5, state, dispatch }) => {
  var _a2;
  const { extendEmptyMarkRange = false } = options;
  const { selection } = tr5;
  const type = getMarkType(typeOrName, state.schema);
  const { $from, empty: empty3, ranges } = selection;
  if (!dispatch) {
    return true;
  }
  if (empty3 && extendEmptyMarkRange) {
    let { from: from3, to: to3 } = selection;
    const attrs = (_a2 = $from.marks().find((mark2) => mark2.type === type)) == null ? void 0 : _a2.attrs;
    const range = getMarkRange($from, type, attrs);
    if (range) {
      from3 = range.from;
      to3 = range.to;
    }
    tr5.removeMark(from3, to3, type);
  } else {
    ranges.forEach((range) => {
      tr5.removeMark(range.$from.pos, range.$to.pos, type);
    });
  }
  tr5.removeStoredMark(type);
  return true;
};
var updateAttributes = (typeOrName, attributes = {}) => ({ tr: tr5, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(
    typeof typeOrName === "string" ? typeOrName : typeOrName.name,
    state.schema
  );
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch) {
    tr5.selection.ranges.forEach((range) => {
      const from3 = range.$from.pos;
      const to3 = range.$to.pos;
      let lastPos;
      let lastNode;
      let trimmedFrom;
      let trimmedTo;
      if (tr5.selection.empty) {
        state.doc.nodesBetween(from3, to3, (node2, pos) => {
          if (nodeType && nodeType === node2.type) {
            trimmedFrom = Math.max(pos, from3);
            trimmedTo = Math.min(pos + node2.nodeSize, to3);
            lastPos = pos;
            lastNode = node2;
          }
        });
      } else {
        state.doc.nodesBetween(from3, to3, (node2, pos) => {
          if (pos < from3 && nodeType && nodeType === node2.type) {
            trimmedFrom = Math.max(pos, from3);
            trimmedTo = Math.min(pos + node2.nodeSize, to3);
            lastPos = pos;
            lastNode = node2;
          }
          if (pos >= from3 && pos <= to3) {
            if (nodeType && nodeType === node2.type) {
              tr5.setNodeMarkup(pos, void 0, {
                ...node2.attrs,
                ...attributes
              });
            }
            if (markType && node2.marks.length) {
              node2.marks.forEach((mark2) => {
                if (markType === mark2.type) {
                  const trimmedFrom2 = Math.max(pos, from3);
                  const trimmedTo2 = Math.min(pos + node2.nodeSize, to3);
                  tr5.addMark(
                    trimmedFrom2,
                    trimmedTo2,
                    markType.create({
                      ...mark2.attrs,
                      ...attributes
                    })
                  );
                }
              });
            }
          }
        });
      }
      if (lastNode) {
        if (lastPos !== void 0) {
          tr5.setNodeMarkup(lastPos, void 0, {
            ...lastNode.attrs,
            ...attributes
          });
        }
        if (markType && lastNode.marks.length) {
          lastNode.marks.forEach((mark2) => {
            if (markType === mark2.type) {
              tr5.addMark(
                trimmedFrom,
                trimmedTo,
                markType.create({
                  ...mark2.attrs,
                  ...attributes
                })
              );
            }
          });
        }
      }
    });
  }
  return true;
};
var wrapIn2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapIn(type, attributes)(state, dispatch);
};
var wrapInList2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapInList(type, attributes)(state, dispatch);
};
var EventEmitter = class {
  constructor() {
    this.callbacks = {};
  }
  on(event, fn3) {
    if (!this.callbacks[event]) {
      this.callbacks[event] = [];
    }
    this.callbacks[event].push(fn3);
    return this;
  }
  emit(event, ...args2) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      callbacks.forEach((callback) => callback.apply(this, args2));
    }
    return this;
  }
  off(event, fn3) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      if (fn3) {
        this.callbacks[event] = callbacks.filter((callback) => callback !== fn3);
      } else {
        delete this.callbacks[event];
      }
    }
    return this;
  }
  once(event, fn3) {
    const onceFn = (...args2) => {
      this.off(event, onceFn);
      fn3.apply(this, args2);
    };
    return this.on(event, onceFn);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
};
var InputRule = class {
  constructor(config) {
    var _a2;
    this.find = config.find;
    this.handler = config.handler;
    this.undoable = (_a2 = config.undoable) != null ? _a2 : true;
  }
};
var inputRuleMatcherHandler = (text10, find4) => {
  if (isRegExp(find4)) {
    return find4.exec(text10);
  }
  const inputRuleMatch = find4(text10);
  if (!inputRuleMatch) {
    return null;
  }
  const result = [inputRuleMatch.text];
  result.index = inputRuleMatch.index;
  result.input = text10;
  result.data = inputRuleMatch.data;
  if (inputRuleMatch.replaceWith) {
    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
      console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
    }
    result.push(inputRuleMatch.replaceWith);
  }
  return result;
};
function run(config) {
  var _a2;
  const { editor, from: from3, to: to3, text: text10, rules, plugin } = config;
  const { view } = editor;
  if (view.composing) {
    return false;
  }
  const $from = view.state.doc.resolve(from3);
  if (
    // check for code node
    $from.parent.type.spec.code || // check for code mark
    !!((_a2 = $from.nodeBefore || $from.nodeAfter) == null ? void 0 : _a2.marks.find((mark2) => mark2.type.spec.code))
  ) {
    return false;
  }
  let matched = false;
  const textBefore = getTextContentFromNodes($from) + text10;
  rules.forEach((rule) => {
    if (matched) {
      return;
    }
    const match = inputRuleMatcherHandler(textBefore, rule.find);
    if (!match) {
      return;
    }
    const tr5 = view.state.tr;
    const state = createChainableState({
      state: view.state,
      transaction: tr5
    });
    const range = {
      from: from3 - (match[0].length - text10.length),
      to: to3
    };
    const { commands, chain, can } = new CommandManager({
      editor,
      state
    });
    const handler = rule.handler({
      state,
      range,
      match,
      commands,
      chain,
      can
    });
    if (handler === null || !tr5.steps.length) {
      return;
    }
    if (rule.undoable) {
      tr5.setMeta(plugin, {
        transform: tr5,
        from: from3,
        to: to3,
        text: text10
      });
    }
    view.dispatch(tr5);
    matched = true;
  });
  return matched;
}
function inputRulesPlugin(props) {
  const { editor, rules } = props;
  const plugin = new Plugin({
    state: {
      init() {
        return null;
      },
      apply(tr5, prev, state) {
        const stored = tr5.getMeta(plugin);
        if (stored) {
          return stored;
        }
        const simulatedInputMeta = tr5.getMeta("applyInputRules");
        const isSimulatedInput = !!simulatedInputMeta;
        if (isSimulatedInput) {
          setTimeout(() => {
            let { text: text10 } = simulatedInputMeta;
            if (typeof text10 === "string") {
              text10 = text10;
            } else {
              text10 = getHTMLFromFragment(Fragment.from(text10), state.schema);
            }
            const { from: from3 } = simulatedInputMeta;
            const to3 = from3 + text10.length;
            run({
              editor,
              from: from3,
              to: to3,
              text: text10,
              rules,
              plugin
            });
          });
        }
        return tr5.selectionSet || tr5.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput(view, from3, to3, text10) {
        return run({
          editor,
          from: from3,
          to: to3,
          text: text10,
          rules,
          plugin
        });
      },
      handleDOMEvents: {
        compositionend: (view) => {
          setTimeout(() => {
            const { $cursor } = view.state.selection;
            if ($cursor) {
              run({
                editor,
                from: $cursor.pos,
                to: $cursor.pos,
                text: "",
                rules,
                plugin
              });
            }
          });
          return false;
        }
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(view, event) {
        if (event.key !== "Enter") {
          return false;
        }
        const { $cursor } = view.state.selection;
        if ($cursor) {
          return run({
            editor,
            from: $cursor.pos,
            to: $cursor.pos,
            text: "\n",
            rules,
            plugin
          });
        }
        return false;
      }
    },
    // @ts-ignore
    isInputRules: true
  });
  return plugin;
}
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}
function isPlainObject(value) {
  if (getType(value) !== "Object") {
    return false;
  }
  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
}
function mergeDeep(target, source) {
  const output = { ...target };
  if (isPlainObject(target) && isPlainObject(source)) {
    Object.keys(source).forEach((key2) => {
      if (isPlainObject(source[key2]) && isPlainObject(target[key2])) {
        output[key2] = mergeDeep(target[key2], source[key2]);
      } else {
        output[key2] = source[key2];
      }
    });
  }
  return output;
}
var Extendable = class {
  constructor(config = {}) {
    this.type = "extendable";
    this.parent = null;
    this.child = null;
    this.name = "";
    this.config = {
      name: this.name
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
  }
  get options() {
    return {
      ...callOrReturn(
        getExtensionField(this, "addOptions", {
          name: this.name
        })
      ) || {}
    };
  }
  get storage() {
    return {
      ...callOrReturn(
        getExtensionField(this, "addStorage", {
          name: this.name,
          options: this.options
        })
      ) || {}
    };
  }
  configure(options = {}) {
    const extension2 = this.extend({
      ...this.config,
      addOptions: () => {
        return mergeDeep(this.options, options);
      }
    });
    extension2.name = this.name;
    extension2.parent = this.parent;
    return extension2;
  }
  extend(extendedConfig = {}) {
    const extension2 = new this.constructor({ ...this.config, ...extendedConfig });
    extension2.parent = this;
    this.child = extension2;
    extension2.name = "name" in extendedConfig ? extendedConfig.name : extension2.parent.name;
    return extension2;
  }
};
var Mark = class _Mark extends Extendable {
  constructor() {
    super(...arguments);
    this.type = "mark";
  }
  /**
   * Create a new Mark instance
   * @param config - Mark configuration object or a function that returns a configuration object
   */
  static create(config = {}) {
    const resolvedConfig = typeof config === "function" ? config() : config;
    return new _Mark(resolvedConfig);
  }
  static handleExit({ editor, mark: mark2 }) {
    const { tr: tr5 } = editor.state;
    const currentPos = editor.state.selection.$from;
    const isAtEnd = currentPos.pos === currentPos.end();
    if (isAtEnd) {
      const currentMarks = currentPos.marks();
      const isInMark = !!currentMarks.find((m) => (m == null ? void 0 : m.type.name) === mark2.name);
      if (!isInMark) {
        return false;
      }
      const removeMark = currentMarks.find((m) => (m == null ? void 0 : m.type.name) === mark2.name);
      if (removeMark) {
        tr5.removeStoredMark(removeMark);
      }
      tr5.insertText(" ", currentPos.pos);
      editor.view.dispatch(tr5);
      return true;
    }
    return false;
  }
  configure(options) {
    return super.configure(options);
  }
  extend(extendedConfig) {
    const resolvedConfig = typeof extendedConfig === "function" ? extendedConfig() : extendedConfig;
    return super.extend(resolvedConfig);
  }
};
function isNumber(value) {
  return typeof value === "number";
}
var PasteRule = class {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
};
var pasteRuleMatcherHandler = (text10, find4, event) => {
  if (isRegExp(find4)) {
    return [...text10.matchAll(find4)];
  }
  const matches2 = find4(text10, event);
  if (!matches2) {
    return [];
  }
  return matches2.map((pasteRuleMatch) => {
    const result = [pasteRuleMatch.text];
    result.index = pasteRuleMatch.index;
    result.input = text10;
    result.data = pasteRuleMatch.data;
    if (pasteRuleMatch.replaceWith) {
      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
        console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
      }
      result.push(pasteRuleMatch.replaceWith);
    }
    return result;
  });
};
function run2(config) {
  const { editor, state, from: from3, to: to3, rule, pasteEvent, dropEvent } = config;
  const { commands, chain, can } = new CommandManager({
    editor,
    state
  });
  const handlers3 = [];
  state.doc.nodesBetween(from3, to3, (node2, pos) => {
    var _a2, _b, _c, _d, _e3;
    if (((_b = (_a2 = node2.type) == null ? void 0 : _a2.spec) == null ? void 0 : _b.code) || !(node2.isText || node2.isTextblock || node2.isInline)) {
      return;
    }
    const contentSize = (_e3 = (_d = (_c = node2.content) == null ? void 0 : _c.size) != null ? _d : node2.nodeSize) != null ? _e3 : 0;
    const resolvedFrom = Math.max(from3, pos);
    const resolvedTo = Math.min(to3, pos + contentSize);
    if (resolvedFrom >= resolvedTo) {
      return;
    }
    const textToMatch = node2.isText ? node2.text || "" : node2.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "");
    const matches2 = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);
    matches2.forEach((match) => {
      if (match.index === void 0) {
        return;
      }
      const start = resolvedFrom + match.index + 1;
      const end = start + match[0].length;
      const range = {
        from: state.tr.mapping.map(start),
        to: state.tr.mapping.map(end)
      };
      const handler = rule.handler({
        state,
        range,
        match,
        commands,
        chain,
        can,
        pasteEvent,
        dropEvent
      });
      handlers3.push(handler);
    });
  });
  const success = handlers3.every((handler) => handler !== null);
  return success;
}
var tiptapDragFromOtherEditor = null;
var createClipboardPasteEvent = (text10) => {
  var _a2;
  const event = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  (_a2 = event.clipboardData) == null ? void 0 : _a2.setData("text/html", text10);
  return event;
};
function pasteRulesPlugin(props) {
  const { editor, rules } = props;
  let dragSourceElement = null;
  let isPastedFromProseMirror = false;
  let isDroppedFromProseMirror = false;
  let pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
  let dropEvent;
  try {
    dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
  } catch {
    dropEvent = null;
  }
  const processEvent = ({
    state,
    from: from3,
    to: to3,
    rule,
    pasteEvt
  }) => {
    const tr5 = state.tr;
    const chainableState = createChainableState({
      state,
      transaction: tr5
    });
    const handler = run2({
      editor,
      state: chainableState,
      from: Math.max(from3 - 1, 0),
      to: to3.b - 1,
      rule,
      pasteEvent: pasteEvt,
      dropEvent
    });
    if (!handler || !tr5.steps.length) {
      return;
    }
    try {
      dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
    } catch {
      dropEvent = null;
    }
    pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
    return tr5;
  };
  const plugins = rules.map((rule) => {
    return new Plugin({
      // we register a global drag handler to track the current drag source element
      view(view) {
        const handleDragstart = (event) => {
          var _a2;
          dragSourceElement = ((_a2 = view.dom.parentElement) == null ? void 0 : _a2.contains(event.target)) ? view.dom.parentElement : null;
          if (dragSourceElement) {
            tiptapDragFromOtherEditor = editor;
          }
        };
        const handleDragend = () => {
          if (tiptapDragFromOtherEditor) {
            tiptapDragFromOtherEditor = null;
          }
        };
        window.addEventListener("dragstart", handleDragstart);
        window.addEventListener("dragend", handleDragend);
        return {
          destroy() {
            window.removeEventListener("dragstart", handleDragstart);
            window.removeEventListener("dragend", handleDragend);
          }
        };
      },
      props: {
        handleDOMEvents: {
          drop: (view, event) => {
            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
            dropEvent = event;
            if (!isDroppedFromProseMirror) {
              const dragFromOtherEditor = tiptapDragFromOtherEditor;
              if (dragFromOtherEditor == null ? void 0 : dragFromOtherEditor.isEditable) {
                setTimeout(() => {
                  const selection = dragFromOtherEditor.state.selection;
                  if (selection) {
                    dragFromOtherEditor.commands.deleteRange({ from: selection.from, to: selection.to });
                  }
                }, 10);
              }
            }
            return false;
          },
          paste: (_view, event) => {
            var _a2;
            const html7 = (_a2 = event.clipboardData) == null ? void 0 : _a2.getData("text/html");
            pasteEvent = event;
            isPastedFromProseMirror = !!(html7 == null ? void 0 : html7.includes("data-pm-slice"));
            return false;
          }
        }
      },
      appendTransaction: (transactions, oldState, state) => {
        const transaction = transactions[0];
        const isPaste = transaction.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
        const isDrop = transaction.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
        const simulatedPasteMeta = transaction.getMeta("applyPasteRules");
        const isSimulatedPaste = !!simulatedPasteMeta;
        if (!isPaste && !isDrop && !isSimulatedPaste) {
          return;
        }
        if (isSimulatedPaste) {
          let { text: text10 } = simulatedPasteMeta;
          if (typeof text10 === "string") {
            text10 = text10;
          } else {
            text10 = getHTMLFromFragment(Fragment.from(text10), state.schema);
          }
          const { from: from22 } = simulatedPasteMeta;
          const to22 = from22 + text10.length;
          const pasteEvt = createClipboardPasteEvent(text10);
          return processEvent({
            rule,
            state,
            from: from22,
            to: { b: to22 },
            pasteEvt
          });
        }
        const from3 = oldState.doc.content.findDiffStart(state.doc.content);
        const to3 = oldState.doc.content.findDiffEnd(state.doc.content);
        if (!isNumber(from3) || !to3 || from3 === to3.b) {
          return;
        }
        return processEvent({
          rule,
          state,
          from: from3,
          to: to3,
          pasteEvt: pasteEvent
        });
      }
    });
  });
  return plugins;
}
var ExtensionManager = class {
  constructor(extensions, editor) {
    this.splittableMarks = [];
    this.editor = editor;
    this.baseExtensions = extensions;
    this.extensions = resolveExtensions(extensions);
    this.schema = getSchemaByResolvedExtensions(this.extensions, editor);
    this.setupExtensions();
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((commands, extension2) => {
      const context = {
        name: extension2.name,
        options: extension2.options,
        storage: this.editor.extensionStorage[extension2.name],
        editor: this.editor,
        type: getSchemaTypeByName(extension2.name, this.schema)
      };
      const addCommands = getExtensionField(extension2, "addCommands", context);
      if (!addCommands) {
        return commands;
      }
      return {
        ...commands,
        ...addCommands()
      };
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor } = this;
    const extensions = sortExtensions([...this.extensions].reverse());
    const allPlugins = extensions.flatMap((extension2) => {
      const context = {
        name: extension2.name,
        options: extension2.options,
        storage: this.editor.extensionStorage[extension2.name],
        editor,
        type: getSchemaTypeByName(extension2.name, this.schema)
      };
      const plugins = [];
      const addKeyboardShortcuts = getExtensionField(
        extension2,
        "addKeyboardShortcuts",
        context
      );
      let defaultBindings = {};
      if (extension2.type === "mark" && getExtensionField(extension2, "exitable", context)) {
        defaultBindings.ArrowRight = () => Mark.handleExit({ editor, mark: extension2 });
      }
      if (addKeyboardShortcuts) {
        const bindings = Object.fromEntries(
          Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {
            return [shortcut, () => method({ editor })];
          })
        );
        defaultBindings = { ...defaultBindings, ...bindings };
      }
      const keyMapPlugin = keymap(defaultBindings);
      plugins.push(keyMapPlugin);
      const addInputRules = getExtensionField(extension2, "addInputRules", context);
      if (isExtensionRulesEnabled(extension2, editor.options.enableInputRules) && addInputRules) {
        const rules = addInputRules();
        if (rules && rules.length) {
          const inputResult = inputRulesPlugin({
            editor,
            rules
          });
          const inputPlugins = Array.isArray(inputResult) ? inputResult : [inputResult];
          plugins.push(...inputPlugins);
        }
      }
      const addPasteRules = getExtensionField(extension2, "addPasteRules", context);
      if (isExtensionRulesEnabled(extension2, editor.options.enablePasteRules) && addPasteRules) {
        const rules = addPasteRules();
        if (rules && rules.length) {
          const pasteRules = pasteRulesPlugin({ editor, rules });
          plugins.push(...pasteRules);
        }
      }
      const addProseMirrorPlugins = getExtensionField(
        extension2,
        "addProseMirrorPlugins",
        context
      );
      if (addProseMirrorPlugins) {
        const proseMirrorPlugins = addProseMirrorPlugins();
        plugins.push(...proseMirrorPlugins);
      }
      return plugins;
    });
    return allPlugins;
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return getAttributesFromExtensions(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor } = this;
    const { nodeExtensions } = splitExtensions(this.extensions);
    return Object.fromEntries(
      nodeExtensions.filter((extension2) => !!getExtensionField(extension2, "addNodeView")).map((extension2) => {
        const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension2.name);
        const context = {
          name: extension2.name,
          options: extension2.options,
          storage: this.editor.extensionStorage[extension2.name],
          editor,
          type: getNodeType(extension2.name, this.schema)
        };
        const addNodeView = getExtensionField(extension2, "addNodeView", context);
        if (!addNodeView) {
          return [];
        }
        const nodeview = (node2, view, getPos, decorations, innerDecorations) => {
          const HTMLAttributes = getRenderedAttributes(node2, extensionAttributes);
          return addNodeView()({
            // pass-through
            node: node2,
            view,
            getPos,
            decorations,
            innerDecorations,
            // tiptap-specific
            editor,
            extension: extension2,
            HTMLAttributes
          });
        };
        return [extension2.name, nodeview];
      })
    );
  }
  get markViews() {
    const { editor } = this;
    const { markExtensions } = splitExtensions(this.extensions);
    return Object.fromEntries(
      markExtensions.filter((extension2) => !!getExtensionField(extension2, "addMarkView")).map((extension2) => {
        const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension2.name);
        const context = {
          name: extension2.name,
          options: extension2.options,
          storage: this.editor.extensionStorage[extension2.name],
          editor,
          type: getMarkType(extension2.name, this.schema)
        };
        const addMarkView = getExtensionField(extension2, "addMarkView", context);
        if (!addMarkView) {
          return [];
        }
        const markView = (mark2, view, inline4) => {
          const HTMLAttributes = getRenderedAttributes(mark2, extensionAttributes);
          return addMarkView()({
            // pass-through
            mark: mark2,
            view,
            inline: inline4,
            // tiptap-specific
            editor,
            extension: extension2,
            HTMLAttributes,
            updateAttributes: (attrs) => {
              updateMarkViewAttributes(mark2, editor, attrs);
            }
          });
        };
        return [extension2.name, markView];
      })
    );
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    const extensions = this.extensions;
    this.editor.extensionStorage = Object.fromEntries(
      extensions.map((extension2) => [extension2.name, extension2.storage])
    );
    extensions.forEach((extension2) => {
      var _a2;
      const context = {
        name: extension2.name,
        options: extension2.options,
        storage: this.editor.extensionStorage[extension2.name],
        editor: this.editor,
        type: getSchemaTypeByName(extension2.name, this.schema)
      };
      if (extension2.type === "mark") {
        const keepOnSplit = (_a2 = callOrReturn(getExtensionField(extension2, "keepOnSplit", context))) != null ? _a2 : true;
        if (keepOnSplit) {
          this.splittableMarks.push(extension2.name);
        }
      }
      const onBeforeCreate = getExtensionField(extension2, "onBeforeCreate", context);
      const onCreate = getExtensionField(extension2, "onCreate", context);
      const onUpdate = getExtensionField(extension2, "onUpdate", context);
      const onSelectionUpdate = getExtensionField(
        extension2,
        "onSelectionUpdate",
        context
      );
      const onTransaction = getExtensionField(extension2, "onTransaction", context);
      const onFocus = getExtensionField(extension2, "onFocus", context);
      const onBlur = getExtensionField(extension2, "onBlur", context);
      const onDestroy = getExtensionField(extension2, "onDestroy", context);
      if (onBeforeCreate) {
        this.editor.on("beforeCreate", onBeforeCreate);
      }
      if (onCreate) {
        this.editor.on("create", onCreate);
      }
      if (onUpdate) {
        this.editor.on("update", onUpdate);
      }
      if (onSelectionUpdate) {
        this.editor.on("selectionUpdate", onSelectionUpdate);
      }
      if (onTransaction) {
        this.editor.on("transaction", onTransaction);
      }
      if (onFocus) {
        this.editor.on("focus", onFocus);
      }
      if (onBlur) {
        this.editor.on("blur", onBlur);
      }
      if (onDestroy) {
        this.editor.on("destroy", onDestroy);
      }
    });
  }
};
ExtensionManager.resolve = resolveExtensions;
ExtensionManager.sort = sortExtensions;
ExtensionManager.flatten = flattenExtensions;
var extensions_exports = {};
__export2(extensions_exports, {
  ClipboardTextSerializer: () => ClipboardTextSerializer,
  Commands: () => Commands,
  Delete: () => Delete,
  Drop: () => Drop,
  Editable: () => Editable,
  FocusEvents: () => FocusEvents,
  Keymap: () => Keymap,
  Paste: () => Paste,
  Tabindex: () => Tabindex,
  focusEventsPluginKey: () => focusEventsPluginKey
});
var Extension = class _Extension extends Extendable {
  constructor() {
    super(...arguments);
    this.type = "extension";
  }
  /**
   * Create a new Extension instance
   * @param config - Extension configuration object or a function that returns a configuration object
   */
  static create(config = {}) {
    const resolvedConfig = typeof config === "function" ? config() : config;
    return new _Extension(resolvedConfig);
  }
  configure(options) {
    return super.configure(options);
  }
  extend(extendedConfig) {
    const resolvedConfig = typeof extendedConfig === "function" ? extendedConfig() : extendedConfig;
    return super.extend(resolvedConfig);
  }
};
var ClipboardTextSerializer = Extension.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor } = this;
            const { state, schema } = editor;
            const { doc: doc2, selection } = state;
            const { ranges } = selection;
            const from3 = Math.min(...ranges.map((range2) => range2.$from.pos));
            const to3 = Math.max(...ranges.map((range2) => range2.$to.pos));
            const textSerializers = getTextSerializersFromSchema(schema);
            const range = { from: from3, to: to3 };
            return getTextBetween(doc2, range, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers
            });
          }
        }
      })
    ];
  }
});
var Commands = Extension.create({
  name: "commands",
  addCommands() {
    return {
      ...commands_exports
    };
  }
});
var Delete = Extension.create({
  name: "delete",
  onUpdate({ transaction, appendedTransactions }) {
    var _a2, _b, _c;
    const callback = () => {
      var _a22, _b2, _c2, _d;
      if ((_d = (_c2 = (_b2 = (_a22 = this.editor.options.coreExtensionOptions) == null ? void 0 : _a22.delete) == null ? void 0 : _b2.filterTransaction) == null ? void 0 : _c2.call(_b2, transaction)) != null ? _d : transaction.getMeta("y-sync$")) {
        return;
      }
      const nextTransaction = combineTransactionSteps(transaction.before, [transaction, ...appendedTransactions]);
      const changes = getChangedRanges(nextTransaction);
      changes.forEach((change) => {
        if (nextTransaction.mapping.mapResult(change.oldRange.from).deletedAfter && nextTransaction.mapping.mapResult(change.oldRange.to).deletedBefore) {
          nextTransaction.before.nodesBetween(change.oldRange.from, change.oldRange.to, (node2, from3) => {
            const to3 = from3 + node2.nodeSize - 2;
            const isFullyWithinRange = change.oldRange.from <= from3 && to3 <= change.oldRange.to;
            this.editor.emit("delete", {
              type: "node",
              node: node2,
              from: from3,
              to: to3,
              newFrom: nextTransaction.mapping.map(from3),
              newTo: nextTransaction.mapping.map(to3),
              deletedRange: change.oldRange,
              newRange: change.newRange,
              partial: !isFullyWithinRange,
              editor: this.editor,
              transaction,
              combinedTransform: nextTransaction
            });
          });
        }
      });
      const mapping = nextTransaction.mapping;
      nextTransaction.steps.forEach((step, index4) => {
        var _a3, _b3;
        if (step instanceof RemoveMarkStep) {
          const newStart = mapping.slice(index4).map(step.from, -1);
          const newEnd = mapping.slice(index4).map(step.to);
          const oldStart = mapping.invert().map(newStart, -1);
          const oldEnd = mapping.invert().map(newEnd);
          const foundBeforeMark = (_a3 = nextTransaction.doc.nodeAt(newStart - 1)) == null ? void 0 : _a3.marks.some((mark2) => mark2.eq(step.mark));
          const foundAfterMark = (_b3 = nextTransaction.doc.nodeAt(newEnd)) == null ? void 0 : _b3.marks.some((mark2) => mark2.eq(step.mark));
          this.editor.emit("delete", {
            type: "mark",
            mark: step.mark,
            from: step.from,
            to: step.to,
            deletedRange: {
              from: oldStart,
              to: oldEnd
            },
            newRange: {
              from: newStart,
              to: newEnd
            },
            partial: Boolean(foundAfterMark || foundBeforeMark),
            editor: this.editor,
            transaction,
            combinedTransform: nextTransaction
          });
        }
      });
    };
    if ((_c = (_b = (_a2 = this.editor.options.coreExtensionOptions) == null ? void 0 : _a2.delete) == null ? void 0 : _b.async) != null ? _c : true) {
      setTimeout(callback, 0);
    } else {
      callback();
    }
  }
});
var Drop = Extension.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tiptapDrop"),
        props: {
          handleDrop: (_, e, slice, moved) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e,
              slice,
              moved
            });
          }
        }
      })
    ];
  }
});
var Editable = Extension.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
});
var focusEventsPluginKey = new PluginKey("focusEvents");
var FocusEvents = Extension.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor } = this;
    return [
      new Plugin({
        key: focusEventsPluginKey,
        props: {
          handleDOMEvents: {
            focus: (view, event) => {
              editor.isFocused = true;
              const transaction = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            },
            blur: (view, event) => {
              editor.isFocused = false;
              const transaction = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            }
          }
        }
      })
    ];
  }
});
var Keymap = Extension.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const handleBackspace = () => this.editor.commands.first(({ commands }) => [
      () => commands.undoInputRule(),
      // maybe convert first text block node to default node
      () => commands.command(({ tr: tr5 }) => {
        const { selection, doc: doc2 } = tr5;
        const { empty: empty3, $anchor } = selection;
        const { pos, parent } = $anchor;
        const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr5.doc.resolve(pos - 1) : $anchor;
        const parentIsIsolating = $parentPos.parent.type.spec.isolating;
        const parentPos = $anchor.pos - $anchor.parentOffset;
        const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc2).from === pos;
        if (!empty3 || !parent.type.isTextblock || parent.textContent.length || !isAtStart || isAtStart && $anchor.parent.type.name === "paragraph") {
          return false;
        }
        return commands.clearNodes();
      }),
      () => commands.deleteSelection(),
      () => commands.joinBackward(),
      () => commands.selectNodeBackward()
    ]);
    const handleDelete2 = () => this.editor.commands.first(({ commands }) => [
      () => commands.deleteSelection(),
      () => commands.deleteCurrentNode(),
      () => commands.joinForward(),
      () => commands.selectNodeForward()
    ]);
    const handleEnter = () => this.editor.commands.first(({ commands }) => [
      () => commands.newlineInCode(),
      () => commands.createParagraphNear(),
      () => commands.liftEmptyBlock(),
      () => commands.splitBlock()
    ]);
    const baseKeymap = {
      Enter: handleEnter,
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: handleBackspace,
      "Mod-Backspace": handleBackspace,
      "Shift-Backspace": handleBackspace,
      Delete: handleDelete2,
      "Mod-Delete": handleDelete2,
      "Mod-a": () => this.editor.commands.selectAll()
    };
    const pcKeymap = {
      ...baseKeymap
    };
    const macKeymap = {
      ...baseKeymap,
      "Ctrl-h": handleBackspace,
      "Alt-Backspace": handleBackspace,
      "Ctrl-d": handleDelete2,
      "Ctrl-Alt-Backspace": handleDelete2,
      "Alt-Delete": handleDelete2,
      "Alt-d": handleDelete2,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    if (isiOS() || isMacOS()) {
      return macKeymap;
    }
    return pcKeymap;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesnt work well
      // with many other commands.
      new Plugin({
        key: new PluginKey("clearDocument"),
        appendTransaction: (transactions, oldState, newState) => {
          if (transactions.some((tr22) => tr22.getMeta("composition"))) {
            return;
          }
          const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
          const ignoreTr = transactions.some((transaction) => transaction.getMeta("preventClearDocument"));
          if (!docChanges || ignoreTr) {
            return;
          }
          const { empty: empty3, from: from3, to: to3 } = oldState.selection;
          const allFrom = Selection.atStart(oldState.doc).from;
          const allEnd = Selection.atEnd(oldState.doc).to;
          const allWasSelected = from3 === allFrom && to3 === allEnd;
          if (empty3 || !allWasSelected) {
            return;
          }
          const isEmpty3 = isNodeEmpty(newState.doc);
          if (!isEmpty3) {
            return;
          }
          const tr5 = newState.tr;
          const state = createChainableState({
            state: newState,
            transaction: tr5
          });
          const { commands } = new CommandManager({
            editor: this.editor,
            state
          });
          commands.clearNodes();
          if (!tr5.steps.length) {
            return;
          }
          return tr5;
        }
      })
    ];
  }
});
var Paste = Extension.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tiptapPaste"),
        props: {
          handlePaste: (_view, e, slice) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e,
              slice
            });
          }
        }
      })
    ];
  }
});
var Tabindex = Extension.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
var NodePos = class _NodePos {
  constructor(pos, editor, isBlock = false, node2 = null) {
    this.currentNode = null;
    this.actualDepth = null;
    this.isBlock = isBlock;
    this.resolvedPos = pos;
    this.editor = editor;
    this.currentNode = node2;
  }
  get name() {
    return this.node.type.name;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var _a2;
    return (_a2 = this.actualDepth) != null ? _a2 : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(content5) {
    let from3 = this.from;
    let to3 = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You cant set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      from3 = this.from + 1;
      to3 = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: from3, to: to3 }, content5);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    if (this.isBlock) {
      return this.pos;
    }
    return this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    if (this.isBlock) {
      return this.pos + this.size;
    }
    return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0) {
      return null;
    }
    const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);
    const $pos = this.resolvedPos.doc.resolve(parentPos);
    return new _NodePos($pos, this.editor);
  }
  get before() {
    let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    if ($pos.depth !== this.depth) {
      $pos = this.resolvedPos.doc.resolve(this.from - 3);
    }
    return new _NodePos($pos, this.editor);
  }
  get after() {
    let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    if ($pos.depth !== this.depth) {
      $pos = this.resolvedPos.doc.resolve(this.to + 3);
    }
    return new _NodePos($pos, this.editor);
  }
  get children() {
    const children = [];
    this.node.content.forEach((node2, offset4) => {
      const isBlock = node2.isBlock && !node2.isTextblock;
      const isNonTextAtom = node2.isAtom && !node2.isText;
      const targetPos = this.pos + offset4 + (isNonTextAtom ? 0 : 1);
      if (targetPos < 0 || targetPos > this.resolvedPos.doc.nodeSize - 2) {
        return;
      }
      const $pos = this.resolvedPos.doc.resolve(targetPos);
      if (!isBlock && $pos.depth <= this.depth) {
        return;
      }
      const childNodePos = new _NodePos($pos, this.editor, isBlock, isBlock ? node2 : null);
      if (isBlock) {
        childNodePos.actualDepth = this.depth + 1;
      }
      children.push(new _NodePos($pos, this.editor, isBlock, isBlock ? node2 : null));
    });
    return children;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const children = this.children;
    return children[children.length - 1] || null;
  }
  closest(selector, attributes = {}) {
    let node2 = null;
    let currentNode = this.parent;
    while (currentNode && !node2) {
      if (currentNode.node.type.name === selector) {
        if (Object.keys(attributes).length > 0) {
          const nodeAttributes = currentNode.node.attrs;
          const attrKeys = Object.keys(attributes);
          for (let index4 = 0; index4 < attrKeys.length; index4 += 1) {
            const key2 = attrKeys[index4];
            if (nodeAttributes[key2] !== attributes[key2]) {
              break;
            }
          }
        } else {
          node2 = currentNode;
        }
      }
      currentNode = currentNode.parent;
    }
    return node2;
  }
  querySelector(selector, attributes = {}) {
    return this.querySelectorAll(selector, attributes, true)[0] || null;
  }
  querySelectorAll(selector, attributes = {}, firstItemOnly = false) {
    let nodes = [];
    if (!this.children || this.children.length === 0) {
      return nodes;
    }
    const attrKeys = Object.keys(attributes);
    this.children.forEach((childPos) => {
      if (firstItemOnly && nodes.length > 0) {
        return;
      }
      if (childPos.node.type.name === selector) {
        const doesAllAttributesMatch = attrKeys.every((key2) => attributes[key2] === childPos.node.attrs[key2]);
        if (doesAllAttributesMatch) {
          nodes.push(childPos);
        }
      }
      if (firstItemOnly && nodes.length > 0) {
        return;
      }
      nodes = nodes.concat(childPos.querySelectorAll(selector, attributes, firstItemOnly));
    });
    return nodes;
  }
  setAttribute(attributes) {
    const { tr: tr5 } = this.editor.state;
    tr5.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...attributes
    });
    this.editor.view.dispatch(tr5);
  }
};
var style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}`;
function createStyleTag(style22, nonce, suffix) {
  const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : ""}]`);
  if (tiptapStyleTag !== null) {
    return tiptapStyleTag;
  }
  const styleNode = document.createElement("style");
  if (nonce) {
    styleNode.setAttribute("nonce", nonce);
  }
  styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : ""}`, "");
  styleNode.innerHTML = style22;
  document.getElementsByTagName("head")[0].appendChild(styleNode);
  return styleNode;
}
var Editor = class extends EventEmitter {
  constructor(options = {}) {
    super();
    this.css = null;
    this.editorView = null;
    this.isFocused = false;
    this.isInitialized = false;
    this.extensionStorage = {};
    this.instanceId = Math.random().toString(36).slice(2, 9);
    this.options = {
      element: typeof document !== "undefined" ? document.createElement("div") : null,
      content: "",
      injectCSS: true,
      injectNonce: void 0,
      extensions: [],
      autofocus: false,
      editable: true,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: true,
      enablePasteRules: true,
      enableCoreExtensions: true,
      enableContentCheck: false,
      emitContentError: false,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onMount: () => null,
      onUnmount: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error: error2 }) => {
        throw error2;
      },
      onPaste: () => null,
      onDrop: () => null,
      onDelete: () => null
    };
    this.isCapturingTransaction = false;
    this.capturedTransaction = null;
    this.setOptions(options);
    this.createExtensionManager();
    this.createCommandManager();
    this.createSchema();
    this.on("beforeCreate", this.options.onBeforeCreate);
    this.emit("beforeCreate", { editor: this });
    this.on("mount", this.options.onMount);
    this.on("unmount", this.options.onUnmount);
    this.on("contentError", this.options.onContentError);
    this.on("create", this.options.onCreate);
    this.on("update", this.options.onUpdate);
    this.on("selectionUpdate", this.options.onSelectionUpdate);
    this.on("transaction", this.options.onTransaction);
    this.on("focus", this.options.onFocus);
    this.on("blur", this.options.onBlur);
    this.on("destroy", this.options.onDestroy);
    this.on("drop", ({ event, slice, moved }) => this.options.onDrop(event, slice, moved));
    this.on("paste", ({ event, slice }) => this.options.onPaste(event, slice));
    this.on("delete", this.options.onDelete);
    const initialDoc = this.createDoc();
    const selection = resolveFocusPosition(initialDoc, this.options.autofocus);
    this.editorState = EditorState.create({
      doc: initialDoc,
      schema: this.schema,
      selection: selection || void 0
    });
    if (this.options.element) {
      this.mount(this.options.element);
    }
  }
  /**
   * Attach the editor to the DOM, creating a new editor view.
   */
  mount(el2) {
    if (typeof document === "undefined") {
      throw new Error(
        `[tiptap error]: The editor cannot be mounted because there is no 'document' defined in this environment.`
      );
    }
    this.createView(el2);
    this.emit("mount", { editor: this });
    if (this.css && !document.head.contains(this.css)) {
      document.head.appendChild(this.css);
    }
    window.setTimeout(() => {
      if (this.isDestroyed) {
        return;
      }
      this.commands.focus(this.options.autofocus);
      this.emit("create", { editor: this });
      this.isInitialized = true;
    }, 0);
  }
  /**
   * Remove the editor from the DOM, but still allow remounting at a different point in time
   */
  unmount() {
    if (this.editorView) {
      const dom = this.editorView.dom;
      if (dom == null ? void 0 : dom.editor) {
        delete dom.editor;
      }
      this.editorView.destroy();
    }
    this.editorView = null;
    this.isInitialized = false;
    if (this.css) {
      try {
        if (typeof this.css.remove === "function") {
          this.css.remove();
        } else if (this.css.parentNode) {
          this.css.parentNode.removeChild(this.css);
        }
      } catch (error2) {
        console.warn("Failed to remove CSS element:", error2);
      }
    }
    this.css = null;
    this.emit("unmount", { editor: this });
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    if (this.options.injectCSS && typeof document !== "undefined") {
      this.css = createStyleTag(style, this.options.injectNonce);
    }
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(options = {}) {
    this.options = {
      ...this.options,
      ...options
    };
    if (!this.editorView || !this.state || this.isDestroyed) {
      return;
    }
    if (this.options.editorProps) {
      this.view.setProps(this.options.editorProps);
    }
    this.view.updateState(this.state);
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(editable, emitUpdate = true) {
    this.setOptions({ editable });
    if (emitUpdate) {
      this.emit("update", { editor: this, transaction: this.state.tr, appendedTransactions: [] });
    }
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get view() {
    if (this.editorView) {
      return this.editorView;
    }
    return new Proxy(
      {
        state: this.editorState,
        updateState: (state) => {
          this.editorState = state;
        },
        dispatch: (tr5) => {
          this.dispatchTransaction(tr5);
        },
        // Stub some commonly accessed properties to prevent errors
        composing: false,
        dragging: null,
        editable: true,
        isDestroyed: false
      },
      {
        get: (obj, key2) => {
          if (this.editorView) {
            return this.editorView[key2];
          }
          if (key2 === "state") {
            return this.editorState;
          }
          if (key2 in obj) {
            return Reflect.get(obj, key2);
          }
          throw new Error(
            `[tiptap error]: The editor view is not available. Cannot access view['${key2}']. The editor may not be mounted yet.`
          );
        }
      }
    );
  }
  /**
   * Returns the editor state.
   */
  get state() {
    if (this.editorView) {
      this.editorState = this.view.state;
    }
    return this.editorState;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(plugin, handlePlugins) {
    const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];
    const state = this.state.reconfigure({ plugins });
    this.view.updateState(state);
    return state;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(nameOrPluginKeyToRemove) {
    if (this.isDestroyed) {
      return void 0;
    }
    const prevPlugins = this.state.plugins;
    let plugins = prevPlugins;
    [].concat(nameOrPluginKeyToRemove).forEach((nameOrPluginKey) => {
      const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
      plugins = plugins.filter((plugin) => !plugin.key.startsWith(name));
    });
    if (prevPlugins.length === plugins.length) {
      return void 0;
    }
    const state = this.state.reconfigure({
      plugins
    });
    this.view.updateState(state);
    return state;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var _a2, _b;
    const coreExtensions = this.options.enableCoreExtensions ? [
      Editable,
      ClipboardTextSerializer.configure({
        blockSeparator: (_b = (_a2 = this.options.coreExtensionOptions) == null ? void 0 : _a2.clipboardTextSerializer) == null ? void 0 : _b.blockSeparator
      }),
      Commands,
      FocusEvents,
      Keymap,
      Tabindex,
      Drop,
      Paste,
      Delete
    ].filter((ext) => {
      if (typeof this.options.enableCoreExtensions === "object") {
        return this.options.enableCoreExtensions[ext.name] !== false;
      }
      return true;
    }) : [];
    const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension2) => {
      return ["extension", "node", "mark"].includes(extension2 == null ? void 0 : extension2.type);
    });
    this.extensionManager = new ExtensionManager(allExtensions, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new CommandManager({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates the initial document.
   */
  createDoc() {
    let doc2;
    try {
      doc2 = createDocument(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: this.options.enableContentCheck
      });
    } catch (e) {
      if (!(e instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(e.message)) {
        throw e;
      }
      this.emit("contentError", {
        editor: this,
        error: e,
        disableCollaboration: () => {
          if ("collaboration" in this.storage && typeof this.storage.collaboration === "object" && this.storage.collaboration) {
            ;
            this.storage.collaboration.isDisabled = true;
          }
          this.options.extensions = this.options.extensions.filter((extension2) => extension2.name !== "collaboration");
          this.createExtensionManager();
        }
      });
      doc2 = createDocument(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: false
      });
    }
    return doc2;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView(element7) {
    var _a2;
    this.editorView = new EditorView(element7, {
      ...this.options.editorProps,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...(_a2 = this.options.editorProps) == null ? void 0 : _a2.attributes
      },
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: this.editorState,
      markViews: this.extensionManager.markViews,
      nodeViews: this.extensionManager.nodeViews
    });
    const newState = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(newState);
    this.prependClass();
    this.injectCSS();
    const dom = this.view.dom;
    dom.editor = this;
  }
  /**
   * Creates all node and mark views.
   */
  createNodeViews() {
    if (this.view.isDestroyed) {
      return;
    }
    this.view.setProps({
      markViews: this.extensionManager.markViews,
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(fn3) {
    this.isCapturingTransaction = true;
    fn3();
    this.isCapturingTransaction = false;
    const tr5 = this.capturedTransaction;
    this.capturedTransaction = null;
    return tr5;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(transaction) {
    if (this.view.isDestroyed) {
      return;
    }
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = transaction;
        return;
      }
      transaction.steps.forEach((step) => {
        var _a2;
        return (_a2 = this.capturedTransaction) == null ? void 0 : _a2.step(step);
      });
      return;
    }
    const { state, transactions } = this.state.applyTransaction(transaction);
    const selectionHasChanged = !this.state.selection.eq(state.selection);
    const rootTrWasApplied = transactions.includes(transaction);
    const prevState = this.state;
    this.emit("beforeTransaction", {
      editor: this,
      transaction,
      nextState: state
    });
    if (!rootTrWasApplied) {
      return;
    }
    this.view.updateState(state);
    this.emit("transaction", {
      editor: this,
      transaction,
      appendedTransactions: transactions.slice(1)
    });
    if (selectionHasChanged) {
      this.emit("selectionUpdate", {
        editor: this,
        transaction
      });
    }
    const mostRecentFocusTr = transactions.findLast((tr5) => tr5.getMeta("focus") || tr5.getMeta("blur"));
    const focus2 = mostRecentFocusTr == null ? void 0 : mostRecentFocusTr.getMeta("focus");
    const blur2 = mostRecentFocusTr == null ? void 0 : mostRecentFocusTr.getMeta("blur");
    if (focus2) {
      this.emit("focus", {
        editor: this,
        event: focus2.event,
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        transaction: mostRecentFocusTr
      });
    }
    if (blur2) {
      this.emit("blur", {
        editor: this,
        event: blur2.event,
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        transaction: mostRecentFocusTr
      });
    }
    if (transaction.getMeta("preventUpdate") || !transactions.some((tr5) => tr5.docChanged) || prevState.doc.eq(state.doc)) {
      return;
    }
    this.emit("update", {
      editor: this,
      transaction,
      appendedTransactions: transactions.slice(1)
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(nameOrType) {
    return getAttributes(this.state, nameOrType);
  }
  isActive(nameOrAttributes, attributesOrUndefined) {
    const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
    const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
    return isActive(this.state, name, attributes);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return getHTMLFromFragment(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(options) {
    const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
    return getText(this.state.doc, {
      blockSeparator,
      textSerializers: {
        ...getTextSerializersFromSchema(this.schema),
        ...textSerializers
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return isNodeEmpty(this.state.doc);
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    this.emit("destroy");
    this.unmount();
    this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var _a2, _b;
    return (_b = (_a2 = this.editorView) == null ? void 0 : _a2.isDestroyed) != null ? _b : true;
  }
  $node(selector, attributes) {
    var _a2;
    return ((_a2 = this.$doc) == null ? void 0 : _a2.querySelector(selector, attributes)) || null;
  }
  $nodes(selector, attributes) {
    var _a2;
    return ((_a2 = this.$doc) == null ? void 0 : _a2.querySelectorAll(selector, attributes)) || null;
  }
  $pos(pos) {
    const $pos = this.state.doc.resolve(pos);
    return new NodePos($pos, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function markInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr: tr5 } = state;
      const captureGroup = match[match.length - 1];
      const fullMatch = match[0];
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr5.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr5.delete(range.from + startSpaces, textStart);
        }
        const markEnd = range.from + startSpaces + captureGroup.length;
        tr5.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr5.removeStoredMark(config.type);
      }
    },
    undoable: config.undoable
  });
}
var markdown_exports = {};
__export2(markdown_exports, {
  createAtomBlockMarkdownSpec: () => createAtomBlockMarkdownSpec,
  createBlockMarkdownSpec: () => createBlockMarkdownSpec,
  createInlineMarkdownSpec: () => createInlineMarkdownSpec,
  parseAttributes: () => parseAttributes,
  parseIndentedBlocks: () => parseIndentedBlocks,
  renderNestedMarkdownContent: () => renderNestedMarkdownContent,
  serializeAttributes: () => serializeAttributes
});
function parseAttributes(attrString) {
  if (!(attrString == null ? void 0 : attrString.trim())) {
    return {};
  }
  const attributes = {};
  const quotedStrings = [];
  const tempString = attrString.replace(/["']([^"']*)["']/g, (match) => {
    quotedStrings.push(match);
    return `__QUOTED_${quotedStrings.length - 1}__`;
  });
  const classMatches = tempString.match(/(?:^|\s)\.([a-zA-Z][\w-]*)/g);
  if (classMatches) {
    const classes = classMatches.map((match) => match.trim().slice(1));
    attributes.class = classes.join(" ");
  }
  const idMatch = tempString.match(/(?:^|\s)#([a-zA-Z][\w-]*)/);
  if (idMatch) {
    attributes.id = idMatch[1];
  }
  const kvRegex = /([a-zA-Z][\w-]*)\s*=\s*(__QUOTED_\d+__)/g;
  const kvMatches = Array.from(tempString.matchAll(kvRegex));
  kvMatches.forEach(([, key2, quotedRef]) => {
    var _a2;
    const quotedIndex = parseInt(((_a2 = quotedRef.match(/__QUOTED_(\d+)__/)) == null ? void 0 : _a2[1]) || "0", 10);
    const quotedValue = quotedStrings[quotedIndex];
    if (quotedValue) {
      attributes[key2] = quotedValue.slice(1, -1);
    }
  });
  const cleanString = tempString.replace(/(?:^|\s)\.([a-zA-Z][\w-]*)/g, "").replace(/(?:^|\s)#([a-zA-Z][\w-]*)/g, "").replace(/([a-zA-Z][\w-]*)\s*=\s*__QUOTED_\d+__/g, "").trim();
  if (cleanString) {
    const booleanAttrs = cleanString.split(/\s+/).filter(Boolean);
    booleanAttrs.forEach((attr2) => {
      if (attr2.match(/^[a-zA-Z][\w-]*$/)) {
        attributes[attr2] = true;
      }
    });
  }
  return attributes;
}
function serializeAttributes(attributes) {
  if (!attributes || Object.keys(attributes).length === 0) {
    return "";
  }
  const parts = [];
  if (attributes.class) {
    const classes = String(attributes.class).split(/\s+/).filter(Boolean);
    classes.forEach((cls) => parts.push(`.${cls}`));
  }
  if (attributes.id) {
    parts.push(`#${attributes.id}`);
  }
  Object.entries(attributes).forEach(([key2, value]) => {
    if (key2 === "class" || key2 === "id") {
      return;
    }
    if (value === true) {
      parts.push(key2);
    } else if (value !== false && value != null) {
      parts.push(`${key2}="${String(value)}"`);
    }
  });
  return parts.join(" ");
}
function createAtomBlockMarkdownSpec(options) {
  const {
    nodeName,
    name: markdownName,
    parseAttributes: parseAttributes2 = parseAttributes,
    serializeAttributes: serializeAttributes22 = serializeAttributes,
    defaultAttributes = {},
    requiredAttributes = [],
    allowedAttributes
  } = options;
  const blockName = markdownName || nodeName;
  const filterAttributes = (attrs) => {
    if (!allowedAttributes) {
      return attrs;
    }
    const filtered = {};
    allowedAttributes.forEach((key2) => {
      if (key2 in attrs) {
        filtered[key2] = attrs[key2];
      }
    });
    return filtered;
  };
  return {
    parseMarkdown: (token, h22) => {
      const attrs = { ...defaultAttributes, ...token.attributes };
      return h22.createNode(nodeName, attrs, []);
    },
    markdownTokenizer: {
      name: nodeName,
      level: "block",
      start(src) {
        var _a2;
        const regex = new RegExp(`^:::${blockName}(?:\\s|$)`, "m");
        const index4 = (_a2 = src.match(regex)) == null ? void 0 : _a2.index;
        return index4 !== void 0 ? index4 : -1;
      },
      tokenize(src, _tokens, _lexer) {
        const regex = new RegExp(`^:::${blockName}(?:\\s+\\{([^}]*)\\})?\\s*:::(?:\\n|$)`);
        const match = src.match(regex);
        if (!match) {
          return void 0;
        }
        const attrString = match[1] || "";
        const attributes = parseAttributes2(attrString);
        const missingRequired = requiredAttributes.find((required) => !(required in attributes));
        if (missingRequired) {
          return void 0;
        }
        return {
          type: nodeName,
          raw: match[0],
          attributes
        };
      }
    },
    renderMarkdown: (node2) => {
      const filteredAttrs = filterAttributes(node2.attrs || {});
      const attrs = serializeAttributes22(filteredAttrs);
      const attrString = attrs ? ` {${attrs}}` : "";
      return `:::${blockName}${attrString} :::`;
    }
  };
}
function createBlockMarkdownSpec(options) {
  const {
    nodeName,
    name: markdownName,
    getContent,
    parseAttributes: parseAttributes2 = parseAttributes,
    serializeAttributes: serializeAttributes22 = serializeAttributes,
    defaultAttributes = {},
    content: content5 = "block",
    allowedAttributes
  } = options;
  const blockName = markdownName || nodeName;
  const filterAttributes = (attrs) => {
    if (!allowedAttributes) {
      return attrs;
    }
    const filtered = {};
    allowedAttributes.forEach((key2) => {
      if (key2 in attrs) {
        filtered[key2] = attrs[key2];
      }
    });
    return filtered;
  };
  return {
    parseMarkdown: (token, h22) => {
      let nodeContent;
      if (getContent) {
        const contentResult = getContent(token);
        nodeContent = typeof contentResult === "string" ? [{ type: "text", text: contentResult }] : contentResult;
      } else if (content5 === "block") {
        nodeContent = h22.parseChildren(token.tokens || []);
      } else {
        nodeContent = h22.parseInline(token.tokens || []);
      }
      const attrs = { ...defaultAttributes, ...token.attributes };
      return h22.createNode(nodeName, attrs, nodeContent);
    },
    markdownTokenizer: {
      name: nodeName,
      level: "block",
      start(src) {
        var _a2;
        const regex = new RegExp(`^:::${blockName}`, "m");
        const index4 = (_a2 = src.match(regex)) == null ? void 0 : _a2.index;
        return index4 !== void 0 ? index4 : -1;
      },
      tokenize(src, _tokens, lexer) {
        var _a2;
        const openingRegex = new RegExp(`^:::${blockName}(?:\\s+\\{([^}]*)\\})?\\s*\\n`);
        const openingMatch = src.match(openingRegex);
        if (!openingMatch) {
          return void 0;
        }
        const [openingTag, attrString = ""] = openingMatch;
        const attributes = parseAttributes2(attrString);
        let level = 1;
        const position4 = openingTag.length;
        let matchedContent = "";
        const blockPattern = /^:::([\w-]*)(\s.*)?/gm;
        const remaining = src.slice(position4);
        blockPattern.lastIndex = 0;
        for (; ; ) {
          const match = blockPattern.exec(remaining);
          if (match === null) {
            break;
          }
          const matchPos = match.index;
          const blockType = match[1];
          if ((_a2 = match[2]) == null ? void 0 : _a2.endsWith(":::")) {
            continue;
          }
          if (blockType) {
            level += 1;
          } else {
            level -= 1;
            if (level === 0) {
              const rawContent = remaining.slice(0, matchPos);
              matchedContent = rawContent.trim();
              const fullMatch = src.slice(0, position4 + matchPos + match[0].length);
              let contentTokens = [];
              if (matchedContent) {
                if (content5 === "block") {
                  contentTokens = lexer.blockTokens(rawContent);
                  contentTokens.forEach((token) => {
                    if (token.text && (!token.tokens || token.tokens.length === 0)) {
                      token.tokens = lexer.inlineTokens(token.text);
                    }
                  });
                  while (contentTokens.length > 0) {
                    const lastToken = contentTokens[contentTokens.length - 1];
                    if (lastToken.type === "paragraph" && (!lastToken.text || lastToken.text.trim() === "")) {
                      contentTokens.pop();
                    } else {
                      break;
                    }
                  }
                } else {
                  contentTokens = lexer.inlineTokens(matchedContent);
                }
              }
              return {
                type: nodeName,
                raw: fullMatch,
                attributes,
                content: matchedContent,
                tokens: contentTokens
              };
            }
          }
        }
        return void 0;
      }
    },
    renderMarkdown: (node2, h22) => {
      const filteredAttrs = filterAttributes(node2.attrs || {});
      const attrs = serializeAttributes22(filteredAttrs);
      const attrString = attrs ? ` {${attrs}}` : "";
      const renderedContent = h22.renderChildren(node2.content || [], "\n\n");
      return `:::${blockName}${attrString}

${renderedContent}

:::`;
    }
  };
}
function parseShortcodeAttributes(attrString) {
  if (!attrString.trim()) {
    return {};
  }
  const attributes = {};
  const regex = /(\w+)=(?:"([^"]*)"|'([^']*)')/g;
  let match = regex.exec(attrString);
  while (match !== null) {
    const [, key2, doubleQuoted, singleQuoted] = match;
    attributes[key2] = doubleQuoted || singleQuoted;
    match = regex.exec(attrString);
  }
  return attributes;
}
function serializeShortcodeAttributes(attrs) {
  return Object.entries(attrs).filter(([, value]) => value !== void 0 && value !== null).map(([key2, value]) => `${key2}="${value}"`).join(" ");
}
function createInlineMarkdownSpec(options) {
  const {
    nodeName,
    name: shortcodeName,
    getContent,
    parseAttributes: parseAttributes2 = parseShortcodeAttributes,
    serializeAttributes: serializeAttributes22 = serializeShortcodeAttributes,
    defaultAttributes = {},
    selfClosing = false,
    allowedAttributes
  } = options;
  const shortcode = shortcodeName || nodeName;
  const filterAttributes = (attrs) => {
    if (!allowedAttributes) {
      return attrs;
    }
    const filtered = {};
    allowedAttributes.forEach((key2) => {
      if (key2 in attrs) {
        filtered[key2] = attrs[key2];
      }
    });
    return filtered;
  };
  const escapedShortcode = shortcode.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  return {
    parseMarkdown: (token, h22) => {
      const attrs = { ...defaultAttributes, ...token.attributes };
      if (selfClosing) {
        return h22.createNode(nodeName, attrs);
      }
      const content5 = getContent ? getContent(token) : token.content || "";
      if (content5) {
        return h22.createNode(nodeName, attrs, [h22.createTextNode(content5)]);
      }
      return h22.createNode(nodeName, attrs, []);
    },
    markdownTokenizer: {
      name: nodeName,
      level: "inline",
      start(src) {
        const startPattern = selfClosing ? new RegExp(`\\[${escapedShortcode}\\s*[^\\]]*\\]`) : new RegExp(`\\[${escapedShortcode}\\s*[^\\]]*\\][\\s\\S]*?\\[\\/${escapedShortcode}\\]`);
        const match = src.match(startPattern);
        const index4 = match == null ? void 0 : match.index;
        return index4 !== void 0 ? index4 : -1;
      },
      tokenize(src, _tokens, _lexer) {
        const tokenPattern = selfClosing ? new RegExp(`^\\[${escapedShortcode}\\s*([^\\]]*)\\]`) : new RegExp(`^\\[${escapedShortcode}\\s*([^\\]]*)\\]([\\s\\S]*?)\\[\\/${escapedShortcode}\\]`);
        const match = src.match(tokenPattern);
        if (!match) {
          return void 0;
        }
        let content5 = "";
        let attrString = "";
        if (selfClosing) {
          const [, attrs] = match;
          attrString = attrs;
        } else {
          const [, attrs, contentMatch] = match;
          attrString = attrs;
          content5 = contentMatch || "";
        }
        const attributes = parseAttributes2(attrString.trim());
        return {
          type: nodeName,
          raw: match[0],
          content: content5.trim(),
          attributes
        };
      }
    },
    renderMarkdown: (node2) => {
      let content5 = "";
      if (getContent) {
        content5 = getContent(node2);
      } else if (node2.content && node2.content.length > 0) {
        content5 = node2.content.filter((child) => child.type === "text").map((child) => child.text).join("");
      }
      const filteredAttrs = filterAttributes(node2.attrs || {});
      const attrs = serializeAttributes22(filteredAttrs);
      const attrString = attrs ? ` ${attrs}` : "";
      if (selfClosing) {
        return `[${shortcode}${attrString}]`;
      }
      return `[${shortcode}${attrString}]${content5}[/${shortcode}]`;
    }
  };
}
function parseIndentedBlocks(src, config, lexer) {
  var _a2, _b, _c, _d;
  const lines = src.split("\n");
  const items = [];
  let totalRaw = "";
  let i2 = 0;
  const baseIndentSize = config.baseIndentSize || 2;
  while (i2 < lines.length) {
    const currentLine = lines[i2];
    const itemMatch = currentLine.match(config.itemPattern);
    if (!itemMatch) {
      if (items.length > 0) {
        break;
      } else if (currentLine.trim() === "") {
        i2 += 1;
        continue;
      } else {
        return void 0;
      }
    }
    const itemData = config.extractItemData(itemMatch);
    const { indentLevel, mainContent } = itemData;
    totalRaw = `${totalRaw}${currentLine}
`;
    const itemContent = [mainContent];
    i2 += 1;
    while (i2 < lines.length) {
      const nextLine = lines[i2];
      if (nextLine.trim() === "") {
        const nextNonEmptyIndex = lines.slice(i2 + 1).findIndex((l2) => l2.trim() !== "");
        if (nextNonEmptyIndex === -1) {
          break;
        }
        const nextNonEmpty = lines[i2 + 1 + nextNonEmptyIndex];
        const nextIndent2 = ((_b = (_a2 = nextNonEmpty.match(/^(\s*)/)) == null ? void 0 : _a2[1]) == null ? void 0 : _b.length) || 0;
        if (nextIndent2 > indentLevel) {
          itemContent.push(nextLine);
          totalRaw = `${totalRaw}${nextLine}
`;
          i2 += 1;
          continue;
        } else {
          break;
        }
      }
      const nextIndent = ((_d = (_c = nextLine.match(/^(\s*)/)) == null ? void 0 : _c[1]) == null ? void 0 : _d.length) || 0;
      if (nextIndent > indentLevel) {
        itemContent.push(nextLine);
        totalRaw = `${totalRaw}${nextLine}
`;
        i2 += 1;
      } else {
        break;
      }
    }
    let nestedTokens;
    const nestedContent = itemContent.slice(1);
    if (nestedContent.length > 0) {
      const dedentedNested = nestedContent.map((nestedLine) => nestedLine.slice(indentLevel + baseIndentSize)).join("\n");
      if (dedentedNested.trim()) {
        if (config.customNestedParser) {
          nestedTokens = config.customNestedParser(dedentedNested);
        } else {
          nestedTokens = lexer.blockTokens(dedentedNested);
        }
      }
    }
    const token = config.createToken(itemData, nestedTokens);
    items.push(token);
  }
  if (items.length === 0) {
    return void 0;
  }
  return {
    items,
    raw: totalRaw.trim()
  };
}
function renderNestedMarkdownContent(node2, h22, prefixOrGenerator, ctx) {
  if (!node2 || !Array.isArray(node2.content)) {
    return "";
  }
  const prefix3 = typeof prefixOrGenerator === "function" ? prefixOrGenerator(ctx) : prefixOrGenerator;
  const [content5, ...children] = node2.content;
  const mainContent = h22.renderChildren([content5]);
  const output = [`${prefix3}${mainContent}`];
  if (children && children.length > 0) {
    children.forEach((child) => {
      const childContent = h22.renderChildren([child]);
      if (childContent) {
        const indentedChild = childContent.split("\n").map((line) => line ? h22.indent(line) : "").join("\n");
        output.push(indentedChild);
      }
    });
  }
  return output.join("\n");
}
function updateMarkViewAttributes(checkMark, editor, attrs = {}) {
  const { state } = editor;
  const { doc: doc2, tr: tr5 } = state;
  const thisMark = checkMark;
  doc2.descendants((node2, pos) => {
    const from3 = tr5.mapping.map(pos);
    const to3 = tr5.mapping.map(pos) + node2.nodeSize;
    let foundMark = null;
    node2.marks.forEach((mark2) => {
      if (mark2 !== thisMark) {
        return false;
      }
      foundMark = mark2;
    });
    if (!foundMark) {
      return;
    }
    let needsUpdate = false;
    Object.keys(attrs).forEach((k2) => {
      if (attrs[k2] !== foundMark.attrs[k2]) {
        needsUpdate = true;
      }
    });
    if (needsUpdate) {
      const updatedMark = checkMark.type.create({
        ...checkMark.attrs,
        ...attrs
      });
      tr5.removeMark(from3, to3, checkMark.type);
      tr5.addMark(from3, to3, updatedMark);
    }
  });
  if (tr5.docChanged) {
    editor.view.dispatch(tr5);
  }
}
var MarkView = class {
  constructor(component, props, options) {
    this.component = component;
    this.editor = props.editor;
    this.options = { ...options };
    this.mark = props.mark;
    this.HTMLAttributes = props.HTMLAttributes;
  }
  get dom() {
    return this.editor.view.dom;
  }
  get contentDOM() {
    return null;
  }
  /**
   * Update the attributes of the mark in the document.
   * @param attrs The attributes to update.
   */
  updateAttributes(attrs, checkMark) {
    updateMarkViewAttributes(checkMark || this.mark, this.editor, attrs);
  }
  ignoreMutation(mutation) {
    if (!this.dom || !this.contentDOM) {
      return true;
    }
    if (typeof this.options.ignoreMutation === "function") {
      return this.options.ignoreMutation({ mutation });
    }
    if (mutation.type === "selection") {
      return false;
    }
    if (this.dom.contains(mutation.target) && mutation.type === "childList" && (isiOS() || isAndroid()) && this.editor.isFocused) {
      const changedNodes = [...Array.from(mutation.addedNodes), ...Array.from(mutation.removedNodes)];
      if (changedNodes.every((node2) => node2.isContentEditable)) {
        return false;
      }
    }
    if (this.contentDOM === mutation.target && mutation.type === "attributes") {
      return true;
    }
    if (this.contentDOM.contains(mutation.target)) {
      return false;
    }
    return true;
  }
};
var Node3 = class _Node extends Extendable {
  constructor() {
    super(...arguments);
    this.type = "node";
  }
  /**
   * Create a new Node instance
   * @param config - Node configuration object or a function that returns a configuration object
   */
  static create(config = {}) {
    const resolvedConfig = typeof config === "function" ? config() : config;
    return new _Node(resolvedConfig);
  }
  configure(options) {
    return super.configure(options);
  }
  extend(extendedConfig) {
    const resolvedConfig = typeof extendedConfig === "function" ? extendedConfig() : extendedConfig;
    return super.extend(resolvedConfig);
  }
};
var NodeView = class {
  constructor(component, props, options) {
    this.isDragging = false;
    this.component = component;
    this.editor = props.editor;
    this.options = {
      stopEvent: null,
      ignoreMutation: null,
      ...options
    };
    this.extension = props.extension;
    this.node = props.node;
    this.decorations = props.decorations;
    this.innerDecorations = props.innerDecorations;
    this.view = props.view;
    this.HTMLAttributes = props.HTMLAttributes;
    this.getPos = props.getPos;
    this.mount();
  }
  mount() {
    return;
  }
  get dom() {
    return this.editor.view.dom;
  }
  get contentDOM() {
    return null;
  }
  onDragStart(event) {
    var _a2, _b, _c, _d, _e3, _f, _g;
    const { view } = this.editor;
    const target = event.target;
    const dragHandle = target.nodeType === 3 ? (_a2 = target.parentElement) == null ? void 0 : _a2.closest("[data-drag-handle]") : target.closest("[data-drag-handle]");
    if (!this.dom || ((_b = this.contentDOM) == null ? void 0 : _b.contains(target)) || !dragHandle) {
      return;
    }
    let x4 = 0;
    let y2 = 0;
    if (this.dom !== dragHandle) {
      const domBox = this.dom.getBoundingClientRect();
      const handleBox = dragHandle.getBoundingClientRect();
      const offsetX = (_d = event.offsetX) != null ? _d : (_c = event.nativeEvent) == null ? void 0 : _c.offsetX;
      const offsetY = (_f = event.offsetY) != null ? _f : (_e3 = event.nativeEvent) == null ? void 0 : _e3.offsetY;
      x4 = handleBox.x - domBox.x + offsetX;
      y2 = handleBox.y - domBox.y + offsetY;
    }
    const clonedNode = this.dom.cloneNode(true);
    try {
      const domBox = this.dom.getBoundingClientRect();
      clonedNode.style.width = `${Math.round(domBox.width)}px`;
      clonedNode.style.height = `${Math.round(domBox.height)}px`;
      clonedNode.style.boxSizing = "border-box";
      clonedNode.style.pointerEvents = "none";
    } catch {
    }
    let dragImageWrapper = null;
    try {
      dragImageWrapper = document.createElement("div");
      dragImageWrapper.style.position = "absolute";
      dragImageWrapper.style.top = "-9999px";
      dragImageWrapper.style.left = "-9999px";
      dragImageWrapper.style.pointerEvents = "none";
      dragImageWrapper.appendChild(clonedNode);
      document.body.appendChild(dragImageWrapper);
      (_g = event.dataTransfer) == null ? void 0 : _g.setDragImage(clonedNode, x4, y2);
    } finally {
      if (dragImageWrapper) {
        setTimeout(() => {
          try {
            dragImageWrapper == null ? void 0 : dragImageWrapper.remove();
          } catch {
          }
        }, 0);
      }
    }
    const pos = this.getPos();
    if (typeof pos !== "number") {
      return;
    }
    const selection = NodeSelection.create(view.state.doc, pos);
    const transaction = view.state.tr.setSelection(selection);
    view.dispatch(transaction);
  }
  stopEvent(event) {
    var _a2;
    if (!this.dom) {
      return false;
    }
    if (typeof this.options.stopEvent === "function") {
      return this.options.stopEvent({ event });
    }
    const target = event.target;
    const isInElement = this.dom.contains(target) && !((_a2 = this.contentDOM) == null ? void 0 : _a2.contains(target));
    if (!isInElement) {
      return false;
    }
    const isDragEvent = event.type.startsWith("drag");
    const isDropEvent = event.type === "drop";
    const isInput3 = ["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(target.tagName) || target.isContentEditable;
    if (isInput3 && !isDropEvent && !isDragEvent) {
      return true;
    }
    const { isEditable } = this.editor;
    const { isDragging } = this;
    const isDraggable = !!this.node.type.spec.draggable;
    const isSelectable = NodeSelection.isSelectable(this.node);
    const isCopyEvent = event.type === "copy";
    const isPasteEvent = event.type === "paste";
    const isCutEvent = event.type === "cut";
    const isClickEvent = event.type === "mousedown";
    if (!isDraggable && isSelectable && isDragEvent && event.target === this.dom) {
      event.preventDefault();
    }
    if (isDraggable && isDragEvent && !isDragging && event.target === this.dom) {
      event.preventDefault();
      return false;
    }
    if (isDraggable && isEditable && !isDragging && isClickEvent) {
      const dragHandle = target.closest("[data-drag-handle]");
      const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));
      if (isValidDragHandle) {
        this.isDragging = true;
        document.addEventListener(
          "dragend",
          () => {
            this.isDragging = false;
          },
          { once: true }
        );
        document.addEventListener(
          "drop",
          () => {
            this.isDragging = false;
          },
          { once: true }
        );
        document.addEventListener(
          "mouseup",
          () => {
            this.isDragging = false;
          },
          { once: true }
        );
      }
    }
    if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {
      return false;
    }
    return true;
  }
  /**
   * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.
   * @return `false` if the editor should re-read the selection or re-parse the range around the mutation
   * @return `true` if it can safely be ignored.
   */
  ignoreMutation(mutation) {
    if (!this.dom || !this.contentDOM) {
      return true;
    }
    if (typeof this.options.ignoreMutation === "function") {
      return this.options.ignoreMutation({ mutation });
    }
    if (this.node.isLeaf || this.node.isAtom) {
      return true;
    }
    if (mutation.type === "selection") {
      return false;
    }
    if (this.dom.contains(mutation.target) && mutation.type === "childList" && (isiOS() || isAndroid()) && this.editor.isFocused) {
      const changedNodes = [...Array.from(mutation.addedNodes), ...Array.from(mutation.removedNodes)];
      if (changedNodes.every((node2) => node2.isContentEditable)) {
        return false;
      }
    }
    if (this.contentDOM === mutation.target && mutation.type === "attributes") {
      return true;
    }
    if (this.contentDOM.contains(mutation.target)) {
      return false;
    }
    return true;
  }
  /**
   * Update the attributes of the prosemirror node.
   */
  updateAttributes(attributes) {
    this.editor.commands.command(({ tr: tr5 }) => {
      const pos = this.getPos();
      if (typeof pos !== "number") {
        return false;
      }
      tr5.setNodeMarkup(pos, void 0, {
        ...this.node.attrs,
        ...attributes
      });
      return true;
    });
  }
  /**
   * Delete the node.
   */
  deleteNode() {
    const from3 = this.getPos();
    if (typeof from3 !== "number") {
      return;
    }
    const to3 = from3 + this.node.nodeSize;
    this.editor.commands.deleteRange({ from: from3, to: to3 });
  }
};
function markPasteRule(config) {
  return new PasteRule({
    find: config.find,
    handler: ({ state, range, match, pasteEvent }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr: tr5 } = state;
      const captureGroup = match[match.length - 1];
      const fullMatch = match[0];
      let markEnd = range.to;
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr5.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr5.delete(range.from + startSpaces, textStart);
        }
        markEnd = range.from + startSpaces + captureGroup.length;
        tr5.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr5.removeStoredMark(config.type);
      }
    }
  });
}

// ../node_modules/.pnpm/@tiptap+core@3.8.0_@tiptap+pm@3.8.0/node_modules/@tiptap/core/dist/jsx-runtime/jsx-runtime.js
var h = (tag, attributes) => {
  if (tag === "slot") {
    return 0;
  }
  if (tag instanceof Function) {
    return tag(attributes);
  }
  const { children, ...rest } = attributes != null ? attributes : {};
  if (tag === "svg") {
    throw new Error("SVG elements are not supported in the JSX syntax, use the array syntax instead");
  }
  return [tag, rest, children];
};

// ../node_modules/.pnpm/@tiptap+extension-bold@3.8._decdbf62f53374d3e03b8d9f48c7846f/node_modules/@tiptap/extension-bold/dist/index.js
var starInputRegex = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/;
var starPasteRegex = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g;
var underscoreInputRegex = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/;
var underscorePasteRegex = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g;
var Bold = Mark.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (node2) => node2.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (mark2) => mark2.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return h("strong", { ...mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), children: h("slot", {}) });
  },
  markdownTokenName: "strong",
  parseMarkdown: (token, helpers) => {
    return helpers.applyMark("bold", helpers.parseInline(token.tokens || []));
  },
  renderMarkdown: (node2, h4) => {
    return `**${h4.renderChildren(node2)}**`;
  },
  addCommands() {
    return {
      setBold: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleBold: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetBold: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex,
        type: this.type
      })
    ];
  }
});
var index_default = Bold;

// ../node_modules/.pnpm/@tiptap+extension-code@3.8._00a705a031e508b14e257c0d3ff386d0/node_modules/@tiptap/extension-code/dist/index.js
var inputRegex = /(^|[^`])`([^`]+)`(?!`)$/;
var pasteRegex = /(^|[^`])`([^`]+)`(?!`)/g;
var Code = Mark.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: true,
  exitable: true,
  parseHTML() {
    return [{ tag: "code" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["code", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  markdownTokenName: "codespan",
  parseMarkdown: (token, helpers) => {
    return helpers.applyMark("code", [{ type: "text", text: token.text || "" }]);
  },
  renderMarkdown: (node2, h4) => {
    if (!node2.content) {
      return "";
    }
    return `\`${h4.renderChildren(node2.content)}\``;
  },
  addCommands() {
    return {
      setCode: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleCode: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetCode: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex,
        type: this.type
      })
    ];
  }
});
var index_default2 = Code;

// ../node_modules/.pnpm/@tiptap+extension-italic@3._daf674fa1a18a586bac55257c7b92fb1/node_modules/@tiptap/extension-italic/dist/index.js
var starInputRegex2 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/;
var starPasteRegex2 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g;
var underscoreInputRegex2 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/;
var underscorePasteRegex2 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g;
var Italic = Mark.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (node2) => node2.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (mark2) => mark2.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["em", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleItalic: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetItalic: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  markdownTokenName: "em",
  parseMarkdown: (token, helpers) => {
    return helpers.applyMark("italic", helpers.parseInline(token.tokens || []));
  },
  renderMarkdown: (node2, h4) => {
    return `*${h4.renderChildren(node2)}*`;
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex2,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex2,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex2,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex2,
        type: this.type
      })
    ];
  }
});
var index_default3 = Italic;

// ../node_modules/.pnpm/@tiptap+extension-strike@3._52f1ce8cd9b0be340d24cee3d9c87ecd/node_modules/@tiptap/extension-strike/dist/index.js
var inputRegex2 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/;
var pasteRegex2 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g;
var Strike = Mark.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style3) => style3.includes("line-through") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["s", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  markdownTokenName: "del",
  parseMarkdown: (token, helpers) => {
    return helpers.applyMark("strike", helpers.parseInline(token.tokens || []));
  },
  renderMarkdown: (node2, h4) => {
    return `~~${h4.renderChildren(node2)}~~`;
  },
  addCommands() {
    return {
      setStrike: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleStrike: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetStrike: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex2,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex2,
        type: this.type
      })
    ];
  }
});
var index_default4 = Strike;

// ../node_modules/.pnpm/@tiptap+extension-underline_896b2c1c443a4fc3b73c538501f4031b/node_modules/@tiptap/extension-underline/dist/index.js
var Underline = Mark.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style3) => style3.includes("underline") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["u", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  parseMarkdown(token, helpers) {
    return helpers.applyMark(this.name || "underline", helpers.parseInline(token.tokens || []));
  },
  renderMarkdown(node2, helpers) {
    return `++${helpers.renderChildren(node2)}++`;
  },
  markdownTokenizer: {
    name: "underline",
    level: "inline",
    start(src) {
      return src.indexOf("++");
    },
    tokenize(src, _tokens, lexer) {
      const rule = /^(\+\+)([\s\S]+?)(\+\+)/;
      const match = rule.exec(src);
      if (!match) {
        return void 0;
      }
      const innerContent = match[2].trim();
      return {
        type: "underline",
        raw: match[0],
        text: innerContent,
        tokens: lexer.inlineTokens(innerContent)
      };
    }
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleUnderline: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetUnderline: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
});
var index_default5 = Underline;

// ../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// ../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// ../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// ../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).substr(1));
}
var i2;
function stringify(arr) {
  var offset4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset4 + 0]] + byteToHex[arr[offset4 + 1]] + byteToHex[arr[offset4 + 2]] + byteToHex[arr[offset4 + 3]] + "-" + byteToHex[arr[offset4 + 4]] + byteToHex[arr[offset4 + 5]] + "-" + byteToHex[arr[offset4 + 6]] + byteToHex[arr[offset4 + 7]] + "-" + byteToHex[arr[offset4 + 8]] + byteToHex[arr[offset4 + 9]] + "-" + byteToHex[arr[offset4 + 10]] + byteToHex[arr[offset4 + 11]] + byteToHex[arr[offset4 + 12]] + byteToHex[arr[offset4 + 13]] + byteToHex[arr[offset4 + 14]] + byteToHex[arr[offset4 + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var stringify_default = stringify;

// ../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v2;
  var arr = new Uint8Array(16);
  arr[0] = (v2 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v2 >>> 16 & 255;
  arr[2] = v2 >>> 8 & 255;
  arr[3] = v2 & 255;
  arr[4] = (v2 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v2 & 255;
  arr[6] = (v2 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v2 & 255;
  arr[8] = (v2 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v2 & 255;
  arr[10] = (v2 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v2 / 4294967296 & 255;
  arr[12] = v2 >>> 24 & 255;
  arr[13] = v2 >>> 16 & 255;
  arr[14] = v2 >>> 8 & 255;
  arr[15] = v2 & 255;
  return arr;
}
var parse_default = parse;

// ../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i2 = 0; i2 < str.length; ++i2) {
    bytes.push(str.charCodeAt(i2));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35_default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset4) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset4 = offset4 || 0;
      for (var i2 = 0; i2 < 16; ++i2) {
        buf[offset4 + i2] = bytes[i2];
      }
      return buf;
    }
    return stringify_default(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}

// ../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i2 = 0; i2 < msg.length; ++i2) {
      bytes[i2] = msg.charCodeAt(i2);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input2) {
  var output = [];
  var length32 = input2.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i2 = 0; i2 < length32; i2 += 8) {
    var x4 = input2[i2 >> 5] >>> i2 % 32 & 255;
    var hex = parseInt(hexTab.charAt(x4 >>> 4 & 15) + hexTab.charAt(x4 & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x4, len) {
  x4[len >> 5] |= 128 << len % 32;
  x4[getOutputLength(len) - 1] = len;
  var a2 = 1732584193;
  var b2 = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (var i2 = 0; i2 < x4.length; i2 += 16) {
    var olda = a2;
    var oldb = b2;
    var oldc = c;
    var oldd = d;
    a2 = md5ff(a2, b2, c, d, x4[i2], 7, -680876936);
    d = md5ff(d, a2, b2, c, x4[i2 + 1], 12, -389564586);
    c = md5ff(c, d, a2, b2, x4[i2 + 2], 17, 606105819);
    b2 = md5ff(b2, c, d, a2, x4[i2 + 3], 22, -1044525330);
    a2 = md5ff(a2, b2, c, d, x4[i2 + 4], 7, -176418897);
    d = md5ff(d, a2, b2, c, x4[i2 + 5], 12, 1200080426);
    c = md5ff(c, d, a2, b2, x4[i2 + 6], 17, -1473231341);
    b2 = md5ff(b2, c, d, a2, x4[i2 + 7], 22, -45705983);
    a2 = md5ff(a2, b2, c, d, x4[i2 + 8], 7, 1770035416);
    d = md5ff(d, a2, b2, c, x4[i2 + 9], 12, -1958414417);
    c = md5ff(c, d, a2, b2, x4[i2 + 10], 17, -42063);
    b2 = md5ff(b2, c, d, a2, x4[i2 + 11], 22, -1990404162);
    a2 = md5ff(a2, b2, c, d, x4[i2 + 12], 7, 1804603682);
    d = md5ff(d, a2, b2, c, x4[i2 + 13], 12, -40341101);
    c = md5ff(c, d, a2, b2, x4[i2 + 14], 17, -1502002290);
    b2 = md5ff(b2, c, d, a2, x4[i2 + 15], 22, 1236535329);
    a2 = md5gg(a2, b2, c, d, x4[i2 + 1], 5, -165796510);
    d = md5gg(d, a2, b2, c, x4[i2 + 6], 9, -1069501632);
    c = md5gg(c, d, a2, b2, x4[i2 + 11], 14, 643717713);
    b2 = md5gg(b2, c, d, a2, x4[i2], 20, -373897302);
    a2 = md5gg(a2, b2, c, d, x4[i2 + 5], 5, -701558691);
    d = md5gg(d, a2, b2, c, x4[i2 + 10], 9, 38016083);
    c = md5gg(c, d, a2, b2, x4[i2 + 15], 14, -660478335);
    b2 = md5gg(b2, c, d, a2, x4[i2 + 4], 20, -405537848);
    a2 = md5gg(a2, b2, c, d, x4[i2 + 9], 5, 568446438);
    d = md5gg(d, a2, b2, c, x4[i2 + 14], 9, -1019803690);
    c = md5gg(c, d, a2, b2, x4[i2 + 3], 14, -187363961);
    b2 = md5gg(b2, c, d, a2, x4[i2 + 8], 20, 1163531501);
    a2 = md5gg(a2, b2, c, d, x4[i2 + 13], 5, -1444681467);
    d = md5gg(d, a2, b2, c, x4[i2 + 2], 9, -51403784);
    c = md5gg(c, d, a2, b2, x4[i2 + 7], 14, 1735328473);
    b2 = md5gg(b2, c, d, a2, x4[i2 + 12], 20, -1926607734);
    a2 = md5hh(a2, b2, c, d, x4[i2 + 5], 4, -378558);
    d = md5hh(d, a2, b2, c, x4[i2 + 8], 11, -2022574463);
    c = md5hh(c, d, a2, b2, x4[i2 + 11], 16, 1839030562);
    b2 = md5hh(b2, c, d, a2, x4[i2 + 14], 23, -35309556);
    a2 = md5hh(a2, b2, c, d, x4[i2 + 1], 4, -1530992060);
    d = md5hh(d, a2, b2, c, x4[i2 + 4], 11, 1272893353);
    c = md5hh(c, d, a2, b2, x4[i2 + 7], 16, -155497632);
    b2 = md5hh(b2, c, d, a2, x4[i2 + 10], 23, -1094730640);
    a2 = md5hh(a2, b2, c, d, x4[i2 + 13], 4, 681279174);
    d = md5hh(d, a2, b2, c, x4[i2], 11, -358537222);
    c = md5hh(c, d, a2, b2, x4[i2 + 3], 16, -722521979);
    b2 = md5hh(b2, c, d, a2, x4[i2 + 6], 23, 76029189);
    a2 = md5hh(a2, b2, c, d, x4[i2 + 9], 4, -640364487);
    d = md5hh(d, a2, b2, c, x4[i2 + 12], 11, -421815835);
    c = md5hh(c, d, a2, b2, x4[i2 + 15], 16, 530742520);
    b2 = md5hh(b2, c, d, a2, x4[i2 + 2], 23, -995338651);
    a2 = md5ii(a2, b2, c, d, x4[i2], 6, -198630844);
    d = md5ii(d, a2, b2, c, x4[i2 + 7], 10, 1126891415);
    c = md5ii(c, d, a2, b2, x4[i2 + 14], 15, -1416354905);
    b2 = md5ii(b2, c, d, a2, x4[i2 + 5], 21, -57434055);
    a2 = md5ii(a2, b2, c, d, x4[i2 + 12], 6, 1700485571);
    d = md5ii(d, a2, b2, c, x4[i2 + 3], 10, -1894986606);
    c = md5ii(c, d, a2, b2, x4[i2 + 10], 15, -1051523);
    b2 = md5ii(b2, c, d, a2, x4[i2 + 1], 21, -2054922799);
    a2 = md5ii(a2, b2, c, d, x4[i2 + 8], 6, 1873313359);
    d = md5ii(d, a2, b2, c, x4[i2 + 15], 10, -30611744);
    c = md5ii(c, d, a2, b2, x4[i2 + 6], 15, -1560198380);
    b2 = md5ii(b2, c, d, a2, x4[i2 + 13], 21, 1309151649);
    a2 = md5ii(a2, b2, c, d, x4[i2 + 4], 6, -145523070);
    d = md5ii(d, a2, b2, c, x4[i2 + 11], 10, -1120210379);
    c = md5ii(c, d, a2, b2, x4[i2 + 2], 15, 718787259);
    b2 = md5ii(b2, c, d, a2, x4[i2 + 9], 21, -343485551);
    a2 = safeAdd(a2, olda);
    b2 = safeAdd(b2, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a2, b2, c, d];
}
function bytesToWords(input2) {
  if (input2.length === 0) {
    return [];
  }
  var length8 = input2.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i2 = 0; i2 < length8; i2 += 8) {
    output[i2 >> 5] |= (input2[i2 / 8] & 255) << i2 % 32;
  }
  return output;
}
function safeAdd(x4, y2) {
  var lsw = (x4 & 65535) + (y2 & 65535);
  var msw = (x4 >> 16) + (y2 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q3, a2, b2, x4, s2, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a2, q3), safeAdd(x4, t)), s2), b2);
}
function md5ff(a2, b2, c, d, x4, s2, t) {
  return md5cmn(b2 & c | ~b2 & d, a2, b2, x4, s2, t);
}
function md5gg(a2, b2, c, d, x4, s2, t) {
  return md5cmn(b2 & d | c & ~d, a2, b2, x4, s2, t);
}
function md5hh(a2, b2, c, d, x4, s2, t) {
  return md5cmn(b2 ^ c ^ d, a2, b2, x4, s2, t);
}
function md5ii(a2, b2, c, d, x4, s2, t) {
  return md5cmn(c ^ (b2 | ~d), a2, b2, x4, s2, t);
}
var md5_default = md5;

// ../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35_default("v3", 48, md5_default);

// ../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset4) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset4 = offset4 || 0;
    for (var i2 = 0; i2 < 16; ++i2) {
      buf[offset4 + i2] = rnds[i2];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default = v4;

// ../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/sha1.js
function f(s2, x4, y2, z4) {
  switch (s2) {
    case 0:
      return x4 & y2 ^ ~x4 & z4;
    case 1:
      return x4 ^ y2 ^ z4;
    case 2:
      return x4 & y2 ^ x4 & z4 ^ y2 & z4;
    case 3:
      return x4 ^ y2 ^ z4;
  }
}
function ROTL(x4, n) {
  return x4 << n | x4 >>> 32 - n;
}
function sha1(bytes) {
  var K4 = [1518500249, 1859775393, 2400959708, 3395469782];
  var H2 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i2 = 0; i2 < msg.length; ++i2) {
      bytes.push(msg.charCodeAt(i2));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l2 = bytes.length / 4 + 2;
  var N4 = Math.ceil(l2 / 16);
  var M3 = new Array(N4);
  for (var _i = 0; _i < N4; ++_i) {
    var arr = new Uint32Array(16);
    for (var j5 = 0; j5 < 16; ++j5) {
      arr[j5] = bytes[_i * 64 + j5 * 4] << 24 | bytes[_i * 64 + j5 * 4 + 1] << 16 | bytes[_i * 64 + j5 * 4 + 2] << 8 | bytes[_i * 64 + j5 * 4 + 3];
    }
    M3[_i] = arr;
  }
  M3[N4 - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M3[N4 - 1][14] = Math.floor(M3[N4 - 1][14]);
  M3[N4 - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N4; ++_i2) {
    var W = new Uint32Array(80);
    for (var t = 0; t < 16; ++t) {
      W[t] = M3[_i2][t];
    }
    for (var _t4 = 16; _t4 < 80; ++_t4) {
      W[_t4] = ROTL(W[_t4 - 3] ^ W[_t4 - 8] ^ W[_t4 - 14] ^ W[_t4 - 16], 1);
    }
    var a2 = H2[0];
    var b2 = H2[1];
    var c = H2[2];
    var d = H2[3];
    var e = H2[4];
    for (var _t22 = 0; _t22 < 80; ++_t22) {
      var s2 = Math.floor(_t22 / 20);
      var T3 = ROTL(a2, 5) + f(s2, b2, c, d) + e + K4[s2] + W[_t22] >>> 0;
      e = d;
      d = c;
      c = ROTL(b2, 30) >>> 0;
      b2 = a2;
      a2 = T3;
    }
    H2[0] = H2[0] + a2 >>> 0;
    H2[1] = H2[1] + b2 >>> 0;
    H2[2] = H2[2] + c >>> 0;
    H2[3] = H2[3] + d >>> 0;
    H2[4] = H2[4] + e >>> 0;
  }
  return [H2[0] >> 24 & 255, H2[0] >> 16 & 255, H2[0] >> 8 & 255, H2[0] & 255, H2[1] >> 24 & 255, H2[1] >> 16 & 255, H2[1] >> 8 & 255, H2[1] & 255, H2[2] >> 24 & 255, H2[2] >> 16 & 255, H2[2] >> 8 & 255, H2[2] & 255, H2[3] >> 24 & 255, H2[3] >> 16 & 255, H2[3] >> 8 & 255, H2[3] & 255, H2[4] >> 24 & 255, H2[4] >> 16 & 255, H2[4] >> 8 & 255, H2[4] & 255];
}
var sha1_default = sha1;

// ../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35_default("v5", 80, sha1_default);

// ../node_modules/.pnpm/prosemirror-highlight@0.13._f8108435f966875ebd623c3ac695c4d9/node_modules/prosemirror-highlight/dist/index.js
var DecorationCache = class _DecorationCache {
  constructor(cache) {
    this.cache = new Map(cache);
  }
  /**
   * Gets the cache entry at the given doc position, or null if it doesn't exist
   * @param pos The doc position of the node you want the cache for
   */
  get(pos) {
    return this.cache.get(pos);
  }
  /**
   * Sets the cache entry at the given position with the give node/decoration
   * values
   * @param pos The doc position of the node to set the cache for
   * @param node The node to place in cache
   * @param decorations The decorations to place in cache
   */
  set(pos, node2, decorations) {
    if (pos < 0) {
      return;
    }
    this.cache.set(pos, [node2, decorations]);
  }
  /**
   * Removes the value at the oldPos (if it exists) and sets the new position to
   * the given values
   * @param oldPos The old node position to overwrite
   * @param newPos The new node position to set the cache for
   * @param node The new node to place in cache
   * @param decorations The new decorations to place in cache
   */
  replace(oldPos, newPos, node2, decorations) {
    this.remove(oldPos);
    this.set(newPos, node2, decorations);
  }
  /**
   * Removes the cache entry at the given position
   * @param pos The doc position to remove from cache
   */
  remove(pos) {
    this.cache.delete(pos);
  }
  /**
   * Invalidates the cache by removing all decoration entries on nodes that have
   * changed, updating the positions of the nodes that haven't and removing all
   * the entries that have been deleted; NOTE: this does not affect the current
   * cache, but returns an entirely new one
   * @param tr A transaction to map the current cache to
   */
  invalidate(tr5) {
    const returnCache = new _DecorationCache(this.cache);
    const mapping = tr5.mapping;
    this.cache.forEach(([node2, decorations], pos) => {
      if (pos < 0) {
        return;
      }
      const result = mapping.mapResult(pos);
      const mappedNode = tr5.doc.nodeAt(result.pos);
      if (result.deleted || !(mappedNode == null ? void 0 : mappedNode.eq(node2))) {
        returnCache.remove(pos);
      } else if (pos !== result.pos) {
        const updatedDecorations = decorations.map((d) => {
          return d.map(mapping, 0, 0);
        }).filter((d) => d != null);
        returnCache.replace(pos, result.pos, mappedNode, updatedDecorations);
      }
    });
    return returnCache;
  }
};
function createHighlightPlugin({
  parser,
  nodeTypes = ["code_block", "codeBlock"],
  languageExtractor = (node2) => node2.attrs.language
}) {
  const key2 = new PluginKey("prosemirror-highlight");
  return new Plugin({
    key: key2,
    state: {
      init(_, instance) {
        const cache = new DecorationCache();
        const [decorations, promises] = calculateDecoration(
          instance.doc,
          parser,
          nodeTypes,
          languageExtractor,
          cache
        );
        return { cache, decorations, promises };
      },
      apply: (tr5, data) => {
        const cache = data.cache.invalidate(tr5);
        const refresh = !!tr5.getMeta("prosemirror-highlight-refresh");
        if (!tr5.docChanged && !refresh) {
          const decorations2 = data.decorations.map(tr5.mapping, tr5.doc);
          const promises2 = data.promises;
          return { cache, decorations: decorations2, promises: promises2 };
        }
        const [decorations, promises] = calculateDecoration(
          tr5.doc,
          parser,
          nodeTypes,
          languageExtractor,
          cache
        );
        return { cache, decorations, promises };
      }
    },
    view: (view) => {
      const promises = /* @__PURE__ */ new Set();
      const refresh = () => {
        if (promises.size > 0) {
          return;
        }
        const tr5 = view.state.tr.setMeta("prosemirror-highlight-refresh", true);
        view.dispatch(tr5);
      };
      const check = () => {
        var _a2;
        const state = key2.getState(view.state);
        for (const promise of (_a2 = state == null ? void 0 : state.promises) != null ? _a2 : []) {
          promises.add(promise);
          promise.then(() => {
            promises.delete(promise);
            refresh();
          }).catch(() => {
            promises.delete(promise);
          });
        }
      };
      check();
      return {
        update: () => {
          check();
        }
      };
    },
    props: {
      decorations(state) {
        var _a2;
        return (_a2 = this.getState(state)) == null ? void 0 : _a2.decorations;
      }
    }
  });
}
function calculateDecoration(doc2, parser, nodeTypes, languageExtractor, cache) {
  const result = [];
  const promises = [];
  doc2.descendants((node2, pos) => {
    if (!node2.type.isTextblock) {
      return true;
    }
    if (nodeTypes.includes(node2.type.name)) {
      const language = languageExtractor(node2);
      const cached = cache.get(pos);
      if (cached) {
        const [_, decorations] = cached;
        result.push(...decorations);
      } else {
        const decorations = parser({
          content: node2.textContent,
          language: language || void 0,
          pos,
          size: node2.nodeSize
        });
        if (decorations && Array.isArray(decorations)) {
          cache.set(pos, node2, decorations);
          result.push(...decorations);
        } else if (decorations instanceof Promise) {
          cache.remove(pos);
          promises.push(decorations);
        }
      }
    }
    return false;
  });
  return [DecorationSet.create(doc2, result), promises];
}

// ../node_modules/.pnpm/prosemirror-highlight@0.13._f8108435f966875ebd623c3ac695c4d9/node_modules/prosemirror-highlight/dist/shiki.js
function createParser(highlighter, options) {
  return function parser({ content: content5, language, pos, size: size5 }) {
    var _a2;
    const decorations = [];
    const { tokens, fg, bg, rootStyle } = highlighter.codeToTokens(content5, {
      lang: language,
      // Use provided options for themes or just use first loaded theme
      ...options != null ? options : {
        theme: highlighter.getLoadedThemes()[0]
      }
    });
    const style3 = rootStyle || (fg && bg ? `--prosemirror-highlight:${fg};--prosemirror-highlight-bg:${bg}` : "");
    if (style3) {
      const decoration = Decoration.node(pos, pos + size5, { style: style3 });
      decorations.push(decoration);
    }
    let from3 = pos + 1;
    for (const line of tokens) {
      for (const token of line) {
        const to3 = from3 + token.content.length;
        const decoration = Decoration.inline(from3, to3, {
          // When using `options.themes` the `htmlStyle` field will be set, otherwise `color` will be set
          style: stringifyTokenStyle(
            (_a2 = token.htmlStyle) != null ? _a2 : `color: ${token.color}`
          ),
          class: "shiki"
        });
        decorations.push(decoration);
        from3 = to3;
      }
      from3 += 1;
    }
    return decorations;
  };
}
function stringifyTokenStyle(token) {
  if (typeof token === "string") return token;
  return Object.entries(token).map(([key2, value]) => `${key2}:${value}`).join(";");
}

// ../node_modules/.pnpm/@blocknote+core@0.41.1_@tip_88da0e2ca7990b1ebffff41010f54baa/node_modules/@blocknote/core/dist/BlockNoteSchema-CYRHak18.js
var mt = Object.defineProperty;
var gt = (e, t, n) => t in e ? mt(e, t, { enumerable: true, configurable: true, writable: true, value: n }) : e[t] = n;
var x = (e, t, n) => gt(e, typeof t != "symbol" ? t + "" : t, n);
function Dt(e, t = JSON.stringify) {
  const n = {};
  return e.filter((o) => {
    const r = t(o);
    return Object.prototype.hasOwnProperty.call(n, r) ? false : n[r] = true;
  });
}
function _t(e) {
  const t = e.filter(
    (o, r) => e.indexOf(o) !== r
  );
  return Dt(t);
}
var qe = Extension.create({
  name: "uniqueID",
  // well set a very high priority to make sure this runs first
  // and is compatible with `appendTransaction` hooks of other extensions
  priority: 1e4,
  addOptions() {
    return {
      attributeName: "id",
      types: [],
      setIdAttribute: false,
      generateID: () => {
        if (typeof window < "u" && window.__TEST_OPTIONS) {
          const e = window.__TEST_OPTIONS;
          return e.mockID === void 0 ? e.mockID = 0 : e.mockID++, e.mockID.toString();
        }
        return v4_default();
      },
      filterTransaction: null
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          [this.options.attributeName]: {
            default: null,
            parseHTML: (e) => e.getAttribute(`data-${this.options.attributeName}`),
            renderHTML: (e) => {
              const t = {
                [`data-${this.options.attributeName}`]: e[this.options.attributeName]
              };
              return this.options.setIdAttribute ? {
                ...t,
                id: e[this.options.attributeName]
              } : t;
            }
          }
        }
      }
    ];
  },
  // check initial content for missing ids
  // onCreate() {
  //   // Dont do this when the collaboration extension is active
  //   // because this may update the content, so Y.js tries to merge these changes.
  //   // This leads to empty block nodes.
  //   // See: https://github.com/ueberdosis/tiptap/issues/2400
  //   if (
  //     this.editor.extensionManager.extensions.find(
  //       (extension) => extension.name === "collaboration"
  //     )
  //   ) {
  //     return;
  //   }
  //   const { view, state } = this.editor;
  //   const { tr, doc } = state;
  //   const { types, attributeName, generateID } = this.options;
  //   const nodesWithoutId = findChildren(doc, (node) => {
  //     return (
  //       types.includes(node.type.name) && node.attrs[attributeName] === null
  //     );
  //   });
  //   nodesWithoutId.forEach(({ node, pos }) => {
  //     tr.setNodeMarkup(pos, undefined, {
  //       ...node.attrs,
  //       [attributeName]: generateID(),
  //     });
  //   });
  //   tr.setMeta("addToHistory", false);
  //   view.dispatch(tr);
  // },
  addProseMirrorPlugins() {
    let e = null, t = false;
    return [
      new Plugin({
        key: new PluginKey("uniqueID"),
        appendTransaction: (n, o, r) => {
          const s2 = n.some((h4) => h4.docChanged) && !o.doc.eq(r.doc), a2 = this.options.filterTransaction && n.some((h4) => {
            var k2, m;
            return !((m = (k2 = this.options).filterTransaction) != null && m.call(k2, h4));
          });
          if (!s2 || a2)
            return;
          const { tr: i2 } = r, { types: c, attributeName: l2, generateID: d } = this.options, u = combineTransactionSteps(
            o.doc,
            n
          ), { mapping: p5 } = u;
          if (getChangedRanges(u).forEach(({ newRange: h4 }) => {
            const k2 = findChildrenInRange(
              r.doc,
              h4,
              (y2) => c.includes(y2.type.name)
            ), m = k2.map(({ node: y2 }) => y2.attrs[l2]).filter((y2) => y2 !== null), b2 = _t(m);
            k2.forEach(({ node: y2, pos: g }) => {
              var V;
              const v2 = (V = i2.doc.nodeAt(g)) == null ? void 0 : V.attrs[l2];
              if (v2 === null) {
                const W = o.doc.type.createAndFill().content;
                if (o.doc.content.findDiffStart(W) === null) {
                  const xe2 = JSON.parse(
                    JSON.stringify(r.doc.toJSON())
                  );
                  if (xe2.content[0].content[0].attrs.id = "initialBlockId", JSON.stringify(xe2.content) === JSON.stringify(W.toJSON())) {
                    i2.setNodeMarkup(g, void 0, {
                      ...y2.attrs,
                      [l2]: "initialBlockId"
                    });
                    return;
                  }
                }
                i2.setNodeMarkup(g, void 0, {
                  ...y2.attrs,
                  [l2]: d()
                });
                return;
              }
              const { deleted: S } = p5.invert().mapResult(g);
              S && b2.includes(v2) && i2.setNodeMarkup(g, void 0, {
                ...y2.attrs,
                [l2]: d()
              });
            });
          }), !!i2.steps.length)
            return i2.setMeta("uniqueID", true), i2;
        },
        // we register a global drag handler to track the current drag source element
        view(n) {
          const o = (r) => {
            let s2;
            e = !((s2 = n.dom.parentElement) === null || s2 === void 0) && s2.contains(r.target) ? n.dom.parentElement : null;
          };
          return window.addEventListener("dragstart", o), {
            destroy() {
              window.removeEventListener("dragstart", o);
            }
          };
        },
        props: {
          // `handleDOMEvents` is called before `transformPasted` so we can do
          // some checks before. However, `transformPasted` only runs when
          // editor content is pasted - not external content.
          handleDOMEvents: {
            // only create new ids for dropped content while holding `alt`
            // or content is dragged from another editor
            drop: (n, o) => {
              let r;
              return e !== n.dom.parentElement || ((r = o.dataTransfer) === null || r === void 0 ? void 0 : r.effectAllowed) === "copy" ? t = true : t = false, e = null, false;
            },
            // always create new ids on pasted content
            paste: () => (t = true, false)
          },
          // well remove ids for every pasted node
          // so we can create a new one within `appendTransaction`
          transformPasted: (n) => {
            if (!t)
              return n;
            const { types: o, attributeName: r } = this.options, s2 = (a2) => {
              const i2 = [];
              return a2.forEach((c) => {
                if (c.isText) {
                  i2.push(c);
                  return;
                }
                if (!o.includes(c.type.name)) {
                  i2.push(c.copy(s2(c.content)));
                  return;
                }
                const l2 = c.type.create(
                  {
                    ...c.attrs,
                    [r]: null
                  },
                  s2(c.content),
                  c.marks
                );
                i2.push(l2);
              }), Fragment.from(i2);
            };
            return t = false, new Slice(
              s2(n.content),
              n.openStart,
              n.openEnd
            );
          }
        }
      })
    ];
  }
});
function Le(e) {
  return e.type === "link";
}
function Ze(e) {
  return typeof e != "string" && e.type === "link";
}
function I(e) {
  return typeof e != "string" && e.type === "text";
}
function se(e) {
  var t, n, o, r, s2;
  return pe(e) ? { ...e } : $(e) ? {
    type: "tableCell",
    content: [].concat(e.content),
    props: {
      backgroundColor: ((t = e.props) == null ? void 0 : t.backgroundColor) ?? "default",
      textColor: ((n = e.props) == null ? void 0 : n.textColor) ?? "default",
      textAlignment: ((o = e.props) == null ? void 0 : o.textAlignment) ?? "left",
      colspan: ((r = e.props) == null ? void 0 : r.colspan) ?? 1,
      rowspan: ((s2 = e.props) == null ? void 0 : s2.rowspan) ?? 1
    }
  } : {
    type: "tableCell",
    content: [].concat(e),
    props: {
      backgroundColor: "default",
      textColor: "default",
      textAlignment: "left",
      colspan: 1,
      rowspan: 1
    }
  };
}
function $(e) {
  return e != null && typeof e != "string" && !Array.isArray(e) && e.type === "tableCell";
}
function pe(e) {
  return $(e) && e.props !== void 0 && e.content !== void 0;
}
function j(e) {
  return pe(e) ? e.props.colspan ?? 1 : 1;
}
function ae(e) {
  return pe(e) ? e.props.rowspan ?? 1 : 1;
}
var Z = class extends Error {
  constructor(t) {
    super(`Unreachable case: ${t}`);
  }
};
function Vo(e, t = true) {
  const { "data-test": n, ...o } = e;
  if (Object.keys(o).length > 0 && t)
    throw new Error("Object must be empty " + JSON.stringify(e));
}
var Rt = () => typeof navigator < "u" && (/Mac/.test(navigator.platform) || /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent));
function T(e, t = "Ctrl") {
  return Rt() ? e.replace("Mod", "") : e.replace("Mod", t);
}
function U(...e) {
  return [
    // Converts to & from set to remove duplicates.
    ...new Set(
      e.filter((t) => t).join(" ").split(" ")
    )
  ].join(" ");
}
var Wo = () => /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
function Vt(e, t, n, o) {
  const r = document.createElement("div");
  r.className = U(
    "bn-block-content",
    n.class
  ), r.setAttribute("data-content-type", e);
  for (const [a2, i2] of Object.entries(n))
    a2 !== "class" && r.setAttribute(a2, i2);
  const s2 = document.createElement(t);
  s2.className = U(
    "bn-inline-content",
    o.class
  );
  for (const [a2, i2] of Object.entries(
    o
  ))
    a2 !== "class" && s2.setAttribute(a2, i2);
  return r.appendChild(s2), {
    dom: r,
    contentDOM: s2
  };
}
var Te = (e, t) => {
  let n = Y(e, t.pmSchema);
  n.type.name === "blockContainer" && (n = n.firstChild);
  const o = t.pmSchema.nodes[n.type.name].spec.toDOM;
  if (o === void 0)
    throw new Error(
      "This block has no default HTML serialization as its corresponding TipTap node doesn't implement `renderHTML`."
    );
  const r = o(n);
  if (typeof r != "object" || !("dom" in r))
    throw new Error(
      "Cannot use this block's default HTML serialization as its corresponding TipTap node's `renderHTML` function does not return an object with the `dom` property."
    );
  return r;
};
function Wt(e, t = "<br>") {
  const n = e.querySelectorAll("p");
  if (n.length > 1) {
    const o = n[0];
    for (let r = 1; r < n.length; r++) {
      const s2 = n[r];
      o.innerHTML += t + s2.innerHTML, s2.remove();
    }
  }
}
function K(e) {
  return "data-" + e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function Fo(e) {
  const t = e.split("/");
  return !t.length || // invalid?
  t[t.length - 1] === "" ? e : t[t.length - 1];
}
function $o(e) {
  var n;
  const t = [
    "mp4",
    "webm",
    "ogg",
    "mov",
    "mkv",
    "flv",
    "avi",
    "wmv",
    "m4v"
  ];
  try {
    const r = ((n = new URL(e).pathname.split(".").pop()) == null ? void 0 : n.toLowerCase()) || "";
    return t.includes(r);
  } catch {
    return false;
  }
}
function Ft(e) {
  const t = {};
  return Object.entries(e).forEach(([n, o]) => {
    t[n] = {
      default: o.default,
      keepOnSplit: true,
      // Props are displayed in kebab-case as HTML attributes. If a prop's
      // value is the same as its default, we don't display an HTML
      // attribute for it.
      parseHTML: (r) => {
        const s2 = r.getAttribute(K(n));
        if (s2 === null)
          return null;
        if (o.default === void 0 && o.type === "boolean" || o.default !== void 0 && typeof o.default == "boolean")
          return s2 === "true" ? true : s2 === "false" ? false : null;
        if (o.default === void 0 && o.type === "number" || o.default !== void 0 && typeof o.default == "number") {
          const a2 = parseFloat(s2);
          return !Number.isNaN(a2) && Number.isFinite(a2) ? a2 : null;
        }
        return s2;
      },
      renderHTML: (r) => r[n] !== o.default ? {
        [K(n)]: r[n]
      } : {}
    };
  }), t;
}
function $t(e, t, n, o) {
  const r = e();
  if (r === void 0)
    throw new Error("Cannot find node position");
  const a2 = n.state.doc.resolve(r).node().attrs.id;
  if (!a2)
    throw new Error("Block doesn't have id");
  const i2 = t.getBlock(a2);
  if (i2.type !== o)
    throw new Error("Block type does not match");
  return i2;
}
function ie(e, t, n, o, r = false, s2) {
  const a2 = document.createElement("div");
  if (s2 !== void 0)
    for (const [i2, c] of Object.entries(s2))
      i2 !== "class" && a2.setAttribute(i2, c);
  a2.className = U(
    "bn-block-content",
    (s2 == null ? void 0 : s2.class) || ""
  ), a2.setAttribute("data-content-type", t);
  for (const [i2, c] of Object.entries(n)) {
    const d = o[i2].default;
    c !== d && a2.setAttribute(K(i2), c);
  }
  return r && a2.setAttribute("data-file-block", ""), a2.appendChild(e.dom), e.contentDOM && (e.contentDOM.className = U(
    "bn-inline-content",
    e.contentDOM.className
  )), {
    ...e,
    dom: a2
  };
}
function jt(e, t, n) {
  return {
    config: {
      type: e.type,
      content: e.content,
      propSchema: t
    },
    implementation: {
      node: e.node,
      render: Te,
      toExternalHTML: Te
    },
    extensions: n
  };
}
function Ut(e, t) {
  e.stopEvent = (n) => (n.type === "mousedown" && setTimeout(() => {
    t.view.dom.blur();
  }, 10), true);
}
function zt(e, t) {
  const n = [
    {
      tag: "[data-content-type=" + e.type + "]",
      contentElement: ".bn-inline-content"
    }
  ];
  return t.parse && n.push({
    tag: "*",
    getAttrs(o) {
      var s2;
      if (typeof o == "string")
        return false;
      const r = (s2 = t.parse) == null ? void 0 : s2.call(t, o);
      return r === void 0 ? false : r;
    },
    getContent: e.content === "inline" || e.content === "none" ? (o, r) => {
      var s2;
      if (t.parseContent)
        return t.parseContent({
          el: o,
          schema: r
        });
      if (e.content === "inline") {
        const i2 = o.cloneNode(true);
        return Wt(
          i2,
          (s2 = t.meta) != null && s2.code ? `
` : "<br>"
        ), DOMParser2.fromSchema(r).parse(i2, {
          topNode: r.nodes.paragraph.create()
        }).content;
      }
      return Fragment.empty;
    } : void 0
  }), n;
}
function qt(e, t, n, o) {
  var s2, a2, i2, c;
  const r = t.node || Node3.create({
    name: e.type,
    content: e.content === "inline" ? "inline*" : e.content === "none" ? "" : e.content,
    group: "blockContent",
    selectable: ((s2 = t.meta) == null ? void 0 : s2.selectable) ?? true,
    isolating: ((a2 = t.meta) == null ? void 0 : a2.isolating) ?? true,
    code: ((i2 = t.meta) == null ? void 0 : i2.code) ?? false,
    defining: ((c = t.meta) == null ? void 0 : c.defining) ?? true,
    priority: o,
    addAttributes() {
      return Ft(e.propSchema);
    },
    parseHTML() {
      return zt(e, t);
    },
    renderHTML({ HTMLAttributes: l2 }) {
      var u;
      const d = document.createElement("div");
      return ie(
        {
          dom: d,
          contentDOM: e.content === "inline" ? d : void 0
        },
        e.type,
        {},
        e.propSchema,
        ((u = t.meta) == null ? void 0 : u.fileBlockAccept) !== void 0,
        l2
      );
    },
    addNodeView() {
      return (l2) => {
        var h4, k2;
        const d = this.options.editor, u = $t(
          l2.getPos,
          d,
          this.editor,
          e.type
        ), p5 = ((h4 = this.options.domAttributes) == null ? void 0 : h4.blockContent) || {}, f2 = t.render.call(
          { blockContentDOMAttributes: p5, props: l2, renderType: "nodeView" },
          u,
          d
        );
        return ((k2 = t.meta) == null ? void 0 : k2.selectable) === false && Ut(f2, this.editor), f2;
      };
    }
  });
  if (r.name !== e.type)
    throw new Error(
      "Node name does not match block type. This is a bug in BlockNote."
    );
  return {
    config: e,
    implementation: {
      ...t,
      node: r,
      render(l2, d) {
        var p5;
        const u = ((p5 = r.options.domAttributes) == null ? void 0 : p5.blockContent) || {};
        return t.render.call(
          {
            blockContentDOMAttributes: u,
            props: void 0,
            renderType: "dom"
          },
          l2,
          d
        );
      },
      // TODO: this should not have wrapInBlockStructure and generally be a lot simpler
      // post-processing in externalHTMLExporter should not be necessary
      toExternalHTML: (l2, d) => {
        var p5, f2;
        const u = ((p5 = r.options.domAttributes) == null ? void 0 : p5.blockContent) || {};
        return ((f2 = t.toExternalHTML) == null ? void 0 : f2.call(
          { blockContentDOMAttributes: u },
          l2,
          d
        )) ?? t.render.call(
          { blockContentDOMAttributes: u, renderType: "dom", props: void 0 },
          l2,
          d
        );
      }
    },
    extensions: n
  };
}
function M(e, t, n) {
  return (o = {}) => {
    const r = typeof e == "function" ? e(o) : e, s2 = typeof t == "function" ? t(o) : t, a2 = n ? typeof n == "function" ? n(o) : n : void 0;
    return {
      config: r,
      implementation: {
        ...s2,
        // TODO: this should not have wrapInBlockStructure and generally be a lot simpler
        // post-processing in externalHTMLExporter should not be necessary
        toExternalHTML(i2, c) {
          var d, u;
          const l2 = (d = s2.toExternalHTML) == null ? void 0 : d.call(
            { blockContentDOMAttributes: this.blockContentDOMAttributes },
            i2,
            c
          );
          if (l2 !== void 0)
            return ie(
              l2,
              i2.type,
              i2.props,
              r.propSchema,
              ((u = s2.meta) == null ? void 0 : u.fileBlockAccept) !== void 0
            );
        },
        render(i2, c) {
          var u;
          const l2 = s2.render.call(
            {
              blockContentDOMAttributes: this.blockContentDOMAttributes,
              renderType: this.renderType,
              props: this.props
            },
            i2,
            c
          );
          return ie(
            l2,
            i2.type,
            i2.props,
            r.propSchema,
            ((u = s2.meta) == null ? void 0 : u.fileBlockAccept) !== void 0,
            this.blockContentDOMAttributes
          );
        }
      },
      extensions: a2
    };
  };
}
function fe(e, t) {
  const n = e.resolve(t);
  if (n.nodeAfter && n.nodeAfter.type.isInGroup("bnBlock"))
    return {
      posBeforeNode: n.pos,
      node: n.nodeAfter
    };
  let o = n.depth, r = n.node(o);
  for (; o > 0; ) {
    if (r.type.isInGroup("bnBlock"))
      return {
        posBeforeNode: n.before(o),
        node: r
      };
    o--, r = n.node(o);
  }
  const s2 = [];
  e.descendants((i2, c) => {
    i2.type.isInGroup("bnBlock") && s2.push(c);
  }), console.warn(`Position ${t} is not within a blockContainer node.`);
  const a2 = e.resolve(
    s2.find((i2) => i2 >= t) || s2[s2.length - 1]
  );
  return {
    posBeforeNode: a2.pos,
    node: a2.nodeAfter
  };
}
function he(e, t) {
  if (!e.type.isInGroup("bnBlock"))
    throw new Error(
      `Attempted to get bnBlock node at position but found node of different type ${e.type.name}`
    );
  const n = e, o = t, r = o + n.nodeSize, s2 = {
    node: n,
    beforePos: o,
    afterPos: r
  };
  if (n.type.name === "blockContainer") {
    let a2, i2;
    if (n.forEach((c, l2) => {
      if (c.type.spec.group === "blockContent") {
        const d = c, u = o + l2 + 1, p5 = u + c.nodeSize;
        a2 = {
          node: d,
          beforePos: u,
          afterPos: p5
        };
      } else if (c.type.name === "blockGroup") {
        const d = c, u = o + l2 + 1, p5 = u + c.nodeSize;
        i2 = {
          node: d,
          beforePos: u,
          afterPos: p5
        };
      }
    }), !a2)
      throw new Error(
        `blockContainer node does not contain a blockContent node in its children: ${n}`
      );
    return {
      isBlockContainer: true,
      bnBlock: s2,
      blockContent: a2,
      childContainer: i2,
      blockNoteType: a2.node.type.name
    };
  } else {
    if (!s2.node.type.isInGroup("childContainer"))
      throw new Error(
        `bnBlock node is not in the childContainer group: ${s2.node}`
      );
    return {
      isBlockContainer: false,
      bnBlock: s2,
      childContainer: s2,
      blockNoteType: s2.node.type.name
    };
  }
}
function z(e) {
  return he(e.node, e.posBeforeNode);
}
function Zt(e) {
  if (!e.nodeAfter)
    throw new Error(
      `Attempted to get blockContainer node at position ${e.pos} but a node at this position does not exist`
    );
  return he(e.nodeAfter, e.pos);
}
function Ge(e) {
  const t = fe(e.doc, e.selection.anchor);
  return z(t);
}
function Gt(e) {
  const t = fe(e.doc, e.selection.anchor);
  return z(t);
}
function G(e) {
  return "doc" in e ? e.doc.type.schema : e.type.schema;
}
function Xe(e) {
  return e.cached.blockNoteEditor;
}
function me(e) {
  return Xe(e).schema;
}
function ge(e) {
  return me(e).blockSchema;
}
function be(e) {
  return me(e).inlineContentSchema;
}
function R(e) {
  return me(e).styleSchema;
}
function ke(e) {
  return Xe(e).blockCache;
}
function Xt(e, t, n) {
  var s2, a2;
  const o = {
    type: "tableContent",
    columnWidths: [],
    headerRows: void 0,
    headerCols: void 0,
    rows: []
  }, r = [];
  e.content.forEach((i2, c, l2) => {
    const d = {
      cells: []
    };
    l2 === 0 && i2.content.forEach((u) => {
      let p5 = u.attrs.colwidth;
      p5 == null && (p5 = new Array(u.attrs.colspan ?? 1).fill(void 0)), o.columnWidths.push(...p5);
    }), d.cells = i2.content.content.map((u, p5) => (r[l2] || (r[l2] = []), r[l2][p5] = u.type.name === "tableHeader", {
      type: "tableCell",
      content: u.content.content.map(
        (h4) => Ce(h4, t, n)
      ).reduce(
        (h4, k2) => {
          if (!h4.length)
            return k2;
          const m = h4[h4.length - 1], b2 = k2[0];
          return b2 && I(m) && I(b2) && JSON.stringify(m.styles) === JSON.stringify(b2.styles) ? (m.text += `
` + b2.text, h4.push(...k2.slice(1)), h4) : (h4.push(...k2), h4);
        },
        []
      ),
      props: {
        colspan: u.attrs.colspan,
        rowspan: u.attrs.rowspan,
        backgroundColor: u.attrs.backgroundColor,
        textColor: u.attrs.textColor,
        textAlignment: u.attrs.textAlignment
      }
    })), o.rows.push(d);
  });
  for (let i2 = 0; i2 < r.length; i2++)
    (s2 = r[i2]) != null && s2.every((c) => c) && (o.headerRows = (o.headerRows ?? 0) + 1);
  for (let i2 = 0; i2 < ((a2 = r[0]) == null ? void 0 : a2.length); i2++)
    r != null && r.every((c) => c[i2]) && (o.headerCols = (o.headerCols ?? 0) + 1);
  return o;
}
function Ce(e, t, n) {
  const o = [];
  let r;
  return e.content.forEach((s2) => {
    if (s2.type.name === "hardBreak") {
      if (r)
        if (I(r))
          r.text += `
`;
        else if (Le(r))
          r.content[r.content.length - 1].text += `
`;
        else
          throw new Error("unexpected");
      else
        r = {
          type: "text",
          text: `
`,
          styles: {}
        };
      return;
    }
    if (s2.type.name !== "link" && s2.type.name !== "text") {
      if (!t[s2.type.name]) {
        console.warn("unrecognized inline content type", s2.type.name);
        return;
      }
      r && (o.push(r), r = void 0), o.push(
        Jt(s2, t, n)
      );
      return;
    }
    const a2 = {};
    let i2;
    for (const c of s2.marks)
      if (c.type.name === "link")
        i2 = c;
      else {
        const l2 = n[c.type.name];
        if (!l2) {
          if (c.type.spec.blocknoteIgnore)
            continue;
          throw new Error(`style ${c.type.name} not found in styleSchema`);
        }
        if (l2.propSchema === "boolean")
          a2[l2.type] = true;
        else if (l2.propSchema === "string")
          a2[l2.type] = c.attrs.stringValue;
        else
          throw new Z(l2.propSchema);
      }
    r ? I(r) ? i2 ? (o.push(r), r = {
      type: "link",
      href: i2.attrs.href,
      content: [
        {
          type: "text",
          text: s2.textContent,
          styles: a2
        }
      ]
    }) : JSON.stringify(r.styles) === JSON.stringify(a2) ? r.text += s2.textContent : (o.push(r), r = {
      type: "text",
      text: s2.textContent,
      styles: a2
    }) : Le(r) && (i2 ? r.href === i2.attrs.href ? JSON.stringify(
      r.content[r.content.length - 1].styles
    ) === JSON.stringify(a2) ? r.content[r.content.length - 1].text += s2.textContent : r.content.push({
      type: "text",
      text: s2.textContent,
      styles: a2
    }) : (o.push(r), r = {
      type: "link",
      href: i2.attrs.href,
      content: [
        {
          type: "text",
          text: s2.textContent,
          styles: a2
        }
      ]
    }) : (o.push(r), r = {
      type: "text",
      text: s2.textContent,
      styles: a2
    })) : i2 ? r = {
      type: "link",
      href: i2.attrs.href,
      content: [
        {
          type: "text",
          text: s2.textContent,
          styles: a2
        }
      ]
    } : r = {
      type: "text",
      text: s2.textContent,
      styles: a2
    };
  }), r && o.push(r), o;
}
function Jt(e, t, n) {
  if (e.type.name === "text" || e.type.name === "link")
    throw new Error("unexpected");
  const o = {}, r = t[e.type.name];
  for (const [i2, c] of Object.entries(e.attrs)) {
    if (!r)
      throw Error("ic node is of an unrecognized type: " + e.type.name);
    const l2 = r.propSchema;
    i2 in l2 && (o[i2] = c);
  }
  let s2;
  return r.content === "styled" ? s2 = Ce(
    e,
    t,
    n
  ) : s2 = void 0, {
    type: e.type.name,
    props: o,
    content: s2
  };
}
function X(e, t, n = ge(t), o = be(t), r = R(t), s2 = ke(t)) {
  var k2;
  if (!e.type.isInGroup("bnBlock"))
    throw Error("Node should be a bnBlock, but is instead: " + e.type.name);
  const a2 = s2 == null ? void 0 : s2.get(e);
  if (a2)
    return a2;
  const i2 = he(e, 0);
  let c = i2.bnBlock.node.attrs.id;
  c === null && (c = qe.options.generateID());
  const l2 = n[i2.blockNoteType];
  if (!l2)
    throw Error("Block is of an unrecognized type: " + i2.blockNoteType);
  const d = {};
  for (const [m, b2] of Object.entries({
    ...e.attrs,
    ...i2.isBlockContainer ? i2.blockContent.node.attrs : {}
  })) {
    const y2 = l2.propSchema;
    m in y2 && !(y2[m].default === void 0 && b2 === void 0) && (d[m] = b2);
  }
  const u = n[i2.blockNoteType], p5 = [];
  (k2 = i2.childContainer) == null || k2.node.forEach((m) => {
    p5.push(
      X(
        m,
        t,
        n,
        o,
        r,
        s2
      )
    );
  });
  let f2;
  if (u.content === "inline") {
    if (!i2.isBlockContainer)
      throw new Error("impossible");
    f2 = Ce(
      i2.blockContent.node,
      o,
      r
    );
  } else if (u.content === "table") {
    if (!i2.isBlockContainer)
      throw new Error("impossible");
    f2 = Xt(
      i2.blockContent.node,
      o,
      r
    );
  } else if (u.content === "none")
    f2 = void 0;
  else
    throw new Z(u.content);
  const h4 = {
    id: c,
    type: u.type,
    props: d,
    content: f2,
    children: p5
  };
  return s2 == null || s2.set(e, h4), h4;
}
function Uo(e, t, n = ge(t), o = be(t), r = R(t), s2 = ke(t)) {
  const a2 = [];
  return e.firstChild.descendants((i2) => (a2.push(
    X(
      i2,
      t,
      n,
      o,
      r,
      s2
    )
  ), false)), a2;
}
function zo(e, t, n = ge(t), o = be(t), r = R(t), s2 = ke(t)) {
  function a2(i2, c, l2) {
    if (i2.type.name !== "blockGroup")
      throw new Error("unexpected");
    const d = [];
    let u, p5;
    return i2.forEach((f2, h4, k2) => {
      if (f2.type.name !== "blockContainer")
        throw new Error("unexpected");
      if (f2.childCount === 0)
        return;
      if (f2.childCount === 0 || f2.childCount > 2)
        throw new Error(
          "unexpected, blockContainer.childCount: " + f2.childCount
        );
      const m = k2 === 0, b2 = k2 === i2.childCount - 1;
      if (f2.firstChild.type.name === "blockGroup") {
        if (!m)
          throw new Error("unexpected");
        const S = a2(
          f2.firstChild,
          Math.max(0, c - 1),
          b2 ? Math.max(0, l2 - 1) : 0
        );
        u = S.blockCutAtStart, b2 && (p5 = S.blockCutAtEnd), d.push(...S.blocks);
        return;
      }
      const y2 = X(
        f2,
        t,
        n,
        o,
        r,
        s2
      ), g = f2.childCount > 1 ? f2.child(1) : void 0;
      let v2 = [];
      if (g) {
        const S = a2(
          g,
          0,
          // TODO: can this be anything other than 0?
          b2 ? Math.max(0, l2 - 1) : 0
        );
        v2 = S.blocks, b2 && (p5 = S.blockCutAtEnd);
      }
      b2 && !g && l2 > 1 && (p5 = y2.id), m && c > 1 && (u = y2.id), d.push({
        ...y2,
        children: v2
      });
    }), { blocks: d, blockCutAtStart: u, blockCutAtEnd: p5 };
  }
  if (e.content.childCount === 0)
    return {
      blocks: [],
      blockCutAtStart: void 0,
      blockCutAtEnd: void 0
    };
  if (e.content.childCount !== 1)
    throw new Error(
      "slice must be a single block, did you forget includeParents=true?"
    );
  return a2(
    e.content.firstChild,
    Math.max(e.openStart - 1, 0),
    Math.max(e.openEnd - 1, 0)
  );
}
function qo(e, t, n, o) {
  return e.dom.setAttribute("data-inline-content-type", t), Object.entries(n).filter(([r, s2]) => {
    const a2 = o[r];
    return s2 !== a2.default;
  }).map(([r, s2]) => [K(r), s2]).forEach(([r, s2]) => e.dom.setAttribute(r, s2)), e.contentDOM && e.contentDOM.setAttribute("data-editable", ""), e;
}
function Zo(e) {
  return {
    Backspace: ({ editor: t }) => {
      const n = t.state.selection.$from;
      return t.state.selection.empty && n.node().type.name === e.type && n.parentOffset === 0;
    }
  };
}
function Kt(e, t) {
  return {
    config: e,
    implementation: t
  };
}
function Je(e) {
  return Object.fromEntries(
    Object.entries(e).map(([t, n]) => [t, n.config])
  );
}
function Qt(e) {
  return e === "boolean" ? {} : {
    stringValue: {
      default: void 0,
      keepOnSplit: true,
      parseHTML: (t) => t.getAttribute("data-value"),
      renderHTML: (t) => t.stringValue !== void 0 ? {
        "data-value": t.stringValue
      } : {}
    }
  };
}
function J(e, t, n, o) {
  return e.dom.setAttribute("data-style-type", t), o === "string" && e.dom.setAttribute("data-value", n), e.contentDOM && e.contentDOM.setAttribute("data-editable", ""), e;
}
function Ke(e, t) {
  return {
    config: e,
    implementation: t
  };
}
function F(e, t) {
  return Ke(
    {
      type: e.name,
      propSchema: t
    },
    {
      mark: e,
      render(n, o) {
        const r = o.pmSchema.marks[e.name].spec.toDOM;
        if (r === void 0)
          throw new Error(
            "This block has no default HTML serialization as its corresponding TipTap node doesn't implement `renderHTML`."
          );
        const s2 = o.pmSchema.mark(e.name, {
          stringValue: n
        }), a2 = DOMSerializer.renderSpec(
          document,
          r(s2, true)
        );
        if (typeof a2 != "object" || !("dom" in a2))
          throw new Error(
            "Cannot use this block's default HTML serialization as its corresponding TipTap mark's `renderHTML` function does not return an object with the `dom` property."
          );
        return a2;
      },
      toExternalHTML(n, o) {
        const r = o.pmSchema.marks[e.name].spec.toDOM;
        if (r === void 0)
          throw new Error(
            "This block has no default HTML serialization as its corresponding TipTap node doesn't implement `renderHTML`."
          );
        const s2 = o.pmSchema.mark(e.name, {
          stringValue: n
        }), a2 = DOMSerializer.renderSpec(
          document,
          r(s2, true)
        );
        if (typeof a2 != "object" || !("dom" in a2))
          throw new Error(
            "Cannot use this block's default HTML serialization as its corresponding TipTap mark's `renderHTML` function does not return an object with the `dom` property."
          );
        return a2;
      }
    }
  );
}
function Qe(e) {
  return Object.fromEntries(
    Object.entries(e).map(([t, n]) => [t, n.config])
  );
}
function Yt(e, t) {
  const n = [
    {
      tag: `[data-style-type="${e.type}"]`,
      contentElement: (o) => {
        const r = o;
        return r.matches("[data-editable]") ? r : r.querySelector("[data-editable]") || r;
      }
    }
  ];
  return t && n.push({
    tag: "*",
    getAttrs(o) {
      if (typeof o == "string")
        return false;
      const r = t == null ? void 0 : t(o);
      return r === void 0 ? false : { stringValue: r };
    }
  }), n;
}
function Ye(e, t) {
  const n = Mark.create({
    name: e.type,
    addAttributes() {
      return Qt(e.propSchema);
    },
    parseHTML() {
      return Yt(e, t.parse);
    },
    renderHTML({ mark: o }) {
      const r = (t.toExternalHTML || t.render)(o.attrs.stringValue);
      return J(
        r,
        e.type,
        o.attrs.stringValue,
        e.propSchema
      );
    },
    addMarkView() {
      return ({ mark: o }) => {
        const r = t.render(o.attrs.stringValue);
        return J(
          r,
          e.type,
          o.attrs.stringValue,
          e.propSchema
        );
      };
    }
  });
  return Ke(e, {
    mark: n,
    render: (o) => {
      const r = t.render(o);
      return J(
        r,
        e.type,
        o,
        e.propSchema
      );
    },
    toExternalHTML: (o) => {
      const r = (t.toExternalHTML || t.render)(o);
      return J(
        r,
        e.type,
        o,
        e.propSchema
      );
    }
  });
}
function en(e) {
  const t = nn(e);
  let { roots: n, nonRoots: o } = Ae(t);
  const r = [];
  for (; n.size; ) {
    r.push(n);
    const s2 = /* @__PURE__ */ new Set();
    for (const a2 of n) {
      const i2 = e.get(a2);
      if (i2)
        for (const c of i2) {
          const l2 = t.get(c);
          if (l2 === void 0)
            continue;
          const d = l2 - 1;
          t.set(c, d), d === 0 && s2.add(c);
        }
    }
    n = s2;
  }
  if (o = Ae(t).nonRoots, o.size)
    throw new Error(
      `Cycle(s) detected; toposort only works on acyclic graphs. Cyclic nodes: ${Array.from(o).join(", ")}`
    );
  return r;
}
function tn(e) {
  const t = on(e);
  return en(t);
}
function nn(e) {
  const t = /* @__PURE__ */ new Map();
  for (const [n, o] of e.entries()) {
    t.has(n) || t.set(n, 0);
    for (const r of o) {
      const s2 = t.get(r) ?? 0;
      t.set(r, s2 + 1);
    }
  }
  return t;
}
function Ae(e) {
  const t = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set();
  for (const [o, r] of e.entries())
    r === 0 ? t.add(o) : n.add(o);
  return { roots: t, nonRoots: n };
}
function on(e) {
  const t = /* @__PURE__ */ new Map();
  for (const [n, o] of e.entries()) {
    t.has(n) || t.set(n, /* @__PURE__ */ new Set());
    for (const r of o)
      t.has(r) || t.set(r, /* @__PURE__ */ new Set()), t.get(r).add(n);
  }
  return t;
}
function rn() {
  return /* @__PURE__ */ new Map();
}
function Ne(e) {
  return e && Object.fromEntries(
    Object.entries(e).filter(([, t]) => t !== void 0)
  );
}
var sn = class {
  constructor(t) {
    x(this, "BlockNoteEditor", "only for types");
    x(this, "Block", "only for types");
    x(this, "PartialBlock", "only for types");
    x(this, "inlineContentSpecs");
    x(this, "styleSpecs");
    x(this, "blockSpecs");
    x(this, "blockSchema");
    x(this, "inlineContentSchema");
    x(this, "styleSchema");
    this.opts = t;
    const {
      blockSpecs: n,
      inlineContentSpecs: o,
      styleSpecs: r,
      blockSchema: s2,
      inlineContentSchema: a2,
      styleSchema: i2
    } = this.init();
    this.blockSpecs = n, this.styleSpecs = r, this.styleSchema = i2, this.inlineContentSpecs = o, this.blockSchema = s2, this.inlineContentSchema = a2;
  }
  init() {
    const t = rn(), n = /* @__PURE__ */ new Set();
    t.set("default", n);
    for (const [i2, c] of Object.entries(this.opts.blockSpecs))
      c.implementation.runsBefore ? t.set(i2, new Set(c.implementation.runsBefore)) : n.add(i2);
    const o = tn(t), r = o.findIndex((i2) => i2.has("default")), s2 = (i2) => 91 + (o.findIndex((l2) => l2.has(i2)) + r) * 10, a2 = Object.fromEntries(
      Object.entries(this.opts.blockSpecs).map(([i2, c]) => [
        i2,
        qt(
          c.config,
          c.implementation,
          c.extensions,
          s2(i2)
        )
      ])
    );
    return {
      blockSpecs: a2,
      blockSchema: Object.fromEntries(
        Object.entries(a2).map(([i2, c]) => [i2, c.config])
      ),
      inlineContentSpecs: Ne(this.opts.inlineContentSpecs),
      styleSpecs: Ne(this.opts.styleSpecs),
      inlineContentSchema: Je(
        this.opts.inlineContentSpecs
      ),
      styleSchema: Qe(this.opts.styleSpecs)
    };
  }
  /**
   * Adds additional block specs to the current schema in a builder pattern.
   * This method allows extending the schema after it has been created.
   *
   * @param additionalBlockSpecs - Additional block specs to add to the schema
   * @returns The current schema instance for chaining
   */
  extend(t) {
    Object.assign(this.opts.blockSpecs, t.blockSpecs), Object.assign(this.opts.inlineContentSpecs, t.inlineContentSpecs), Object.assign(this.opts.styleSpecs, t.styleSpecs);
    const {
      blockSpecs: n,
      inlineContentSpecs: o,
      styleSpecs: r,
      blockSchema: s2,
      inlineContentSchema: a2,
      styleSchema: i2
    } = this.init();
    return this.blockSpecs = n, this.styleSpecs = r, this.styleSchema = i2, this.inlineContentSpecs = o, this.blockSchema = s2, this.inlineContentSchema = a2, this;
  }
};
function N(e) {
  const { height: t, width: n } = et(e), o = new Array(t).fill(false).map(() => new Array(n).fill(null)), r = (s2, a2) => {
    for (let i2 = s2; i2 < t; i2++)
      for (let c = a2; c < n; c++)
        if (!o[i2][c])
          return { row: i2, col: c };
    throw new Error(
      "Unable to create occupancy grid for table, no more available cells"
    );
  };
  for (let s2 = 0; s2 < e.content.rows.length; s2++)
    for (let a2 = 0; a2 < e.content.rows[s2].cells.length; a2++) {
      const i2 = se(e.content.rows[s2].cells[a2]), c = ae(i2), l2 = j(i2), { row: d, col: u } = r(s2, a2);
      for (let p5 = d; p5 < d + c; p5++)
        for (let f2 = u; f2 < u + l2; f2++) {
          if (o[p5][f2])
            throw new Error(
              `Unable to create occupancy grid for table, cell at ${p5},${f2} is already occupied`
            );
          o[p5][f2] = {
            row: s2,
            col: a2,
            rowspan: c,
            colspan: l2,
            cell: i2
          };
        }
    }
  return o;
}
function q(e) {
  const t = /* @__PURE__ */ new Set();
  return e.map((n) => ({
    cells: n.map((o) => t.has(o.row + ":" + o.col) ? false : (t.add(o.row + ":" + o.col), o.cell)).filter((o) => o !== false)
  }));
}
function P(e, t, n = N(t)) {
  for (let o = 0; o < n.length; o++)
    for (let r = 0; r < n[o].length; r++) {
      const s2 = n[o][r];
      if (s2.row === e.row && s2.col === e.col)
        return { row: o, col: r, cell: s2.cell };
    }
  throw new Error(
    `Unable to resolve relative table cell indices for table, cell at ${e.row},${e.col} is not occupied`
  );
}
function et(e) {
  const t = e.content.rows.length;
  let n = 0;
  return e.content.rows.forEach((o) => {
    let r = 0;
    o.cells.forEach((s2) => {
      r += j(s2);
    }), n = Math.max(n, r);
  }), { height: t, width: n };
}
function tt(e, t, n = N(t)) {
  var r;
  const o = (r = n[e.row]) == null ? void 0 : r[e.col];
  if (o)
    return {
      row: o.row,
      col: o.col,
      cell: o.cell
    };
}
function an(e, t) {
  var s2;
  const n = N(e);
  if (t < 0 || t >= n.length)
    return [];
  let o = 0;
  for (let a2 = 0; a2 < t; a2++) {
    const i2 = (s2 = n[o]) == null ? void 0 : s2[0];
    if (!i2)
      return [];
    o += i2.rowspan;
  }
  const r = new Array(n[0].length).fill(false).map((a2, i2) => tt(
    { row: o, col: i2 },
    e,
    n
  )).filter(
    (a2) => a2 !== void 0
  );
  return r.filter((a2, i2) => r.findIndex((c) => c.row === a2.row && c.col === a2.col) === i2);
}
function cn(e, t) {
  var s2;
  const n = N(e);
  if (t < 0 || t >= n[0].length)
    return [];
  let o = 0;
  for (let a2 = 0; a2 < t; a2++) {
    const i2 = (s2 = n[0]) == null ? void 0 : s2[o];
    if (!i2)
      return [];
    o += i2.colspan;
  }
  const r = new Array(n.length).fill(false).map((a2, i2) => tt(
    { row: i2, col: o },
    e,
    n
  )).filter(
    (a2) => a2 !== void 0
  );
  return r.filter((a2, i2) => r.findIndex((c) => c.row === a2.row && c.col === a2.col) === i2);
}
function Xo(e, t, n, o = N(e)) {
  const { col: r } = P(
    {
      row: 0,
      col: t
    },
    e,
    o
  ), { col: s2 } = P(
    {
      row: 0,
      col: n
    },
    e,
    o
  );
  return o.forEach((a2) => {
    const [i2] = a2.splice(r, 1);
    a2.splice(s2, 0, i2);
  }), q(o);
}
function Jo(e, t, n, o = N(e)) {
  const { row: r } = P(
    {
      row: t,
      col: 0
    },
    e,
    o
  ), { row: s2 } = P(
    {
      row: n,
      col: 0
    },
    e,
    o
  ), [a2] = o.splice(r, 1);
  return o.splice(s2, 0, a2), q(o);
}
function ce(e) {
  return e ? $(e) ? ce(e.content) : typeof e == "string" ? e.length === 0 : Array.isArray(e) ? e.every(
    (t) => typeof t == "string" ? t.length === 0 : I(t) ? t.text.length === 0 : Ze(t) ? typeof t.content == "string" ? t.content.length === 0 : t.content.every((n) => n.text.length === 0) : false
  ) : false : true;
}
function Ko(e, t, n = N(e)) {
  if (t === "columns") {
    let s2 = 0;
    for (let a2 = n[0].length - 1; a2 >= 0 && n.every(
      (c) => ce(c[a2].cell) && c[a2].colspan === 1
    ); a2--)
      s2++;
    for (let a2 = n.length - 1; a2 >= 0; a2--) {
      const i2 = Math.max(
        n[a2].length - s2,
        1
      );
      n[a2] = n[a2].slice(0, i2);
    }
    return q(n);
  }
  let o = 0;
  for (let s2 = n.length - 1; s2 >= 0 && n[s2].every(
    (i2) => ce(i2.cell) && i2.rowspan === 1
  ); s2--)
    o++;
  const r = Math.min(o, n.length - 1);
  return n.splice(n.length - r, r), q(n);
}
function Qo(e, t, n, o = N(e)) {
  const { width: r, height: s2 } = et(e);
  if (t === "columns")
    o.forEach((a2, i2) => {
      if (n >= 0)
        for (let c = 0; c < n; c++)
          a2.push({
            row: i2,
            col: Math.max(...a2.map((l2) => l2.col)) + 1,
            rowspan: 1,
            colspan: 1,
            cell: se("")
          });
      else
        a2.splice(r + n, -1 * n);
    });
  else if (n > 0)
    for (let a2 = 0; a2 < n; a2++) {
      const i2 = new Array(r).fill(null).map((c, l2) => ({
        row: s2 + a2,
        col: l2,
        rowspan: 1,
        colspan: 1,
        cell: se("")
      }));
      o.push(i2);
    }
  else n < 0 && o.splice(s2 + n, -1 * n);
  return q(o);
}
function Yo(e, t, n) {
  const o = an(e, n);
  if (!o.some((c) => ae(c.cell) > 1))
    return true;
  let s2 = n, a2 = n;
  return o.forEach((c) => {
    const l2 = ae(c.cell);
    s2 = Math.max(s2, c.row + l2 - 1), a2 = Math.min(a2, c.row);
  }), t < n ? n === s2 : n === a2;
}
function er(e, t, n) {
  const o = cn(e, n);
  if (!o.some((c) => j(c.cell) > 1))
    return true;
  let s2 = n, a2 = n;
  return o.forEach((c) => {
    const l2 = j(c.cell);
    s2 = Math.max(s2, c.col + l2 - 1), a2 = Math.min(a2, c.col);
  }), t < n ? n === s2 : n === a2;
}
function tr(e, t, n) {
  const o = P(e, n), r = P(t, n);
  return o.col === r.col;
}
function Ie(e, t, n, o) {
  const r = [];
  for (const [a2, i2] of Object.entries(e.styles || {})) {
    const c = n[a2];
    if (!c)
      throw new Error(`style ${a2} not found in styleSchema`);
    if (c.propSchema === "boolean")
      i2 && r.push(t.mark(a2));
    else if (c.propSchema === "string")
      i2 && r.push(t.mark(a2, { stringValue: i2 }));
    else
      throw new Z(c.propSchema);
  }
  return !o || !t.nodes[o].spec.code ? e.text.split(/(\n)/g).filter((a2) => a2.length > 0).map((a2) => a2 === `
` ? t.nodes.hardBreak.createChecked() : t.text(a2, r)) : e.text.length > 0 ? [t.text(e.text, r)] : [];
}
function ln(e, t, n) {
  const o = t.marks.link.create({
    href: e.href
  });
  return le(e.content, t, n).map(
    (r) => {
      if (r.type.name === "text")
        return r.mark([...r.marks, o]);
      if (r.type.name === "hardBreak")
        return r;
      throw new Error("unexpected node type");
    }
  );
}
function le(e, t, n, o) {
  const r = [];
  if (typeof e == "string")
    return r.push(
      ...Ie(
        { text: e, styles: {} },
        t,
        n,
        o
      )
    ), r;
  for (const s2 of e)
    r.push(
      ...Ie(s2, t, n, o)
    );
  return r;
}
function O(e, t, n, o = R(t)) {
  const r = [];
  for (const s2 of e)
    typeof s2 == "string" ? r.push(
      ...le(s2, t, o, n)
    ) : Ze(s2) ? r.push(...ln(s2, t, o)) : I(s2) ? r.push(
      ...le([s2], t, o, n)
    ) : r.push(
      ot(s2, t, o)
    );
  return r;
}
function nt(e, t, n = R(t)) {
  const o = [], r = new Array(e.headerRows ?? 0).fill(true), s2 = new Array(e.headerCols ?? 0).fill(true), a2 = e.columnWidths ?? [];
  for (let i2 = 0; i2 < e.rows.length; i2++) {
    const c = e.rows[i2], l2 = [], d = r[i2];
    for (let p5 = 0; p5 < c.cells.length; p5++) {
      const f2 = c.cells[p5], h4 = s2[p5], k2 = void 0;
      let m = null;
      const b2 = P(
        {
          row: i2,
          col: p5
        },
        { content: e }
      );
      let y2 = a2[b2.col] ? [a2[b2.col]] : null;
      if (f2) if (typeof f2 == "string")
        m = t.text(f2);
      else if ($(f2)) {
        f2.content && (m = O(
          f2.content,
          t,
          "tableParagraph",
          n
        ));
        const v2 = j(f2);
        v2 > 1 && (y2 = new Array(v2).fill(false).map((S, oe3) => a2[b2.col + oe3] ?? void 0));
      } else
        m = O(
          f2,
          t,
          "tableParagraph",
          n
        );
      const g = t.nodes[h4 || d ? "tableHeader" : "tableCell"].createChecked(
        {
          ...$(f2) ? f2.props : {},
          colwidth: y2
        },
        t.nodes.tableParagraph.createChecked(k2, m)
      );
      l2.push(g);
    }
    const u = t.nodes.tableRow.createChecked({}, l2);
    o.push(u);
  }
  return o;
}
function ot(e, t, n) {
  let o, r = e.type;
  if (r === void 0 && (r = "paragraph"), !t.nodes[r])
    throw new Error(`node type ${r} not found in schema`);
  if (!e.content)
    o = t.nodes[r].createChecked(e.props);
  else if (typeof e.content == "string") {
    const s2 = O(
      [e.content],
      t,
      r,
      n
    );
    o = t.nodes[r].createChecked(e.props, s2);
  } else if (Array.isArray(e.content)) {
    const s2 = O(
      e.content,
      t,
      r,
      n
    );
    o = t.nodes[r].createChecked(e.props, s2);
  } else if (e.content.type === "tableContent") {
    const s2 = nt(e.content, t, n);
    o = t.nodes[r].createChecked(e.props, s2);
  } else
    throw new Z(e.content.type);
  return o;
}
function Y(e, t, n = R(t)) {
  let o = e.id;
  o === void 0 && (o = qe.options.generateID());
  const r = [];
  if (e.children)
    for (const a2 of e.children)
      r.push(Y(a2, t, n));
  if (!e.type || // can happen if block.type is not defined (this should create the default node)
  t.nodes[e.type].isInGroup("blockContent")) {
    const a2 = ot(
      e,
      t,
      n
    ), i2 = r.length > 0 ? t.nodes.blockGroup.createChecked({}, r) : void 0;
    return t.nodes.blockContainer.createChecked(
      {
        id: o,
        ...e.props
      },
      i2 ? [a2, i2] : a2
    );
  } else {
    if (t.nodes[e.type].isInGroup("bnBlock"))
      return t.nodes[e.type].createChecked(
        {
          id: o,
          ...e.props
        },
        r
      );
    throw new Error(
      `block type ${e.type} doesn't match blockContent or bnBlock group`
    );
  }
}
function un(e, t) {
  let n, o;
  if (t.firstChild.descendants((r, s2) => n ? false : !dn(r) || r.attrs.id !== e ? true : (n = r, o = s2 + 1, false)), !(n === void 0 || o === void 0))
    return {
      node: n,
      posBeforeNode: o
    };
}
function dn(e) {
  return e.type.isInGroup("bnBlock");
}
var nr = (e, t) => ({
  tr: n,
  dispatch: o
}) => (o && ye(n, e, t), true);
function ye(e, t, n, o, r) {
  const s2 = Zt(e.doc.resolve(t));
  let a2 = null;
  s2.blockNoteType === "table" && (a2 = fn(e));
  const i2 = G(e);
  if (o !== void 0 && r !== void 0 && o > r)
    throw new Error("Invalid replaceFromPos or replaceToPos");
  const c = i2.nodes[s2.blockNoteType], l2 = i2.nodes[n.type || s2.blockNoteType], d = l2.isInGroup("bnBlock") ? l2 : i2.nodes.blockContainer;
  if (s2.isBlockContainer && l2.isInGroup("blockContent")) {
    const u = o !== void 0 && o > s2.blockContent.beforePos && o < s2.blockContent.afterPos ? o - s2.blockContent.beforePos - 1 : void 0, p5 = r !== void 0 && r > s2.blockContent.beforePos && r < s2.blockContent.afterPos ? r - s2.blockContent.beforePos - 1 : void 0;
    Pe(n, e, s2), pn(
      n,
      e,
      c,
      l2,
      s2,
      u,
      p5
    );
  } else if (!s2.isBlockContainer && l2.isInGroup("bnBlock"))
    Pe(n, e, s2);
  else {
    const u = X(s2.bnBlock.node, i2);
    e.replaceWith(
      s2.bnBlock.beforePos,
      s2.bnBlock.afterPos,
      Y(
        {
          children: u.children,
          // if no children are passed in, use existing children
          ...n
        },
        i2
      )
    );
    return;
  }
  e.setNodeMarkup(s2.bnBlock.beforePos, d, {
    ...s2.bnBlock.node.attrs,
    ...n.props
  }), a2 && hn(e, s2, a2);
}
function pn(e, t, n, o, r, s2, a2) {
  const i2 = G(t);
  let c = "keep";
  if (e.content)
    if (typeof e.content == "string")
      c = O(
        [e.content],
        i2,
        o.name
      );
    else if (Array.isArray(e.content))
      c = O(e.content, i2, o.name);
    else if (e.content.type === "tableContent")
      c = nt(e.content, i2);
    else
      throw new Z(e.content.type);
  else
    n.spec.content === "" || o.spec.content !== n.spec.content && (c = []);
  if (c === "keep")
    t.setNodeMarkup(r.blockContent.beforePos, o, {
      ...r.blockContent.node.attrs,
      ...e.props
    });
  else if (s2 !== void 0 || a2 !== void 0) {
    t.setNodeMarkup(r.blockContent.beforePos, o, {
      ...r.blockContent.node.attrs,
      ...e.props
    });
    const l2 = r.blockContent.beforePos + 1 + (s2 ?? 0), d = r.blockContent.beforePos + 1 + (a2 ?? r.blockContent.node.content.size), u = t.doc.resolve(r.blockContent.beforePos).depth, p5 = t.doc.resolve(l2).depth, f2 = t.doc.resolve(d).depth;
    t.replace(
      l2,
      d,
      new Slice(
        Fragment.from(c),
        p5 - u - 1,
        f2 - u - 1
      )
    );
  } else
    t.replaceWith(
      r.blockContent.beforePos,
      r.blockContent.afterPos,
      o.createChecked(
        {
          ...r.blockContent.node.attrs,
          ...e.props
        },
        c
      )
    );
}
function Pe(e, t, n) {
  const o = G(t);
  if (e.children !== void 0 && e.children.length > 0) {
    const r = e.children.map((s2) => Y(s2, o));
    if (n.childContainer)
      t.step(
        new ReplaceStep(
          n.childContainer.beforePos + 1,
          n.childContainer.afterPos - 1,
          new Slice(Fragment.from(r), 0, 0)
        )
      );
    else {
      if (!n.isBlockContainer)
        throw new Error("impossible");
      t.insert(
        n.blockContent.afterPos,
        o.nodes.blockGroup.createChecked({}, r)
      );
    }
  }
}
function or(e, t, n, o, r) {
  const s2 = typeof t == "string" ? t : t.id, a2 = un(s2, e.doc);
  if (!a2)
    throw new Error(`Block with ID ${s2} not found`);
  ye(
    e,
    a2.posBeforeNode,
    n,
    o,
    r
  );
  const i2 = e.doc.resolve(a2.posBeforeNode + 1).node(), c = G(e);
  return X(i2, c);
}
function fn(e) {
  const t = "selection" in e ? e.selection : null;
  if (!(t instanceof TextSelection))
    return null;
  const n = e.doc.resolve(t.head);
  let o = -1, r = -1;
  for (let m = n.depth; m >= 0; m--) {
    const b2 = n.node(m).type.name;
    if (o < 0 && (b2 === "tableCell" || b2 === "tableHeader") && (o = m), b2 === "table") {
      r = m;
      break;
    }
  }
  if (o < 0 || r < 0)
    return null;
  const s2 = n.before(o), a2 = n.before(r), i2 = e.doc.nodeAt(a2);
  if (!i2 || i2.type.name !== "table")
    return null;
  const c = TableMap.get(i2), l2 = s2 - (a2 + 1), d = c.map.indexOf(l2);
  if (d < 0)
    return null;
  const u = Math.floor(d / c.width), p5 = d % c.width, h4 = s2 + 1 + 1, k2 = Math.max(0, t.head - h4);
  return { row: u, col: p5, offset: k2 };
}
function hn(e, t, n) {
  var m;
  if (t.blockNoteType !== "table")
    return false;
  let o = -1;
  if (t.isBlockContainer)
    o = e.mapping.map(t.blockContent.beforePos);
  else {
    const b2 = e.mapping.map(t.bnBlock.beforePos), y2 = b2 + (((m = e.doc.nodeAt(b2)) == null ? void 0 : m.nodeSize) || 0);
    e.doc.nodesBetween(b2, y2, (g, v2) => g.type.name === "table" ? (o = v2, false) : true);
  }
  const r = o >= 0 ? e.doc.nodeAt(o) : null;
  if (!r || r.type.name !== "table")
    return false;
  const s2 = TableMap.get(r), a2 = Math.max(0, Math.min(n.row, s2.height - 1)), i2 = Math.max(0, Math.min(n.col, s2.width - 1)), c = a2 * s2.width + i2, l2 = s2.map[c];
  if (l2 == null)
    return false;
  const u = o + 1 + l2 + 1, p5 = e.doc.nodeAt(u), f2 = u + 1, h4 = p5 ? p5.content.size : 0, k2 = f2 + Math.max(0, Math.min(n.offset, h4));
  return "selection" in e && e.setSelection(TextSelection.create(e.doc, k2)), true;
}
var A = {
  gray: {
    text: "#9b9a97",
    background: "#ebeced"
  },
  brown: {
    text: "#64473a",
    background: "#e9e5e3"
  },
  red: {
    text: "#e03e3e",
    background: "#fbe4e4"
  },
  orange: {
    text: "#d9730d",
    background: "#f6e9d9"
  },
  yellow: {
    text: "#dfab01",
    background: "#fbf3db"
  },
  green: {
    text: "#4d6461",
    background: "#ddedea"
  },
  blue: {
    text: "#0b6e99",
    background: "#ddebf1"
  },
  purple: {
    text: "#6940a5",
    background: "#eae4f2"
  },
  pink: {
    text: "#ad1a72",
    background: "#f4dfeb"
  }
};
var rr = {
  gray: {
    text: "#bebdb8",
    background: "#9b9a97"
  },
  brown: {
    text: "#8e6552",
    background: "#64473a"
  },
  red: {
    text: "#ec4040",
    background: "#be3434"
  },
  orange: {
    text: "#e3790d",
    background: "#b7600a"
  },
  yellow: {
    text: "#dfab01",
    background: "#b58b00"
  },
  green: {
    text: "#6b8b87",
    background: "#4d6461"
  },
  blue: {
    text: "#0e87bc",
    background: "#0b6e99"
  },
  purple: {
    text: "#8552d7",
    background: "#6940a5"
  },
  pink: {
    text: "#da208f",
    background: "#ad1a72"
  }
};
var C = {
  backgroundColor: {
    default: "default"
  },
  textColor: {
    default: "default"
  },
  textAlignment: {
    default: "left",
    values: ["left", "center", "right", "justify"]
  }
};
var B = (e) => {
  const t = {};
  return e.hasAttribute("data-background-color") ? t.backgroundColor = e.getAttribute("data-background-color") : e.style.backgroundColor && (t.backgroundColor = e.style.backgroundColor), e.hasAttribute("data-text-color") ? t.textColor = e.getAttribute("data-text-color") : e.style.color && (t.textColor = e.style.color), t.textAlignment = C.textAlignment.values.includes(
    e.style.textAlign
  ) ? e.style.textAlign : void 0, t;
};
var H = (e, t) => {
  e.backgroundColor && e.backgroundColor !== C.backgroundColor.default && (t.style.backgroundColor = e.backgroundColor in A ? A[e.backgroundColor].background : e.backgroundColor), e.textColor && e.textColor !== C.textColor.default && (t.style.color = e.textColor in A ? A[e.textColor].text : e.textColor), e.textAlignment && e.textAlignment !== C.textAlignment.default && (t.style.textAlign = e.textAlignment);
};
var sr = (e = "backgroundColor") => ({
  default: C.backgroundColor.default,
  parseHTML: (t) => t.hasAttribute("data-background-color") ? t.getAttribute("data-background-color") : t.style.backgroundColor ? t.style.backgroundColor : C.backgroundColor.default,
  renderHTML: (t) => t[e] === C.backgroundColor.default ? {} : {
    "data-background-color": t[e]
  }
});
var ar = (e = "textColor") => ({
  default: C.textColor.default,
  parseHTML: (t) => t.hasAttribute("data-text-color") ? t.getAttribute("data-text-color") : t.style.color ? t.style.color : C.textColor.default,
  renderHTML: (t) => t[e] === C.textColor.default ? {} : {
    "data-text-color": t[e]
  }
});
var ee = (e, t) => {
  const n = e.querySelector(
    t
  );
  if (!n)
    return;
  const o = e.querySelector("figcaption"), r = (o == null ? void 0 : o.textContent) ?? void 0;
  return { targetElement: n, caption: r };
};
var mn = (e, t, n) => {
  const o = document.createElement("div");
  o.className = "bn-add-file-button";
  const r = document.createElement("div");
  r.className = "bn-add-file-button-icon", n ? r.appendChild(n) : r.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 8L9.00319 2H19.9978C20.5513 2 21 2.45531 21 2.9918V21.0082C21 21.556 20.5551 22 20.0066 22H3.9934C3.44476 22 3 21.5501 3 20.9932V8ZM10 4V9H5V20H19V4H10Z"></path></svg>', o.appendChild(r);
  const s2 = document.createElement("p");
  s2.className = "bn-add-file-button-text", s2.innerHTML = e.type in t.dictionary.file_blocks.add_button_text ? t.dictionary.file_blocks.add_button_text[e.type] : t.dictionary.file_blocks.add_button_text.file, o.appendChild(s2);
  const a2 = (c) => {
    c.preventDefault();
  }, i2 = () => {
    t.transact(
      (c) => c.setMeta(t.filePanel.plugins[0], {
        block: e
      })
    );
  };
  return o.addEventListener(
    "mousedown",
    a2,
    true
  ), o.addEventListener("click", i2, true), {
    dom: o,
    destroy: () => {
      o.removeEventListener(
        "mousedown",
        a2,
        true
      ), o.removeEventListener(
        "click",
        i2,
        true
      );
    }
  };
};
var gn = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 8L9.00319 2H19.9978C20.5513 2 21 2.45531 21 2.9918V21.0082C21 21.556 20.5551 22 20.0066 22H3.9934C3.44476 22 3 21.5501 3 20.9932V8ZM10 4V9H5V20H19V4H10Z"></path></svg>';
var bn = (e) => {
  const t = document.createElement("div");
  t.className = "bn-file-name-with-icon";
  const n = document.createElement("div");
  n.className = "bn-file-icon", n.innerHTML = gn, t.appendChild(n);
  const o = document.createElement("p");
  return o.className = "bn-file-name", o.textContent = e.props.name, t.appendChild(o), {
    dom: t
  };
};
var we = (e, t, n, o) => {
  const r = document.createElement("div");
  if (r.className = "bn-file-block-content-wrapper", e.props.url === "") {
    const a2 = mn(e, t, o);
    r.appendChild(a2.dom);
    const i2 = t.onUploadStart((c) => {
      if (c === e.id) {
        r.removeChild(a2.dom);
        const l2 = document.createElement("div");
        l2.className = "bn-file-loading-preview", l2.textContent = "Loading...", r.appendChild(l2);
      }
    });
    return {
      dom: r,
      destroy: () => {
        i2(), a2.destroy();
      }
    };
  }
  const s2 = { dom: r };
  if (e.props.showPreview === false || !n) {
    const a2 = bn(e);
    r.appendChild(a2.dom), s2.destroy = () => {
      var i2;
      (i2 = a2.destroy) == null || i2.call(a2);
    };
  } else
    r.appendChild(n.dom);
  if (e.props.caption) {
    const a2 = document.createElement("p");
    a2.className = "bn-file-caption", a2.textContent = e.props.caption, r.appendChild(a2);
  }
  return s2;
};
var ve = (e, t) => {
  const n = document.createElement("figure"), o = document.createElement("figcaption");
  return o.textContent = t, n.appendChild(e), n.appendChild(o), { dom: n };
};
var te = (e, t) => {
  const n = document.createElement("div"), o = document.createElement("p");
  return o.textContent = t, n.appendChild(e), n.appendChild(o), {
    dom: n
  };
};
var He = (e) => ({ url: e.src || void 0 });
var kn = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M2 16.0001H5.88889L11.1834 20.3319C11.2727 20.405 11.3846 20.4449 11.5 20.4449C11.7761 20.4449 12 20.2211 12 19.9449V4.05519C12 3.93977 11.9601 3.8279 11.887 3.73857C11.7121 3.52485 11.3971 3.49335 11.1834 3.66821L5.88889 8.00007H2C1.44772 8.00007 1 8.44778 1 9.00007V15.0001C1 15.5524 1.44772 16.0001 2 16.0001ZM23 12C23 15.292 21.5539 18.2463 19.2622 20.2622L17.8445 18.8444C19.7758 17.1937 21 14.7398 21 12C21 9.26016 19.7758 6.80629 17.8445 5.15557L19.2622 3.73779C21.5539 5.75368 23 8.70795 23 12ZM18 12C18 10.0883 17.106 8.38548 15.7133 7.28673L14.2842 8.71584C15.3213 9.43855 16 10.64 16 12C16 13.36 15.3213 14.5614 14.2842 15.2841L15.7133 16.7132C17.106 15.6145 18 13.9116 18 12Z"></path></svg>';
var Cn = (e) => ({
  type: "audio",
  propSchema: {
    backgroundColor: C.backgroundColor,
    // File name.
    name: {
      default: ""
    },
    // File url.
    url: {
      default: ""
    },
    // File caption.
    caption: {
      default: ""
    },
    showPreview: {
      default: true
    }
  },
  content: "none"
});
var yn = (e = {}) => (t) => {
  if (t.tagName === "AUDIO") {
    if (t.closest("figure"))
      return;
    const { backgroundColor: n } = B(t);
    return {
      ...He(t),
      backgroundColor: n
    };
  }
  if (t.tagName === "FIGURE") {
    const n = ee(t, "audio");
    if (!n)
      return;
    const { targetElement: o, caption: r } = n, { backgroundColor: s2 } = B(t);
    return {
      ...He(o),
      backgroundColor: s2,
      caption: r
    };
  }
};
var wn = (e = {}) => (t, n) => {
  const o = document.createElement("div");
  o.innerHTML = e.icon ?? kn;
  const r = document.createElement("audio");
  return r.className = "bn-audio", n.resolveFileUrl ? n.resolveFileUrl(t.props.url).then((s2) => {
    r.src = s2;
  }) : r.src = t.props.url, r.controls = true, r.contentEditable = "false", r.draggable = false, we(
    t,
    n,
    { dom: r },
    o.firstElementChild
  );
};
var vn = (e = {}) => (t, n) => {
  if (!t.props.url) {
    const r = document.createElement("p");
    return r.textContent = "Add audio", {
      dom: r
    };
  }
  let o;
  return t.props.showPreview ? (o = document.createElement("audio"), o.src = t.props.url) : (o = document.createElement("a"), o.href = t.props.url, o.textContent = t.props.name || t.props.url), t.props.caption ? t.props.showPreview ? ve(o, t.props.caption) : te(o, t.props.caption) : {
    dom: o
  };
};
var En = M(
  Cn,
  (e) => ({
    meta: {
      fileBlockAccept: ["audio/*"]
    },
    parse: yn(e),
    render: wn(e),
    toExternalHTML: vn(e),
    runsBefore: ["file"]
  })
);
var xn = class {
  constructor() {
    x(this, "callbacks", {});
  }
  on(t, n) {
    return this.callbacks[t] || (this.callbacks[t] = []), this.callbacks[t].push(n), () => this.off(t, n);
  }
  emit(t, ...n) {
    const o = this.callbacks[t];
    o && o.forEach((r) => r.apply(this, n));
  }
  off(t, n) {
    const o = this.callbacks[t];
    o && (n ? this.callbacks[t] = o.filter((r) => r !== n) : delete this.callbacks[t]);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
};
var Sn = class extends xn {
  // eslint-disable-next-line
  constructor(...n) {
    super();
    x(this, "plugins", []);
    x(this, "inputRules");
    x(this, "keyboardShortcuts");
    x(this, "tiptapExtensions");
  }
  static key() {
    throw new Error("You must implement the key method in your extension");
  }
  addProsemirrorPlugin(n) {
    this.plugins.push(n);
  }
  get priority() {
  }
};
function L(e) {
  const t = Object.create(Sn.prototype);
  return t.key = e.key, t.inputRules = e.inputRules, t.keyboardShortcuts = e.keyboardShortcuts, t.plugins = e.plugins ?? [], t.tiptapExtensions = e.tiptapExtensions, t;
}
var Oe = Symbol.for("blocknote.shikiParser");
var re = Symbol.for(
  "blocknote.shikiHighlighterPromise"
);
function Bn(e) {
  const t = globalThis;
  let n, o, r = false;
  return createHighlightPlugin({
    parser: (a2) => {
      if (!e.createHighlighter)
        return !r && (console.log(
          "For syntax highlighting of code blocks, you must provide a `createCodeBlockSpec({ createHighlighter: () => ... })` function"
        ), r = true), [];
      if (!n)
        return t[re] = t[re] || e.createHighlighter(), t[re].then(
          (c) => {
            n = c;
          }
        );
      const i2 = rt(e, a2.language);
      return !i2 || i2 === "text" || i2 === "none" || i2 === "plaintext" || i2 === "txt" ? [] : n.getLoadedLanguages().includes(i2) ? (o || (o = t[Oe] || createParser(n), t[Oe] = o), o(a2)) : n.loadLanguage(i2);
    },
    languageExtractor: (a2) => a2.attrs.language,
    nodeTypes: ["codeBlock"]
  });
}
var Mn = ({ defaultLanguage: e = "text" }) => ({
  type: "codeBlock",
  propSchema: {
    language: {
      default: e
    }
  },
  content: "inline"
});
var Ln = M(
  Mn,
  (e) => ({
    meta: {
      code: true,
      defining: true,
      isolating: false
    },
    parse: (t) => {
      var r, s2;
      if (t.tagName !== "PRE" || t.childElementCount !== 1 || ((r = t.firstElementChild) == null ? void 0 : r.tagName) !== "CODE")
        return;
      const n = t.firstElementChild;
      return { language: n.getAttribute("data-language") || ((s2 = n.className.split(" ").find((a2) => a2.includes("language-"))) == null ? void 0 : s2.replace("language-", "")) };
    },
    parseContent: ({ el: t, schema: n }) => {
      const o = DOMParser2.fromSchema(n), r = t.firstElementChild;
      return o.parse(r, {
        topNode: n.nodes.codeBlock.create()
      }).content;
    },
    render(t, n) {
      const o = document.createDocumentFragment(), r = document.createElement("pre"), s2 = document.createElement("code");
      r.appendChild(s2);
      let a2;
      if (e.supportedLanguages) {
        const i2 = document.createElement("select");
        Object.entries(e.supportedLanguages ?? {}).forEach(
          ([d, { name: u }]) => {
            const p5 = document.createElement("option");
            p5.value = d, p5.text = u, i2.appendChild(p5);
          }
        ), i2.value = t.props.language || e.defaultLanguage || "text";
        const c = (d) => {
          const u = d.target.value;
          n.updateBlock(t.id, { props: { language: u } });
        };
        i2.addEventListener("change", c), a2 = () => i2.removeEventListener("change", c);
        const l2 = document.createElement("div");
        l2.contentEditable = "false", l2.appendChild(i2), o.appendChild(l2);
      }
      return o.appendChild(r), {
        dom: o,
        contentDOM: s2,
        destroy: () => {
          a2 == null || a2();
        }
      };
    },
    toExternalHTML(t) {
      const n = document.createElement("pre"), o = document.createElement("code");
      return o.className = `language-${t.props.language}`, o.dataset.language = t.props.language, n.appendChild(o), {
        dom: n,
        contentDOM: o
      };
    }
  }),
  (e) => [
    L({
      key: "code-block-highlighter",
      plugins: [Bn(e)]
    }),
    L({
      key: "code-block-keyboard-shortcuts",
      keyboardShortcuts: {
        Delete: ({ editor: t }) => t.transact((n) => {
          const { block: o } = t.getTextCursorPosition();
          if (o.type !== "codeBlock")
            return false;
          const { $from: r } = n.selection;
          return r.parent.textContent ? false : (t.removeBlocks([o]), true);
        }),
        Tab: ({ editor: t }) => e.indentLineWithTab === false ? false : t.transact((n) => {
          const { block: o } = t.getTextCursorPosition();
          return o.type === "codeBlock" ? (n.insertText("  "), true) : false;
        }),
        Enter: ({ editor: t }) => t.transact((n) => {
          const { block: o, nextBlock: r } = t.getTextCursorPosition();
          if (o.type !== "codeBlock")
            return false;
          const { $from: s2 } = n.selection, a2 = s2.parentOffset === s2.parent.nodeSize - 2, i2 = s2.parent.textContent.endsWith(`

`);
          if (a2 && i2) {
            if (n.delete(s2.pos - 2, s2.pos), r)
              return t.setTextCursorPosition(r, "start"), true;
            const [c] = t.insertBlocks(
              [{ type: "paragraph" }],
              o,
              "after"
            );
            return t.setTextCursorPosition(c, "start"), true;
          }
          return n.insertText(`
`), true;
        }),
        "Shift-Enter": ({ editor: t }) => t.transact(() => {
          const { block: n } = t.getTextCursorPosition();
          if (n.type !== "codeBlock")
            return false;
          const [o] = t.insertBlocks(
            // insert a new paragraph
            [{ type: "paragraph" }],
            n,
            "after"
          );
          return t.setTextCursorPosition(o, "start"), true;
        })
      },
      inputRules: [
        {
          find: /^```(.*?)\s$/,
          replace: ({ match: t }) => {
            const n = t[1].trim();
            return {
              type: "codeBlock",
              props: {
                language: {
                  language: rt(e, n) ?? n
                }.language
              },
              content: []
            };
          }
        }
      ]
    })
  ]
);
function rt(e, t) {
  var n;
  return (n = Object.entries(e.supportedLanguages ?? {}).find(
    ([o, { aliases: r }]) => (r == null ? void 0 : r.includes(t)) || o === t
  )) == null ? void 0 : n[0];
}
var Tn = () => ({
  type: "divider",
  propSchema: {},
  content: "none"
});
var An = M(
  Tn,
  {
    meta: {
      isolating: false
    },
    parse(e) {
      if (e.tagName === "HR")
        return {};
    },
    render() {
      return {
        dom: document.createElement("hr")
      };
    }
  },
  [
    L({
      key: "divider-block-shortcuts",
      inputRules: [
        {
          find: new RegExp("^---$"),
          replace() {
            return { type: "divider", props: {}, content: [] };
          }
        }
      ]
    })
  ]
);
var De = (e) => ({ url: e.src || void 0 });
var Nn = () => ({
  type: "file",
  propSchema: {
    backgroundColor: C.backgroundColor,
    // File name.
    name: {
      default: ""
    },
    // File url.
    url: {
      default: ""
    },
    // File caption.
    caption: {
      default: ""
    }
  },
  content: "none"
});
var In = () => (e) => {
  if (e.tagName === "EMBED") {
    if (e.closest("figure"))
      return;
    const { backgroundColor: t } = B(e);
    return {
      ...De(e),
      backgroundColor: t
    };
  }
  if (e.tagName === "FIGURE") {
    const t = ee(e, "embed");
    if (!t)
      return;
    const { targetElement: n, caption: o } = t, { backgroundColor: r } = B(e);
    return {
      ...De(n),
      backgroundColor: r,
      caption: o
    };
  }
};
var Pn = M(Nn, {
  meta: {
    fileBlockAccept: ["*/*"]
  },
  parse: In(),
  render(e, t) {
    return we(e, t);
  },
  toExternalHTML(e) {
    if (!e.props.url) {
      const n = document.createElement("p");
      return n.textContent = "Add file", {
        dom: n
      };
    }
    const t = document.createElement("a");
    return t.href = e.props.url, t.textContent = e.props.name || e.props.url, e.props.caption ? te(t, e.props.caption) : {
      dom: t
    };
  }
});
var Hn = {
  set: (e, t) => window.localStorage.setItem(
    `toggle-${e.id}`,
    t ? "true" : "false"
  ),
  get: (e) => window.localStorage.getItem(`toggle-${e.id}`) === "true"
};
var st = (e, t, n, o = Hn) => {
  if ("isToggleable" in e.props && !e.props.isToggleable)
    return {
      dom: n
    };
  const r = document.createElement("div"), s2 = document.createElement("div");
  s2.className = "bn-toggle-wrapper";
  const a2 = document.createElement("button");
  a2.className = "bn-toggle-button", a2.type = "button", a2.innerHTML = // https://fonts.google.com/icons?selected=Material+Symbols+Rounded:chevron_right:FILL@0;wght@700;GRAD@0;opsz@24&icon.query=chevron&icon.style=Rounded&icon.size=24&icon.color=%23e8eaed
  '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="CURRENTCOLOR"><path d="M320-200v-560l440 280-440 280Z"/></svg>';
  const i2 = (h4) => h4.preventDefault();
  a2.addEventListener("mousedown", i2);
  const c = () => {
    var h4;
    s2.getAttribute("data-show-children") === "true" ? (s2.setAttribute("data-show-children", "false"), o.set(t.getBlock(e), false), r.contains(l2) && r.removeChild(l2)) : (s2.setAttribute("data-show-children", "true"), o.set(t.getBlock(e), true), ((h4 = t.getBlock(e)) == null ? void 0 : h4.children.length) === 0 && !r.contains(l2) && r.appendChild(l2));
  };
  a2.addEventListener("click", c), s2.appendChild(a2), s2.appendChild(n);
  const l2 = document.createElement("button");
  l2.className = "bn-toggle-add-block-button", l2.type = "button", l2.textContent = t.dictionary.toggle_blocks.add_block_button;
  const d = (h4) => h4.preventDefault();
  l2.addEventListener(
    "mousedown",
    d
  );
  const u = () => {
    t.transact(() => {
      const h4 = t.updateBlock(e, {
        // Single empty block with default type.
        children: [{}]
      });
      t.setTextCursorPosition(h4.children[0].id, "end"), t.focus();
    });
  };
  l2.addEventListener("click", u), r.appendChild(s2);
  let p5 = e.children.length;
  const f2 = t.onChange(() => {
    var k2;
    const h4 = ((k2 = t.getBlock(e)) == null ? void 0 : k2.children.length) ?? 0;
    h4 > p5 ? (s2.getAttribute("data-show-children") === "false" && (s2.setAttribute("data-show-children", "true"), o.set(t.getBlock(e), true)), r.contains(l2) && r.removeChild(l2)) : h4 === 0 && h4 < p5 && (s2.getAttribute("data-show-children") === "true" && (s2.setAttribute("data-show-children", "false"), o.set(t.getBlock(e), false)), r.contains(l2) && r.removeChild(l2)), p5 = h4;
  });
  return o.get(e) ? (s2.setAttribute("data-show-children", "true"), e.children.length === 0 && r.appendChild(l2)) : s2.setAttribute("data-show-children", "false"), {
    dom: r,
    // Prevents re-renders when the toggle button is clicked.
    ignoreMutation: (h4) => h4 instanceof MutationRecord && // We want to prevent re-renders when the view changes, so we ignore
    // all mutations where the `data-show-children` attribute is changed
    // or the "add block" button is added/removed.
    (h4.type === "attributes" && h4.target === s2 && h4.attributeName === "data-show-children" || h4.type === "childList" && (h4.addedNodes[0] === l2 || h4.removedNodes[0] === l2)),
    destroy: () => {
      a2.removeEventListener("mousedown", i2), a2.removeEventListener("click", c), l2.removeEventListener(
        "mousedown",
        d
      ), l2.removeEventListener(
        "click",
        u
      ), f2 == null || f2();
    }
  };
};
var at = [1, 2, 3, 4, 5, 6];
var On = ({
  defaultLevel: e = 1,
  levels: t = at,
  allowToggleHeadings: n = true
} = {}) => ({
  type: "heading",
  propSchema: {
    ...C,
    level: { default: e, values: t },
    ...n ? { isToggleable: { default: false, optional: true } } : {}
  },
  content: "inline"
});
var Dn = M(
  On,
  ({ allowToggleHeadings: e = true } = {}) => ({
    meta: {
      isolating: false
    },
    parse(t) {
      let n;
      switch (t.tagName) {
        case "H1":
          n = 1;
          break;
        case "H2":
          n = 2;
          break;
        case "H3":
          n = 3;
          break;
        case "H4":
          n = 4;
          break;
        case "H5":
          n = 5;
          break;
        case "H6":
          n = 6;
          break;
        default:
          return;
      }
      return {
        ...B(t),
        level: n
      };
    },
    render(t, n) {
      const o = document.createElement(`h${t.props.level}`);
      return e ? { ...st(t, n, o), contentDOM: o } : {
        dom: o,
        contentDOM: o
      };
    },
    toExternalHTML(t) {
      const n = document.createElement(`h${t.props.level}`);
      return H(t.props, n), {
        dom: n,
        contentDOM: n
      };
    }
  }),
  ({ levels: e = at } = {}) => [
    L({
      key: "heading-shortcuts",
      keyboardShortcuts: Object.fromEntries(
        e.map((t) => [
          `Mod-Alt-${t}`,
          ({ editor: n }) => {
            const o = n.getTextCursorPosition();
            return n.schema.blockSchema[o.block.type].content !== "inline" ? false : (n.updateBlock(o.block, {
              type: "heading",
              props: {
                level: t
              }
            }), true);
          }
        ]) ?? []
      ),
      inputRules: e.map((t) => ({
        find: new RegExp(`^(#{${t}})\\s$`),
        replace({ match: n }) {
          return {
            type: "heading",
            props: {
              level: n[1].length
            }
          };
        }
      }))
    })
  ]
);
var it = (e, t, n, o, r) => {
  const { dom: s2, destroy: a2 } = we(
    e,
    t,
    n,
    r
  ), i2 = s2;
  i2.style.position = "relative", e.props.url && e.props.showPreview && (e.props.previewWidth ? i2.style.width = `${e.props.previewWidth}px` : i2.style.width = "fit-content");
  const c = document.createElement("div");
  c.className = "bn-resize-handle", c.style.left = "4px";
  const l2 = document.createElement("div");
  l2.className = "bn-resize-handle", l2.style.right = "4px";
  const d = document.createElement("div");
  d.style.position = "absolute", d.style.height = "100%", d.style.width = "100%";
  let u, p5 = e.props.previewWidth;
  const f2 = (g) => {
    var V, W;
    if (!u) {
      !t.isEditable && o.contains(c) && o.contains(l2) && (o.removeChild(c), o.removeChild(l2));
      return;
    }
    let v2;
    const S = "touches" in g ? g.touches[0].clientX : g.clientX;
    e.props.textAlignment === "center" ? u.handleUsed === "left" ? v2 = u.initialWidth + (u.initialClientX - S) * 2 : v2 = u.initialWidth + (S - u.initialClientX) * 2 : u.handleUsed === "left" ? v2 = u.initialWidth + u.initialClientX - S : v2 = u.initialWidth + S - u.initialClientX, p5 = Math.min(
      Math.max(v2, 64),
      ((W = (V = t.domElement) == null ? void 0 : V.firstElementChild) == null ? void 0 : W.clientWidth) || Number.MAX_VALUE
    ), i2.style.width = `${p5}px`;
  }, h4 = (g) => {
    (!g.target || !i2.contains(g.target) || !t.isEditable) && o.contains(c) && o.contains(l2) && (o.removeChild(c), o.removeChild(l2)), u && (u = void 0, i2.contains(d) && i2.removeChild(d), t.updateBlock(e, {
      props: {
        previewWidth: p5
      }
    }));
  }, k2 = () => {
    t.isEditable && (o.appendChild(c), o.appendChild(l2));
  }, m = (g) => {
    g.relatedTarget === c || g.relatedTarget === l2 || u || t.isEditable && o.contains(c) && o.contains(l2) && (o.removeChild(c), o.removeChild(l2));
  }, b2 = (g) => {
    g.preventDefault(), i2.contains(d) || i2.appendChild(d);
    const v2 = "touches" in g ? g.touches[0].clientX : g.clientX;
    u = {
      handleUsed: "left",
      initialWidth: i2.clientWidth,
      initialClientX: v2
    };
  }, y2 = (g) => {
    g.preventDefault(), i2.contains(d) || i2.appendChild(d);
    const v2 = "touches" in g ? g.touches[0].clientX : g.clientX;
    u = {
      handleUsed: "right",
      initialWidth: i2.clientWidth,
      initialClientX: v2
    };
  };
  return window.addEventListener("mousemove", f2), window.addEventListener("touchmove", f2), window.addEventListener("mouseup", h4), window.addEventListener("touchend", h4), i2.addEventListener("mouseenter", k2), i2.addEventListener("mouseleave", m), c.addEventListener(
    "mousedown",
    b2
  ), c.addEventListener(
    "touchstart",
    b2
  ), l2.addEventListener(
    "mousedown",
    y2
  ), l2.addEventListener(
    "touchstart",
    y2
  ), {
    dom: i2,
    destroy: () => {
      a2 == null || a2(), window.removeEventListener("mousemove", f2), window.removeEventListener("touchmove", f2), window.removeEventListener("mouseup", h4), window.removeEventListener("touchend", h4), i2.removeEventListener("mouseenter", k2), i2.removeEventListener("mouseleave", m), c.removeEventListener(
        "mousedown",
        b2
      ), c.removeEventListener(
        "touchstart",
        b2
      ), l2.removeEventListener(
        "mousedown",
        y2
      ), l2.removeEventListener(
        "touchstart",
        y2
      );
    }
  };
};
var _e = (e) => {
  const t = e.src || void 0, n = e.width || void 0, o = e.alt || void 0;
  return { url: t, previewWidth: n, name: o };
};
var _n = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M5 11.1005L7 9.1005L12.5 14.6005L16 11.1005L19 14.1005V5H5V11.1005ZM4 3H20C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3ZM15.5 10C14.6716 10 14 9.32843 14 8.5C14 7.67157 14.6716 7 15.5 7C16.3284 7 17 7.67157 17 8.5C17 9.32843 16.3284 10 15.5 10Z"></path></svg>';
var Rn = (e = {}) => ({
  type: "image",
  propSchema: {
    textAlignment: C.textAlignment,
    backgroundColor: C.backgroundColor,
    // File name.
    name: {
      default: ""
    },
    // File url.
    url: {
      default: ""
    },
    // File caption.
    caption: {
      default: ""
    },
    showPreview: {
      default: true
    },
    // File preview width in px.
    previewWidth: {
      default: void 0,
      type: "number"
    }
  },
  content: "none"
});
var Vn = (e = {}) => (t) => {
  if (t.tagName === "IMG") {
    if (t.closest("figure"))
      return;
    const { backgroundColor: n } = B(t);
    return {
      ..._e(t),
      backgroundColor: n
    };
  }
  if (t.tagName === "FIGURE") {
    const n = ee(t, "img");
    if (!n)
      return;
    const { targetElement: o, caption: r } = n, { backgroundColor: s2 } = B(t);
    return {
      ..._e(o),
      backgroundColor: s2,
      caption: r
    };
  }
};
var Wn = (e = {}) => (t, n) => {
  const o = document.createElement("div");
  o.innerHTML = e.icon ?? _n;
  const r = document.createElement("div");
  r.className = "bn-visual-media-wrapper";
  const s2 = document.createElement("img");
  return s2.className = "bn-visual-media", n.resolveFileUrl ? n.resolveFileUrl(t.props.url).then((a2) => {
    s2.src = a2;
  }) : s2.src = t.props.url, s2.alt = t.props.name || t.props.caption || "BlockNote image", s2.contentEditable = "false", s2.draggable = false, r.appendChild(s2), it(
    t,
    n,
    { dom: r },
    r,
    o.firstElementChild
  );
};
var Fn = (e = {}) => (t, n) => {
  if (!t.props.url) {
    const r = document.createElement("p");
    return r.textContent = "Add image", {
      dom: r
    };
  }
  let o;
  return t.props.showPreview ? (o = document.createElement("img"), o.src = t.props.url, o.alt = t.props.name || t.props.caption || "BlockNote image", t.props.previewWidth && (o.width = t.props.previewWidth)) : (o = document.createElement("a"), o.href = t.props.url, o.textContent = t.props.name || t.props.url), t.props.caption ? t.props.showPreview ? ve(o, t.props.caption) : te(o, t.props.caption) : {
    dom: o
  };
};
var $n = M(
  Rn,
  (e) => ({
    meta: {
      fileBlockAccept: ["image/*"]
    },
    parse: Vn(e),
    render: Wn(e),
    toExternalHTML: Fn(e),
    runsBefore: ["file"]
  })
);
var cr = (e, t, n) => ({
  state: o,
  dispatch: r
}) => r ? ct(o.tr, e, t, n) : true;
var ct = (e, t, n, o) => {
  const r = fe(e.doc, t), s2 = z(r);
  if (!s2.isBlockContainer)
    return false;
  const a2 = G(e), i2 = [
    {
      type: s2.bnBlock.node.type,
      // always keep blockcontainer type
      attrs: o ? { ...s2.bnBlock.node.attrs, id: void 0 } : {}
    },
    {
      type: n ? s2.blockContent.node.type : a2.nodes.paragraph,
      attrs: o ? { ...s2.blockContent.node.attrs } : {}
    }
  ];
  return e.split(t, 2, i2), true;
};
var ne = (e, t) => {
  const { blockInfo: n, selectionEmpty: o } = e.transact((a2) => ({
    blockInfo: Gt(a2),
    selectionEmpty: a2.selection.anchor === a2.selection.head
  }));
  if (!n.isBlockContainer)
    return false;
  const { bnBlock: r, blockContent: s2 } = n;
  return s2.node.type.name !== t || !o ? false : s2.node.childCount === 0 ? (e.transact((a2) => {
    ye(a2, r.beforePos, {
      type: "paragraph",
      props: {}
    });
  }), true) : s2.node.childCount > 0 ? e.transact((a2) => (a2.deleteSelection(), ct(a2, a2.selection.from, true))) : false;
};
function Ee(e, t, n) {
  var u, p5, f2;
  const o = DOMParser2.fromSchema(t), r = e, s2 = document.createElement("div");
  s2.setAttribute("data-node-type", "blockGroup");
  for (const h4 of Array.from(r.childNodes))
    s2.appendChild(h4.cloneNode(true));
  let a2 = o.parse(s2, {
    topNode: t.nodes.blockGroup.create()
  });
  ((p5 = (u = a2.firstChild) == null ? void 0 : u.firstChild) == null ? void 0 : p5.type.name) === "checkListItem" && (a2 = a2.copy(
    a2.content.cut(
      a2.firstChild.firstChild.nodeSize + 2
    )
  ));
  const i2 = (f2 = a2.firstChild) == null ? void 0 : f2.firstChild;
  if (!(i2 != null && i2.isTextblock))
    return Fragment.from(a2);
  const c = t.nodes[n].create(
    {},
    i2.content
  ), l2 = a2.content.cut(
    // +2 for the `blockGroup` node's start and end markers
    i2.nodeSize + 2
  );
  if (l2.size > 0) {
    const h4 = a2.copy(l2);
    return c.content.addToEnd(h4);
  }
  return c.content;
}
var jn = () => ({
  type: "bulletListItem",
  propSchema: {
    ...C
  },
  content: "inline"
});
var Un = M(
  jn,
  {
    meta: {
      isolating: false
    },
    parse(e) {
      var n;
      if (e.tagName !== "LI")
        return;
      const t = e.parentElement;
      if (t !== null && (t.tagName === "UL" || t.tagName === "DIV" && ((n = t.parentElement) == null ? void 0 : n.tagName) === "UL"))
        return B(e);
    },
    // As `li` elements can contain multiple paragraphs, we need to merge their contents
    // into a single one so that ProseMirror can parse everything correctly.
    parseContent: ({ el: e, schema: t }) => Ee(e, t, "bulletListItem"),
    render() {
      const e = document.createElement("p");
      return {
        dom: e,
        contentDOM: e
      };
    },
    toExternalHTML(e) {
      const t = document.createElement("li"), n = document.createElement("p");
      return H(e.props, t), t.appendChild(n), {
        dom: t,
        contentDOM: n
      };
    }
  },
  [
    L({
      key: "bullet-list-item-shortcuts",
      keyboardShortcuts: {
        Enter: ({ editor: e }) => ne(e, "bulletListItem"),
        "Mod-Shift-8": ({ editor: e }) => {
          const t = e.getTextCursorPosition();
          return e.schema.blockSchema[t.block.type].content !== "inline" ? false : (e.updateBlock(t.block, {
            type: "bulletListItem",
            props: {}
          }), true);
        }
      },
      inputRules: [
        {
          find: new RegExp("^[-+*]\\s$"),
          replace({ editor: e }) {
            if (Ge(
              e.prosemirrorState
            ).blockNoteType !== "heading")
              return {
                type: "bulletListItem",
                props: {}
              };
          }
        }
      ]
    })
  ]
);
var zn = () => ({
  type: "checkListItem",
  propSchema: {
    ...C,
    checked: { default: false, type: "boolean" }
  },
  content: "inline"
});
var qn = M(
  zn,
  {
    meta: {
      isolating: false
    },
    parse(e) {
      var n;
      if (e.tagName === "input")
        return e.closest("[data-content-type]") || e.closest("li") ? void 0 : e.type === "checkbox" ? { checked: e.checked } : void 0;
      if (e.tagName !== "LI")
        return;
      const t = e.parentElement;
      if (t !== null && (t.tagName === "UL" || t.tagName === "DIV" && ((n = t.parentElement) == null ? void 0 : n.tagName) === "UL")) {
        const o = e.querySelector("input[type=checkbox]") || null;
        return o === null ? void 0 : { ...B(e), checked: o.checked };
      }
    },
    // As `li` elements can contain multiple paragraphs, we need to merge their contents
    // into a single one so that ProseMirror can parse everything correctly.
    parseContent: ({ el: e, schema: t }) => Ee(e, t, "checkListItem"),
    render(e, t) {
      const n = document.createDocumentFragment(), o = document.createElement("input");
      o.type = "checkbox", o.checked = e.props.checked, e.props.checked && o.setAttribute("checked", ""), o.addEventListener("change", () => {
        t.updateBlock(e, { props: { checked: !e.props.checked } });
      });
      const r = document.createElement("p");
      return n.appendChild(o), n.appendChild(r), {
        dom: n,
        contentDOM: r
      };
    },
    toExternalHTML(e) {
      const t = document.createElement("li"), n = document.createElement("input");
      n.type = "checkbox", n.checked = e.props.checked, e.props.checked && n.setAttribute("checked", "");
      const o = document.createElement("p");
      return H(e.props, t), t.appendChild(n), t.appendChild(o), {
        dom: t,
        contentDOM: o
      };
    },
    runsBefore: ["bulletListItem"]
  },
  [
    L({
      key: "check-list-item-shortcuts",
      keyboardShortcuts: {
        Enter: ({ editor: e }) => ne(e, "checkListItem"),
        "Mod-Shift-9": ({ editor: e }) => {
          const t = e.getTextCursorPosition();
          return e.schema.blockSchema[t.block.type].content !== "inline" ? false : (e.updateBlock(t.block, {
            type: "checkListItem",
            props: {}
          }), true);
        }
      },
      inputRules: [
        {
          find: new RegExp("\\[\\s*\\]\\s$"),
          replace() {
            return {
              type: "checkListItem",
              props: {
                checked: false
              },
              content: []
            };
          }
        },
        {
          find: new RegExp("\\[[Xx]\\]\\s$"),
          replace() {
            return {
              type: "checkListItem",
              props: {
                checked: true
              }
            };
          }
        }
      ]
    })
  ]
);
function lt(e, t, n, o) {
  let r = e.firstChild.attrs.start || 1, s2 = true;
  const a2 = !!e.firstChild.attrs.start, i2 = z({
    posBeforeNode: t,
    node: e
  });
  if (!i2.isBlockContainer)
    throw new Error("impossible");
  const c = n.doc.resolve(i2.bnBlock.beforePos).nodeBefore, l2 = c ? o.get(c) : void 0;
  return l2 !== void 0 ? (r = l2 + 1, s2 = false) : c && z({
    posBeforeNode: i2.bnBlock.beforePos - c.nodeSize,
    node: c
  }).blockNoteType === "numberedListItem" && (r = lt(
    c,
    i2.bnBlock.beforePos - c.nodeSize,
    n,
    o
  ).index + 1, s2 = false), o.set(e, r), { index: r, isFirst: s2, hasStart: a2 };
}
function Re(e, t) {
  const n = /* @__PURE__ */ new Map(), o = t.decorations.map(
    e.mapping,
    e.doc
  ), r = [];
  e.doc.nodesBetween(0, e.doc.nodeSize - 2, (a2, i2) => {
    if (a2.type.name === "blockContainer" && a2.firstChild.type.name === "numberedListItem") {
      const { index: c, isFirst: l2, hasStart: d } = lt(
        a2,
        i2,
        e,
        n
      );
      o.find(
        i2,
        i2 + a2.nodeSize,
        (p5) => p5.index === c && p5.isFirst === l2 && p5.hasStart === d
      ).length === 0 && r.push(
        // move in by 1 to account for the block container
        Decoration.node(i2 + 1, i2 + a2.nodeSize - 1, {
          "data-index": c.toString()
        })
      );
    }
  });
  const s2 = r.flatMap(
    (a2) => o.find(a2.from, a2.to)
  );
  return {
    decorations: o.remove(s2).add(e.doc, r)
  };
}
var Zn = () => new Plugin({
  key: new PluginKey("numbered-list-indexing-decorations"),
  state: {
    init(e, t) {
      return Re(t.tr, {
        decorations: DecorationSet.empty
      });
    },
    apply(e, t) {
      return !e.docChanged && !e.selectionSet && t.decorations ? t : Re(e, t);
    }
  },
  props: {
    decorations(e) {
      var t;
      return ((t = this.getState(e)) == null ? void 0 : t.decorations) ?? DecorationSet.empty;
    }
  }
});
var Gn = () => ({
  type: "numberedListItem",
  propSchema: {
    ...C,
    start: { default: void 0, type: "number" }
  },
  content: "inline"
});
var Xn = M(
  Gn,
  {
    meta: {
      isolating: false
    },
    parse(e) {
      var n;
      if (e.tagName !== "LI")
        return;
      const t = e.parentElement;
      if (t !== null && (t.tagName === "OL" || t.tagName === "DIV" && ((n = t.parentElement) == null ? void 0 : n.tagName) === "OL")) {
        const o = parseInt(t.getAttribute("start") || "1"), r = B(e);
        return e.previousElementSibling || o === 1 ? r : {
          ...r,
          start: o
        };
      }
    },
    // As `li` elements can contain multiple paragraphs, we need to merge their contents
    // into a single one so that ProseMirror can parse everything correctly.
    parseContent: ({ el: e, schema: t }) => Ee(e, t, "numberedListItem"),
    render() {
      const e = document.createElement("p");
      return {
        dom: e,
        contentDOM: e
      };
    },
    toExternalHTML(e) {
      const t = document.createElement("li"), n = document.createElement("p");
      return H(e.props, t), t.appendChild(n), {
        dom: t,
        contentDOM: n
      };
    }
  },
  [
    L({
      key: "numbered-list-item-shortcuts",
      inputRules: [
        {
          find: new RegExp("^(\\d+)\\.\\s$"),
          replace({ match: e, editor: t }) {
            if (Ge(
              t.prosemirrorState
            ).blockNoteType === "heading")
              return;
            const o = parseInt(e[1]);
            return {
              type: "numberedListItem",
              props: {
                start: o !== 1 ? o : void 0
              }
            };
          }
        }
      ],
      keyboardShortcuts: {
        Enter: ({ editor: e }) => ne(e, "numberedListItem"),
        "Mod-Shift-7": ({ editor: e }) => {
          const t = e.getTextCursorPosition();
          return e.schema.blockSchema[t.block.type].content !== "inline" ? false : (e.updateBlock(t.block, {
            type: "numberedListItem",
            props: {}
          }), true);
        }
      },
      plugins: [Zn()]
    })
  ]
);
var Jn = () => ({
  type: "toggleListItem",
  propSchema: {
    ...C
  },
  content: "inline"
});
var Kn = M(
  Jn,
  {
    meta: {
      isolating: false
    },
    render(e, t) {
      const n = document.createElement("p");
      return { ...st(
        e,
        t,
        n
      ), contentDOM: n };
    },
    toExternalHTML(e) {
      const t = document.createElement("li"), n = document.createElement("p");
      return H(e.props, t), t.appendChild(n), {
        dom: t,
        contentDOM: n
      };
    }
  },
  [
    L({
      key: "toggle-list-item-shortcuts",
      keyboardShortcuts: {
        Enter: ({ editor: e }) => ne(e, "toggleListItem"),
        "Mod-Shift-6": ({ editor: e }) => {
          const t = e.getTextCursorPosition();
          return e.schema.blockSchema[t.block.type].content !== "inline" ? false : (e.updateBlock(t.block, {
            type: "toggleListItem",
            props: {}
          }), true);
        }
      }
    })
  ]
);
var Qn = () => ({
  type: "pageBreak",
  propSchema: {},
  content: "none"
});
var Yn = M(
  Qn,
  {
    parse(e) {
      if (e.tagName === "DIV" && e.hasAttribute("data-page-break"))
        return {};
    },
    render() {
      const e = document.createElement("div");
      return e.setAttribute("data-page-break", ""), {
        dom: e
      };
    },
    toExternalHTML() {
      const e = document.createElement("div");
      return e.setAttribute("data-page-break", ""), {
        dom: e
      };
    }
  }
);
var eo = () => ({
  type: "paragraph",
  propSchema: C,
  content: "inline"
});
var to = M(
  eo,
  {
    meta: {
      isolating: false
    },
    parse: (e) => {
      var t;
      if (e.tagName === "P" && (t = e.textContent) != null && t.trim())
        return B(e);
    },
    render: () => {
      const e = document.createElement("p");
      return {
        dom: e,
        contentDOM: e
      };
    },
    toExternalHTML: (e) => {
      const t = document.createElement("p");
      return H(e.props, t), {
        dom: t,
        contentDOM: t
      };
    },
    runsBefore: ["default"]
  },
  [
    L({
      key: "paragraph-shortcuts",
      keyboardShortcuts: {
        "Mod-Alt-0": ({ editor: e }) => {
          const t = e.getTextCursorPosition();
          return e.schema.blockSchema[t.block.type].content !== "inline" ? false : (e.updateBlock(t.block, {
            type: "paragraph",
            props: {}
          }), true);
        }
      }
    })
  ]
);
var no = () => ({
  type: "quote",
  propSchema: {
    backgroundColor: C.backgroundColor,
    textColor: C.textColor
  },
  content: "inline"
});
var oo = M(
  no,
  {
    meta: {
      isolating: false
    },
    parse(e) {
      if (e.tagName === "BLOCKQUOTE") {
        const { backgroundColor: t, textColor: n } = B(e);
        return { backgroundColor: t, textColor: n };
      }
    },
    render() {
      const e = document.createElement("blockquote");
      return {
        dom: e,
        contentDOM: e
      };
    },
    toExternalHTML(e) {
      const t = document.createElement("blockquote");
      return H(e.props, t), {
        dom: t,
        contentDOM: t
      };
    }
  },
  [
    L({
      key: "quote-block-shortcuts",
      keyboardShortcuts: {
        "Mod-Alt-q": ({ editor: e }) => {
          const t = e.getTextCursorPosition();
          return e.schema.blockSchema[t.block.type].content !== "inline" ? false : (e.updateBlock(t.block, {
            type: "quote",
            props: {}
          }), true);
        }
      },
      inputRules: [
        {
          find: new RegExp("^>\\s$"),
          replace() {
            return {
              type: "quote",
              props: {}
            };
          }
        }
      ]
    })
  ]
);
var ro = 35;
var ut = 120;
var ur = 31;
var so = Extension.create({
  name: "BlockNoteTableExtension",
  addProseMirrorPlugins: () => [
    columnResizing({
      cellMinWidth: ro,
      defaultCellMinWidth: ut,
      // We set this to null as we implement our own node view in the table
      // block content. This node view is the same as what's used by default,
      // but is wrapped in a `blockContent` HTML element.
      View: null
    }),
    tableEditing()
  ],
  addKeyboardShortcuts() {
    return {
      // Makes enter create a new line within the cell.
      Enter: () => this.editor.state.selection.empty && this.editor.state.selection.$head.parent.type.name === "tableParagraph" ? (this.editor.commands.insertContent({ type: "hardBreak" }), true) : false,
      // Ensures that backspace won't delete the table if the text cursor is at
      // the start of a cell and the selection is empty.
      Backspace: () => {
        const e = this.editor.state.selection, t = e.empty, n = e.$head.parentOffset === 0, o = e.$head.node().type.name === "tableParagraph";
        return t && n && o;
      },
      // Enables navigating cells using the tab key.
      Tab: () => this.editor.commands.command(
        ({ state: e, dispatch: t, view: n }) => goToNextCell(1)(e, t, n)
      ),
      "Shift-Tab": () => this.editor.commands.command(
        ({ state: e, dispatch: t, view: n }) => goToNextCell(-1)(e, t, n)
      )
    };
  },
  extendNodeSchema(e) {
    const t = {
      name: e.name,
      options: e.options,
      storage: e.storage
    };
    return {
      tableRole: callOrReturn(
        getExtensionField(e, "tableRole", t)
      )
    };
  }
});
var ao = {
  textColor: C.textColor
};
var io = Node3.create({
  name: "tableHeader",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  /**
   * We allow table headers and cells to have multiple tableContent nodes because
   * when merging cells, prosemirror-tables will concat the contents of the cells naively.
   * This would cause that content to overflow into other cells when prosemirror tries to enforce the cell structure.
   *
   * So, we manually fix this up when reading back in the `nodeToBlock` and only ever place a single tableContent back into the cell.
   */
  content: "tableContent+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (e) => {
          const t = e.getAttribute("colwidth");
          return t ? t.split(",").map((o) => parseInt(o, 10)) : null;
        }
      }
    };
  },
  tableRole: "header_cell",
  isolating: true,
  parseHTML() {
    return [
      {
        tag: "th",
        // As `th` elements can contain multiple paragraphs, we need to merge their contents
        // into a single one so that ProseMirror can parse everything correctly.
        getContent: (e, t) => dt(e, t)
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return [
      "th",
      mergeAttributes(this.options.HTMLAttributes, e),
      0
    ];
  }
});
var co = Node3.create({
  name: "tableCell",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "tableContent+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (e) => {
          const t = e.getAttribute("colwidth");
          return t ? t.split(",").map((o) => parseInt(o, 10)) : null;
        }
      }
    };
  },
  tableRole: "cell",
  isolating: true,
  parseHTML() {
    return [
      {
        tag: "td",
        // As `td` elements can contain multiple paragraphs, we need to merge their contents
        // into a single one so that ProseMirror can parse everything correctly.
        getContent: (e, t) => dt(e, t)
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return [
      "td",
      mergeAttributes(this.options.HTMLAttributes, e),
      0
    ];
  }
});
var lo = Node3.create({
  name: "table",
  content: "tableRow+",
  group: "blockContent",
  tableRole: "table",
  marks: "deletion insertion modification",
  isolating: true,
  parseHTML() {
    return [
      {
        tag: "table"
      }
    ];
  },
  renderHTML({ node: e, HTMLAttributes: t }) {
    var r, s2, a2;
    const n = Vt(
      this.name,
      "table",
      {
        ...((r = this.options.domAttributes) == null ? void 0 : r.blockContent) || {},
        ...t
      },
      ((s2 = this.options.domAttributes) == null ? void 0 : s2.inlineContent) || {}
    ), o = document.createElement("colgroup");
    for (const i2 of e.children[0].children)
      if (i2.attrs.colwidth)
        for (const l2 of i2.attrs.colwidth) {
          const d = document.createElement("col");
          l2 && (d.style = `width: ${l2}px`), o.appendChild(d);
        }
      else
        o.appendChild(document.createElement("col"));
    return (a2 = n.dom.firstChild) == null || a2.appendChild(o), n;
  },
  // This node view is needed for the `columnResizing` plugin. By default, the
  // plugin adds its own node view, which overrides how the node is rendered vs
  // `renderHTML`. This means that the wrapping `blockContent` HTML element is
  // no longer rendered. The `columnResizing` plugin uses the `TableView` as its
  // default node view. `BlockNoteTableView` extends it by wrapping it in a
  // `blockContent` element, so the DOM structure is consistent with other block
  // types.
  addNodeView() {
    return ({ node: e, HTMLAttributes: t }) => {
      var o;
      class n extends TableView {
        constructor(s2, a2, i2) {
          super(s2, a2), this.node = s2, this.cellMinWidth = a2, this.blockContentHTMLAttributes = i2;
          const c = document.createElement("div");
          c.className = U(
            "bn-block-content",
            i2.class
          ), c.setAttribute("data-content-type", "table");
          for (const [p5, f2] of Object.entries(
            i2
          ))
            p5 !== "class" && c.setAttribute(p5, f2);
          const l2 = this.dom, d = document.createElement("div");
          d.className = "tableWrapper-inner", d.appendChild(l2.firstChild), l2.appendChild(d), c.appendChild(l2);
          const u = document.createElement("div");
          u.className = "table-widgets-container", u.style.position = "relative", l2.appendChild(u), this.dom = c;
        }
        ignoreMutation(s2) {
          return !s2.target.closest(".tableWrapper-inner") || super.ignoreMutation(s2);
        }
      }
      return new n(e, ut, {
        ...((o = this.options.domAttributes) == null ? void 0 : o.blockContent) || {},
        ...t
      });
    };
  }
});
var uo = Node3.create({
  name: "tableParagraph",
  group: "tableContent",
  content: "inline*",
  parseHTML() {
    return [
      {
        tag: "p",
        getAttrs: (e) => {
          if (typeof e == "string" || !e.textContent || !e.closest("[data-content-type]"))
            return false;
          const t = e.parentElement;
          return t === null ? false : t.tagName === "TD" || t.tagName === "TH" ? {} : false;
        },
        node: "tableParagraph"
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["p", e, 0];
  }
});
var po = Node3.create({
  name: "tableRow",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "(tableCell | tableHeader)+",
  tableRole: "row",
  marks: "deletion insertion modification",
  parseHTML() {
    return [{ tag: "tr" }];
  },
  renderHTML({ HTMLAttributes: e }) {
    return [
      "tr",
      mergeAttributes(this.options.HTMLAttributes, e),
      0
    ];
  }
});
function dt(e, t) {
  const o = DOMParser2.fromSchema(t).parse(e, {
    topNode: t.nodes.blockGroup.create()
  }), r = [];
  return o.content.descendants((s2) => {
    if (s2.isInline)
      return r.push(s2), false;
  }), Fragment.fromArray(r);
}
var fo = () => jt(
  { node: lo, type: "table", content: "table" },
  ao,
  [
    L({
      key: "table-extensions",
      tiptapExtensions: [
        so,
        uo,
        io,
        co,
        po
      ]
    }),
    // Extension for keyboard shortcut which deletes the table if it's empty
    // and all cells are selected. Uses a separate extension as it needs
    // priority over keyboard handlers in the `TableExtension`'s
    // `tableEditing` plugin.
    L({
      key: "table-keyboard-delete",
      keyboardShortcuts: {
        Backspace: ({ editor: e }) => {
          if (!(e.prosemirrorState.selection instanceof CellSelection))
            return false;
          const t = e.getTextCursorPosition().block, n = t.content;
          let o = 0;
          for (const s2 of n.rows)
            for (const a2 of s2.cells) {
              if ("type" in a2 && a2.content.length > 0 || !("type" in a2) && a2.length > 0)
                return false;
              o++;
            }
          let r = 0;
          return e.prosemirrorState.selection.forEachCell(() => {
            r++;
          }), r < o ? false : (e.transact(() => {
            (e.getPrevBlock(t) || e.getNextBlock(t)) && e.setTextCursorPosition(t), e.removeBlocks([t]);
          }), true);
        }
      }
    })
  ]
);
var Ve = (e) => {
  const t = e.src || void 0, n = e.width || void 0;
  return { url: t, previewWidth: n };
};
var ho = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M2 3.9934C2 3.44476 2.45531 3 2.9918 3H21.0082C21.556 3 22 3.44495 22 3.9934V20.0066C22 20.5552 21.5447 21 21.0082 21H2.9918C2.44405 21 2 20.5551 2 20.0066V3.9934ZM8 5V19H16V5H8ZM4 5V7H6V5H4ZM18 5V7H20V5H18ZM4 9V11H6V9H4ZM18 9V11H20V9H18ZM4 13V15H6V13H4ZM18 13V15H20V13H18ZM4 17V19H6V17H4ZM18 17V19H20V17H18Z"></path></svg>';
var mo = (e) => ({
  type: "video",
  propSchema: {
    textAlignment: C.textAlignment,
    backgroundColor: C.backgroundColor,
    name: { default: "" },
    url: { default: "" },
    caption: { default: "" },
    showPreview: { default: true },
    previewWidth: { default: void 0, type: "number" }
  },
  content: "none"
});
var go = (e) => (t) => {
  if (t.tagName === "VIDEO") {
    if (t.closest("figure"))
      return;
    const { backgroundColor: n } = B(t);
    return {
      ...Ve(t),
      backgroundColor: n
    };
  }
  if (t.tagName === "FIGURE") {
    const n = ee(t, "video");
    if (!n)
      return;
    const { targetElement: o, caption: r } = n, { backgroundColor: s2 } = B(t);
    return {
      ...Ve(o),
      backgroundColor: s2,
      caption: r
    };
  }
};
var bo = M(
  mo,
  (e) => ({
    meta: {
      fileBlockAccept: ["video/*"]
    },
    parse: go(),
    render(t, n) {
      const o = document.createElement("div");
      o.innerHTML = e.icon ?? ho;
      const r = document.createElement("div");
      r.className = "bn-visual-media-wrapper";
      const s2 = document.createElement("video");
      return s2.className = "bn-visual-media", n.resolveFileUrl ? n.resolveFileUrl(t.props.url).then((a2) => {
        s2.src = a2;
      }) : s2.src = t.props.url, s2.controls = true, s2.contentEditable = "false", s2.draggable = false, s2.width = t.props.previewWidth, r.appendChild(s2), it(
        t,
        n,
        { dom: r },
        r,
        o.firstElementChild
      );
    },
    toExternalHTML(t) {
      if (!t.props.url) {
        const o = document.createElement("p");
        return o.textContent = "Add video", {
          dom: o
        };
      }
      let n;
      return t.props.showPreview ? (n = document.createElement("video"), n.src = t.props.url, t.props.previewWidth && (n.width = t.props.previewWidth)) : (n = document.createElement("a"), n.href = t.props.url, n.textContent = t.props.name || t.props.url), t.props.caption ? t.props.showPreview ? ve(n, t.props.caption) : te(n, t.props.caption) : {
        dom: n
      };
    },
    runsBefore: ["file"]
  })
);
function E(e, t, n) {
  if (!(t in e.schema.blockSpecs))
    return false;
  if (!n)
    return true;
  for (const [o, r] of Object.entries(n)) {
    if (!(o in e.schema.blockSpecs[t].config.propSchema))
      return false;
    if (typeof r == "string") {
      if (e.schema.blockSpecs[t].config.propSchema[o].default && typeof e.schema.blockSpecs[t].config.propSchema[o].default !== r || e.schema.blockSpecs[t].config.propSchema[o].type && e.schema.blockSpecs[t].config.propSchema[o].type !== r)
        return false;
    } else {
      if (e.schema.blockSpecs[t].config.propSchema[o].default !== r.default || e.schema.blockSpecs[t].config.propSchema[o].default === void 0 && r.default === void 0 && e.schema.blockSpecs[t].config.propSchema[o].type !== r.type || typeof e.schema.blockSpecs[t].config.propSchema[o].values != typeof r.values)
        return false;
      if (typeof e.schema.blockSpecs[t].config.propSchema[o].values == "object" && typeof r.values == "object") {
        if (e.schema.blockSpecs[t].config.propSchema[o].values.length !== r.values.length)
          return false;
        for (let s2 = 0; s2 < e.schema.blockSpecs[t].config.propSchema[o].values.length; s2++)
          if (e.schema.blockSpecs[t].config.propSchema[o].values[s2] !== r.values[s2])
            return false;
      }
    }
  }
  return true;
}
function pr(e, t, n, o) {
  return E(t, n, o) && e.type === n;
}
function fr(e) {
  return e instanceof CellSelection;
}
function ko(e) {
  let t = e.getTextCursorPosition().block, n = e.schema.blockSchema[t.type].content;
  for (; n === "none"; ) {
    if (t = e.getTextCursorPosition().nextBlock, t === void 0)
      return;
    n = e.schema.blockSchema[t.type].content, e.setTextCursorPosition(t, "end");
  }
}
function w(e, t) {
  const n = e.getTextCursorPosition().block;
  if (n.content === void 0)
    throw new Error("Slash Menu open in a block that doesn't contain content.");
  let o;
  return Array.isArray(n.content) && (n.content.length === 1 && I(n.content[0]) && n.content[0].type === "text" && n.content[0].text === "/" || n.content.length === 0) ? (o = e.updateBlock(n, t), e.setTextCursorPosition(o)) : (o = e.insertBlocks([t], n, "after")[0], e.setTextCursorPosition(e.getTextCursorPosition().nextBlock)), ko(e), o;
}
function hr(e) {
  const t = [];
  return E(e, "heading", { level: "number" }) && t.push(
    {
      onItemClick: () => {
        w(e, {
          type: "heading",
          props: { level: 1 }
        });
      },
      badge: T("Mod-Alt-1"),
      key: "heading",
      ...e.dictionary.slash_menu.heading
    },
    {
      onItemClick: () => {
        w(e, {
          type: "heading",
          props: { level: 2 }
        });
      },
      badge: T("Mod-Alt-2"),
      key: "heading_2",
      ...e.dictionary.slash_menu.heading_2
    },
    {
      onItemClick: () => {
        w(e, {
          type: "heading",
          props: { level: 3 }
        });
      },
      badge: T("Mod-Alt-3"),
      key: "heading_3",
      ...e.dictionary.slash_menu.heading_3
    }
  ), E(e, "quote") && t.push({
    onItemClick: () => {
      w(e, {
        type: "quote"
      });
    },
    key: "quote",
    ...e.dictionary.slash_menu.quote
  }), E(e, "toggleListItem") && t.push({
    onItemClick: () => {
      w(e, {
        type: "toggleListItem"
      });
    },
    badge: T("Mod-Shift-6"),
    key: "toggle_list",
    ...e.dictionary.slash_menu.toggle_list
  }), E(e, "numberedListItem") && t.push({
    onItemClick: () => {
      w(e, {
        type: "numberedListItem"
      });
    },
    badge: T("Mod-Shift-7"),
    key: "numbered_list",
    ...e.dictionary.slash_menu.numbered_list
  }), E(e, "bulletListItem") && t.push({
    onItemClick: () => {
      w(e, {
        type: "bulletListItem"
      });
    },
    badge: T("Mod-Shift-8"),
    key: "bullet_list",
    ...e.dictionary.slash_menu.bullet_list
  }), E(e, "checkListItem") && t.push({
    onItemClick: () => {
      w(e, {
        type: "checkListItem"
      });
    },
    badge: T("Mod-Shift-9"),
    key: "check_list",
    ...e.dictionary.slash_menu.check_list
  }), E(e, "paragraph") && t.push({
    onItemClick: () => {
      w(e, {
        type: "paragraph"
      });
    },
    badge: T("Mod-Alt-0"),
    key: "paragraph",
    ...e.dictionary.slash_menu.paragraph
  }), E(e, "codeBlock") && t.push({
    onItemClick: () => {
      w(e, {
        type: "codeBlock"
      });
    },
    badge: T("Mod-Alt-c"),
    key: "code_block",
    ...e.dictionary.slash_menu.code_block
  }), E(e, "divider") && t.push({
    onItemClick: () => {
      w(e, { type: "divider" });
    },
    key: "divider",
    ...e.dictionary.slash_menu.divider
  }), E(e, "table") && t.push({
    onItemClick: () => {
      w(e, {
        type: "table",
        content: {
          type: "tableContent",
          rows: [
            {
              cells: ["", "", ""]
            },
            {
              cells: ["", "", ""]
            }
          ]
        }
      });
    },
    badge: void 0,
    key: "table",
    ...e.dictionary.slash_menu.table
  }), E(e, "image", { url: "string" }) && t.push({
    onItemClick: () => {
      const n = w(e, {
        type: "image"
      });
      e.transact(
        (o) => o.setMeta(e.filePanel.plugins[0], {
          block: n
        })
      );
    },
    key: "image",
    ...e.dictionary.slash_menu.image
  }), E(e, "video", { url: "string" }) && t.push({
    onItemClick: () => {
      const n = w(e, {
        type: "video"
      });
      e.transact(
        (o) => o.setMeta(e.filePanel.plugins[0], {
          block: n
        })
      );
    },
    key: "video",
    ...e.dictionary.slash_menu.video
  }), E(e, "audio", { url: "string" }) && t.push({
    onItemClick: () => {
      const n = w(e, {
        type: "audio"
      });
      e.transact(
        (o) => o.setMeta(e.filePanel.plugins[0], {
          block: n
        })
      );
    },
    key: "audio",
    ...e.dictionary.slash_menu.audio
  }), E(e, "file", { url: "string" }) && t.push({
    onItemClick: () => {
      const n = w(e, {
        type: "file"
      });
      e.transact(
        (o) => o.setMeta(e.filePanel.plugins[0], {
          block: n
        })
      );
    },
    key: "file",
    ...e.dictionary.slash_menu.file
  }), E(e, "heading", {
    level: "number",
    isToggleable: "boolean"
  }) && t.push(
    {
      onItemClick: () => {
        w(e, {
          type: "heading",
          props: { level: 1, isToggleable: true }
        });
      },
      key: "toggle_heading",
      ...e.dictionary.slash_menu.toggle_heading
    },
    {
      onItemClick: () => {
        w(e, {
          type: "heading",
          props: { level: 2, isToggleable: true }
        });
      },
      key: "toggle_heading_2",
      ...e.dictionary.slash_menu.toggle_heading_2
    },
    {
      onItemClick: () => {
        w(e, {
          type: "heading",
          props: { level: 3, isToggleable: true }
        });
      },
      key: "toggle_heading_3",
      ...e.dictionary.slash_menu.toggle_heading_3
    }
  ), E(e, "heading", { level: "number" }) && (e.schema.blockSchema.heading.propSchema.level.values || []).filter((n) => n > 3).forEach((n) => {
    t.push({
      onItemClick: () => {
        w(e, {
          type: "heading",
          props: { level: n }
        });
      },
      key: `heading_${n}`,
      ...e.dictionary.slash_menu[`heading_${n}`]
    });
  }), t.push({
    onItemClick: () => {
      e.openSuggestionMenu(":", {
        deleteTriggerCharacter: true,
        ignoreQueryLength: true
      });
    },
    key: "emoji",
    ...e.dictionary.slash_menu.emoji
  }), t;
}
function mr(e, t) {
  return e.filter(
    ({ title: n, aliases: o }) => n.toLowerCase().includes(t.toLowerCase()) || o && o.filter(
      (r) => r.toLowerCase().includes(t.toLowerCase())
    ).length !== 0
  );
}
function Co(e) {
  return "pageBreak" in e.schema.blockSchema;
}
function gr(e) {
  const t = [];
  return Co(e) && t.push({
    ...e.dictionary.slash_menu.page_break,
    onItemClick: () => {
      w(e, {
        type: "pageBreak"
      });
    },
    key: "page_break"
  }), t;
}
var yo = {
  audio: En(),
  bulletListItem: Un(),
  checkListItem: qn(),
  codeBlock: Ln(),
  divider: An(),
  file: Pn(),
  heading: Dn(),
  image: $n(),
  numberedListItem: Xn(),
  paragraph: to(),
  quote: oo(),
  table: fo(),
  toggleListItem: Kn(),
  video: bo()
};
var wo = Ye(
  {
    type: "textColor",
    propSchema: "string"
  },
  {
    render: () => {
      const e = document.createElement("span");
      return {
        dom: e,
        contentDOM: e
      };
    },
    toExternalHTML: (e) => {
      const t = document.createElement("span");
      return e !== C.textColor.default && (t.style.color = e in A ? A[e].text : e), {
        dom: t,
        contentDOM: t
      };
    },
    parse: (e) => {
      if (e.tagName === "SPAN" && e.style.color)
        return e.style.color;
    }
  }
);
var vo = Ye(
  {
    type: "backgroundColor",
    propSchema: "string"
  },
  {
    render: () => {
      const e = document.createElement("span");
      return {
        dom: e,
        contentDOM: e
      };
    },
    toExternalHTML: (e) => {
      const t = document.createElement("span");
      return e !== C.backgroundColor.default && (t.style.backgroundColor = e in A ? A[e].background : e), {
        dom: t,
        contentDOM: t
      };
    },
    parse: (e) => {
      if (e.tagName === "SPAN" && e.style.backgroundColor)
        return e.style.backgroundColor;
    }
  }
);
var pt = {
  bold: F(index_default, "boolean"),
  italic: F(index_default3, "boolean"),
  underline: F(index_default5, "boolean"),
  strike: F(index_default4, "boolean"),
  code: F(index_default2, "boolean"),
  textColor: wo,
  backgroundColor: vo
};
var br = Qe(pt);
var ft = {
  text: { config: "text", implementation: {} },
  link: { config: "link", implementation: {} }
};
var kr = Je(
  ft
);
var ht = class _ht extends sn {
  static create(t) {
    return new _ht({
      blockSpecs: (t == null ? void 0 : t.blockSpecs) ?? yo,
      inlineContentSpecs: (t == null ? void 0 : t.inlineContentSpecs) ?? ft,
      styleSpecs: (t == null ? void 0 : t.styleSpecs) ?? pt
    });
  }
};

// ../node_modules/.pnpm/@blocknote+core@0.41.1_@tip_88da0e2ca7990b1ebffff41010f54baa/node_modules/@blocknote/core/dist/blocknote.js
var import_fast_deep_equal = __toESM(require_fast_deep_equal());

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/map.js
var create = () => /* @__PURE__ */ new Map();
var copy = (m) => {
  const r = create();
  m.forEach((v2, k2) => {
    r.set(k2, v2);
  });
  return r;
};
var setIfUndefined = (map6, key2, createT) => {
  let set = map6.get(key2);
  if (set === void 0) {
    map6.set(key2, set = createT());
  }
  return set;
};
var map = (m, f2) => {
  const res = [];
  for (const [key2, value] of m) {
    res.push(f2(value, key2));
  }
  return res;
};
var any = (m, f2) => {
  for (const [key2, value] of m) {
    if (f2(value, key2)) {
      return true;
    }
  }
  return false;
};

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/set.js
var create2 = () => /* @__PURE__ */ new Set();

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/array.js
var last = (arr) => arr[arr.length - 1];
var appendTo = (dest, src) => {
  for (let i2 = 0; i2 < src.length; i2++) {
    dest.push(src[i2]);
  }
};
var from2 = Array.from;
var some = (arr, f2) => {
  for (let i2 = 0; i2 < arr.length; i2++) {
    if (f2(arr[i2], i2, arr)) {
      return true;
    }
  }
  return false;
};
var isArray = Array.isArray;

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/observable.js
var ObservableV2 = class {
  constructor() {
    this._observers = create();
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  on(name, f2) {
    setIfUndefined(
      this._observers,
      /** @type {string} */
      name,
      create2
    ).add(f2);
    return f2;
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  once(name, f2) {
    const _f = (...args2) => {
      this.off(
        name,
        /** @type {any} */
        _f
      );
      f2(...args2);
    };
    this.on(
      name,
      /** @type {any} */
      _f
    );
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  off(name, f2) {
    const observers = this._observers.get(name);
    if (observers !== void 0) {
      observers.delete(f2);
      if (observers.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name The event name.
   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
   */
  emit(name, args2) {
    return from2((this._observers.get(name) || create()).values()).forEach((f2) => f2(...args2));
  }
  destroy() {
    this._observers = create();
  }
};

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/math.js
var floor2 = Math.floor;
var abs = Math.abs;
var min2 = (a2, b2) => a2 < b2 ? a2 : b2;
var max2 = (a2, b2) => a2 > b2 ? a2 : b2;
var isNaN2 = Number.isNaN;
var isNegativeZero = (n) => n !== 0 ? n < 0 : 1 / n < 0;

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/binary.js
var BIT1 = 1;
var BIT2 = 2;
var BIT3 = 4;
var BIT4 = 8;
var BIT6 = 32;
var BIT7 = 64;
var BIT8 = 128;
var BIT18 = 1 << 17;
var BIT19 = 1 << 18;
var BIT20 = 1 << 19;
var BIT21 = 1 << 20;
var BIT22 = 1 << 21;
var BIT23 = 1 << 22;
var BIT24 = 1 << 23;
var BIT25 = 1 << 24;
var BIT26 = 1 << 25;
var BIT27 = 1 << 26;
var BIT28 = 1 << 27;
var BIT29 = 1 << 28;
var BIT30 = 1 << 29;
var BIT31 = 1 << 30;
var BIT32 = 1 << 31;
var BITS5 = 31;
var BITS6 = 63;
var BITS7 = 127;
var BITS17 = BIT18 - 1;
var BITS18 = BIT19 - 1;
var BITS19 = BIT20 - 1;
var BITS20 = BIT21 - 1;
var BITS21 = BIT22 - 1;
var BITS22 = BIT23 - 1;
var BITS23 = BIT24 - 1;
var BITS24 = BIT25 - 1;
var BITS25 = BIT26 - 1;
var BITS26 = BIT27 - 1;
var BITS27 = BIT28 - 1;
var BITS28 = BIT29 - 1;
var BITS29 = BIT30 - 1;
var BITS30 = BIT31 - 1;
var BITS31 = 2147483647;

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/number.js
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;
var LOWEST_INT32 = 1 << 31;
var isInteger = Number.isInteger || ((num) => typeof num === "number" && isFinite(num) && floor2(num) === num);
var isNaN3 = Number.isNaN;
var parseInt2 = Number.parseInt;

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/string.js
var fromCharCode = String.fromCharCode;
var fromCodePoint = String.fromCodePoint;
var MAX_UTF16_CHARACTER = fromCharCode(65535);
var toLowerCase = (s2) => s2.toLowerCase();
var trimLeftRegex = /^\s*/g;
var trimLeft = (s2) => s2.replace(trimLeftRegex, "");
var fromCamelCaseRegex = /([A-Z])/g;
var fromCamelCase = (s2, separator) => trimLeft(s2.replace(fromCamelCaseRegex, (match) => `${separator}${toLowerCase(match)}`));
var _encodeUtf8Polyfill = (str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  const buf = new Uint8Array(len);
  for (let i2 = 0; i2 < len; i2++) {
    buf[i2] = /** @type {number} */
    encodedString.codePointAt(i2);
  }
  return buf;
};
var utf8TextEncoder = (
  /** @type {TextEncoder} */
  typeof TextEncoder !== "undefined" ? new TextEncoder() : null
);
var _encodeUtf8Native = (str) => utf8TextEncoder.encode(str);
var encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;
var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {
  utf8TextDecoder = null;
}

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/encoding.js
var Encoder = class {
  constructor() {
    this.cpos = 0;
    this.cbuf = new Uint8Array(100);
    this.bufs = [];
  }
};
var createEncoder = () => new Encoder();
var encode = (f2) => {
  const encoder = createEncoder();
  f2(encoder);
  return toUint8Array(encoder);
};
var length = (encoder) => {
  let len = encoder.cpos;
  for (let i2 = 0; i2 < encoder.bufs.length; i2++) {
    len += encoder.bufs[i2].length;
  }
  return len;
};
var toUint8Array = (encoder) => {
  const uint8arr = new Uint8Array(length(encoder));
  let curPos = 0;
  for (let i2 = 0; i2 < encoder.bufs.length; i2++) {
    const d = encoder.bufs[i2];
    uint8arr.set(d, curPos);
    curPos += d.length;
  }
  uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);
  return uint8arr;
};
var verifyLen = (encoder, len) => {
  const bufferLen = encoder.cbuf.length;
  if (bufferLen - encoder.cpos < len) {
    encoder.bufs.push(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos));
    encoder.cbuf = new Uint8Array(max2(bufferLen, len) * 2);
    encoder.cpos = 0;
  }
};
var write = (encoder, num) => {
  const bufferLen = encoder.cbuf.length;
  if (encoder.cpos === bufferLen) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(bufferLen * 2);
    encoder.cpos = 0;
  }
  encoder.cbuf[encoder.cpos++] = num;
};
var writeUint8 = write;
var writeVarUint = (encoder, num) => {
  while (num > BITS7) {
    write(encoder, BIT8 | BITS7 & num);
    num = floor2(num / 128);
  }
  write(encoder, BITS7 & num);
};
var writeVarInt = (encoder, num) => {
  const isNegative = isNegativeZero(num);
  if (isNegative) {
    num = -num;
  }
  write(encoder, (num > BITS6 ? BIT8 : 0) | (isNegative ? BIT7 : 0) | BITS6 & num);
  num = floor2(num / 64);
  while (num > 0) {
    write(encoder, (num > BITS7 ? BIT8 : 0) | BITS7 & num);
    num = floor2(num / 128);
  }
};
var _strBuffer = new Uint8Array(3e4);
var _maxStrBSize = _strBuffer.length / 3;
var _writeVarStringNative = (encoder, str) => {
  if (str.length < _maxStrBSize) {
    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;
    writeVarUint(encoder, written);
    for (let i2 = 0; i2 < written; i2++) {
      write(encoder, _strBuffer[i2]);
    }
  } else {
    writeVarUint8Array(encoder, encodeUtf8(str));
  }
};
var _writeVarStringPolyfill = (encoder, str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  writeVarUint(encoder, len);
  for (let i2 = 0; i2 < len; i2++) {
    write(
      encoder,
      /** @type {number} */
      encodedString.codePointAt(i2)
    );
  }
};
var writeVarString = utf8TextEncoder && /** @type {any} */
utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;
var writeUint8Array = (encoder, uint8Array) => {
  const bufferLen = encoder.cbuf.length;
  const cpos = encoder.cpos;
  const leftCopyLen = min2(bufferLen - cpos, uint8Array.length);
  const rightCopyLen = uint8Array.length - leftCopyLen;
  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
  encoder.cpos += leftCopyLen;
  if (rightCopyLen > 0) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(max2(bufferLen * 2, rightCopyLen));
    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
    encoder.cpos = rightCopyLen;
  }
};
var writeVarUint8Array = (encoder, uint8Array) => {
  writeVarUint(encoder, uint8Array.byteLength);
  writeUint8Array(encoder, uint8Array);
};
var writeOnDataView = (encoder, len) => {
  verifyLen(encoder, len);
  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);
  encoder.cpos += len;
  return dview;
};
var writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false);
var writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false);
var writeBigInt64 = (encoder, num) => (
  /** @type {any} */
  writeOnDataView(encoder, 8).setBigInt64(0, num, false)
);
var floatTestBed = new DataView(new ArrayBuffer(4));
var isFloat32 = (num) => {
  floatTestBed.setFloat32(0, num);
  return floatTestBed.getFloat32(0) === num;
};
var writeAny = (encoder, data) => {
  switch (typeof data) {
    case "string":
      write(encoder, 119);
      writeVarString(encoder, data);
      break;
    case "number":
      if (isInteger(data) && abs(data) <= BITS31) {
        write(encoder, 125);
        writeVarInt(encoder, data);
      } else if (isFloat32(data)) {
        write(encoder, 124);
        writeFloat32(encoder, data);
      } else {
        write(encoder, 123);
        writeFloat64(encoder, data);
      }
      break;
    case "bigint":
      write(encoder, 122);
      writeBigInt64(encoder, data);
      break;
    case "object":
      if (data === null) {
        write(encoder, 126);
      } else if (isArray(data)) {
        write(encoder, 117);
        writeVarUint(encoder, data.length);
        for (let i2 = 0; i2 < data.length; i2++) {
          writeAny(encoder, data[i2]);
        }
      } else if (data instanceof Uint8Array) {
        write(encoder, 116);
        writeVarUint8Array(encoder, data);
      } else {
        write(encoder, 118);
        const keys3 = Object.keys(data);
        writeVarUint(encoder, keys3.length);
        for (let i2 = 0; i2 < keys3.length; i2++) {
          const key2 = keys3[i2];
          writeVarString(encoder, key2);
          writeAny(encoder, data[key2]);
        }
      }
      break;
    case "boolean":
      write(encoder, data ? 120 : 121);
      break;
    default:
      write(encoder, 127);
  }
};
var RleEncoder = class extends Encoder {
  /**
   * @param {function(Encoder, T):void} writer
   */
  constructor(writer) {
    super();
    this.w = writer;
    this.s = null;
    this.count = 0;
  }
  /**
   * @param {T} v
   */
  write(v2) {
    if (this.s === v2) {
      this.count++;
    } else {
      if (this.count > 0) {
        writeVarUint(this, this.count - 1);
      }
      this.count = 1;
      this.w(this, v2);
      this.s = v2;
    }
  }
};
var flushUintOptRleEncoder = (encoder) => {
  if (encoder.count > 0) {
    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);
    if (encoder.count > 1) {
      writeVarUint(encoder.encoder, encoder.count - 2);
    }
  }
};
var UintOptRleEncoder = class {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
  }
  /**
   * @param {number} v
   */
  write(v2) {
    if (this.s === v2) {
      this.count++;
    } else {
      flushUintOptRleEncoder(this);
      this.count = 1;
      this.s = v2;
    }
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    flushUintOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
};
var flushIntDiffOptRleEncoder = (encoder) => {
  if (encoder.count > 0) {
    const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1);
    writeVarInt(encoder.encoder, encodedDiff);
    if (encoder.count > 1) {
      writeVarUint(encoder.encoder, encoder.count - 2);
    }
  }
};
var IntDiffOptRleEncoder = class {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  /**
   * @param {number} v
   */
  write(v2) {
    if (this.diff === v2 - this.s) {
      this.s = v2;
      this.count++;
    } else {
      flushIntDiffOptRleEncoder(this);
      this.count = 1;
      this.diff = v2 - this.s;
      this.s = v2;
    }
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    flushIntDiffOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
};
var StringEncoder = class {
  constructor() {
    this.sarr = [];
    this.s = "";
    this.lensE = new UintOptRleEncoder();
  }
  /**
   * @param {string} string
   */
  write(string3) {
    this.s += string3;
    if (this.s.length > 19) {
      this.sarr.push(this.s);
      this.s = "";
    }
    this.lensE.write(string3.length);
  }
  toUint8Array() {
    const encoder = new Encoder();
    this.sarr.push(this.s);
    this.s = "";
    writeVarString(encoder, this.sarr.join(""));
    writeUint8Array(encoder, this.lensE.toUint8Array());
    return toUint8Array(encoder);
  }
};

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/error.js
var create3 = (s2) => new Error(s2);
var methodUnimplemented = () => {
  throw create3("Method unimplemented");
};
var unexpectedCase = () => {
  throw create3("Unexpected case");
};

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/decoding.js
var errorUnexpectedEndOfArray = create3("Unexpected end of array");
var errorIntegerOutOfRange = create3("Integer out of Range");
var Decoder = class {
  /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */
  constructor(uint8Array) {
    this.arr = uint8Array;
    this.pos = 0;
  }
};
var createDecoder = (uint8Array) => new Decoder(uint8Array);
var hasContent = (decoder) => decoder.pos !== decoder.arr.length;
var readUint8Array = (decoder, len) => {
  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);
  decoder.pos += len;
  return view;
};
var readVarUint8Array = (decoder) => readUint8Array(decoder, readVarUint(decoder));
var readUint8 = (decoder) => decoder.arr[decoder.pos++];
var readVarUint = (decoder) => {
  let num = 0;
  let mult = 1;
  const len = decoder.arr.length;
  while (decoder.pos < len) {
    const r = decoder.arr[decoder.pos++];
    num = num + (r & BITS7) * mult;
    mult *= 128;
    if (r < BIT8) {
      return num;
    }
    if (num > MAX_SAFE_INTEGER) {
      throw errorIntegerOutOfRange;
    }
  }
  throw errorUnexpectedEndOfArray;
};
var readVarInt = (decoder) => {
  let r = decoder.arr[decoder.pos++];
  let num = r & BITS6;
  let mult = 64;
  const sign = (r & BIT7) > 0 ? -1 : 1;
  if ((r & BIT8) === 0) {
    return sign * num;
  }
  const len = decoder.arr.length;
  while (decoder.pos < len) {
    r = decoder.arr[decoder.pos++];
    num = num + (r & BITS7) * mult;
    mult *= 128;
    if (r < BIT8) {
      return sign * num;
    }
    if (num > MAX_SAFE_INTEGER) {
      throw errorIntegerOutOfRange;
    }
  }
  throw errorUnexpectedEndOfArray;
};
var _readVarStringPolyfill = (decoder) => {
  let remainingLen = readVarUint(decoder);
  if (remainingLen === 0) {
    return "";
  } else {
    let encodedString = String.fromCodePoint(readUint8(decoder));
    if (--remainingLen < 100) {
      while (remainingLen--) {
        encodedString += String.fromCodePoint(readUint8(decoder));
      }
    } else {
      while (remainingLen > 0) {
        const nextLen = remainingLen < 1e4 ? remainingLen : 1e4;
        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);
        decoder.pos += nextLen;
        encodedString += String.fromCodePoint.apply(
          null,
          /** @type {any} */
          bytes
        );
        remainingLen -= nextLen;
      }
    }
    return decodeURIComponent(escape(encodedString));
  }
};
var _readVarStringNative = (decoder) => (
  /** @type any */
  utf8TextDecoder.decode(readVarUint8Array(decoder))
);
var readVarString = utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;
var readFromDataView = (decoder, len) => {
  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len);
  decoder.pos += len;
  return dv;
};
var readFloat32 = (decoder) => readFromDataView(decoder, 4).getFloat32(0, false);
var readFloat64 = (decoder) => readFromDataView(decoder, 8).getFloat64(0, false);
var readBigInt64 = (decoder) => (
  /** @type {any} */
  readFromDataView(decoder, 8).getBigInt64(0, false)
);
var readAnyLookupTable = [
  (decoder) => void 0,
  // CASE 127: undefined
  (decoder) => null,
  // CASE 126: null
  readVarInt,
  // CASE 125: integer
  readFloat32,
  // CASE 124: float32
  readFloat64,
  // CASE 123: float64
  readBigInt64,
  // CASE 122: bigint
  (decoder) => false,
  // CASE 121: boolean (false)
  (decoder) => true,
  // CASE 120: boolean (true)
  readVarString,
  // CASE 119: string
  (decoder) => {
    const len = readVarUint(decoder);
    const obj = {};
    for (let i2 = 0; i2 < len; i2++) {
      const key2 = readVarString(decoder);
      obj[key2] = readAny(decoder);
    }
    return obj;
  },
  (decoder) => {
    const len = readVarUint(decoder);
    const arr = [];
    for (let i2 = 0; i2 < len; i2++) {
      arr.push(readAny(decoder));
    }
    return arr;
  },
  readVarUint8Array
  // CASE 116: Uint8Array
];
var readAny = (decoder) => readAnyLookupTable[127 - readUint8(decoder)](decoder);
var RleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   * @param {function(Decoder):T} reader
   */
  constructor(uint8Array, reader) {
    super(uint8Array);
    this.reader = reader;
    this.s = null;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = this.reader(this);
      if (hasContent(this)) {
        this.count = readVarUint(this) + 1;
      } else {
        this.count = -1;
      }
    }
    this.count--;
    return (
      /** @type {T} */
      this.s
    );
  }
};
var UintOptRleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = readVarInt(this);
      const isNegative = isNegativeZero(this.s);
      this.count = 1;
      if (isNegative) {
        this.s = -this.s;
        this.count = readVarUint(this) + 2;
      }
    }
    this.count--;
    return (
      /** @type {number} */
      this.s
    );
  }
};
var IntDiffOptRleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  /**
   * @return {number}
   */
  read() {
    if (this.count === 0) {
      const diff = readVarInt(this);
      const hasCount = diff & 1;
      this.diff = floor2(diff / 2);
      this.count = 1;
      if (hasCount) {
        this.count = readVarUint(this) + 2;
      }
    }
    this.s += this.diff;
    this.count--;
    return this.s;
  }
};
var StringDecoder = class {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    this.decoder = new UintOptRleDecoder(uint8Array);
    this.str = readVarString(this.decoder);
    this.spos = 0;
  }
  /**
   * @return {string}
   */
  read() {
    const end = this.spos + this.decoder.read();
    const res = this.str.slice(this.spos, end);
    this.spos = end;
    return res;
  }
};

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/webcrypto.js
var subtle = crypto.subtle;
var getRandomValues2 = crypto.getRandomValues.bind(crypto);

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/random.js
var rand = Math.random;
var uint32 = () => getRandomValues2(new Uint32Array(1))[0];
var oneOf = (arr) => arr[floor2(rand() * arr.length)];
var uuidv4Template = "10000000-1000-4000-8000" + -1e11;
var uuidv4 = () => uuidv4Template.replace(
  /[018]/g,
  /** @param {number} c */
  (c) => (c ^ uint32() & 15 >> c / 4).toString(16)
);

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/time.js
var getUnixTime = Date.now;

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/promise.js
var create4 = (f2) => (
  /** @type {Promise<T>} */
  new Promise(f2)
);
var all = Promise.all.bind(Promise);

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/conditions.js
var undefinedToNull = (v2) => v2 === void 0 ? null : v2;

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/storage.js
var VarStoragePolyfill = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(key2, newValue) {
    this.map.set(key2, newValue);
  }
  /**
   * @param {string} key
   */
  getItem(key2) {
    return this.map.get(key2);
  }
};
var _localStorage = new VarStoragePolyfill();
var usePolyfill = true;
try {
  if (typeof localStorage !== "undefined" && localStorage) {
    _localStorage = localStorage;
    usePolyfill = false;
  }
} catch (e) {
}
var varStorage = _localStorage;

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/object.js
var assign = Object.assign;
var keys = Object.keys;
var forEach2 = (obj, f2) => {
  for (const key2 in obj) {
    f2(obj[key2], key2);
  }
};
var size4 = (obj) => keys(obj).length;
var isEmpty2 = (obj) => {
  for (const _k in obj) {
    return false;
  }
  return true;
};
var every = (obj, f2) => {
  for (const key2 in obj) {
    if (!f2(obj[key2], key2)) {
      return false;
    }
  }
  return true;
};
var hasProperty = (obj, key2) => Object.prototype.hasOwnProperty.call(obj, key2);
var equalFlat = (a2, b2) => a2 === b2 || size4(a2) === size4(b2) && every(a2, (val, key2) => (val !== void 0 || hasProperty(b2, key2)) && b2[key2] === val);
var freeze = Object.freeze;
var deepFreeze = (o) => {
  for (const key2 in o) {
    const c = o[key2];
    if (typeof c === "object" || typeof c === "function") {
      deepFreeze(o[key2]);
    }
  }
  return freeze(o);
};

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/traits.js
var EqualityTraitSymbol = Symbol("Equality");

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/function.js
var callAll = (fs2, args2, i2 = 0) => {
  try {
    for (; i2 < fs2.length; i2++) {
      fs2[i2](...args2);
    }
  } finally {
    if (i2 < fs2.length) {
      callAll(fs2, args2, i2 + 1);
    }
  }
};
var id = (a2) => a2;
var isOneOf = (value, options) => options.includes(value);

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/environment.js
var isNode2 = typeof process !== "undefined" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && !isNode2;
var isMac2 = typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
var params;
var args = [];
var computeParams = () => {
  if (params === void 0) {
    if (isNode2) {
      params = create();
      const pargs = process.argv;
      let currParamName = null;
      for (let i2 = 0; i2 < pargs.length; i2++) {
        const parg = pargs[i2];
        if (parg[0] === "-") {
          if (currParamName !== null) {
            params.set(currParamName, "");
          }
          currParamName = parg;
        } else {
          if (currParamName !== null) {
            params.set(currParamName, parg);
            currParamName = null;
          } else {
            args.push(parg);
          }
        }
      }
      if (currParamName !== null) {
        params.set(currParamName, "");
      }
    } else if (typeof location === "object") {
      params = create();
      (location.search || "?").slice(1).split("&").forEach((kv) => {
        if (kv.length !== 0) {
          const [key2, value] = kv.split("=");
          params.set(`--${fromCamelCase(key2, "-")}`, value);
          params.set(`-${fromCamelCase(key2, "-")}`, value);
        }
      });
    } else {
      params = create();
    }
  }
  return params;
};
var hasParam = (name) => computeParams().has(name);
var getVariable = (name) => isNode2 ? undefinedToNull(process.env[name.toUpperCase().replaceAll("-", "_")]) : undefinedToNull(varStorage.getItem(name));
var hasConf = (name) => hasParam("--" + name) || getVariable(name) !== null;
var production = hasConf("production");
var forceColor = isNode2 && isOneOf(process.env.FORCE_COLOR, ["true", "1", "2"]);
var supportsColor = forceColor || !hasParam("--no-colors") && // @todo deprecate --no-colors
!hasConf("no-color") && (!isNode2 || process.stdout.isTTY) && (!isNode2 || hasParam("--color") || getVariable("COLORTERM") !== null || (getVariable("TERM") || "").includes("color"));

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/buffer.js
var createUint8ArrayFromLen = (len) => new Uint8Array(len);
var toBase64Browser = (bytes) => {
  let s2 = "";
  for (let i2 = 0; i2 < bytes.byteLength; i2++) {
    s2 += fromCharCode(bytes[i2]);
  }
  return btoa(s2);
};
var toBase64Node = (bytes) => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString("base64");
var toBase64 = isBrowser ? toBase64Browser : toBase64Node;
var copyUint8Array = (uint8Array) => {
  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength);
  newBuf.set(uint8Array);
  return newBuf;
};
var encodeAny = (data) => encode((encoder) => writeAny(encoder, data));

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/pair.js
var Pair = class {
  /**
   * @param {L} left
   * @param {R} right
   */
  constructor(left, right) {
    this.left = left;
    this.right = right;
  }
};
var create5 = (left, right) => new Pair(left, right);

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/dom.js
var doc = (
  /** @type {Document} */
  typeof document !== "undefined" ? document : {}
);
var domParser = (
  /** @type {DOMParser} */
  typeof DOMParser !== "undefined" ? new DOMParser() : null
);
var mapToStyleString = (m) => map(m, (value, key2) => `${key2}:${value};`).join("");
var ELEMENT_NODE = doc.ELEMENT_NODE;
var TEXT_NODE = doc.TEXT_NODE;
var CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE;
var COMMENT_NODE = doc.COMMENT_NODE;
var DOCUMENT_NODE = doc.DOCUMENT_NODE;
var DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE;
var DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE;

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/eventloop.js
var createTimeoutClass = (clearFunction) => class TT {
  /**
   * @param {number} timeoutId
   */
  constructor(timeoutId) {
    this._ = timeoutId;
  }
  destroy() {
    clearFunction(this._);
  }
};
var Timeout = createTimeoutClass(clearTimeout);
var timeout = (timeout2, callback) => new Timeout(setTimeout(callback, timeout2));
var Interval = createTimeoutClass(clearInterval);
var Animation = createTimeoutClass((arg) => typeof requestAnimationFrame !== "undefined" && cancelAnimationFrame(arg));
var Idle = createTimeoutClass((arg) => typeof cancelIdleCallback !== "undefined" && cancelIdleCallback(arg));

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/symbol.js
var create6 = Symbol;

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/logging.common.js
var BOLD = create6();
var UNBOLD = create6();
var BLUE = create6();
var GREY = create6();
var GREEN = create6();
var RED = create6();
var PURPLE = create6();
var ORANGE = create6();
var UNCOLOR = create6();
var computeNoColorLoggingArgs = (args2) => {
  if (args2.length === 1 && args2[0]?.constructor === Function) {
    args2 = /** @type {Array<string|Symbol|Object|number>} */
    /** @type {[function]} */
    args2[0]();
  }
  const strBuilder = [];
  const logArgs = [];
  let i2 = 0;
  for (; i2 < args2.length; i2++) {
    const arg = args2[i2];
    if (arg === void 0) {
      break;
    } else if (arg.constructor === String || arg.constructor === Number) {
      strBuilder.push(arg);
    } else if (arg.constructor === Object) {
      break;
    }
  }
  if (i2 > 0) {
    logArgs.push(strBuilder.join(""));
  }
  for (; i2 < args2.length; i2++) {
    const arg = args2[i2];
    if (!(arg instanceof Symbol)) {
      logArgs.push(arg);
    }
  }
  return logArgs;
};
var lastLoggingTime = getUnixTime();

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/logging.js
var _browserStyleMap = {
  [BOLD]: create5("font-weight", "bold"),
  [UNBOLD]: create5("font-weight", "normal"),
  [BLUE]: create5("color", "blue"),
  [GREEN]: create5("color", "green"),
  [GREY]: create5("color", "grey"),
  [RED]: create5("color", "red"),
  [PURPLE]: create5("color", "purple"),
  [ORANGE]: create5("color", "orange"),
  // not well supported in chrome when debugging node with inspector - TODO: deprecate
  [UNCOLOR]: create5("color", "black")
};
var computeBrowserLoggingArgs = (args2) => {
  if (args2.length === 1 && args2[0]?.constructor === Function) {
    args2 = /** @type {Array<string|Symbol|Object|number>} */
    /** @type {[function]} */
    args2[0]();
  }
  const strBuilder = [];
  const styles = [];
  const currentStyle = create();
  let logArgs = [];
  let i2 = 0;
  for (; i2 < args2.length; i2++) {
    const arg = args2[i2];
    const style3 = _browserStyleMap[arg];
    if (style3 !== void 0) {
      currentStyle.set(style3.left, style3.right);
    } else {
      if (arg === void 0) {
        break;
      }
      if (arg.constructor === String || arg.constructor === Number) {
        const style4 = mapToStyleString(currentStyle);
        if (i2 > 0 || style4.length > 0) {
          strBuilder.push("%c" + arg);
          styles.push(style4);
        } else {
          strBuilder.push(arg);
        }
      } else {
        break;
      }
    }
  }
  if (i2 > 0) {
    logArgs = styles;
    logArgs.unshift(strBuilder.join(""));
  }
  for (; i2 < args2.length; i2++) {
    const arg = args2[i2];
    if (!(arg instanceof Symbol)) {
      logArgs.push(arg);
    }
  }
  return logArgs;
};
var computeLoggingArgs = supportsColor ? computeBrowserLoggingArgs : computeNoColorLoggingArgs;
var print = (...args2) => {
  console.log(...computeLoggingArgs(args2));
  vconsoles.forEach((vc) => vc.print(args2));
};
var warn2 = (...args2) => {
  console.warn(...computeLoggingArgs(args2));
  args2.unshift(ORANGE);
  vconsoles.forEach((vc) => vc.print(args2));
};
var vconsoles = create2();

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/iterator.js
var createIterator = (next2) => ({
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return this;
  },
  // @ts-ignore
  next: next2
});
var iteratorFilter = (iterator, filter) => createIterator(() => {
  let res;
  do {
    res = iterator.next();
  } while (!res.done && !filter(res.value));
  return res;
});
var iteratorMap = (iterator, fmap) => createIterator(() => {
  const { done, value } = iterator.next();
  return { done, value: done ? void 0 : fmap(value) };
});

// ../node_modules/.pnpm/yjs@13.6.27/node_modules/yjs/dist/yjs.mjs
var DeleteItem = class {
  /**
   * @param {number} clock
   * @param {number} len
   */
  constructor(clock, len) {
    this.clock = clock;
    this.len = len;
  }
};
var DeleteSet = class {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
};
var iterateDeletedStructs = (transaction, ds2, f2) => ds2.clients.forEach((deletes, clientid) => {
  const structs = (
    /** @type {Array<GC|Item>} */
    transaction.doc.store.clients.get(clientid)
  );
  if (structs != null) {
    const lastStruct = structs[structs.length - 1];
    const clockState = lastStruct.id.clock + lastStruct.length;
    for (let i2 = 0, del2 = deletes[i2]; i2 < deletes.length && del2.clock < clockState; del2 = deletes[++i2]) {
      iterateStructs(transaction, structs, del2.clock, del2.len, f2);
    }
  }
});
var findIndexDS = (dis, clock) => {
  let left = 0;
  let right = dis.length - 1;
  while (left <= right) {
    const midindex = floor2((left + right) / 2);
    const mid = dis[midindex];
    const midclock = mid.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.len) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
  }
  return null;
};
var isDeleted = (ds2, id2) => {
  const dis = ds2.clients.get(id2.client);
  return dis !== void 0 && findIndexDS(dis, id2.clock) !== null;
};
var sortAndMergeDeleteSet = (ds2) => {
  ds2.clients.forEach((dels) => {
    dels.sort((a2, b2) => a2.clock - b2.clock);
    let i2, j5;
    for (i2 = 1, j5 = 1; i2 < dels.length; i2++) {
      const left = dels[j5 - 1];
      const right = dels[i2];
      if (left.clock + left.len >= right.clock) {
        left.len = max2(left.len, right.clock + right.len - left.clock);
      } else {
        if (j5 < i2) {
          dels[j5] = right;
        }
        j5++;
      }
    }
    dels.length = j5;
  });
};
var mergeDeleteSets = (dss) => {
  const merged = new DeleteSet();
  for (let dssI = 0; dssI < dss.length; dssI++) {
    dss[dssI].clients.forEach((delsLeft, client) => {
      if (!merged.clients.has(client)) {
        const dels = delsLeft.slice();
        for (let i2 = dssI + 1; i2 < dss.length; i2++) {
          appendTo(dels, dss[i2].clients.get(client) || []);
        }
        merged.clients.set(client, dels);
      }
    });
  }
  sortAndMergeDeleteSet(merged);
  return merged;
};
var addToDeleteSet = (ds2, client, clock, length3) => {
  setIfUndefined(ds2.clients, client, () => (
    /** @type {Array<DeleteItem>} */
    []
  )).push(new DeleteItem(clock, length3));
};
var createDeleteSet = () => new DeleteSet();
var createDeleteSetFromStructStore = (ss2) => {
  const ds2 = createDeleteSet();
  ss2.clients.forEach((structs, client) => {
    const dsitems = [];
    for (let i2 = 0; i2 < structs.length; i2++) {
      const struct = structs[i2];
      if (struct.deleted) {
        const clock = struct.id.clock;
        let len = struct.length;
        if (i2 + 1 < structs.length) {
          for (let next2 = structs[i2 + 1]; i2 + 1 < structs.length && next2.deleted; next2 = structs[++i2 + 1]) {
            len += next2.length;
          }
        }
        dsitems.push(new DeleteItem(clock, len));
      }
    }
    if (dsitems.length > 0) {
      ds2.clients.set(client, dsitems);
    }
  });
  return ds2;
};
var writeDeleteSet = (encoder, ds2) => {
  writeVarUint(encoder.restEncoder, ds2.clients.size);
  from2(ds2.clients.entries()).sort((a2, b2) => b2[0] - a2[0]).forEach(([client, dsitems]) => {
    encoder.resetDsCurVal();
    writeVarUint(encoder.restEncoder, client);
    const len = dsitems.length;
    writeVarUint(encoder.restEncoder, len);
    for (let i2 = 0; i2 < len; i2++) {
      const item = dsitems[i2];
      encoder.writeDsClock(item.clock);
      encoder.writeDsLen(item.len);
    }
  });
};
var readDeleteSet = (decoder) => {
  const ds2 = new DeleteSet();
  const numClients = readVarUint(decoder.restDecoder);
  for (let i2 = 0; i2 < numClients; i2++) {
    decoder.resetDsCurVal();
    const client = readVarUint(decoder.restDecoder);
    const numberOfDeletes = readVarUint(decoder.restDecoder);
    if (numberOfDeletes > 0) {
      const dsField = setIfUndefined(ds2.clients, client, () => (
        /** @type {Array<DeleteItem>} */
        []
      ));
      for (let i3 = 0; i3 < numberOfDeletes; i3++) {
        dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));
      }
    }
  }
  return ds2;
};
var readAndApplyDeleteSet = (decoder, transaction, store) => {
  const unappliedDS = new DeleteSet();
  const numClients = readVarUint(decoder.restDecoder);
  for (let i2 = 0; i2 < numClients; i2++) {
    decoder.resetDsCurVal();
    const client = readVarUint(decoder.restDecoder);
    const numberOfDeletes = readVarUint(decoder.restDecoder);
    const structs = store.clients.get(client) || [];
    const state = getState(store, client);
    for (let i3 = 0; i3 < numberOfDeletes; i3++) {
      const clock = decoder.readDsClock();
      const clockEnd = clock + decoder.readDsLen();
      if (clock < state) {
        if (state < clockEnd) {
          addToDeleteSet(unappliedDS, client, state, clockEnd - state);
        }
        let index4 = findIndexSS(structs, clock);
        let struct = structs[index4];
        if (!struct.deleted && struct.id.clock < clock) {
          structs.splice(index4 + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
          index4++;
        }
        while (index4 < structs.length) {
          struct = structs[index4++];
          if (struct.id.clock < clockEnd) {
            if (!struct.deleted) {
              if (clockEnd < struct.id.clock + struct.length) {
                structs.splice(index4, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));
              }
              struct.delete(transaction);
            }
          } else {
            break;
          }
        }
      } else {
        addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);
      }
    }
  }
  if (unappliedDS.clients.size > 0) {
    const ds2 = new UpdateEncoderV2();
    writeVarUint(ds2.restEncoder, 0);
    writeDeleteSet(ds2, unappliedDS);
    return ds2.toUint8Array();
  }
  return null;
};
var generateNewClientId = uint32;
var Doc = class _Doc extends ObservableV2 {
  /**
   * @param {DocOpts} opts configuration
   */
  constructor({ guid = uuidv4(), collectionid = null, gc = true, gcFilter = () => true, meta: meta2 = null, autoLoad = false, shouldLoad = true } = {}) {
    super();
    this.gc = gc;
    this.gcFilter = gcFilter;
    this.clientID = generateNewClientId();
    this.guid = guid;
    this.collectionid = collectionid;
    this.share = /* @__PURE__ */ new Map();
    this.store = new StructStore();
    this._transaction = null;
    this._transactionCleanups = [];
    this.subdocs = /* @__PURE__ */ new Set();
    this._item = null;
    this.shouldLoad = shouldLoad;
    this.autoLoad = autoLoad;
    this.meta = meta2;
    this.isLoaded = false;
    this.isSynced = false;
    this.isDestroyed = false;
    this.whenLoaded = create4((resolve2) => {
      this.on("load", () => {
        this.isLoaded = true;
        resolve2(this);
      });
    });
    const provideSyncedPromise = () => create4((resolve2) => {
      const eventHandler = (isSynced) => {
        if (isSynced === void 0 || isSynced === true) {
          this.off("sync", eventHandler);
          resolve2();
        }
      };
      this.on("sync", eventHandler);
    });
    this.on("sync", (isSynced) => {
      if (isSynced === false && this.isSynced) {
        this.whenSynced = provideSyncedPromise();
      }
      this.isSynced = isSynced === void 0 || isSynced === true;
      if (this.isSynced && !this.isLoaded) {
        this.emit("load", [this]);
      }
    });
    this.whenSynced = provideSyncedPromise();
  }
  /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */
  load() {
    const item = this._item;
    if (item !== null && !this.shouldLoad) {
      transact(
        /** @type {any} */
        item.parent.doc,
        (transaction) => {
          transaction.subdocsLoaded.add(this);
        },
        null,
        true
      );
    }
    this.shouldLoad = true;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(from2(this.subdocs).map((doc2) => doc2.guid));
  }
  /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */
  transact(f2, origin = null) {
    return transact(this, f2, origin);
  }
  /**
   * Define a shared data type.
   *
   * Multiple calls of `ydoc.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `ydoc.get(name, Y.Array) === ydoc.get(name, Y.Array)`
   *
   * After this method is called, the type is also available on `ydoc.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Y.Doc instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @template {typeof AbstractType<any>} Type
   * @example
   *   const ydoc = new Y.Doc(..)
   *   const appState = {
   *     document: ydoc.getText('document')
   *     comments: ydoc.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor
   *
   * @public
   */
  get(name, TypeConstructor = (
    /** @type {any} */
    AbstractType
  )) {
    const type = setIfUndefined(this.share, name, () => {
      const t = new TypeConstructor();
      t._integrate(this, null);
      return t;
    });
    const Constr = type.constructor;
    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {
      if (Constr === AbstractType) {
        const t = new TypeConstructor();
        t._map = type._map;
        type._map.forEach(
          /** @param {Item?} n */
          (n) => {
            for (; n !== null; n = n.left) {
              n.parent = t;
            }
          }
        );
        t._start = type._start;
        for (let n = t._start; n !== null; n = n.right) {
          n.parent = t;
        }
        t._length = type._length;
        this.share.set(name, t);
        t._integrate(this, null);
        return (
          /** @type {InstanceType<Type>} */
          t
        );
      } else {
        throw new Error(`Type with the name ${name} has already been defined with a different constructor`);
      }
    }
    return (
      /** @type {InstanceType<Type>} */
      type
    );
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */
  getArray(name = "") {
    return (
      /** @type {YArray<T>} */
      this.get(name, YArray)
    );
  }
  /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */
  getText(name = "") {
    return this.get(name, YText);
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */
  getMap(name = "") {
    return (
      /** @type {YMap<T>} */
      this.get(name, YMap)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlElement}
   *
   * @public
   */
  getXmlElement(name = "") {
    return (
      /** @type {YXmlElement<{[key:string]:string}>} */
      this.get(name, YXmlElement)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */
  getXmlFragment(name = "") {
    return this.get(name, YXmlFragment);
  }
  /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */
  toJSON() {
    const doc2 = {};
    this.share.forEach((value, key2) => {
      doc2[key2] = value.toJSON();
    });
    return doc2;
  }
  /**
   * Emit `destroy` event and unregister all event handlers.
   */
  destroy() {
    this.isDestroyed = true;
    from2(this.subdocs).forEach((subdoc) => subdoc.destroy());
    const item = this._item;
    if (item !== null) {
      this._item = null;
      const content5 = (
        /** @type {ContentDoc} */
        item.content
      );
      content5.doc = new _Doc({ guid: this.guid, ...content5.opts, shouldLoad: false });
      content5.doc._item = item;
      transact(
        /** @type {any} */
        item.parent.doc,
        (transaction) => {
          const doc2 = content5.doc;
          if (!item.deleted) {
            transaction.subdocsAdded.add(doc2);
          }
          transaction.subdocsRemoved.add(this);
        },
        null,
        true
      );
    }
    this.emit("destroyed", [true]);
    this.emit("destroy", [this]);
    super.destroy();
  }
};
var DSDecoderV1 = class {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    this.restDecoder = decoder;
  }
  resetDsCurVal() {
  }
  /**
   * @return {number}
   */
  readDsClock() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {number}
   */
  readDsLen() {
    return readVarUint(this.restDecoder);
  }
};
var UpdateDecoderV1 = class extends DSDecoderV1 {
  /**
   * @return {ID}
   */
  readLeftID() {
    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return readUint8(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readString() {
    return readVarString(this.restDecoder);
  }
  /**
   * @return {boolean} isKey
   */
  readParentInfo() {
    return readVarUint(this.restDecoder) === 1;
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readTypeRef() {
    return readVarUint(this.restDecoder);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number} len
   */
  readLen() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {any}
   */
  readAny() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return copyUint8Array(readVarUint8Array(this.restDecoder));
  }
  /**
   * Legacy implementation uses JSON parse. We use any-decoding in v2.
   *
   * @return {any}
   */
  readJSON() {
    return JSON.parse(readVarString(this.restDecoder));
  }
  /**
   * @return {string}
   */
  readKey() {
    return readVarString(this.restDecoder);
  }
};
var DSDecoderV2 = class {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    this.dsCurrVal = 0;
    this.restDecoder = decoder;
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @return {number}
   */
  readDsClock() {
    this.dsCurrVal += readVarUint(this.restDecoder);
    return this.dsCurrVal;
  }
  /**
   * @return {number}
   */
  readDsLen() {
    const diff = readVarUint(this.restDecoder) + 1;
    this.dsCurrVal += diff;
    return diff;
  }
};
var UpdateDecoderV2 = class extends DSDecoderV2 {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    super(decoder);
    this.keys = [];
    readVarUint(decoder);
    this.keyClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.clientDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
    this.leftClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.rightClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.infoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
    this.stringDecoder = new StringDecoder(readVarUint8Array(decoder));
    this.parentInfoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
    this.typeRefDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
    this.lenDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
  }
  /**
   * @return {ID}
   */
  readLeftID() {
    return new ID(this.clientDecoder.read(), this.leftClockDecoder.read());
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return new ID(this.clientDecoder.read(), this.rightClockDecoder.read());
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return this.clientDecoder.read();
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return (
      /** @type {number} */
      this.infoDecoder.read()
    );
  }
  /**
   * @return {string}
   */
  readString() {
    return this.stringDecoder.read();
  }
  /**
   * @return {boolean}
   */
  readParentInfo() {
    return this.parentInfoDecoder.read() === 1;
  }
  /**
   * @return {number} An unsigned 8-bit integer
   */
  readTypeRef() {
    return this.typeRefDecoder.read();
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number}
   */
  readLen() {
    return this.lenDecoder.read();
  }
  /**
   * @return {any}
   */
  readAny() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return readVarUint8Array(this.restDecoder);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @return {any}
   */
  readJSON() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readKey() {
    const keyClock = this.keyClockDecoder.read();
    if (keyClock < this.keys.length) {
      return this.keys[keyClock];
    } else {
      const key2 = this.stringDecoder.read();
      this.keys.push(key2);
      return key2;
    }
  }
};
var DSEncoderV1 = class {
  constructor() {
    this.restEncoder = createEncoder();
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
  }
  /**
   * @param {number} clock
   */
  writeDsClock(clock) {
    writeVarUint(this.restEncoder, clock);
  }
  /**
   * @param {number} len
   */
  writeDsLen(len) {
    writeVarUint(this.restEncoder, len);
  }
};
var UpdateEncoderV1 = class extends DSEncoderV1 {
  /**
   * @param {ID} id
   */
  writeLeftID(id2) {
    writeVarUint(this.restEncoder, id2.client);
    writeVarUint(this.restEncoder, id2.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(id2) {
    writeVarUint(this.restEncoder, id2.client);
    writeVarUint(this.restEncoder, id2.clock);
  }
  /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */
  writeClient(client) {
    writeVarUint(this.restEncoder, client);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(info) {
    writeUint8(this.restEncoder, info);
  }
  /**
   * @param {string} s
   */
  writeString(s2) {
    writeVarString(this.restEncoder, s2);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(isYKey) {
    writeVarUint(this.restEncoder, isYKey ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(info) {
    writeVarUint(this.restEncoder, info);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(len) {
    writeVarUint(this.restEncoder, len);
  }
  /**
   * @param {any} any
   */
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  /**
   * @param {any} embed
   */
  writeJSON(embed) {
    writeVarString(this.restEncoder, JSON.stringify(embed));
  }
  /**
   * @param {string} key
   */
  writeKey(key2) {
    writeVarString(this.restEncoder, key2);
  }
};
var DSEncoderV2 = class {
  constructor() {
    this.restEncoder = createEncoder();
    this.dsCurrVal = 0;
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @param {number} clock
   */
  writeDsClock(clock) {
    const diff = clock - this.dsCurrVal;
    this.dsCurrVal = clock;
    writeVarUint(this.restEncoder, diff);
  }
  /**
   * @param {number} len
   */
  writeDsLen(len) {
    if (len === 0) {
      unexpectedCase();
    }
    writeVarUint(this.restEncoder, len - 1);
    this.dsCurrVal += len;
  }
};
var UpdateEncoderV2 = class extends DSEncoderV2 {
  constructor() {
    super();
    this.keyMap = /* @__PURE__ */ new Map();
    this.keyClock = 0;
    this.keyClockEncoder = new IntDiffOptRleEncoder();
    this.clientEncoder = new UintOptRleEncoder();
    this.leftClockEncoder = new IntDiffOptRleEncoder();
    this.rightClockEncoder = new IntDiffOptRleEncoder();
    this.infoEncoder = new RleEncoder(writeUint8);
    this.stringEncoder = new StringEncoder();
    this.parentInfoEncoder = new RleEncoder(writeUint8);
    this.typeRefEncoder = new UintOptRleEncoder();
    this.lenEncoder = new UintOptRleEncoder();
  }
  toUint8Array() {
    const encoder = createEncoder();
    writeVarUint(encoder, 0);
    writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, toUint8Array(this.infoEncoder));
    writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());
    writeVarUint8Array(encoder, toUint8Array(this.parentInfoEncoder));
    writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());
    writeUint8Array(encoder, toUint8Array(this.restEncoder));
    return toUint8Array(encoder);
  }
  /**
   * @param {ID} id
   */
  writeLeftID(id2) {
    this.clientEncoder.write(id2.client);
    this.leftClockEncoder.write(id2.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(id2) {
    this.clientEncoder.write(id2.client);
    this.rightClockEncoder.write(id2.clock);
  }
  /**
   * @param {number} client
   */
  writeClient(client) {
    this.clientEncoder.write(client);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(info) {
    this.infoEncoder.write(info);
  }
  /**
   * @param {string} s
   */
  writeString(s2) {
    this.stringEncoder.write(s2);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(isYKey) {
    this.parentInfoEncoder.write(isYKey ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(info) {
    this.typeRefEncoder.write(info);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(len) {
    this.lenEncoder.write(len);
  }
  /**
   * @param {any} any
   */
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */
  writeJSON(embed) {
    writeAny(this.restEncoder, embed);
  }
  /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */
  writeKey(key2) {
    const clock = this.keyMap.get(key2);
    if (clock === void 0) {
      this.keyClockEncoder.write(this.keyClock++);
      this.stringEncoder.write(key2);
    } else {
      this.keyClockEncoder.write(clock);
    }
  }
};
var writeStructs = (encoder, structs, client, clock) => {
  clock = max2(clock, structs[0].id.clock);
  const startNewStructs = findIndexSS(structs, clock);
  writeVarUint(encoder.restEncoder, structs.length - startNewStructs);
  encoder.writeClient(client);
  writeVarUint(encoder.restEncoder, clock);
  const firstStruct = structs[startNewStructs];
  firstStruct.write(encoder, clock - firstStruct.id.clock);
  for (let i2 = startNewStructs + 1; i2 < structs.length; i2++) {
    structs[i2].write(encoder, 0);
  }
};
var writeClientsStructs = (encoder, store, _sm) => {
  const sm = /* @__PURE__ */ new Map();
  _sm.forEach((clock, client) => {
    if (getState(store, client) > clock) {
      sm.set(client, clock);
    }
  });
  getStateVector(store).forEach((_clock, client) => {
    if (!_sm.has(client)) {
      sm.set(client, 0);
    }
  });
  writeVarUint(encoder.restEncoder, sm.size);
  from2(sm.entries()).sort((a2, b2) => b2[0] - a2[0]).forEach(([client, clock]) => {
    writeStructs(
      encoder,
      /** @type {Array<GC|Item>} */
      store.clients.get(client),
      client,
      clock
    );
  });
};
var readClientsStructRefs = (decoder, doc2) => {
  const clientRefs = create();
  const numOfStateUpdates = readVarUint(decoder.restDecoder);
  for (let i2 = 0; i2 < numOfStateUpdates; i2++) {
    const numberOfStructs = readVarUint(decoder.restDecoder);
    const refs = new Array(numberOfStructs);
    const client = decoder.readClient();
    let clock = readVarUint(decoder.restDecoder);
    clientRefs.set(client, { i: 0, refs });
    for (let i3 = 0; i3 < numberOfStructs; i3++) {
      const info = decoder.readInfo();
      switch (BITS5 & info) {
        case 0: {
          const len = decoder.readLen();
          refs[i3] = new GC(createID(client, clock), len);
          clock += len;
          break;
        }
        case 10: {
          const len = readVarUint(decoder.restDecoder);
          refs[i3] = new Skip(createID(client, clock), len);
          clock += len;
          break;
        }
        default: {
          const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
          const struct = new Item(
            createID(client, clock),
            null,
            // left
            (info & BIT8) === BIT8 ? decoder.readLeftID() : null,
            // origin
            null,
            // right
            (info & BIT7) === BIT7 ? decoder.readRightID() : null,
            // right origin
            cantCopyParentInfo ? decoder.readParentInfo() ? doc2.get(decoder.readString()) : decoder.readLeftID() : null,
            // parent
            cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,
            // parentSub
            readItemContent(decoder, info)
            // item content
          );
          refs[i3] = struct;
          clock += struct.length;
        }
      }
    }
  }
  return clientRefs;
};
var integrateStructs = (transaction, store, clientsStructRefs) => {
  const stack = [];
  let clientsStructRefsIds = from2(clientsStructRefs.keys()).sort((a2, b2) => a2 - b2);
  if (clientsStructRefsIds.length === 0) {
    return null;
  }
  const getNextStructTarget = () => {
    if (clientsStructRefsIds.length === 0) {
      return null;
    }
    let nextStructsTarget = (
      /** @type {{i:number,refs:Array<GC|Item>}} */
      clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1])
    );
    while (nextStructsTarget.refs.length === nextStructsTarget.i) {
      clientsStructRefsIds.pop();
      if (clientsStructRefsIds.length > 0) {
        nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */
        clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
      } else {
        return null;
      }
    }
    return nextStructsTarget;
  };
  let curStructsTarget = getNextStructTarget();
  if (curStructsTarget === null) {
    return null;
  }
  const restStructs = new StructStore();
  const missingSV = /* @__PURE__ */ new Map();
  const updateMissingSv = (client, clock) => {
    const mclock = missingSV.get(client);
    if (mclock == null || mclock > clock) {
      missingSV.set(client, clock);
    }
  };
  let stackHead = (
    /** @type {any} */
    curStructsTarget.refs[
      /** @type {any} */
      curStructsTarget.i++
    ]
  );
  const state = /* @__PURE__ */ new Map();
  const addStackToRestSS = () => {
    for (const item of stack) {
      const client = item.id.client;
      const inapplicableItems = clientsStructRefs.get(client);
      if (inapplicableItems) {
        inapplicableItems.i--;
        restStructs.clients.set(client, inapplicableItems.refs.slice(inapplicableItems.i));
        clientsStructRefs.delete(client);
        inapplicableItems.i = 0;
        inapplicableItems.refs = [];
      } else {
        restStructs.clients.set(client, [item]);
      }
      clientsStructRefsIds = clientsStructRefsIds.filter((c) => c !== client);
    }
    stack.length = 0;
  };
  while (true) {
    if (stackHead.constructor !== Skip) {
      const localClock = setIfUndefined(state, stackHead.id.client, () => getState(store, stackHead.id.client));
      const offset4 = localClock - stackHead.id.clock;
      if (offset4 < 0) {
        stack.push(stackHead);
        updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);
        addStackToRestSS();
      } else {
        const missing = stackHead.getMissing(transaction, store);
        if (missing !== null) {
          stack.push(stackHead);
          const structRefs = clientsStructRefs.get(
            /** @type {number} */
            missing
          ) || { refs: [], i: 0 };
          if (structRefs.refs.length === structRefs.i) {
            updateMissingSv(
              /** @type {number} */
              missing,
              getState(store, missing)
            );
            addStackToRestSS();
          } else {
            stackHead = structRefs.refs[structRefs.i++];
            continue;
          }
        } else if (offset4 === 0 || offset4 < stackHead.length) {
          stackHead.integrate(transaction, offset4);
          state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);
        }
      }
    }
    if (stack.length > 0) {
      stackHead = /** @type {GC|Item} */
      stack.pop();
    } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {
      stackHead = /** @type {GC|Item} */
      curStructsTarget.refs[curStructsTarget.i++];
    } else {
      curStructsTarget = getNextStructTarget();
      if (curStructsTarget === null) {
        break;
      } else {
        stackHead = /** @type {GC|Item} */
        curStructsTarget.refs[curStructsTarget.i++];
      }
    }
  }
  if (restStructs.clients.size > 0) {
    const encoder = new UpdateEncoderV2();
    writeClientsStructs(encoder, restStructs, /* @__PURE__ */ new Map());
    writeVarUint(encoder.restEncoder, 0);
    return { missing: missingSV, update: encoder.toUint8Array() };
  }
  return null;
};
var writeStructsFromTransaction = (encoder, transaction) => writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);
var readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) => transact(ydoc, (transaction) => {
  transaction.local = false;
  let retry = false;
  const doc2 = transaction.doc;
  const store = doc2.store;
  const ss2 = readClientsStructRefs(structDecoder, doc2);
  const restStructs = integrateStructs(transaction, store, ss2);
  const pending = store.pendingStructs;
  if (pending) {
    for (const [client, clock] of pending.missing) {
      if (clock < getState(store, client)) {
        retry = true;
        break;
      }
    }
    if (restStructs) {
      for (const [client, clock] of restStructs.missing) {
        const mclock = pending.missing.get(client);
        if (mclock == null || mclock > clock) {
          pending.missing.set(client, clock);
        }
      }
      pending.update = mergeUpdatesV2([pending.update, restStructs.update]);
    }
  } else {
    store.pendingStructs = restStructs;
  }
  const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);
  if (store.pendingDs) {
    const pendingDSUpdate = new UpdateDecoderV2(createDecoder(store.pendingDs));
    readVarUint(pendingDSUpdate.restDecoder);
    const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);
    if (dsRest && dsRest2) {
      store.pendingDs = mergeUpdatesV2([dsRest, dsRest2]);
    } else {
      store.pendingDs = dsRest || dsRest2;
    }
  } else {
    store.pendingDs = dsRest;
  }
  if (retry) {
    const update = (
      /** @type {{update: Uint8Array}} */
      store.pendingStructs.update
    );
    store.pendingStructs = null;
    applyUpdateV2(transaction.doc, update);
  }
}, transactionOrigin, false);
var applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {
  const decoder = createDecoder(update);
  readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));
};
var applyUpdate = (ydoc, update, transactionOrigin) => applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);
var writeStateAsUpdate = (encoder, doc2, targetStateVector = /* @__PURE__ */ new Map()) => {
  writeClientsStructs(encoder, doc2.store, targetStateVector);
  writeDeleteSet(encoder, createDeleteSetFromStructStore(doc2.store));
};
var encodeStateAsUpdateV2 = (doc2, encodedTargetStateVector = new Uint8Array([0]), encoder = new UpdateEncoderV2()) => {
  const targetStateVector = decodeStateVector(encodedTargetStateVector);
  writeStateAsUpdate(encoder, doc2, targetStateVector);
  const updates = [encoder.toUint8Array()];
  if (doc2.store.pendingDs) {
    updates.push(doc2.store.pendingDs);
  }
  if (doc2.store.pendingStructs) {
    updates.push(diffUpdateV2(doc2.store.pendingStructs.update, encodedTargetStateVector));
  }
  if (updates.length > 1) {
    if (encoder.constructor === UpdateEncoderV1) {
      return mergeUpdates(updates.map((update, i2) => i2 === 0 ? update : convertUpdateFormatV2ToV1(update)));
    } else if (encoder.constructor === UpdateEncoderV2) {
      return mergeUpdatesV2(updates);
    }
  }
  return updates[0];
};
var encodeStateAsUpdate = (doc2, encodedTargetStateVector) => encodeStateAsUpdateV2(doc2, encodedTargetStateVector, new UpdateEncoderV1());
var readStateVector = (decoder) => {
  const ss2 = /* @__PURE__ */ new Map();
  const ssLength = readVarUint(decoder.restDecoder);
  for (let i2 = 0; i2 < ssLength; i2++) {
    const client = readVarUint(decoder.restDecoder);
    const clock = readVarUint(decoder.restDecoder);
    ss2.set(client, clock);
  }
  return ss2;
};
var decodeStateVector = (decodedState) => readStateVector(new DSDecoderV1(createDecoder(decodedState)));
var writeStateVector = (encoder, sv) => {
  writeVarUint(encoder.restEncoder, sv.size);
  from2(sv.entries()).sort((a2, b2) => b2[0] - a2[0]).forEach(([client, clock]) => {
    writeVarUint(encoder.restEncoder, client);
    writeVarUint(encoder.restEncoder, clock);
  });
  return encoder;
};
var writeDocumentStateVector = (encoder, doc2) => writeStateVector(encoder, getStateVector(doc2.store));
var encodeStateVectorV2 = (doc2, encoder = new DSEncoderV2()) => {
  if (doc2 instanceof Map) {
    writeStateVector(encoder, doc2);
  } else {
    writeDocumentStateVector(encoder, doc2);
  }
  return encoder.toUint8Array();
};
var encodeStateVector = (doc2) => encodeStateVectorV2(doc2, new DSEncoderV1());
var EventHandler = class {
  constructor() {
    this.l = [];
  }
};
var createEventHandler = () => new EventHandler();
var addEventHandlerListener = (eventHandler, f2) => eventHandler.l.push(f2);
var removeEventHandlerListener = (eventHandler, f2) => {
  const l2 = eventHandler.l;
  const len = l2.length;
  eventHandler.l = l2.filter((g) => f2 !== g);
  if (len === eventHandler.l.length) {
    console.error("[yjs] Tried to remove event handler that doesn't exist.");
  }
};
var callEventHandlerListeners = (eventHandler, arg0, arg1) => callAll(eventHandler.l, [arg0, arg1]);
var ID = class {
  /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */
  constructor(client, clock) {
    this.client = client;
    this.clock = clock;
  }
};
var compareIDs = (a2, b2) => a2 === b2 || a2 !== null && b2 !== null && a2.client === b2.client && a2.clock === b2.clock;
var createID = (client, clock) => new ID(client, clock);
var findRootTypeKey = (type) => {
  for (const [key2, value] of type.doc.share.entries()) {
    if (value === type) {
      return key2;
    }
  }
  throw unexpectedCase();
};
var isParentOf = (parent, child) => {
  while (child !== null) {
    if (child.parent === parent) {
      return true;
    }
    child = /** @type {AbstractType<any>} */
    child.parent._item;
  }
  return false;
};
var RelativePosition = class {
  /**
   * @param {ID|null} type
   * @param {string|null} tname
   * @param {ID|null} item
   * @param {number} assoc
   */
  constructor(type, tname, item, assoc = 0) {
    this.type = type;
    this.tname = tname;
    this.item = item;
    this.assoc = assoc;
  }
};
var createRelativePositionFromJSON = (json) => new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname ?? null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);
var AbsolutePosition = class {
  /**
   * @param {AbstractType<any>} type
   * @param {number} index
   * @param {number} [assoc]
   */
  constructor(type, index4, assoc = 0) {
    this.type = type;
    this.index = index4;
    this.assoc = assoc;
  }
};
var createAbsolutePosition = (type, index4, assoc = 0) => new AbsolutePosition(type, index4, assoc);
var createRelativePosition = (type, item, assoc) => {
  let typeid = null;
  let tname = null;
  if (type._item === null) {
    tname = findRootTypeKey(type);
  } else {
    typeid = createID(type._item.id.client, type._item.id.clock);
  }
  return new RelativePosition(typeid, tname, item, assoc);
};
var createRelativePositionFromTypeIndex = (type, index4, assoc = 0) => {
  let t = type._start;
  if (assoc < 0) {
    if (index4 === 0) {
      return createRelativePosition(type, null, assoc);
    }
    index4--;
  }
  while (t !== null) {
    if (!t.deleted && t.countable) {
      if (t.length > index4) {
        return createRelativePosition(type, createID(t.id.client, t.id.clock + index4), assoc);
      }
      index4 -= t.length;
    }
    if (t.right === null && assoc < 0) {
      return createRelativePosition(type, t.lastId, assoc);
    }
    t = t.right;
  }
  return createRelativePosition(type, null, assoc);
};
var getItemWithOffset = (store, id2) => {
  const item = getItem(store, id2);
  const diff = id2.clock - item.id.clock;
  return {
    item,
    diff
  };
};
var createAbsolutePositionFromRelativePosition = (rpos, doc2, followUndoneDeletions = true) => {
  const store = doc2.store;
  const rightID = rpos.item;
  const typeID = rpos.type;
  const tname = rpos.tname;
  const assoc = rpos.assoc;
  let type = null;
  let index4 = 0;
  if (rightID !== null) {
    if (getState(store, rightID.client) <= rightID.clock) {
      return null;
    }
    const res = followUndoneDeletions ? followRedone(store, rightID) : getItemWithOffset(store, rightID);
    const right = res.item;
    if (!(right instanceof Item)) {
      return null;
    }
    type = /** @type {AbstractType<any>} */
    right.parent;
    if (type._item === null || !type._item.deleted) {
      index4 = right.deleted || !right.countable ? 0 : res.diff + (assoc >= 0 ? 0 : 1);
      let n = right.left;
      while (n !== null) {
        if (!n.deleted && n.countable) {
          index4 += n.length;
        }
        n = n.left;
      }
    }
  } else {
    if (tname !== null) {
      type = doc2.get(tname);
    } else if (typeID !== null) {
      if (getState(store, typeID.client) <= typeID.clock) {
        return null;
      }
      const { item } = followUndoneDeletions ? followRedone(store, typeID) : { item: getItem(store, typeID) };
      if (item instanceof Item && item.content instanceof ContentType) {
        type = item.content.type;
      } else {
        return null;
      }
    } else {
      throw unexpectedCase();
    }
    if (assoc >= 0) {
      index4 = type._length;
    } else {
      index4 = 0;
    }
  }
  return createAbsolutePosition(type, index4, rpos.assoc);
};
var compareRelativePositions = (a2, b2) => a2 === b2 || a2 !== null && b2 !== null && a2.tname === b2.tname && compareIDs(a2.item, b2.item) && compareIDs(a2.type, b2.type) && a2.assoc === b2.assoc;
var Snapshot = class {
  /**
   * @param {DeleteSet} ds
   * @param {Map<number,number>} sv state map
   */
  constructor(ds2, sv) {
    this.ds = ds2;
    this.sv = sv;
  }
};
var createSnapshot = (ds2, sm) => new Snapshot(ds2, sm);
var emptySnapshot = createSnapshot(createDeleteSet(), /* @__PURE__ */ new Map());
var snapshot = (doc2) => createSnapshot(createDeleteSetFromStructStore(doc2.store), getStateVector(doc2.store));
var isVisible = (item, snapshot2) => snapshot2 === void 0 ? !item.deleted : snapshot2.sv.has(item.id.client) && (snapshot2.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot2.ds, item.id);
var splitSnapshotAffectedStructs = (transaction, snapshot2) => {
  const meta2 = setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, create2);
  const store = transaction.doc.store;
  if (!meta2.has(snapshot2)) {
    snapshot2.sv.forEach((clock, client) => {
      if (clock < getState(store, client)) {
        getItemCleanStart(transaction, createID(client, clock));
      }
    });
    iterateDeletedStructs(transaction, snapshot2.ds, (_item) => {
    });
    meta2.add(snapshot2);
  }
};
var StructStore = class {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
    this.pendingStructs = null;
    this.pendingDs = null;
  }
};
var getStateVector = (store) => {
  const sm = /* @__PURE__ */ new Map();
  store.clients.forEach((structs, client) => {
    const struct = structs[structs.length - 1];
    sm.set(client, struct.id.clock + struct.length);
  });
  return sm;
};
var getState = (store, client) => {
  const structs = store.clients.get(client);
  if (structs === void 0) {
    return 0;
  }
  const lastStruct = structs[structs.length - 1];
  return lastStruct.id.clock + lastStruct.length;
};
var addStruct = (store, struct) => {
  let structs = store.clients.get(struct.id.client);
  if (structs === void 0) {
    structs = [];
    store.clients.set(struct.id.client, structs);
  } else {
    const lastStruct = structs[structs.length - 1];
    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {
      throw unexpectedCase();
    }
  }
  structs.push(struct);
};
var findIndexSS = (structs, clock) => {
  let left = 0;
  let right = structs.length - 1;
  let mid = structs[right];
  let midclock = mid.id.clock;
  if (midclock === clock) {
    return right;
  }
  let midindex = floor2(clock / (midclock + mid.length - 1) * right);
  while (left <= right) {
    mid = structs[midindex];
    midclock = mid.id.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.length) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
    midindex = floor2((left + right) / 2);
  }
  throw unexpectedCase();
};
var find2 = (store, id2) => {
  const structs = store.clients.get(id2.client);
  return structs[findIndexSS(structs, id2.clock)];
};
var getItem = (
  /** @type {function(StructStore,ID):Item} */
  find2
);
var findIndexCleanStart = (transaction, structs, clock) => {
  const index4 = findIndexSS(structs, clock);
  const struct = structs[index4];
  if (struct.id.clock < clock && struct instanceof Item) {
    structs.splice(index4 + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
    return index4 + 1;
  }
  return index4;
};
var getItemCleanStart = (transaction, id2) => {
  const structs = (
    /** @type {Array<Item>} */
    transaction.doc.store.clients.get(id2.client)
  );
  return structs[findIndexCleanStart(transaction, structs, id2.clock)];
};
var getItemCleanEnd = (transaction, store, id2) => {
  const structs = store.clients.get(id2.client);
  const index4 = findIndexSS(structs, id2.clock);
  const struct = structs[index4];
  if (id2.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {
    structs.splice(index4 + 1, 0, splitItem(transaction, struct, id2.clock - struct.id.clock + 1));
  }
  return struct;
};
var replaceStruct = (store, struct, newStruct) => {
  const structs = (
    /** @type {Array<GC|Item>} */
    store.clients.get(struct.id.client)
  );
  structs[findIndexSS(structs, struct.id.clock)] = newStruct;
};
var iterateStructs = (transaction, structs, clockStart, len, f2) => {
  if (len === 0) {
    return;
  }
  const clockEnd = clockStart + len;
  let index4 = findIndexCleanStart(transaction, structs, clockStart);
  let struct;
  do {
    struct = structs[index4++];
    if (clockEnd < struct.id.clock + struct.length) {
      findIndexCleanStart(transaction, structs, clockEnd);
    }
    f2(struct);
  } while (index4 < structs.length && structs[index4].id.clock < clockEnd);
};
var Transaction = class {
  /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */
  constructor(doc2, origin, local) {
    this.doc = doc2;
    this.deleteSet = new DeleteSet();
    this.beforeState = getStateVector(doc2.store);
    this.afterState = /* @__PURE__ */ new Map();
    this.changed = /* @__PURE__ */ new Map();
    this.changedParentTypes = /* @__PURE__ */ new Map();
    this._mergeStructs = [];
    this.origin = origin;
    this.meta = /* @__PURE__ */ new Map();
    this.local = local;
    this.subdocsAdded = /* @__PURE__ */ new Set();
    this.subdocsRemoved = /* @__PURE__ */ new Set();
    this.subdocsLoaded = /* @__PURE__ */ new Set();
    this._needFormattingCleanup = false;
  }
};
var writeUpdateMessageFromTransaction = (encoder, transaction) => {
  if (transaction.deleteSet.clients.size === 0 && !any(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {
    return false;
  }
  sortAndMergeDeleteSet(transaction.deleteSet);
  writeStructsFromTransaction(encoder, transaction);
  writeDeleteSet(encoder, transaction.deleteSet);
  return true;
};
var addChangedTypeToTransaction = (transaction, type, parentSub) => {
  const item = type._item;
  if (item === null || item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted) {
    setIfUndefined(transaction.changed, type, create2).add(parentSub);
  }
};
var tryToMergeWithLefts = (structs, pos) => {
  let right = structs[pos];
  let left = structs[pos - 1];
  let i2 = pos;
  for (; i2 > 0; right = left, left = structs[--i2 - 1]) {
    if (left.deleted === right.deleted && left.constructor === right.constructor) {
      if (left.mergeWith(right)) {
        if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */
        right.parent._map.get(right.parentSub) === right) {
          right.parent._map.set(
            right.parentSub,
            /** @type {Item} */
            left
          );
        }
        continue;
      }
    }
    break;
  }
  const merged = pos - i2;
  if (merged) {
    structs.splice(pos + 1 - merged, merged);
  }
  return merged;
};
var tryGcDeleteSet = (ds2, store, gcFilter) => {
  for (const [client, deleteItems] of ds2.clients.entries()) {
    const structs = (
      /** @type {Array<GC|Item>} */
      store.clients.get(client)
    );
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const endDeleteItemClock = deleteItem.clock + deleteItem.len;
      for (let si = findIndexSS(structs, deleteItem.clock), struct = structs[si]; si < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si]) {
        const struct2 = structs[si];
        if (deleteItem.clock + deleteItem.len <= struct2.id.clock) {
          break;
        }
        if (struct2 instanceof Item && struct2.deleted && !struct2.keep && gcFilter(struct2)) {
          struct2.gc(store, false);
        }
      }
    }
  }
};
var tryMergeDeleteSet = (ds2, store) => {
  ds2.clients.forEach((deleteItems, client) => {
    const structs = (
      /** @type {Array<GC|Item>} */
      store.clients.get(client)
    );
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const mostRightIndexToCheck = min2(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));
      for (let si = mostRightIndexToCheck, struct = structs[si]; si > 0 && struct.id.clock >= deleteItem.clock; struct = structs[si]) {
        si -= 1 + tryToMergeWithLefts(structs, si);
      }
    }
  });
};
var cleanupTransactions = (transactionCleanups, i2) => {
  if (i2 < transactionCleanups.length) {
    const transaction = transactionCleanups[i2];
    const doc2 = transaction.doc;
    const store = doc2.store;
    const ds2 = transaction.deleteSet;
    const mergeStructs = transaction._mergeStructs;
    try {
      sortAndMergeDeleteSet(ds2);
      transaction.afterState = getStateVector(transaction.doc.store);
      doc2.emit("beforeObserverCalls", [transaction, doc2]);
      const fs2 = [];
      transaction.changed.forEach(
        (subs, itemtype) => fs2.push(() => {
          if (itemtype._item === null || !itemtype._item.deleted) {
            itemtype._callObserver(transaction, subs);
          }
        })
      );
      fs2.push(() => {
        transaction.changedParentTypes.forEach((events, type) => {
          if (type._dEH.l.length > 0 && (type._item === null || !type._item.deleted)) {
            events = events.filter(
              (event) => event.target._item === null || !event.target._item.deleted
            );
            events.forEach((event) => {
              event.currentTarget = type;
              event._path = null;
            });
            events.sort((event1, event2) => event1.path.length - event2.path.length);
            callEventHandlerListeners(type._dEH, events, transaction);
          }
        });
      });
      fs2.push(() => doc2.emit("afterTransaction", [transaction, doc2]));
      callAll(fs2, []);
      if (transaction._needFormattingCleanup) {
        cleanupYTextAfterTransaction(transaction);
      }
    } finally {
      if (doc2.gc) {
        tryGcDeleteSet(ds2, store, doc2.gcFilter);
      }
      tryMergeDeleteSet(ds2, store);
      transaction.afterState.forEach((clock, client) => {
        const beforeClock = transaction.beforeState.get(client) || 0;
        if (beforeClock !== clock) {
          const structs = (
            /** @type {Array<GC|Item>} */
            store.clients.get(client)
          );
          const firstChangePos = max2(findIndexSS(structs, beforeClock), 1);
          for (let i3 = structs.length - 1; i3 >= firstChangePos; ) {
            i3 -= 1 + tryToMergeWithLefts(structs, i3);
          }
        }
      });
      for (let i3 = mergeStructs.length - 1; i3 >= 0; i3--) {
        const { client, clock } = mergeStructs[i3].id;
        const structs = (
          /** @type {Array<GC|Item>} */
          store.clients.get(client)
        );
        const replacedStructPos = findIndexSS(structs, clock);
        if (replacedStructPos + 1 < structs.length) {
          if (tryToMergeWithLefts(structs, replacedStructPos + 1) > 1) {
            continue;
          }
        }
        if (replacedStructPos > 0) {
          tryToMergeWithLefts(structs, replacedStructPos);
        }
      }
      if (!transaction.local && transaction.afterState.get(doc2.clientID) !== transaction.beforeState.get(doc2.clientID)) {
        print(ORANGE, BOLD, "[yjs] ", UNBOLD, RED, "Changed the client-id because another client seems to be using it.");
        doc2.clientID = generateNewClientId();
      }
      doc2.emit("afterTransactionCleanup", [transaction, doc2]);
      if (doc2._observers.has("update")) {
        const encoder = new UpdateEncoderV1();
        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);
        if (hasContent2) {
          doc2.emit("update", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);
        }
      }
      if (doc2._observers.has("updateV2")) {
        const encoder = new UpdateEncoderV2();
        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);
        if (hasContent2) {
          doc2.emit("updateV2", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);
        }
      }
      const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;
      if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {
        subdocsAdded.forEach((subdoc) => {
          subdoc.clientID = doc2.clientID;
          if (subdoc.collectionid == null) {
            subdoc.collectionid = doc2.collectionid;
          }
          doc2.subdocs.add(subdoc);
        });
        subdocsRemoved.forEach((subdoc) => doc2.subdocs.delete(subdoc));
        doc2.emit("subdocs", [{ loaded: subdocsLoaded, added: subdocsAdded, removed: subdocsRemoved }, doc2, transaction]);
        subdocsRemoved.forEach((subdoc) => subdoc.destroy());
      }
      if (transactionCleanups.length <= i2 + 1) {
        doc2._transactionCleanups = [];
        doc2.emit("afterAllTransactions", [doc2, transactionCleanups]);
      } else {
        cleanupTransactions(transactionCleanups, i2 + 1);
      }
    }
  }
};
var transact = (doc2, f2, origin = null, local = true) => {
  const transactionCleanups = doc2._transactionCleanups;
  let initialCall = false;
  let result = null;
  if (doc2._transaction === null) {
    initialCall = true;
    doc2._transaction = new Transaction(doc2, origin, local);
    transactionCleanups.push(doc2._transaction);
    if (transactionCleanups.length === 1) {
      doc2.emit("beforeAllTransactions", [doc2]);
    }
    doc2.emit("beforeTransaction", [doc2._transaction, doc2]);
  }
  try {
    result = f2(doc2._transaction);
  } finally {
    if (initialCall) {
      const finishCleanup = doc2._transaction === transactionCleanups[0];
      doc2._transaction = null;
      if (finishCleanup) {
        cleanupTransactions(transactionCleanups, 0);
      }
    }
  }
  return result;
};
var StackItem = class {
  /**
   * @param {DeleteSet} deletions
   * @param {DeleteSet} insertions
   */
  constructor(deletions, insertions) {
    this.insertions = insertions;
    this.deletions = deletions;
    this.meta = /* @__PURE__ */ new Map();
  }
};
var clearUndoManagerStackItem = (tr5, um, stackItem) => {
  iterateDeletedStructs(tr5, stackItem.deletions, (item) => {
    if (item instanceof Item && um.scope.some((type) => type === tr5.doc || isParentOf(
      /** @type {AbstractType<any>} */
      type,
      item
    ))) {
      keepItem(item, false);
    }
  });
};
var popStackItem = (undoManager, stack, eventType) => {
  let _tr = null;
  const doc2 = undoManager.doc;
  const scope = undoManager.scope;
  transact(doc2, (transaction) => {
    while (stack.length > 0 && undoManager.currStackItem === null) {
      const store = doc2.store;
      const stackItem = (
        /** @type {StackItem} */
        stack.pop()
      );
      const itemsToRedo = /* @__PURE__ */ new Set();
      const itemsToDelete = [];
      let performedChange = false;
      iterateDeletedStructs(transaction, stackItem.insertions, (struct) => {
        if (struct instanceof Item) {
          if (struct.redone !== null) {
            let { item, diff } = followRedone(store, struct.id);
            if (diff > 0) {
              item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));
            }
            struct = item;
          }
          if (!struct.deleted && scope.some((type) => type === transaction.doc || isParentOf(
            /** @type {AbstractType<any>} */
            type,
            /** @type {Item} */
            struct
          ))) {
            itemsToDelete.push(struct);
          }
        }
      });
      iterateDeletedStructs(transaction, stackItem.deletions, (struct) => {
        if (struct instanceof Item && scope.some((type) => type === transaction.doc || isParentOf(
          /** @type {AbstractType<any>} */
          type,
          struct
        )) && // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.
        !isDeleted(stackItem.insertions, struct.id)) {
          itemsToRedo.add(struct);
        }
      });
      itemsToRedo.forEach((struct) => {
        performedChange = redoItem(transaction, struct, itemsToRedo, stackItem.insertions, undoManager.ignoreRemoteMapChanges, undoManager) !== null || performedChange;
      });
      for (let i2 = itemsToDelete.length - 1; i2 >= 0; i2--) {
        const item = itemsToDelete[i2];
        if (undoManager.deleteFilter(item)) {
          item.delete(transaction);
          performedChange = true;
        }
      }
      undoManager.currStackItem = performedChange ? stackItem : null;
    }
    transaction.changed.forEach((subProps, type) => {
      if (subProps.has(null) && type._searchMarker) {
        type._searchMarker.length = 0;
      }
    });
    _tr = transaction;
  }, undoManager);
  const res = undoManager.currStackItem;
  if (res != null) {
    const changedParentTypes = _tr.changedParentTypes;
    undoManager.emit("stack-item-popped", [{ stackItem: res, type: eventType, changedParentTypes, origin: undoManager }, undoManager]);
    undoManager.currStackItem = null;
  }
  return res;
};
var UndoManager = class extends ObservableV2 {
  /**
   * @param {Doc|AbstractType<any>|Array<AbstractType<any>>} typeScope Limits the scope of the UndoManager. If this is set to a ydoc instance, all changes on that ydoc will be undone. If set to a specific type, only changes on that type or its children will be undone. Also accepts an array of types.
   * @param {UndoManagerOptions} options
   */
  constructor(typeScope, {
    captureTimeout = 500,
    captureTransaction = (_tr) => true,
    deleteFilter = () => true,
    trackedOrigins = /* @__PURE__ */ new Set([null]),
    ignoreRemoteMapChanges = false,
    doc: doc2 = (
      /** @type {Doc} */
      isArray(typeScope) ? typeScope[0].doc : typeScope instanceof Doc ? typeScope : typeScope.doc
    )
  } = {}) {
    super();
    this.scope = [];
    this.doc = doc2;
    this.addToScope(typeScope);
    this.deleteFilter = deleteFilter;
    trackedOrigins.add(this);
    this.trackedOrigins = trackedOrigins;
    this.captureTransaction = captureTransaction;
    this.undoStack = [];
    this.redoStack = [];
    this.undoing = false;
    this.redoing = false;
    this.currStackItem = null;
    this.lastChange = 0;
    this.ignoreRemoteMapChanges = ignoreRemoteMapChanges;
    this.captureTimeout = captureTimeout;
    this.afterTransactionHandler = (transaction) => {
      if (!this.captureTransaction(transaction) || !this.scope.some((type) => transaction.changedParentTypes.has(
        /** @type {AbstractType<any>} */
        type
      ) || type === this.doc) || !this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor))) {
        return;
      }
      const undoing = this.undoing;
      const redoing = this.redoing;
      const stack = undoing ? this.redoStack : this.undoStack;
      if (undoing) {
        this.stopCapturing();
      } else if (!redoing) {
        this.clear(false, true);
      }
      const insertions = new DeleteSet();
      transaction.afterState.forEach((endClock, client) => {
        const startClock = transaction.beforeState.get(client) || 0;
        const len = endClock - startClock;
        if (len > 0) {
          addToDeleteSet(insertions, client, startClock, len);
        }
      });
      const now = getUnixTime();
      let didAdd = false;
      if (this.lastChange > 0 && now - this.lastChange < this.captureTimeout && stack.length > 0 && !undoing && !redoing) {
        const lastOp = stack[stack.length - 1];
        lastOp.deletions = mergeDeleteSets([lastOp.deletions, transaction.deleteSet]);
        lastOp.insertions = mergeDeleteSets([lastOp.insertions, insertions]);
      } else {
        stack.push(new StackItem(transaction.deleteSet, insertions));
        didAdd = true;
      }
      if (!undoing && !redoing) {
        this.lastChange = now;
      }
      iterateDeletedStructs(
        transaction,
        transaction.deleteSet,
        /** @param {Item|GC} item */
        (item) => {
          if (item instanceof Item && this.scope.some((type) => type === transaction.doc || isParentOf(
            /** @type {AbstractType<any>} */
            type,
            item
          ))) {
            keepItem(item, true);
          }
        }
      );
      const changeEvent = [{ stackItem: stack[stack.length - 1], origin: transaction.origin, type: undoing ? "redo" : "undo", changedParentTypes: transaction.changedParentTypes }, this];
      if (didAdd) {
        this.emit("stack-item-added", changeEvent);
      } else {
        this.emit("stack-item-updated", changeEvent);
      }
    };
    this.doc.on("afterTransaction", this.afterTransactionHandler);
    this.doc.on("destroy", () => {
      this.destroy();
    });
  }
  /**
   * Extend the scope.
   *
   * @param {Array<AbstractType<any> | Doc> | AbstractType<any> | Doc} ytypes
   */
  addToScope(ytypes) {
    const tmpSet = new Set(this.scope);
    ytypes = isArray(ytypes) ? ytypes : [ytypes];
    ytypes.forEach((ytype) => {
      if (!tmpSet.has(ytype)) {
        tmpSet.add(ytype);
        if (ytype instanceof AbstractType ? ytype.doc !== this.doc : ytype !== this.doc) warn2("[yjs#509] Not same Y.Doc");
        this.scope.push(ytype);
      }
    });
  }
  /**
   * @param {any} origin
   */
  addTrackedOrigin(origin) {
    this.trackedOrigins.add(origin);
  }
  /**
   * @param {any} origin
   */
  removeTrackedOrigin(origin) {
    this.trackedOrigins.delete(origin);
  }
  clear(clearUndoStack = true, clearRedoStack = true) {
    if (clearUndoStack && this.canUndo() || clearRedoStack && this.canRedo()) {
      this.doc.transact((tr5) => {
        if (clearUndoStack) {
          this.undoStack.forEach((item) => clearUndoManagerStackItem(tr5, this, item));
          this.undoStack = [];
        }
        if (clearRedoStack) {
          this.redoStack.forEach((item) => clearUndoManagerStackItem(tr5, this, item));
          this.redoStack = [];
        }
        this.emit("stack-cleared", [{ undoStackCleared: clearUndoStack, redoStackCleared: clearRedoStack }]);
      });
    }
  }
  /**
   * UndoManager merges Undo-StackItem if they are created within time-gap
   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next
   * StackItem won't be merged.
   *
   *
   * @example
   *     // without stopCapturing
   *     ytext.insert(0, 'a')
   *     ytext.insert(1, 'b')
   *     um.undo()
   *     ytext.toString() // => '' (note that 'ab' was removed)
   *     // with stopCapturing
   *     ytext.insert(0, 'a')
   *     um.stopCapturing()
   *     ytext.insert(0, 'b')
   *     um.undo()
   *     ytext.toString() // => 'a' (note that only 'b' was removed)
   *
   */
  stopCapturing() {
    this.lastChange = 0;
  }
  /**
   * Undo last changes on type.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */
  undo() {
    this.undoing = true;
    let res;
    try {
      res = popStackItem(this, this.undoStack, "undo");
    } finally {
      this.undoing = false;
    }
    return res;
  }
  /**
   * Redo last undo operation.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */
  redo() {
    this.redoing = true;
    let res;
    try {
      res = popStackItem(this, this.redoStack, "redo");
    } finally {
      this.redoing = false;
    }
    return res;
  }
  /**
   * Are undo steps available?
   *
   * @return {boolean} `true` if undo is possible
   */
  canUndo() {
    return this.undoStack.length > 0;
  }
  /**
   * Are redo steps available?
   *
   * @return {boolean} `true` if redo is possible
   */
  canRedo() {
    return this.redoStack.length > 0;
  }
  destroy() {
    this.trackedOrigins.delete(this);
    this.doc.off("afterTransaction", this.afterTransactionHandler);
    super.destroy();
  }
};
function* lazyStructReaderGenerator(decoder) {
  const numOfStateUpdates = readVarUint(decoder.restDecoder);
  for (let i2 = 0; i2 < numOfStateUpdates; i2++) {
    const numberOfStructs = readVarUint(decoder.restDecoder);
    const client = decoder.readClient();
    let clock = readVarUint(decoder.restDecoder);
    for (let i3 = 0; i3 < numberOfStructs; i3++) {
      const info = decoder.readInfo();
      if (info === 10) {
        const len = readVarUint(decoder.restDecoder);
        yield new Skip(createID(client, clock), len);
        clock += len;
      } else if ((BITS5 & info) !== 0) {
        const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
        const struct = new Item(
          createID(client, clock),
          null,
          // left
          (info & BIT8) === BIT8 ? decoder.readLeftID() : null,
          // origin
          null,
          // right
          (info & BIT7) === BIT7 ? decoder.readRightID() : null,
          // right origin
          // @ts-ignore Force writing a string here.
          cantCopyParentInfo ? decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID() : null,
          // parent
          cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,
          // parentSub
          readItemContent(decoder, info)
          // item content
        );
        yield struct;
        clock += struct.length;
      } else {
        const len = decoder.readLen();
        yield new GC(createID(client, clock), len);
        clock += len;
      }
    }
  }
}
var LazyStructReader = class {
  /**
   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
   * @param {boolean} filterSkips
   */
  constructor(decoder, filterSkips) {
    this.gen = lazyStructReaderGenerator(decoder);
    this.curr = null;
    this.done = false;
    this.filterSkips = filterSkips;
    this.next();
  }
  /**
   * @return {Item | GC | Skip |null}
   */
  next() {
    do {
      this.curr = this.gen.next().value || null;
    } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip);
    return this.curr;
  }
};
var LazyStructWriter = class {
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  constructor(encoder) {
    this.currClient = 0;
    this.startClock = 0;
    this.written = 0;
    this.encoder = encoder;
    this.clientStructs = [];
  }
};
var mergeUpdates = (updates) => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);
var sliceStruct = (left, diff) => {
  if (left.constructor === GC) {
    const { client, clock } = left.id;
    return new GC(createID(client, clock + diff), left.length - diff);
  } else if (left.constructor === Skip) {
    const { client, clock } = left.id;
    return new Skip(createID(client, clock + diff), left.length - diff);
  } else {
    const leftItem = (
      /** @type {Item} */
      left
    );
    const { client, clock } = leftItem.id;
    return new Item(
      createID(client, clock + diff),
      null,
      createID(client, clock + diff - 1),
      null,
      leftItem.rightOrigin,
      leftItem.parent,
      leftItem.parentSub,
      leftItem.content.splice(diff)
    );
  }
};
var mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  if (updates.length === 1) {
    return updates[0];
  }
  const updateDecoders = updates.map((update) => new YDecoder(createDecoder(update)));
  let lazyStructDecoders = updateDecoders.map((decoder) => new LazyStructReader(decoder, true));
  let currWrite = null;
  const updateEncoder = new YEncoder();
  const lazyStructEncoder = new LazyStructWriter(updateEncoder);
  while (true) {
    lazyStructDecoders = lazyStructDecoders.filter((dec) => dec.curr !== null);
    lazyStructDecoders.sort(
      /** @type {function(any,any):number} */
      (dec1, dec2) => {
        if (dec1.curr.id.client === dec2.curr.id.client) {
          const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;
          if (clockDiff === 0) {
            return dec1.curr.constructor === dec2.curr.constructor ? 0 : dec1.curr.constructor === Skip ? 1 : -1;
          } else {
            return clockDiff;
          }
        } else {
          return dec2.curr.id.client - dec1.curr.id.client;
        }
      }
    );
    if (lazyStructDecoders.length === 0) {
      break;
    }
    const currDecoder = lazyStructDecoders[0];
    const firstClient = (
      /** @type {Item | GC} */
      currDecoder.curr.id.client
    );
    if (currWrite !== null) {
      let curr = (
        /** @type {Item | GC | null} */
        currDecoder.curr
      );
      let iterated = false;
      while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {
        curr = currDecoder.next();
        iterated = true;
      }
      if (curr === null || // current decoder is empty
      curr.id.client !== firstClient || // check whether there is another decoder that has has updates from `firstClient`
      iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length) {
        continue;
      }
      if (firstClient !== currWrite.struct.id.client) {
        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
        currWrite = { struct: curr, offset: 0 };
        currDecoder.next();
      } else {
        if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {
          if (currWrite.struct.constructor === Skip) {
            currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;
          } else {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;
            const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);
            currWrite = { struct, offset: 0 };
          }
        } else {
          const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;
          if (diff > 0) {
            if (currWrite.struct.constructor === Skip) {
              currWrite.struct.length -= diff;
            } else {
              curr = sliceStruct(curr, diff);
            }
          }
          if (!currWrite.struct.mergeWith(
            /** @type {any} */
            curr
          )) {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            currWrite = { struct: curr, offset: 0 };
            currDecoder.next();
          }
        }
      }
    } else {
      currWrite = { struct: (
        /** @type {Item | GC} */
        currDecoder.curr
      ), offset: 0 };
      currDecoder.next();
    }
    for (let next2 = currDecoder.curr; next2 !== null && next2.id.client === firstClient && next2.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next2.constructor !== Skip; next2 = currDecoder.next()) {
      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
      currWrite = { struct: next2, offset: 0 };
    }
  }
  if (currWrite !== null) {
    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
    currWrite = null;
  }
  finishLazyStructWriting(lazyStructEncoder);
  const dss = updateDecoders.map((decoder) => readDeleteSet(decoder));
  const ds2 = mergeDeleteSets(dss);
  writeDeleteSet(updateEncoder, ds2);
  return updateEncoder.toUint8Array();
};
var diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  const state = decodeStateVector(sv);
  const encoder = new YEncoder();
  const lazyStructWriter = new LazyStructWriter(encoder);
  const decoder = new YDecoder(createDecoder(update));
  const reader = new LazyStructReader(decoder, false);
  while (reader.curr) {
    const curr = reader.curr;
    const currClient = curr.id.client;
    const svClock = state.get(currClient) || 0;
    if (reader.curr.constructor === Skip) {
      reader.next();
      continue;
    }
    if (curr.id.clock + curr.length > svClock) {
      writeStructToLazyStructWriter(lazyStructWriter, curr, max2(svClock - curr.id.clock, 0));
      reader.next();
      while (reader.curr && reader.curr.id.client === currClient) {
        writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);
        reader.next();
      }
    } else {
      while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {
        reader.next();
      }
    }
  }
  finishLazyStructWriting(lazyStructWriter);
  const ds2 = readDeleteSet(decoder);
  writeDeleteSet(encoder, ds2);
  return encoder.toUint8Array();
};
var flushLazyStructWriter = (lazyWriter) => {
  if (lazyWriter.written > 0) {
    lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: toUint8Array(lazyWriter.encoder.restEncoder) });
    lazyWriter.encoder.restEncoder = createEncoder();
    lazyWriter.written = 0;
  }
};
var writeStructToLazyStructWriter = (lazyWriter, struct, offset4) => {
  if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {
    flushLazyStructWriter(lazyWriter);
  }
  if (lazyWriter.written === 0) {
    lazyWriter.currClient = struct.id.client;
    lazyWriter.encoder.writeClient(struct.id.client);
    writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset4);
  }
  struct.write(lazyWriter.encoder, offset4);
  lazyWriter.written++;
};
var finishLazyStructWriting = (lazyWriter) => {
  flushLazyStructWriter(lazyWriter);
  const restEncoder = lazyWriter.encoder.restEncoder;
  writeVarUint(restEncoder, lazyWriter.clientStructs.length);
  for (let i2 = 0; i2 < lazyWriter.clientStructs.length; i2++) {
    const partStructs = lazyWriter.clientStructs[i2];
    writeVarUint(restEncoder, partStructs.written);
    writeUint8Array(restEncoder, partStructs.restEncoder);
  }
};
var convertUpdateFormat = (update, blockTransformer, YDecoder, YEncoder) => {
  const updateDecoder = new YDecoder(createDecoder(update));
  const lazyDecoder = new LazyStructReader(updateDecoder, false);
  const updateEncoder = new YEncoder();
  const lazyWriter = new LazyStructWriter(updateEncoder);
  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
    writeStructToLazyStructWriter(lazyWriter, blockTransformer(curr), 0);
  }
  finishLazyStructWriting(lazyWriter);
  const ds2 = readDeleteSet(updateDecoder);
  writeDeleteSet(updateEncoder, ds2);
  return updateEncoder.toUint8Array();
};
var convertUpdateFormatV2ToV1 = (update) => convertUpdateFormat(update, id, UpdateDecoderV2, UpdateEncoderV1);
var errorComputeChanges = "You must not compute changes after the event-handler fired.";
var YEvent = class {
  /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */
  constructor(target, transaction) {
    this.target = target;
    this.currentTarget = target;
    this.transaction = transaction;
    this._changes = null;
    this._keys = null;
    this._delta = null;
    this._path = null;
  }
  /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */
  get path() {
    return this._path || (this._path = getPathTo(this.currentTarget, this.target));
  }
  /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  deletes(struct) {
    return isDeleted(this.transaction.deleteSet, struct.id);
  }
  /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
   */
  get keys() {
    if (this._keys === null) {
      if (this.transaction.doc._transactionCleanups.length === 0) {
        throw create3(errorComputeChanges);
      }
      const keys3 = /* @__PURE__ */ new Map();
      const target = this.target;
      const changed = (
        /** @type Set<string|null> */
        this.transaction.changed.get(target)
      );
      changed.forEach((key2) => {
        if (key2 !== null) {
          const item = (
            /** @type {Item} */
            target._map.get(key2)
          );
          let action;
          let oldValue;
          if (this.adds(item)) {
            let prev = item.left;
            while (prev !== null && this.adds(prev)) {
              prev = prev.left;
            }
            if (this.deletes(item)) {
              if (prev !== null && this.deletes(prev)) {
                action = "delete";
                oldValue = last(prev.content.getContent());
              } else {
                return;
              }
            } else {
              if (prev !== null && this.deletes(prev)) {
                action = "update";
                oldValue = last(prev.content.getContent());
              } else {
                action = "add";
                oldValue = void 0;
              }
            }
          } else {
            if (this.deletes(item)) {
              action = "delete";
              oldValue = last(
                /** @type {Item} */
                item.content.getContent()
              );
            } else {
              return;
            }
          }
          keys3.set(key2, { action, oldValue });
        }
      });
      this._keys = keys3;
    }
    return this._keys;
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */
  get delta() {
    return this.changes.delta;
  }
  /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  adds(struct) {
    return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    let changes = this._changes;
    if (changes === null) {
      if (this.transaction.doc._transactionCleanups.length === 0) {
        throw create3(errorComputeChanges);
      }
      const target = this.target;
      const added = create2();
      const deleted = create2();
      const delta = [];
      changes = {
        added,
        deleted,
        delta,
        keys: this.keys
      };
      const changed = (
        /** @type Set<string|null> */
        this.transaction.changed.get(target)
      );
      if (changed.has(null)) {
        let lastOp = null;
        const packOp = () => {
          if (lastOp) {
            delta.push(lastOp);
          }
        };
        for (let item = target._start; item !== null; item = item.right) {
          if (item.deleted) {
            if (this.deletes(item) && !this.adds(item)) {
              if (lastOp === null || lastOp.delete === void 0) {
                packOp();
                lastOp = { delete: 0 };
              }
              lastOp.delete += item.length;
              deleted.add(item);
            }
          } else {
            if (this.adds(item)) {
              if (lastOp === null || lastOp.insert === void 0) {
                packOp();
                lastOp = { insert: [] };
              }
              lastOp.insert = lastOp.insert.concat(item.content.getContent());
              added.add(item);
            } else {
              if (lastOp === null || lastOp.retain === void 0) {
                packOp();
                lastOp = { retain: 0 };
              }
              lastOp.retain += item.length;
            }
          }
        }
        if (lastOp !== null && lastOp.retain === void 0) {
          packOp();
        }
      }
      this._changes = changes;
    }
    return (
      /** @type {any} */
      changes
    );
  }
};
var getPathTo = (parent, child) => {
  const path2 = [];
  while (child._item !== null && child !== parent) {
    if (child._item.parentSub !== null) {
      path2.unshift(child._item.parentSub);
    } else {
      let i2 = 0;
      let c = (
        /** @type {AbstractType<any>} */
        child._item.parent._start
      );
      while (c !== child._item && c !== null) {
        if (!c.deleted && c.countable) {
          i2 += c.length;
        }
        c = c.right;
      }
      path2.unshift(i2);
    }
    child = /** @type {AbstractType<any>} */
    child._item.parent;
  }
  return path2;
};
var warnPrematureAccess = () => {
  warn2("Invalid access: Add Yjs type to a document before reading data.");
};
var maxSearchMarker = 80;
var globalSearchMarkerTimestamp = 0;
var ArraySearchMarker = class {
  /**
   * @param {Item} p
   * @param {number} index
   */
  constructor(p5, index4) {
    p5.marker = true;
    this.p = p5;
    this.index = index4;
    this.timestamp = globalSearchMarkerTimestamp++;
  }
};
var refreshMarkerTimestamp = (marker) => {
  marker.timestamp = globalSearchMarkerTimestamp++;
};
var overwriteMarker = (marker, p5, index4) => {
  marker.p.marker = false;
  marker.p = p5;
  p5.marker = true;
  marker.index = index4;
  marker.timestamp = globalSearchMarkerTimestamp++;
};
var markPosition = (searchMarker, p5, index4) => {
  if (searchMarker.length >= maxSearchMarker) {
    const marker = searchMarker.reduce((a2, b2) => a2.timestamp < b2.timestamp ? a2 : b2);
    overwriteMarker(marker, p5, index4);
    return marker;
  } else {
    const pm = new ArraySearchMarker(p5, index4);
    searchMarker.push(pm);
    return pm;
  }
};
var findMarker = (yarray, index4) => {
  if (yarray._start === null || index4 === 0 || yarray._searchMarker === null) {
    return null;
  }
  const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a2, b2) => abs(index4 - a2.index) < abs(index4 - b2.index) ? a2 : b2);
  let p5 = yarray._start;
  let pindex = 0;
  if (marker !== null) {
    p5 = marker.p;
    pindex = marker.index;
    refreshMarkerTimestamp(marker);
  }
  while (p5.right !== null && pindex < index4) {
    if (!p5.deleted && p5.countable) {
      if (index4 < pindex + p5.length) {
        break;
      }
      pindex += p5.length;
    }
    p5 = p5.right;
  }
  while (p5.left !== null && pindex > index4) {
    p5 = p5.left;
    if (!p5.deleted && p5.countable) {
      pindex -= p5.length;
    }
  }
  while (p5.left !== null && p5.left.id.client === p5.id.client && p5.left.id.clock + p5.left.length === p5.id.clock) {
    p5 = p5.left;
    if (!p5.deleted && p5.countable) {
      pindex -= p5.length;
    }
  }
  if (marker !== null && abs(marker.index - pindex) < /** @type {YText|YArray<any>} */
  p5.parent.length / maxSearchMarker) {
    overwriteMarker(marker, p5, pindex);
    return marker;
  } else {
    return markPosition(yarray._searchMarker, p5, pindex);
  }
};
var updateMarkerChanges = (searchMarker, index4, len) => {
  for (let i2 = searchMarker.length - 1; i2 >= 0; i2--) {
    const m = searchMarker[i2];
    if (len > 0) {
      let p5 = m.p;
      p5.marker = false;
      while (p5 && (p5.deleted || !p5.countable)) {
        p5 = p5.left;
        if (p5 && !p5.deleted && p5.countable) {
          m.index -= p5.length;
        }
      }
      if (p5 === null || p5.marker === true) {
        searchMarker.splice(i2, 1);
        continue;
      }
      m.p = p5;
      p5.marker = true;
    }
    if (index4 < m.index || len > 0 && index4 === m.index) {
      m.index = max2(index4, m.index + len);
    }
  }
};
var callTypeObservers = (type, transaction, event) => {
  const changedType = type;
  const changedParentTypes = transaction.changedParentTypes;
  while (true) {
    setIfUndefined(changedParentTypes, type, () => []).push(event);
    if (type._item === null) {
      break;
    }
    type = /** @type {AbstractType<any>} */
    type._item.parent;
  }
  callEventHandlerListeners(changedType._eH, event, transaction);
};
var AbstractType = class {
  constructor() {
    this._item = null;
    this._map = /* @__PURE__ */ new Map();
    this._start = null;
    this.doc = null;
    this._length = 0;
    this._eH = createEventHandler();
    this._dEH = createEventHandler();
    this._searchMarker = null;
  }
  /**
   * @return {AbstractType<any>|null}
   */
  get parent() {
    return this._item ? (
      /** @type {AbstractType<any>} */
      this._item.parent
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */
  _integrate(y2, item) {
    this.doc = y2;
    this._item = item;
  }
  /**
   * @return {AbstractType<EventType>}
   */
  _copy() {
    throw methodUnimplemented();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {AbstractType<EventType>}
   */
  clone() {
    throw methodUnimplemented();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */
  _write(_encoder) {
  }
  /**
   * The first non-deleted item
   */
  get _first() {
    let n = this._start;
    while (n !== null && n.deleted) {
      n = n.right;
    }
    return n;
  }
  /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, _parentSubs) {
    if (!transaction.local && this._searchMarker) {
      this._searchMarker.length = 0;
    }
  }
  /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */
  observe(f2) {
    addEventHandlerListener(this._eH, f2);
  }
  /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  observeDeep(f2) {
    addEventHandlerListener(this._dEH, f2);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */
  unobserve(f2) {
    removeEventHandlerListener(this._eH, f2);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  unobserveDeep(f2) {
    removeEventHandlerListener(this._dEH, f2);
  }
  /**
   * @abstract
   * @return {any}
   */
  toJSON() {
  }
};
var typeListSlice = (type, start, end) => {
  type.doc ?? warnPrematureAccess();
  if (start < 0) {
    start = type._length + start;
  }
  if (end < 0) {
    end = type._length + end;
  }
  let len = end - start;
  const cs2 = [];
  let n = type._start;
  while (n !== null && len > 0) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      if (c.length <= start) {
        start -= c.length;
      } else {
        for (let i2 = start; i2 < c.length && len > 0; i2++) {
          cs2.push(c[i2]);
          len--;
        }
        start = 0;
      }
    }
    n = n.right;
  }
  return cs2;
};
var typeListToArray = (type) => {
  type.doc ?? warnPrematureAccess();
  const cs2 = [];
  let n = type._start;
  while (n !== null) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      for (let i2 = 0; i2 < c.length; i2++) {
        cs2.push(c[i2]);
      }
    }
    n = n.right;
  }
  return cs2;
};
var typeListToArraySnapshot = (type, snapshot2) => {
  const cs2 = [];
  let n = type._start;
  while (n !== null) {
    if (n.countable && isVisible(n, snapshot2)) {
      const c = n.content.getContent();
      for (let i2 = 0; i2 < c.length; i2++) {
        cs2.push(c[i2]);
      }
    }
    n = n.right;
  }
  return cs2;
};
var typeListForEach = (type, f2) => {
  let index4 = 0;
  let n = type._start;
  type.doc ?? warnPrematureAccess();
  while (n !== null) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      for (let i2 = 0; i2 < c.length; i2++) {
        f2(c[i2], index4++, type);
      }
    }
    n = n.right;
  }
};
var typeListMap = (type, f2) => {
  const result = [];
  typeListForEach(type, (c, i2) => {
    result.push(f2(c, i2, type));
  });
  return result;
};
var typeListCreateIterator = (type) => {
  let n = type._start;
  let currentContent = null;
  let currentContentIndex = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: () => {
      if (currentContent === null) {
        while (n !== null && n.deleted) {
          n = n.right;
        }
        if (n === null) {
          return {
            done: true,
            value: void 0
          };
        }
        currentContent = n.content.getContent();
        currentContentIndex = 0;
        n = n.right;
      }
      const value = currentContent[currentContentIndex++];
      if (currentContent.length <= currentContentIndex) {
        currentContent = null;
      }
      return {
        done: false,
        value
      };
    }
  };
};
var typeListGet = (type, index4) => {
  type.doc ?? warnPrematureAccess();
  const marker = findMarker(type, index4);
  let n = type._start;
  if (marker !== null) {
    n = marker.p;
    index4 -= marker.index;
  }
  for (; n !== null; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index4 < n.length) {
        return n.content.getContent()[index4];
      }
      index4 -= n.length;
    }
  }
};
var typeListInsertGenericsAfter = (transaction, parent, referenceItem, content5) => {
  let left = referenceItem;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  const store = doc2.store;
  const right = referenceItem === null ? parent._start : referenceItem.right;
  let jsonContent = [];
  const packJsonContent = () => {
    if (jsonContent.length > 0) {
      left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));
      left.integrate(transaction, 0);
      jsonContent = [];
    }
  };
  content5.forEach((c) => {
    if (c === null) {
      jsonContent.push(c);
    } else {
      switch (c.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          jsonContent.push(c);
          break;
        default:
          packJsonContent();
          switch (c.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(
                /** @type {Uint8Array} */
                c
              )));
              left.integrate(transaction, 0);
              break;
            case Doc:
              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(
                /** @type {Doc} */
                c
              ));
              left.integrate(transaction, 0);
              break;
            default:
              if (c instanceof AbstractType) {
                left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c));
                left.integrate(transaction, 0);
              } else {
                throw new Error("Unexpected content type in insert operation");
              }
          }
      }
    }
  });
  packJsonContent();
};
var lengthExceeded = () => create3("Length exceeded!");
var typeListInsertGenerics = (transaction, parent, index4, content5) => {
  if (index4 > parent._length) {
    throw lengthExceeded();
  }
  if (index4 === 0) {
    if (parent._searchMarker) {
      updateMarkerChanges(parent._searchMarker, index4, content5.length);
    }
    return typeListInsertGenericsAfter(transaction, parent, null, content5);
  }
  const startIndex = index4;
  const marker = findMarker(parent, index4);
  let n = parent._start;
  if (marker !== null) {
    n = marker.p;
    index4 -= marker.index;
    if (index4 === 0) {
      n = n.prev;
      index4 += n && n.countable && !n.deleted ? n.length : 0;
    }
  }
  for (; n !== null; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index4 <= n.length) {
        if (index4 < n.length) {
          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index4));
        }
        break;
      }
      index4 -= n.length;
    }
  }
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, startIndex, content5.length);
  }
  return typeListInsertGenericsAfter(transaction, parent, n, content5);
};
var typeListPushGenerics = (transaction, parent, content5) => {
  const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker) => currMarker.index > maxMarker.index ? currMarker : maxMarker, { index: 0, p: parent._start });
  let n = marker.p;
  if (n) {
    while (n.right) {
      n = n.right;
    }
  }
  return typeListInsertGenericsAfter(transaction, parent, n, content5);
};
var typeListDelete = (transaction, parent, index4, length3) => {
  if (length3 === 0) {
    return;
  }
  const startIndex = index4;
  const startLength = length3;
  const marker = findMarker(parent, index4);
  let n = parent._start;
  if (marker !== null) {
    n = marker.p;
    index4 -= marker.index;
  }
  for (; n !== null && index4 > 0; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index4 < n.length) {
        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index4));
      }
      index4 -= n.length;
    }
  }
  while (length3 > 0 && n !== null) {
    if (!n.deleted) {
      if (length3 < n.length) {
        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length3));
      }
      n.delete(transaction);
      length3 -= n.length;
    }
    n = n.right;
  }
  if (length3 > 0) {
    throw lengthExceeded();
  }
  if (parent._searchMarker) {
    updateMarkerChanges(
      parent._searchMarker,
      startIndex,
      -startLength + length3
      /* in case we remove the above exception */
    );
  }
};
var typeMapDelete = (transaction, parent, key2) => {
  const c = parent._map.get(key2);
  if (c !== void 0) {
    c.delete(transaction);
  }
};
var typeMapSet = (transaction, parent, key2, value) => {
  const left = parent._map.get(key2) || null;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  let content5;
  if (value == null) {
    content5 = new ContentAny([value]);
  } else {
    switch (value.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
      case Date:
      case BigInt:
        content5 = new ContentAny([value]);
        break;
      case Uint8Array:
        content5 = new ContentBinary(
          /** @type {Uint8Array} */
          value
        );
        break;
      case Doc:
        content5 = new ContentDoc(
          /** @type {Doc} */
          value
        );
        break;
      default:
        if (value instanceof AbstractType) {
          content5 = new ContentType(value);
        } else {
          throw new Error("Unexpected content type");
        }
    }
  }
  new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, null, null, parent, key2, content5).integrate(transaction, 0);
};
var typeMapGet = (parent, key2) => {
  parent.doc ?? warnPrematureAccess();
  const val = parent._map.get(key2);
  return val !== void 0 && !val.deleted ? val.content.getContent()[val.length - 1] : void 0;
};
var typeMapGetAll = (parent) => {
  const res = {};
  parent.doc ?? warnPrematureAccess();
  parent._map.forEach((value, key2) => {
    if (!value.deleted) {
      res[key2] = value.content.getContent()[value.length - 1];
    }
  });
  return res;
};
var typeMapHas = (parent, key2) => {
  parent.doc ?? warnPrematureAccess();
  const val = parent._map.get(key2);
  return val !== void 0 && !val.deleted;
};
var typeMapGetAllSnapshot = (parent, snapshot2) => {
  const res = {};
  parent._map.forEach((value, key2) => {
    let v2 = value;
    while (v2 !== null && (!snapshot2.sv.has(v2.id.client) || v2.id.clock >= (snapshot2.sv.get(v2.id.client) || 0))) {
      v2 = v2.left;
    }
    if (v2 !== null && isVisible(v2, snapshot2)) {
      res[key2] = v2.content.getContent()[v2.length - 1];
    }
  });
  return res;
};
var createMapIterator = (type) => {
  type.doc ?? warnPrematureAccess();
  return iteratorFilter(
    type._map.entries(),
    /** @param {any} entry */
    (entry) => !entry[1].deleted
  );
};
var YArrayEvent = class extends YEvent {
};
var YArray = class _YArray extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
    this._searchMarker = [];
  }
  /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */
  static from(items) {
    const a2 = new _YArray();
    a2.push(items);
    return a2;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y2, item) {
    super._integrate(y2, item);
    this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    );
    this._prelimContent = null;
  }
  /**
   * @return {YArray<T>}
   */
  _copy() {
    return new _YArray();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YArray<T>}
   */
  clone() {
    const arr = new _YArray();
    arr.insert(0, this.toArray().map(
      (el2) => el2 instanceof AbstractType ? (
        /** @type {typeof el} */
        el2.clone()
      ) : el2
    ));
    return arr;
  }
  get length() {
    this.doc ?? warnPrematureAccess();
    return this._length;
  }
  /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    callTypeObservers(this, transaction, new YArrayEvent(this, transaction));
  }
  /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */
  insert(index4, content5) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(
          transaction,
          this,
          index4,
          /** @type {any} */
          content5
        );
      });
    } else {
      this._prelimContent.splice(index4, 0, ...content5);
    }
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */
  push(content5) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListPushGenerics(
          transaction,
          this,
          /** @type {any} */
          content5
        );
      });
    } else {
      this._prelimContent.push(...content5);
    }
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<T>} content Array of content to prepend.
   */
  unshift(content5) {
    this.insert(0, content5);
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */
  delete(index4, length3 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index4, length3);
      });
    } else {
      this._prelimContent.splice(index4, length3);
    }
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */
  get(index4) {
    return typeListGet(this, index4);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */
  toArray() {
    return typeListToArray(this);
  }
  /**
   * Returns a portion of this YArray into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */
  slice(start = 0, end = this.length) {
    return typeListSlice(this, start, end);
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */
  toJSON() {
    return this.map((c) => c instanceof AbstractType ? c.toJSON() : c);
  }
  /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */
  map(f2) {
    return typeListMap(
      this,
      /** @type {any} */
      f2
    );
  }
  /**
   * Executes a provided function once on every element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */
  forEach(f2) {
    typeListForEach(this, f2);
  }
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return typeListCreateIterator(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YArrayRefID);
  }
};
var readYArray = (_decoder) => new YArray();
var YMapEvent = class extends YEvent {
  /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */
  constructor(ymap, transaction, subs) {
    super(ymap, transaction);
    this.keysChanged = subs;
  }
};
var YMap = class _YMap extends AbstractType {
  /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */
  constructor(entries) {
    super();
    this._prelimContent = null;
    if (entries === void 0) {
      this._prelimContent = /* @__PURE__ */ new Map();
    } else {
      this._prelimContent = new Map(entries);
    }
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y2, item) {
    super._integrate(y2, item);
    this._prelimContent.forEach((value, key2) => {
      this.set(key2, value);
    });
    this._prelimContent = null;
  }
  /**
   * @return {YMap<MapType>}
   */
  _copy() {
    return new _YMap();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YMap<MapType>}
   */
  clone() {
    const map6 = new _YMap();
    this.forEach((value, key2) => {
      map6.set(key2, value instanceof AbstractType ? (
        /** @type {typeof value} */
        value.clone()
      ) : value);
    });
    return map6;
  }
  /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */
  toJSON() {
    this.doc ?? warnPrematureAccess();
    const map6 = {};
    this._map.forEach((item, key2) => {
      if (!item.deleted) {
        const v2 = item.content.getContent()[item.length - 1];
        map6[key2] = v2 instanceof AbstractType ? v2.toJSON() : v2;
      }
    });
    return map6;
  }
  /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */
  get size() {
    return [...createMapIterator(this)].length;
  }
  /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */
  keys() {
    return iteratorMap(
      createMapIterator(this),
      /** @param {any} v */
      (v2) => v2[0]
    );
  }
  /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<MapType>}
   */
  values() {
    return iteratorMap(
      createMapIterator(this),
      /** @param {any} v */
      (v2) => v2[1].content.getContent()[v2[1].length - 1]
    );
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  entries() {
    return iteratorMap(
      createMapIterator(this),
      /** @param {any} v */
      (v2) => (
        /** @type {any} */
        [v2[0], v2[1].content.getContent()[v2[1].length - 1]]
      )
    );
  }
  /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */
  forEach(f2) {
    this.doc ?? warnPrematureAccess();
    this._map.forEach((item, key2) => {
      if (!item.deleted) {
        f2(item.content.getContent()[item.length - 1], key2, this);
      }
    });
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */
  delete(key2) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, key2);
      });
    } else {
      this._prelimContent.delete(key2);
    }
  }
  /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */
  set(key2, value) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(
          transaction,
          this,
          key2,
          /** @type {any} */
          value
        );
      });
    } else {
      this._prelimContent.set(key2, value);
    }
    return value;
  }
  /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */
  get(key2) {
    return (
      /** @type {any} */
      typeMapGet(this, key2)
    );
  }
  /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */
  has(key2) {
    return typeMapHas(this, key2);
  }
  /**
   * Removes all elements from this YMap.
   */
  clear() {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        this.forEach(function(_value, key2, map6) {
          typeMapDelete(transaction, map6, key2);
        });
      });
    } else {
      this._prelimContent.clear();
    }
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YMapRefID);
  }
};
var readYMap = (_decoder) => new YMap();
var equalAttrs = (a2, b2) => a2 === b2 || typeof a2 === "object" && typeof b2 === "object" && a2 && b2 && equalFlat(a2, b2);
var ItemTextListPosition = class {
  /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */
  constructor(left, right, index4, currentAttributes) {
    this.left = left;
    this.right = right;
    this.index = index4;
    this.currentAttributes = currentAttributes;
  }
  /**
   * Only call this if you know that this.right is defined
   */
  forward() {
    if (this.right === null) {
      unexpectedCase();
    }
    switch (this.right.content.constructor) {
      case ContentFormat:
        if (!this.right.deleted) {
          updateCurrentAttributes(
            this.currentAttributes,
            /** @type {ContentFormat} */
            this.right.content
          );
        }
        break;
      default:
        if (!this.right.deleted) {
          this.index += this.right.length;
        }
        break;
    }
    this.left = this.right;
    this.right = this.right.right;
  }
};
var findNextPosition = (transaction, pos, count2) => {
  while (pos.right !== null && count2 > 0) {
    switch (pos.right.content.constructor) {
      case ContentFormat:
        if (!pos.right.deleted) {
          updateCurrentAttributes(
            pos.currentAttributes,
            /** @type {ContentFormat} */
            pos.right.content
          );
        }
        break;
      default:
        if (!pos.right.deleted) {
          if (count2 < pos.right.length) {
            getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count2));
          }
          pos.index += pos.right.length;
          count2 -= pos.right.length;
        }
        break;
    }
    pos.left = pos.right;
    pos.right = pos.right.right;
  }
  return pos;
};
var findPosition = (transaction, parent, index4, useSearchMarker) => {
  const currentAttributes = /* @__PURE__ */ new Map();
  const marker = useSearchMarker ? findMarker(parent, index4) : null;
  if (marker) {
    const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);
    return findNextPosition(transaction, pos, index4 - marker.index);
  } else {
    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);
    return findNextPosition(transaction, pos, index4);
  }
};
var insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {
  while (currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === ContentFormat && equalAttrs(
    negatedAttributes.get(
      /** @type {ContentFormat} */
      currPos.right.content.key
    ),
    /** @type {ContentFormat} */
    currPos.right.content.value
  ))) {
    if (!currPos.right.deleted) {
      negatedAttributes.delete(
        /** @type {ContentFormat} */
        currPos.right.content.key
      );
    }
    currPos.forward();
  }
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  negatedAttributes.forEach((val, key2) => {
    const left = currPos.left;
    const right = currPos.right;
    const nextFormat = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key2, val));
    nextFormat.integrate(transaction, 0);
    currPos.right = nextFormat;
    currPos.forward();
  });
};
var updateCurrentAttributes = (currentAttributes, format) => {
  const { key: key2, value } = format;
  if (value === null) {
    currentAttributes.delete(key2);
  } else {
    currentAttributes.set(key2, value);
  }
};
var minimizeAttributeChanges = (currPos, attributes) => {
  while (true) {
    if (currPos.right === null) {
      break;
    } else if (currPos.right.deleted || currPos.right.content.constructor === ContentFormat && equalAttrs(
      attributes[
        /** @type {ContentFormat} */
        currPos.right.content.key
      ] ?? null,
      /** @type {ContentFormat} */
      currPos.right.content.value
    )) ;
    else {
      break;
    }
    currPos.forward();
  }
};
var insertAttributes = (transaction, parent, currPos, attributes) => {
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  const negatedAttributes = /* @__PURE__ */ new Map();
  for (const key2 in attributes) {
    const val = attributes[key2];
    const currentVal = currPos.currentAttributes.get(key2) ?? null;
    if (!equalAttrs(currentVal, val)) {
      negatedAttributes.set(key2, currentVal);
      const { left, right } = currPos;
      currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key2, val));
      currPos.right.integrate(transaction, 0);
      currPos.forward();
    }
  }
  return negatedAttributes;
};
var insertText = (transaction, parent, currPos, text10, attributes) => {
  currPos.currentAttributes.forEach((_val, key2) => {
    if (attributes[key2] === void 0) {
      attributes[key2] = null;
    }
  });
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  const content5 = text10.constructor === String ? new ContentString(
    /** @type {string} */
    text10
  ) : text10 instanceof AbstractType ? new ContentType(text10) : new ContentEmbed(text10);
  let { left, right, index: index4 } = currPos;
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, content5.getLength());
  }
  right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content5);
  right.integrate(transaction, 0);
  currPos.right = right;
  currPos.index = index4;
  currPos.forward();
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
var formatText = (transaction, parent, currPos, length3, attributes) => {
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  iterationLoop: while (currPos.right !== null && (length3 > 0 || negatedAttributes.size > 0 && (currPos.right.deleted || currPos.right.content.constructor === ContentFormat))) {
    if (!currPos.right.deleted) {
      switch (currPos.right.content.constructor) {
        case ContentFormat: {
          const { key: key2, value } = (
            /** @type {ContentFormat} */
            currPos.right.content
          );
          const attr2 = attributes[key2];
          if (attr2 !== void 0) {
            if (equalAttrs(attr2, value)) {
              negatedAttributes.delete(key2);
            } else {
              if (length3 === 0) {
                break iterationLoop;
              }
              negatedAttributes.set(key2, value);
            }
            currPos.right.delete(transaction);
          } else {
            currPos.currentAttributes.set(key2, value);
          }
          break;
        }
        default:
          if (length3 < currPos.right.length) {
            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length3));
          }
          length3 -= currPos.right.length;
          break;
      }
    }
    currPos.forward();
  }
  if (length3 > 0) {
    let newlines = "";
    for (; length3 > 0; length3--) {
      newlines += "\n";
    }
    currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));
    currPos.right.integrate(transaction, 0);
    currPos.forward();
  }
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
var cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes) => {
  let end = start;
  const endFormats = create();
  while (end && (!end.countable || end.deleted)) {
    if (!end.deleted && end.content.constructor === ContentFormat) {
      const cf = (
        /** @type {ContentFormat} */
        end.content
      );
      endFormats.set(cf.key, cf);
    }
    end = end.right;
  }
  let cleanups = 0;
  let reachedCurr = false;
  while (start !== end) {
    if (curr === start) {
      reachedCurr = true;
    }
    if (!start.deleted) {
      const content5 = start.content;
      switch (content5.constructor) {
        case ContentFormat: {
          const { key: key2, value } = (
            /** @type {ContentFormat} */
            content5
          );
          const startAttrValue = startAttributes.get(key2) ?? null;
          if (endFormats.get(key2) !== content5 || startAttrValue === value) {
            start.delete(transaction);
            cleanups++;
            if (!reachedCurr && (currAttributes.get(key2) ?? null) === value && startAttrValue !== value) {
              if (startAttrValue === null) {
                currAttributes.delete(key2);
              } else {
                currAttributes.set(key2, startAttrValue);
              }
            }
          }
          if (!reachedCurr && !start.deleted) {
            updateCurrentAttributes(
              currAttributes,
              /** @type {ContentFormat} */
              content5
            );
          }
          break;
        }
      }
    }
    start = /** @type {Item} */
    start.right;
  }
  return cleanups;
};
var cleanupContextlessFormattingGap = (transaction, item) => {
  while (item && item.right && (item.right.deleted || !item.right.countable)) {
    item = item.right;
  }
  const attrs = /* @__PURE__ */ new Set();
  while (item && (item.deleted || !item.countable)) {
    if (!item.deleted && item.content.constructor === ContentFormat) {
      const key2 = (
        /** @type {ContentFormat} */
        item.content.key
      );
      if (attrs.has(key2)) {
        item.delete(transaction);
      } else {
        attrs.add(key2);
      }
    }
    item = item.left;
  }
};
var cleanupYTextFormatting = (type) => {
  let res = 0;
  transact(
    /** @type {Doc} */
    type.doc,
    (transaction) => {
      let start = (
        /** @type {Item} */
        type._start
      );
      let end = type._start;
      let startAttributes = create();
      const currentAttributes = copy(startAttributes);
      while (end) {
        if (end.deleted === false) {
          switch (end.content.constructor) {
            case ContentFormat:
              updateCurrentAttributes(
                currentAttributes,
                /** @type {ContentFormat} */
                end.content
              );
              break;
            default:
              res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);
              startAttributes = copy(currentAttributes);
              start = end;
              break;
          }
        }
        end = end.right;
      }
    }
  );
  return res;
};
var cleanupYTextAfterTransaction = (transaction) => {
  const needFullCleanup = /* @__PURE__ */ new Set();
  const doc2 = transaction.doc;
  for (const [client, afterClock] of transaction.afterState.entries()) {
    const clock = transaction.beforeState.get(client) || 0;
    if (afterClock === clock) {
      continue;
    }
    iterateStructs(
      transaction,
      /** @type {Array<Item|GC>} */
      doc2.store.clients.get(client),
      clock,
      afterClock,
      (item) => {
        if (!item.deleted && /** @type {Item} */
        item.content.constructor === ContentFormat && item.constructor !== GC) {
          needFullCleanup.add(
            /** @type {any} */
            item.parent
          );
        }
      }
    );
  }
  transact(doc2, (t) => {
    iterateDeletedStructs(transaction, transaction.deleteSet, (item) => {
      if (item instanceof GC || !/** @type {YText} */
      item.parent._hasFormatting || needFullCleanup.has(
        /** @type {YText} */
        item.parent
      )) {
        return;
      }
      const parent = (
        /** @type {YText} */
        item.parent
      );
      if (item.content.constructor === ContentFormat) {
        needFullCleanup.add(parent);
      } else {
        cleanupContextlessFormattingGap(t, item);
      }
    });
    for (const yText of needFullCleanup) {
      cleanupYTextFormatting(yText);
    }
  });
};
var deleteText = (transaction, currPos, length3) => {
  const startLength = length3;
  const startAttrs = copy(currPos.currentAttributes);
  const start = currPos.right;
  while (length3 > 0 && currPos.right !== null) {
    if (currPos.right.deleted === false) {
      switch (currPos.right.content.constructor) {
        case ContentType:
        case ContentEmbed:
        case ContentString:
          if (length3 < currPos.right.length) {
            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length3));
          }
          length3 -= currPos.right.length;
          currPos.right.delete(transaction);
          break;
      }
    }
    currPos.forward();
  }
  if (start) {
    cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);
  }
  const parent = (
    /** @type {AbstractType<any>} */
    /** @type {Item} */
    (currPos.left || currPos.right).parent
  );
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length3);
  }
  return currPos;
};
var YTextEvent = class extends YEvent {
  /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */
  constructor(ytext, transaction, subs) {
    super(ytext, transaction);
    this.childListChanged = false;
    this.keysChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub) => {
      if (sub === null) {
        this.childListChanged = true;
      } else {
        this.keysChanged.add(sub);
      }
    });
  }
  /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    if (this._changes === null) {
      const changes = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = changes;
    }
    return (
      /** @type {any} */
      this._changes
    );
  }
  /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */
  get delta() {
    if (this._delta === null) {
      const y2 = (
        /** @type {Doc} */
        this.target.doc
      );
      const delta = [];
      transact(y2, (transaction) => {
        const currentAttributes = /* @__PURE__ */ new Map();
        const oldAttributes = /* @__PURE__ */ new Map();
        let item = this.target._start;
        let action = null;
        const attributes = {};
        let insert = "";
        let retain = 0;
        let deleteLen = 0;
        const addOp = () => {
          if (action !== null) {
            let op = null;
            switch (action) {
              case "delete":
                if (deleteLen > 0) {
                  op = { delete: deleteLen };
                }
                deleteLen = 0;
                break;
              case "insert":
                if (typeof insert === "object" || insert.length > 0) {
                  op = { insert };
                  if (currentAttributes.size > 0) {
                    op.attributes = {};
                    currentAttributes.forEach((value, key2) => {
                      if (value !== null) {
                        op.attributes[key2] = value;
                      }
                    });
                  }
                }
                insert = "";
                break;
              case "retain":
                if (retain > 0) {
                  op = { retain };
                  if (!isEmpty2(attributes)) {
                    op.attributes = assign({}, attributes);
                  }
                }
                retain = 0;
                break;
            }
            if (op) delta.push(op);
            action = null;
          }
        };
        while (item !== null) {
          switch (item.content.constructor) {
            case ContentType:
            case ContentEmbed:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  addOp();
                  action = "insert";
                  insert = item.content.getContent()[0];
                  addOp();
                }
              } else if (this.deletes(item)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += 1;
              } else if (!item.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += 1;
              }
              break;
            case ContentString:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  if (action !== "insert") {
                    addOp();
                    action = "insert";
                  }
                  insert += /** @type {ContentString} */
                  item.content.str;
                }
              } else if (this.deletes(item)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += item.length;
              } else if (!item.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += item.length;
              }
              break;
            case ContentFormat: {
              const { key: key2, value } = (
                /** @type {ContentFormat} */
                item.content
              );
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  const curVal = currentAttributes.get(key2) ?? null;
                  if (!equalAttrs(curVal, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (equalAttrs(value, oldAttributes.get(key2) ?? null)) {
                      delete attributes[key2];
                    } else {
                      attributes[key2] = value;
                    }
                  } else if (value !== null) {
                    item.delete(transaction);
                  }
                }
              } else if (this.deletes(item)) {
                oldAttributes.set(key2, value);
                const curVal = currentAttributes.get(key2) ?? null;
                if (!equalAttrs(curVal, value)) {
                  if (action === "retain") {
                    addOp();
                  }
                  attributes[key2] = curVal;
                }
              } else if (!item.deleted) {
                oldAttributes.set(key2, value);
                const attr2 = attributes[key2];
                if (attr2 !== void 0) {
                  if (!equalAttrs(attr2, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (value === null) {
                      delete attributes[key2];
                    } else {
                      attributes[key2] = value;
                    }
                  } else if (attr2 !== null) {
                    item.delete(transaction);
                  }
                }
              }
              if (!item.deleted) {
                if (action === "insert") {
                  addOp();
                }
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  item.content
                );
              }
              break;
            }
          }
          item = item.right;
        }
        addOp();
        while (delta.length > 0) {
          const lastOp = delta[delta.length - 1];
          if (lastOp.retain !== void 0 && lastOp.attributes === void 0) {
            delta.pop();
          } else {
            break;
          }
        }
      });
      this._delta = delta;
    }
    return (
      /** @type {any} */
      this._delta
    );
  }
};
var YText = class _YText extends AbstractType {
  /**
   * @param {String} [string] The initial value of the YText.
   */
  constructor(string3) {
    super();
    this._pending = string3 !== void 0 ? [() => this.insert(0, string3)] : [];
    this._searchMarker = [];
    this._hasFormatting = false;
  }
  /**
   * Number of characters of this text type.
   *
   * @type {number}
   */
  get length() {
    this.doc ?? warnPrematureAccess();
    return this._length;
  }
  /**
   * @param {Doc} y
   * @param {Item} item
   */
  _integrate(y2, item) {
    super._integrate(y2, item);
    try {
      this._pending.forEach((f2) => f2());
    } catch (e) {
      console.error(e);
    }
    this._pending = null;
  }
  _copy() {
    return new _YText();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YText}
   */
  clone() {
    const text10 = new _YText();
    text10.applyDelta(this.toDelta());
    return text10;
  }
  /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    const event = new YTextEvent(this, transaction, parentSubs);
    callTypeObservers(this, transaction, event);
    if (!transaction.local && this._hasFormatting) {
      transaction._needFormattingCleanup = true;
    }
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */
  toString() {
    this.doc ?? warnPrematureAccess();
    let str = "";
    let n = this._start;
    while (n !== null) {
      if (!n.deleted && n.countable && n.content.constructor === ContentString) {
        str += /** @type {ContentString} */
        n.content.str;
      }
      n = n.right;
    }
    return str;
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {Array<any>} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */
  applyDelta(delta, { sanitize = true } = {}) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const currPos = new ItemTextListPosition(null, this._start, 0, /* @__PURE__ */ new Map());
        for (let i2 = 0; i2 < delta.length; i2++) {
          const op = delta[i2];
          if (op.insert !== void 0) {
            const ins = !sanitize && typeof op.insert === "string" && i2 === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === "\n" ? op.insert.slice(0, -1) : op.insert;
            if (typeof ins !== "string" || ins.length > 0) {
              insertText(transaction, this, currPos, ins, op.attributes || {});
            }
          } else if (op.retain !== void 0) {
            formatText(transaction, this, currPos, op.retain, op.attributes || {});
          } else if (op.delete !== void 0) {
            deleteText(transaction, currPos, op.delete);
          }
        }
      });
    } else {
      this._pending.push(() => this.applyDelta(delta));
    }
  }
  /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */
  toDelta(snapshot2, prevSnapshot, computeYChange) {
    this.doc ?? warnPrematureAccess();
    const ops = [];
    const currentAttributes = /* @__PURE__ */ new Map();
    const doc2 = (
      /** @type {Doc} */
      this.doc
    );
    let str = "";
    let n = this._start;
    function packStr() {
      if (str.length > 0) {
        const attributes = {};
        let addAttributes = false;
        currentAttributes.forEach((value, key2) => {
          addAttributes = true;
          attributes[key2] = value;
        });
        const op = { insert: str };
        if (addAttributes) {
          op.attributes = attributes;
        }
        ops.push(op);
        str = "";
      }
    }
    const computeDelta = () => {
      while (n !== null) {
        if (isVisible(n, snapshot2) || prevSnapshot !== void 0 && isVisible(n, prevSnapshot)) {
          switch (n.content.constructor) {
            case ContentString: {
              const cur = currentAttributes.get("ychange");
              if (snapshot2 !== void 0 && !isVisible(n, snapshot2)) {
                if (cur === void 0 || cur.user !== n.id.client || cur.type !== "removed") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("removed", n.id) : { type: "removed" });
                }
              } else if (prevSnapshot !== void 0 && !isVisible(n, prevSnapshot)) {
                if (cur === void 0 || cur.user !== n.id.client || cur.type !== "added") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("added", n.id) : { type: "added" });
                }
              } else if (cur !== void 0) {
                packStr();
                currentAttributes.delete("ychange");
              }
              str += /** @type {ContentString} */
              n.content.str;
              break;
            }
            case ContentType:
            case ContentEmbed: {
              packStr();
              const op = {
                insert: n.content.getContent()[0]
              };
              if (currentAttributes.size > 0) {
                const attrs = (
                  /** @type {Object<string,any>} */
                  {}
                );
                op.attributes = attrs;
                currentAttributes.forEach((value, key2) => {
                  attrs[key2] = value;
                });
              }
              ops.push(op);
              break;
            }
            case ContentFormat:
              if (isVisible(n, snapshot2)) {
                packStr();
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  n.content
                );
              }
              break;
          }
        }
        n = n.right;
      }
      packStr();
    };
    if (snapshot2 || prevSnapshot) {
      transact(doc2, (transaction) => {
        if (snapshot2) {
          splitSnapshotAffectedStructs(transaction, snapshot2);
        }
        if (prevSnapshot) {
          splitSnapshotAffectedStructs(transaction, prevSnapshot);
        }
        computeDelta();
      }, "cleanup");
    } else {
      computeDelta();
    }
    return ops;
  }
  /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */
  insert(index4, text10, attributes) {
    if (text10.length <= 0) {
      return;
    }
    const y2 = this.doc;
    if (y2 !== null) {
      transact(y2, (transaction) => {
        const pos = findPosition(transaction, this, index4, !attributes);
        if (!attributes) {
          attributes = {};
          pos.currentAttributes.forEach((v2, k2) => {
            attributes[k2] = v2;
          });
        }
        insertText(transaction, this, pos, text10, attributes);
      });
    } else {
      this._pending.push(() => this.insert(index4, text10, attributes));
    }
  }
  /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} [attributes] Attribute information to apply on the
   *                                    embed
   *
   * @public
   */
  insertEmbed(index4, embed, attributes) {
    const y2 = this.doc;
    if (y2 !== null) {
      transact(y2, (transaction) => {
        const pos = findPosition(transaction, this, index4, !attributes);
        insertText(transaction, this, pos, embed, attributes || {});
      });
    } else {
      this._pending.push(() => this.insertEmbed(index4, embed, attributes || {}));
    }
  }
  /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */
  delete(index4, length3) {
    if (length3 === 0) {
      return;
    }
    const y2 = this.doc;
    if (y2 !== null) {
      transact(y2, (transaction) => {
        deleteText(transaction, findPosition(transaction, this, index4, true), length3);
      });
    } else {
      this._pending.push(() => this.delete(index4, length3));
    }
  }
  /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */
  format(index4, length3, attributes) {
    if (length3 === 0) {
      return;
    }
    const y2 = this.doc;
    if (y2 !== null) {
      transact(y2, (transaction) => {
        const pos = findPosition(transaction, this, index4, false);
        if (pos.right === null) {
          return;
        }
        formatText(transaction, this, pos, length3, attributes);
      });
    } else {
      this._pending.push(() => this.format(index4, length3, attributes));
    }
  }
  /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._pending.push(() => this.removeAttribute(attributeName));
    }
  }
  /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._pending.push(() => this.setAttribute(attributeName, attributeValue));
    }
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */
  getAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapGet(this, attributeName)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return typeMapGetAll(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YTextRefID);
  }
};
var readYText = (_decoder) => new YText();
var YXmlTreeWalker = class {
  /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */
  constructor(root6, f2 = () => true) {
    this._filter = f2;
    this._root = root6;
    this._currentNode = /** @type {Item} */
    root6._start;
    this._firstCall = true;
    root6.doc ?? warnPrematureAccess();
  }
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */
  next() {
    let n = this._currentNode;
    let type = n && n.content && /** @type {any} */
    n.content.type;
    if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) {
      do {
        type = /** @type {any} */
        n.content.type;
        if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {
          n = type._start;
        } else {
          while (n !== null) {
            const nxt = n.next;
            if (nxt !== null) {
              n = nxt;
              break;
            } else if (n.parent === this._root) {
              n = null;
            } else {
              n = /** @type {AbstractType<any>} */
              n.parent._item;
            }
          }
        }
      } while (n !== null && (n.deleted || !this._filter(
        /** @type {ContentType} */
        n.content.type
      )));
    }
    this._firstCall = false;
    if (n === null) {
      return { value: void 0, done: true };
    }
    this._currentNode = n;
    return { value: (
      /** @type {any} */
      n.content.type
    ), done: false };
  }
};
var YXmlFragment = class _YXmlFragment extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get firstChild() {
    const first2 = this._first;
    return first2 ? first2.content.getContent()[0] : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y2, item) {
    super._integrate(y2, item);
    this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    );
    this._prelimContent = null;
  }
  _copy() {
    return new _YXmlFragment();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlFragment}
   */
  clone() {
    const el2 = new _YXmlFragment();
    el2.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el2;
  }
  get length() {
    this.doc ?? warnPrematureAccess();
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */
  createTreeWalker(filter) {
    return new YXmlTreeWalker(this, filter);
  }
  /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */
  querySelector(query) {
    query = query.toUpperCase();
    const iterator = new YXmlTreeWalker(this, (element7) => element7.nodeName && element7.nodeName.toUpperCase() === query);
    const next2 = iterator.next();
    if (next2.done) {
      return null;
    } else {
      return next2.value;
    }
  }
  /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */
  querySelectorAll(query) {
    query = query.toUpperCase();
    return from2(new YXmlTreeWalker(this, (element7) => element7.nodeName && element7.nodeName.toUpperCase() === query));
  }
  /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));
  }
  /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */
  toString() {
    return typeListMap(this, (xml2) => xml2.toString()).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const fragment = _document.createDocumentFragment();
    if (binding !== void 0) {
      binding._createAssociation(fragment, this);
    }
    typeListForEach(this, (xmlType) => {
      fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);
    });
    return fragment;
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insert(index4, content5) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(transaction, this, index4, content5);
      });
    } else {
      this._prelimContent.splice(index4, 0, ...content5);
    }
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insertAfter(ref, content5) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const refItem = ref && ref instanceof AbstractType ? ref._item : ref;
        typeListInsertGenericsAfter(transaction, this, refItem, content5);
      });
    } else {
      const pc = (
        /** @type {Array<any>} */
        this._prelimContent
      );
      const index4 = ref === null ? 0 : pc.findIndex((el2) => el2 === ref) + 1;
      if (index4 === 0 && ref !== null) {
        throw create3("Reference item not found");
      }
      pc.splice(index4, 0, ...content5);
    }
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */
  delete(index4, length3 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index4, length3);
      });
    } else {
      this._prelimContent.splice(index4, length3);
    }
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */
  toArray() {
    return typeListToArray(this);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */
  push(content5) {
    this.insert(this.length, content5);
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to prepend.
   */
  unshift(content5) {
    this.insert(0, content5);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */
  get(index4) {
    return typeListGet(this, index4);
  }
  /**
   * Returns a portion of this YXmlFragment into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */
  slice(start = 0, end = this.length) {
    return typeListSlice(this, start, end);
  }
  /**
   * Executes a provided function on once on every child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */
  forEach(f2) {
    typeListForEach(this, f2);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlFragmentRefID);
  }
};
var readYXmlFragment = (_decoder) => new YXmlFragment();
var YXmlElement = class _YXmlElement extends YXmlFragment {
  constructor(nodeName = "UNDEFINED") {
    super();
    this.nodeName = nodeName;
    this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const n = this._item ? this._item.next : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const n = this._item ? this._item.prev : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y2, item) {
    super._integrate(y2, item);
    /** @type {Map<string, any>} */
    this._prelimAttrs.forEach((value, key2) => {
      this.setAttribute(key2, value);
    });
    this._prelimAttrs = null;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */
  _copy() {
    return new _YXmlElement(this.nodeName);
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlElement<KV>}
   */
  clone() {
    const el2 = new _YXmlElement(this.nodeName);
    const attrs = this.getAttributes();
    forEach2(attrs, (value, key2) => {
      if (typeof value === "string") {
        el2.setAttribute(key2, value);
      }
    });
    el2.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el2;
  }
  /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */
  toString() {
    const attrs = this.getAttributes();
    const stringBuilder = [];
    const keys3 = [];
    for (const key2 in attrs) {
      keys3.push(key2);
    }
    keys3.sort();
    const keysLen = keys3.length;
    for (let i2 = 0; i2 < keysLen; i2++) {
      const key2 = keys3[i2];
      stringBuilder.push(key2 + '="' + attrs[key2] + '"');
    }
    const nodeName = this.nodeName.toLocaleLowerCase();
    const attrsString = stringBuilder.length > 0 ? " " + stringBuilder.join(" ") : "";
    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`;
  }
  /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._prelimAttrs.delete(attributeName);
    }
  }
  /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._prelimAttrs.set(attributeName, attributeValue);
    }
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */
  getAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapGet(this, attributeName)
    );
  }
  /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */
  hasAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapHas(this, attributeName)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @param {Snapshot} [snapshot]
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes(snapshot2) {
    return (
      /** @type {any} */
      snapshot2 ? typeMapGetAllSnapshot(this, snapshot2) : typeMapGetAll(this)
    );
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const dom = _document.createElement(this.nodeName);
    const attrs = this.getAttributes();
    for (const key2 in attrs) {
      const value = attrs[key2];
      if (typeof value === "string") {
        dom.setAttribute(key2, value);
      }
    }
    typeListForEach(this, (yxml) => {
      dom.appendChild(yxml.toDOM(_document, hooks, binding));
    });
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlElementRefID);
    encoder.writeKey(this.nodeName);
  }
};
var readYXmlElement = (decoder) => new YXmlElement(decoder.readKey());
var YXmlEvent = class extends YEvent {
  /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with which the
   *                                  change was created.
   */
  constructor(target, subs, transaction) {
    super(target, transaction);
    this.childListChanged = false;
    this.attributesChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub) => {
      if (sub === null) {
        this.childListChanged = true;
      } else {
        this.attributesChanged.add(sub);
      }
    });
  }
};
var YXmlHook = class _YXmlHook extends YMap {
  /**
   * @param {string} hookName nodeName of the Dom Node.
   */
  constructor(hookName) {
    super();
    this.hookName = hookName;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   */
  _copy() {
    return new _YXmlHook(this.hookName);
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlHook}
   */
  clone() {
    const el2 = new _YXmlHook(this.hookName);
    this.forEach((value, key2) => {
      el2.set(key2, value);
    });
    return el2;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type
   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const hook = hooks[this.hookName];
    let dom;
    if (hook !== void 0) {
      dom = hook.createDom(this);
    } else {
      dom = document.createElement(this.hookName);
    }
    dom.setAttribute("data-yjs-hook", this.hookName);
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlHookRefID);
    encoder.writeKey(this.hookName);
  }
};
var readYXmlHook = (decoder) => new YXmlHook(decoder.readKey());
var YXmlText = class _YXmlText extends YText {
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const n = this._item ? this._item.next : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const n = this._item ? this._item.prev : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  _copy() {
    return new _YXmlText();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlText}
   */
  clone() {
    const text10 = new _YXmlText();
    text10.applyDelta(this.toDelta());
    return text10;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlText.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks, binding) {
    const dom = _document.createTextNode(this.toString());
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  toString() {
    return this.toDelta().map((delta) => {
      const nestedNodes = [];
      for (const nodeName in delta.attributes) {
        const attrs = [];
        for (const key2 in delta.attributes[nodeName]) {
          attrs.push({ key: key2, value: delta.attributes[nodeName][key2] });
        }
        attrs.sort((a2, b2) => a2.key < b2.key ? -1 : 1);
        nestedNodes.push({ nodeName, attrs });
      }
      nestedNodes.sort((a2, b2) => a2.nodeName < b2.nodeName ? -1 : 1);
      let str = "";
      for (let i2 = 0; i2 < nestedNodes.length; i2++) {
        const node2 = nestedNodes[i2];
        str += `<${node2.nodeName}`;
        for (let j5 = 0; j5 < node2.attrs.length; j5++) {
          const attr2 = node2.attrs[j5];
          str += ` ${attr2.key}="${attr2.value}"`;
        }
        str += ">";
      }
      str += delta.insert;
      for (let i2 = nestedNodes.length - 1; i2 >= 0; i2--) {
        str += `</${nestedNodes[i2].nodeName}>`;
      }
      return str;
    }).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlTextRefID);
  }
};
var readYXmlText = (decoder) => new YXmlText();
var AbstractStruct = class {
  /**
   * @param {ID} id
   * @param {number} length
   */
  constructor(id2, length3) {
    this.id = id2;
    this.length = length3;
  }
  /**
   * @type {boolean}
   */
  get deleted() {
    throw methodUnimplemented();
  }
  /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} whether this merged with right
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */
  write(encoder, offset4, encodingRef) {
    throw methodUnimplemented();
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset4) {
    throw methodUnimplemented();
  }
};
var structGCRefNumber = 0;
var GC = class extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  /**
   * @param {GC} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset4) {
    if (offset4 > 0) {
      this.id.clock += offset4;
      this.length -= offset4;
    }
    addStruct(transaction.doc.store, this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset4) {
    encoder.writeInfo(structGCRefNumber);
    encoder.writeLen(this.length - offset4);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    return null;
  }
};
var ContentBinary = class _ContentBinary {
  /**
   * @param {Uint8Array} content
   */
  constructor(content5) {
    this.content = content5;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.content];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentBinary}
   */
  copy() {
    return new _ContentBinary(this.content);
  }
  /**
   * @param {number} offset
   * @return {ContentBinary}
   */
  splice(offset4) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentBinary} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset4) {
    encoder.writeBuf(this.content);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 3;
  }
};
var readContentBinary = (decoder) => new ContentBinary(decoder.readBuf());
var ContentDeleted = class _ContentDeleted {
  /**
   * @param {number} len
   */
  constructor(len) {
    this.len = len;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.len;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return false;
  }
  /**
   * @return {ContentDeleted}
   */
  copy() {
    return new _ContentDeleted(this.len);
  }
  /**
   * @param {number} offset
   * @return {ContentDeleted}
   */
  splice(offset4) {
    const right = new _ContentDeleted(this.len - offset4);
    this.len = offset4;
    return right;
  }
  /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.len += right.len;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);
    item.markDeleted();
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset4) {
    encoder.writeLen(this.len - offset4);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 1;
  }
};
var readContentDeleted = (decoder) => new ContentDeleted(decoder.readLen());
var createDocFromOpts = (guid, opts) => new Doc({ guid, ...opts, shouldLoad: opts.shouldLoad || opts.autoLoad || false });
var ContentDoc = class _ContentDoc {
  /**
   * @param {Doc} doc
   */
  constructor(doc2) {
    if (doc2._item) {
      console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid.");
    }
    this.doc = doc2;
    const opts = {};
    this.opts = opts;
    if (!doc2.gc) {
      opts.gc = false;
    }
    if (doc2.autoLoad) {
      opts.autoLoad = true;
    }
    if (doc2.meta !== null) {
      opts.meta = doc2.meta;
    }
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.doc];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentDoc}
   */
  copy() {
    return new _ContentDoc(createDocFromOpts(this.doc.guid, this.opts));
  }
  /**
   * @param {number} offset
   * @return {ContentDoc}
   */
  splice(offset4) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentDoc} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    this.doc._item = item;
    transaction.subdocsAdded.add(this.doc);
    if (this.doc.shouldLoad) {
      transaction.subdocsLoaded.add(this.doc);
    }
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
    if (transaction.subdocsAdded.has(this.doc)) {
      transaction.subdocsAdded.delete(this.doc);
    } else {
      transaction.subdocsRemoved.add(this.doc);
    }
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset4) {
    encoder.writeString(this.doc.guid);
    encoder.writeAny(this.opts);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 9;
  }
};
var readContentDoc = (decoder) => new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny()));
var ContentEmbed = class _ContentEmbed {
  /**
   * @param {Object} embed
   */
  constructor(embed) {
    this.embed = embed;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.embed];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentEmbed}
   */
  copy() {
    return new _ContentEmbed(this.embed);
  }
  /**
   * @param {number} offset
   * @return {ContentEmbed}
   */
  splice(offset4) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset4) {
    encoder.writeJSON(this.embed);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 5;
  }
};
var readContentEmbed = (decoder) => new ContentEmbed(decoder.readJSON());
var ContentFormat = class _ContentFormat {
  /**
   * @param {string} key
   * @param {Object} value
   */
  constructor(key2, value) {
    this.key = key2;
    this.value = value;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return false;
  }
  /**
   * @return {ContentFormat}
   */
  copy() {
    return new _ContentFormat(this.key, this.value);
  }
  /**
   * @param {number} _offset
   * @return {ContentFormat}
   */
  splice(_offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */
  mergeWith(_right) {
    return false;
  }
  /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */
  integrate(_transaction, item) {
    const p5 = (
      /** @type {YText} */
      item.parent
    );
    p5._searchMarker = null;
    p5._hasFormatting = true;
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset4) {
    encoder.writeKey(this.key);
    encoder.writeJSON(this.value);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 6;
  }
};
var readContentFormat = (decoder) => new ContentFormat(decoder.readKey(), decoder.readJSON());
var ContentJSON = class _ContentJSON {
  /**
   * @param {Array<any>} arr
   */
  constructor(arr) {
    this.arr = arr;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentJSON}
   */
  copy() {
    return new _ContentJSON(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentJSON}
   */
  splice(offset4) {
    const right = new _ContentJSON(this.arr.slice(offset4));
    this.arr = this.arr.slice(0, offset4);
    return right;
  }
  /**
   * @param {ContentJSON} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset4) {
    const len = this.arr.length;
    encoder.writeLen(len - offset4);
    for (let i2 = offset4; i2 < len; i2++) {
      const c = this.arr[i2];
      encoder.writeString(c === void 0 ? "undefined" : JSON.stringify(c));
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 2;
  }
};
var readContentJSON = (decoder) => {
  const len = decoder.readLen();
  const cs2 = [];
  for (let i2 = 0; i2 < len; i2++) {
    const c = decoder.readString();
    if (c === "undefined") {
      cs2.push(void 0);
    } else {
      cs2.push(JSON.parse(c));
    }
  }
  return new ContentJSON(cs2);
};
var isDevMode = getVariable("node_env") === "development";
var ContentAny = class _ContentAny {
  /**
   * @param {Array<any>} arr
   */
  constructor(arr) {
    this.arr = arr;
    isDevMode && deepFreeze(arr);
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentAny}
   */
  copy() {
    return new _ContentAny(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentAny}
   */
  splice(offset4) {
    const right = new _ContentAny(this.arr.slice(offset4));
    this.arr = this.arr.slice(0, offset4);
    return right;
  }
  /**
   * @param {ContentAny} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset4) {
    const len = this.arr.length;
    encoder.writeLen(len - offset4);
    for (let i2 = offset4; i2 < len; i2++) {
      const c = this.arr[i2];
      encoder.writeAny(c);
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 8;
  }
};
var readContentAny = (decoder) => {
  const len = decoder.readLen();
  const cs2 = [];
  for (let i2 = 0; i2 < len; i2++) {
    cs2.push(decoder.readAny());
  }
  return new ContentAny(cs2);
};
var ContentString = class _ContentString {
  /**
   * @param {string} str
   */
  constructor(str) {
    this.str = str;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.str.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.str.split("");
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentString}
   */
  copy() {
    return new _ContentString(this.str);
  }
  /**
   * @param {number} offset
   * @return {ContentString}
   */
  splice(offset4) {
    const right = new _ContentString(this.str.slice(offset4));
    this.str = this.str.slice(0, offset4);
    const firstCharCode = this.str.charCodeAt(offset4 - 1);
    if (firstCharCode >= 55296 && firstCharCode <= 56319) {
      this.str = this.str.slice(0, offset4 - 1) + "";
      right.str = "" + right.str.slice(1);
    }
    return right;
  }
  /**
   * @param {ContentString} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.str += right.str;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset4) {
    encoder.writeString(offset4 === 0 ? this.str : this.str.slice(offset4));
  }
  /**
   * @return {number}
   */
  getRef() {
    return 4;
  }
};
var readContentString = (decoder) => new ContentString(decoder.readString());
var typeRefs = [
  readYArray,
  readYMap,
  readYText,
  readYXmlElement,
  readYXmlFragment,
  readYXmlHook,
  readYXmlText
];
var YArrayRefID = 0;
var YMapRefID = 1;
var YTextRefID = 2;
var YXmlElementRefID = 3;
var YXmlFragmentRefID = 4;
var YXmlHookRefID = 5;
var YXmlTextRefID = 6;
var ContentType = class _ContentType {
  /**
   * @param {AbstractType<any>} type
   */
  constructor(type) {
    this.type = type;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.type];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentType}
   */
  copy() {
    return new _ContentType(this.type._copy());
  }
  /**
   * @param {number} offset
   * @return {ContentType}
   */
  splice(offset4) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentType} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    this.type._integrate(transaction.doc, item);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
    let item = this.type._start;
    while (item !== null) {
      if (!item.deleted) {
        item.delete(transaction);
      } else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) {
        transaction._mergeStructs.push(item);
      }
      item = item.right;
    }
    this.type._map.forEach((item2) => {
      if (!item2.deleted) {
        item2.delete(transaction);
      } else if (item2.id.clock < (transaction.beforeState.get(item2.id.client) || 0)) {
        transaction._mergeStructs.push(item2);
      }
    });
    transaction.changed.delete(this.type);
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
    let item = this.type._start;
    while (item !== null) {
      item.gc(store, true);
      item = item.right;
    }
    this.type._start = null;
    this.type._map.forEach(
      /** @param {Item | null} item */
      (item2) => {
        while (item2 !== null) {
          item2.gc(store, true);
          item2 = item2.left;
        }
      }
    );
    this.type._map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset4) {
    this.type._write(encoder);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 7;
  }
};
var readContentType = (decoder) => new ContentType(typeRefs[decoder.readTypeRef()](decoder));
var followRedone = (store, id2) => {
  let nextID = id2;
  let diff = 0;
  let item;
  do {
    if (diff > 0) {
      nextID = createID(nextID.client, nextID.clock + diff);
    }
    item = getItem(store, nextID);
    diff = nextID.clock - item.id.clock;
    nextID = item.redone;
  } while (nextID !== null && item instanceof Item);
  return {
    item,
    diff
  };
};
var keepItem = (item, keep) => {
  while (item !== null && item.keep !== keep) {
    item.keep = keep;
    item = /** @type {AbstractType<any>} */
    item.parent._item;
  }
};
var splitItem = (transaction, leftItem, diff) => {
  const { client, clock } = leftItem.id;
  const rightItem = new Item(
    createID(client, clock + diff),
    leftItem,
    createID(client, clock + diff - 1),
    leftItem.right,
    leftItem.rightOrigin,
    leftItem.parent,
    leftItem.parentSub,
    leftItem.content.splice(diff)
  );
  if (leftItem.deleted) {
    rightItem.markDeleted();
  }
  if (leftItem.keep) {
    rightItem.keep = true;
  }
  if (leftItem.redone !== null) {
    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);
  }
  leftItem.right = rightItem;
  if (rightItem.right !== null) {
    rightItem.right.left = rightItem;
  }
  transaction._mergeStructs.push(rightItem);
  if (rightItem.parentSub !== null && rightItem.right === null) {
    rightItem.parent._map.set(rightItem.parentSub, rightItem);
  }
  leftItem.length = diff;
  return rightItem;
};
var isDeletedByUndoStack = (stack, id2) => some(
  stack,
  /** @param {StackItem} s */
  (s2) => isDeleted(s2.deletions, id2)
);
var redoItem = (transaction, item, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) => {
  const doc2 = transaction.doc;
  const store = doc2.store;
  const ownClientID = doc2.clientID;
  const redone = item.redone;
  if (redone !== null) {
    return getItemCleanStart(transaction, redone);
  }
  let parentItem = (
    /** @type {AbstractType<any>} */
    item.parent._item
  );
  let left = null;
  let right;
  if (parentItem !== null && parentItem.deleted === true) {
    if (parentItem.redone === null && (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) === null)) {
      return null;
    }
    while (parentItem.redone !== null) {
      parentItem = getItemCleanStart(transaction, parentItem.redone);
    }
  }
  const parentType = parentItem === null ? (
    /** @type {AbstractType<any>} */
    item.parent
  ) : (
    /** @type {ContentType} */
    parentItem.content.type
  );
  if (item.parentSub === null) {
    left = item.left;
    right = item;
    while (left !== null) {
      let leftTrace = left;
      while (leftTrace !== null && /** @type {AbstractType<any>} */
      leftTrace.parent._item !== parentItem) {
        leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);
      }
      if (leftTrace !== null && /** @type {AbstractType<any>} */
      leftTrace.parent._item === parentItem) {
        left = leftTrace;
        break;
      }
      left = left.left;
    }
    while (right !== null) {
      let rightTrace = right;
      while (rightTrace !== null && /** @type {AbstractType<any>} */
      rightTrace.parent._item !== parentItem) {
        rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);
      }
      if (rightTrace !== null && /** @type {AbstractType<any>} */
      rightTrace.parent._item === parentItem) {
        right = rightTrace;
        break;
      }
      right = right.right;
    }
  } else {
    right = null;
    if (item.right && !ignoreRemoteMapChanges) {
      left = item;
      while (left !== null && left.right !== null && (left.right.redone || isDeleted(itemsToDelete, left.right.id) || isDeletedByUndoStack(um.undoStack, left.right.id) || isDeletedByUndoStack(um.redoStack, left.right.id))) {
        left = left.right;
        while (left.redone) left = getItemCleanStart(transaction, left.redone);
      }
      if (left && left.right !== null) {
        return null;
      }
    } else {
      left = parentType._map.get(item.parentSub) || null;
    }
  }
  const nextClock = getState(store, ownClientID);
  const nextId = createID(ownClientID, nextClock);
  const redoneItem = new Item(
    nextId,
    left,
    left && left.lastId,
    right,
    right && right.id,
    parentType,
    item.parentSub,
    item.content.copy()
  );
  item.redone = nextId;
  keepItem(redoneItem, true);
  redoneItem.integrate(transaction, 0);
  return redoneItem;
};
var Item = class _Item extends AbstractStruct {
  /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */
  constructor(id2, left, origin, right, rightOrigin, parent, parentSub, content5) {
    super(id2, content5.getLength());
    this.origin = origin;
    this.left = left;
    this.right = right;
    this.rightOrigin = rightOrigin;
    this.parent = parent;
    this.parentSub = parentSub;
    this.redone = null;
    this.content = content5;
    this.info = this.content.isCountable() ? BIT2 : 0;
  }
  /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */
  set marker(isMarked) {
    if ((this.info & BIT4) > 0 !== isMarked) {
      this.info ^= BIT4;
    }
  }
  get marker() {
    return (this.info & BIT4) > 0;
  }
  /**
   * If true, do not garbage collect this Item.
   */
  get keep() {
    return (this.info & BIT1) > 0;
  }
  set keep(doKeep) {
    if (this.keep !== doKeep) {
      this.info ^= BIT1;
    }
  }
  get countable() {
    return (this.info & BIT2) > 0;
  }
  /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */
  get deleted() {
    return (this.info & BIT3) > 0;
  }
  set deleted(doDelete) {
    if (this.deleted !== doDelete) {
      this.info ^= BIT3;
    }
  }
  markDeleted() {
    this.info |= BIT3;
  }
  /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {
      return this.origin.client;
    }
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {
      return this.rightOrigin.client;
    }
    if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {
      return this.parent.client;
    }
    if (this.origin) {
      this.left = getItemCleanEnd(transaction, store, this.origin);
      this.origin = this.left.lastId;
    }
    if (this.rightOrigin) {
      this.right = getItemCleanStart(transaction, this.rightOrigin);
      this.rightOrigin = this.right.id;
    }
    if (this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) {
      this.parent = null;
    } else if (!this.parent) {
      if (this.left && this.left.constructor === _Item) {
        this.parent = this.left.parent;
        this.parentSub = this.left.parentSub;
      } else if (this.right && this.right.constructor === _Item) {
        this.parent = this.right.parent;
        this.parentSub = this.right.parentSub;
      }
    } else if (this.parent.constructor === ID) {
      const parentItem = getItem(store, this.parent);
      if (parentItem.constructor === GC) {
        this.parent = null;
      } else {
        this.parent = /** @type {ContentType} */
        parentItem.content.type;
      }
    }
    return null;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset4) {
    if (offset4 > 0) {
      this.id.clock += offset4;
      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));
      this.origin = this.left.lastId;
      this.content = this.content.splice(offset4);
      this.length -= offset4;
    }
    if (this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let left = this.left;
        let o;
        if (left !== null) {
          o = left.right;
        } else if (this.parentSub !== null) {
          o = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null;
          while (o !== null && o.left !== null) {
            o = o.left;
          }
        } else {
          o = /** @type {AbstractType<any>} */
          this.parent._start;
        }
        const conflictingItems = /* @__PURE__ */ new Set();
        const itemsBeforeOrigin = /* @__PURE__ */ new Set();
        while (o !== null && o !== this.right) {
          itemsBeforeOrigin.add(o);
          conflictingItems.add(o);
          if (compareIDs(this.origin, o.origin)) {
            if (o.id.client < this.id.client) {
              left = o;
              conflictingItems.clear();
            } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {
              break;
            }
          } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) {
            if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {
              left = o;
              conflictingItems.clear();
            }
          } else {
            break;
          }
          o = o.right;
        }
        this.left = left;
      }
      if (this.left !== null) {
        const right = this.left.right;
        this.right = right;
        this.left.right = this;
      } else {
        let r;
        if (this.parentSub !== null) {
          r = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null;
          while (r !== null && r.left !== null) {
            r = r.left;
          }
        } else {
          r = /** @type {AbstractType<any>} */
          this.parent._start;
          this.parent._start = this;
        }
        this.right = r;
      }
      if (this.right !== null) {
        this.right.left = this;
      } else if (this.parentSub !== null) {
        this.parent._map.set(this.parentSub, this);
        if (this.left !== null) {
          this.left.delete(transaction);
        }
      }
      if (this.parentSub === null && this.countable && !this.deleted) {
        this.parent._length += this.length;
      }
      addStruct(transaction.doc.store, this);
      this.content.integrate(transaction, this);
      addChangedTypeToTransaction(
        transaction,
        /** @type {AbstractType<any>} */
        this.parent,
        this.parentSub
      );
      if (
        /** @type {AbstractType<any>} */
        this.parent._item !== null && /** @type {AbstractType<any>} */
        this.parent._item.deleted || this.parentSub !== null && this.right !== null
      ) {
        this.delete(transaction);
      }
    } else {
      new GC(this.id, this.length).integrate(transaction, 0);
    }
  }
  /**
   * Returns the next non-deleted item
   */
  get next() {
    let n = this.right;
    while (n !== null && n.deleted) {
      n = n.right;
    }
    return n;
  }
  /**
   * Returns the previous non-deleted item
   */
  get prev() {
    let n = this.left;
    while (n !== null && n.deleted) {
      n = n.left;
    }
    return n;
  }
  /**
   * Computes the last content address of this Item.
   */
  get lastId() {
    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1);
  }
  /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor === right.constructor && compareIDs(right.origin, this.lastId) && this.right === right && compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {
      const searchMarker = (
        /** @type {AbstractType<any>} */
        this.parent._searchMarker
      );
      if (searchMarker) {
        searchMarker.forEach((marker) => {
          if (marker.p === right) {
            marker.p = this;
            if (!this.deleted && this.countable) {
              marker.index -= this.length;
            }
          }
        });
      }
      if (right.keep) {
        this.keep = true;
      }
      this.right = right.right;
      if (this.right !== null) {
        this.right.left = this;
      }
      this.length += right.length;
      return true;
    }
    return false;
  }
  /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */
  delete(transaction) {
    if (!this.deleted) {
      const parent = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (this.countable && this.parentSub === null) {
        parent._length -= this.length;
      }
      this.markDeleted();
      addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);
      addChangedTypeToTransaction(transaction, parent, this.parentSub);
      this.content.delete(transaction);
    }
  }
  /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */
  gc(store, parentGCd) {
    if (!this.deleted) {
      throw unexpectedCase();
    }
    this.content.gc(store);
    if (parentGCd) {
      replaceStruct(store, this, new GC(this.id, this.length));
    } else {
      this.content = new ContentDeleted(this.length);
    }
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */
  write(encoder, offset4) {
    const origin = offset4 > 0 ? createID(this.id.client, this.id.clock + offset4 - 1) : this.origin;
    const rightOrigin = this.rightOrigin;
    const parentSub = this.parentSub;
    const info = this.content.getRef() & BITS5 | (origin === null ? 0 : BIT8) | // origin is defined
    (rightOrigin === null ? 0 : BIT7) | // right origin is defined
    (parentSub === null ? 0 : BIT6);
    encoder.writeInfo(info);
    if (origin !== null) {
      encoder.writeLeftID(origin);
    }
    if (rightOrigin !== null) {
      encoder.writeRightID(rightOrigin);
    }
    if (origin === null && rightOrigin === null) {
      const parent = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (parent._item !== void 0) {
        const parentItem = parent._item;
        if (parentItem === null) {
          const ykey = findRootTypeKey(parent);
          encoder.writeParentInfo(true);
          encoder.writeString(ykey);
        } else {
          encoder.writeParentInfo(false);
          encoder.writeLeftID(parentItem.id);
        }
      } else if (parent.constructor === String) {
        encoder.writeParentInfo(true);
        encoder.writeString(parent);
      } else if (parent.constructor === ID) {
        encoder.writeParentInfo(false);
        encoder.writeLeftID(parent);
      } else {
        unexpectedCase();
      }
      if (parentSub !== null) {
        encoder.writeString(parentSub);
      }
    }
    this.content.write(encoder, offset4);
  }
};
var readItemContent = (decoder, info) => contentRefs[info & BITS5](decoder);
var contentRefs = [
  () => {
    unexpectedCase();
  },
  // GC is not ItemContent
  readContentDeleted,
  // 1
  readContentJSON,
  // 2
  readContentBinary,
  // 3
  readContentString,
  // 4
  readContentEmbed,
  // 5
  readContentFormat,
  // 6
  readContentType,
  // 7
  readContentAny,
  // 8
  readContentDoc,
  // 9
  () => {
    unexpectedCase();
  }
  // 10 - Skip is not ItemContent
];
var structSkipRefNumber = 10;
var Skip = class extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  /**
   * @param {Skip} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset4) {
    unexpectedCase();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset4) {
    encoder.writeInfo(structSkipRefNumber);
    writeVarUint(encoder.restEncoder, this.length - offset4);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    return null;
  }
};
var glo = (
  /** @type {any} */
  typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {}
);
var importIdentifier = "__ $YJS$ __";
if (glo[importIdentifier] === true) {
  console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
}
glo[importIdentifier] = true;

// ../node_modules/.pnpm/@tiptap+extensions@3.8.0_@t_e926699ef874b6373e88d05041c7eaa1/node_modules/@tiptap/extensions/dist/index.js
var CharacterCount = Extension.create({
  name: "characterCount",
  addOptions() {
    return {
      limit: null,
      mode: "textSize",
      textCounter: (text10) => text10.length,
      wordCounter: (text10) => text10.split(" ").filter((word) => word !== "").length
    };
  },
  addStorage() {
    return {
      characters: () => 0,
      words: () => 0
    };
  },
  onBeforeCreate() {
    this.storage.characters = (options) => {
      const node2 = (options == null ? void 0 : options.node) || this.editor.state.doc;
      const mode = (options == null ? void 0 : options.mode) || this.options.mode;
      if (mode === "textSize") {
        const text10 = node2.textBetween(0, node2.content.size, void 0, " ");
        return this.options.textCounter(text10);
      }
      return node2.nodeSize;
    };
    this.storage.words = (options) => {
      const node2 = (options == null ? void 0 : options.node) || this.editor.state.doc;
      const text10 = node2.textBetween(0, node2.content.size, " ", " ");
      return this.options.wordCounter(text10);
    };
  },
  addProseMirrorPlugins() {
    let initialEvaluationDone = false;
    return [
      new Plugin({
        key: new PluginKey("characterCount"),
        appendTransaction: (transactions, oldState, newState) => {
          if (initialEvaluationDone) {
            return;
          }
          const limit = this.options.limit;
          if (limit === null || limit === void 0 || limit === 0) {
            initialEvaluationDone = true;
            return;
          }
          const initialContentSize = this.storage.characters({ node: newState.doc });
          if (initialContentSize > limit) {
            const over = initialContentSize - limit;
            const from3 = 0;
            const to3 = over;
            console.warn(
              `[CharacterCount] Initial content exceeded limit of ${limit} characters. Content was automatically trimmed.`
            );
            const tr5 = newState.tr.deleteRange(from3, to3);
            initialEvaluationDone = true;
            return tr5;
          }
          initialEvaluationDone = true;
        },
        filterTransaction: (transaction, state) => {
          const limit = this.options.limit;
          if (!transaction.docChanged || limit === 0 || limit === null || limit === void 0) {
            return true;
          }
          const oldSize = this.storage.characters({ node: state.doc });
          const newSize = this.storage.characters({ node: transaction.doc });
          if (newSize <= limit) {
            return true;
          }
          if (oldSize > limit && newSize > limit && newSize <= oldSize) {
            return true;
          }
          if (oldSize > limit && newSize > limit && newSize > oldSize) {
            return false;
          }
          const isPaste = transaction.getMeta("paste");
          if (!isPaste) {
            return false;
          }
          const pos = transaction.selection.$head.pos;
          const over = newSize - limit;
          const from3 = pos - over;
          const to3 = pos;
          transaction.deleteRange(from3, to3);
          const updatedSize = this.storage.characters({ node: transaction.doc });
          if (updatedSize > limit) {
            return false;
          }
          return true;
        }
      })
    ];
  }
});
var Dropcursor = Extension.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [dropCursor(this.options)];
  }
});
var Focus = Extension.create({
  name: "focus",
  addOptions() {
    return {
      className: "has-focus",
      mode: "all"
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("focus"),
        props: {
          decorations: ({ doc: doc2, selection }) => {
            const { isEditable, isFocused } = this.editor;
            const { anchor } = selection;
            const decorations = [];
            if (!isEditable || !isFocused) {
              return DecorationSet.create(doc2, []);
            }
            let maxLevels = 0;
            if (this.options.mode === "deepest") {
              doc2.descendants((node2, pos) => {
                if (node2.isText) {
                  return;
                }
                const isCurrent = anchor >= pos && anchor <= pos + node2.nodeSize - 1;
                if (!isCurrent) {
                  return false;
                }
                maxLevels += 1;
              });
            }
            let currentLevel = 0;
            doc2.descendants((node2, pos) => {
              if (node2.isText) {
                return false;
              }
              const isCurrent = anchor >= pos && anchor <= pos + node2.nodeSize - 1;
              if (!isCurrent) {
                return false;
              }
              currentLevel += 1;
              const outOfScope = this.options.mode === "deepest" && maxLevels - currentLevel > 0 || this.options.mode === "shallowest" && currentLevel > 1;
              if (outOfScope) {
                return this.options.mode === "deepest";
              }
              decorations.push(
                Decoration.node(pos, pos + node2.nodeSize, {
                  class: this.options.className
                })
              );
            });
            return DecorationSet.create(doc2, decorations);
          }
        }
      })
    ];
  }
});
var Gapcursor = Extension.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [gapCursor()];
  },
  extendNodeSchema(extension2) {
    var _a2;
    const context = {
      name: extension2.name,
      options: extension2.options,
      storage: extension2.storage
    };
    return {
      allowGapCursor: (_a2 = callOrReturn(getExtensionField(extension2, "allowGapCursor", context))) != null ? _a2 : null
    };
  }
});
var Placeholder = Extension.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      placeholder: "Write something ",
      showOnlyWhenEditable: true,
      showOnlyCurrent: true,
      includeChildren: false
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("placeholder"),
        props: {
          decorations: ({ doc: doc2, selection }) => {
            const active = this.editor.isEditable || !this.options.showOnlyWhenEditable;
            const { anchor } = selection;
            const decorations = [];
            if (!active) {
              return null;
            }
            const isEmptyDoc = this.editor.isEmpty;
            doc2.descendants((node2, pos) => {
              const hasAnchor = anchor >= pos && anchor <= pos + node2.nodeSize;
              const isEmpty3 = !node2.isLeaf && isNodeEmpty(node2);
              if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty3) {
                const classes = [this.options.emptyNodeClass];
                if (isEmptyDoc) {
                  classes.push(this.options.emptyEditorClass);
                }
                const decoration = Decoration.node(pos, pos + node2.nodeSize, {
                  class: classes.join(" "),
                  "data-placeholder": typeof this.options.placeholder === "function" ? this.options.placeholder({
                    editor: this.editor,
                    node: node2,
                    pos,
                    hasAnchor
                  }) : this.options.placeholder
                });
                decorations.push(decoration);
              }
              return this.options.includeChildren;
            });
            return DecorationSet.create(doc2, decorations);
          }
        }
      })
    ];
  }
});
var Selection2 = Extension.create({
  name: "selection",
  addOptions() {
    return {
      className: "selection"
    };
  },
  addProseMirrorPlugins() {
    const { editor, options } = this;
    return [
      new Plugin({
        key: new PluginKey("selection"),
        props: {
          decorations(state) {
            if (state.selection.empty || editor.isFocused || !editor.isEditable || isNodeSelection(state.selection) || editor.view.dragging) {
              return null;
            }
            return DecorationSet.create(state.doc, [
              Decoration.inline(state.selection.from, state.selection.to, {
                class: options.className
              })
            ]);
          }
        }
      })
    ];
  }
});
function nodeEqualsType({ types: types2, node: node2 }) {
  return node2 && Array.isArray(types2) && types2.includes(node2.type) || (node2 == null ? void 0 : node2.type) === types2;
}
var TrailingNode = Extension.create({
  name: "trailingNode",
  addOptions() {
    return {
      node: void 0,
      notAfter: []
    };
  },
  addProseMirrorPlugins() {
    var _a2;
    const plugin = new PluginKey(this.name);
    const defaultNode = ((_a2 = this.editor.schema.topNodeType.contentMatch.defaultType) == null ? void 0 : _a2.name) || this.options.node || "paragraph";
    const disabledNodes = Object.entries(this.editor.schema.nodes).map(([, value]) => value).filter((node2) => (this.options.notAfter || []).concat(defaultNode).includes(node2.name));
    return [
      new Plugin({
        key: plugin,
        appendTransaction: (_, __, state) => {
          const { doc: doc2, tr: tr5, schema } = state;
          const shouldInsertNodeAtEnd = plugin.getState(state);
          const endPosition = doc2.content.size;
          const type = schema.nodes[defaultNode];
          if (!shouldInsertNodeAtEnd) {
            return;
          }
          return tr5.insert(endPosition, type.create());
        },
        state: {
          init: (_, state) => {
            const lastNode = state.tr.doc.lastChild;
            return !nodeEqualsType({ node: lastNode, types: disabledNodes });
          },
          apply: (tr5, value) => {
            if (!tr5.docChanged) {
              return value;
            }
            const lastNode = tr5.doc.lastChild;
            return !nodeEqualsType({ node: lastNode, types: disabledNodes });
          }
        }
      })
    ];
  }
});
var UndoRedo = Extension.create({
  name: "undoRedo",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state, dispatch }) => {
        return undo(state, dispatch);
      },
      redo: () => ({ state, dispatch }) => {
        return redo(state, dispatch);
      }
    };
  },
  addProseMirrorPlugins() {
    return [history(this.options)];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-": () => this.editor.commands.undo(),
      "Shift-Mod-": () => this.editor.commands.redo()
    };
  }
});

// ../node_modules/.pnpm/@tiptap+extension-link@3.8._76db3949d893ef7f73cd713ad5cb0951/node_modules/@tiptap/extension-link/dist/index.js
var UNICODE_WHITESPACE_PATTERN = "[\0- -\u2029]";
var UNICODE_WHITESPACE_REGEX = new RegExp(UNICODE_WHITESPACE_PATTERN);
var UNICODE_WHITESPACE_REGEX_END = new RegExp(`${UNICODE_WHITESPACE_PATTERN}$`);
var UNICODE_WHITESPACE_REGEX_GLOBAL = new RegExp(UNICODE_WHITESPACE_PATTERN, "g");
function isValidLinkStructure(tokens) {
  if (tokens.length === 1) {
    return tokens[0].isLink;
  }
  if (tokens.length === 3 && tokens[1].isLink) {
    return ["()", "[]"].includes(tokens[0].value + tokens[2].value);
  }
  return false;
}
function autolink(options) {
  return new Plugin({
    key: new PluginKey("autolink"),
    appendTransaction: (transactions, oldState, newState) => {
      const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
      const preventAutolink = transactions.some((transaction) => transaction.getMeta("preventAutolink"));
      if (!docChanges || preventAutolink) {
        return;
      }
      const { tr: tr5 } = newState;
      const transform2 = combineTransactionSteps(oldState.doc, [...transactions]);
      const changes = getChangedRanges(transform2);
      changes.forEach(({ newRange }) => {
        const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, (node2) => node2.isTextblock);
        let textBlock;
        let textBeforeWhitespace;
        if (nodesInChangedRanges.length > 1) {
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(
            textBlock.pos,
            textBlock.pos + textBlock.node.nodeSize,
            void 0,
            " "
          );
        } else if (nodesInChangedRanges.length) {
          const endText = newState.doc.textBetween(newRange.from, newRange.to, " ", " ");
          if (!UNICODE_WHITESPACE_REGEX_END.test(endText)) {
            return;
          }
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, void 0, " ");
        }
        if (textBlock && textBeforeWhitespace) {
          const wordsBeforeWhitespace = textBeforeWhitespace.split(UNICODE_WHITESPACE_REGEX).filter(Boolean);
          if (wordsBeforeWhitespace.length <= 0) {
            return false;
          }
          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];
          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);
          if (!lastWordBeforeSpace) {
            return false;
          }
          const linksBeforeSpace = tokenize(lastWordBeforeSpace).map((t) => t.toObject(options.defaultProtocol));
          if (!isValidLinkStructure(linksBeforeSpace)) {
            return false;
          }
          linksBeforeSpace.filter((link3) => link3.isLink).map((link3) => ({
            ...link3,
            from: lastWordAndBlockOffset + link3.start + 1,
            to: lastWordAndBlockOffset + link3.end + 1
          })).filter((link3) => {
            if (!newState.schema.marks.code) {
              return true;
            }
            return !newState.doc.rangeHasMark(link3.from, link3.to, newState.schema.marks.code);
          }).filter((link3) => options.validate(link3.value)).filter((link3) => options.shouldAutoLink(link3.value)).forEach((link3) => {
            if (getMarksBetween(link3.from, link3.to, newState.doc).some((item) => item.mark.type === options.type)) {
              return;
            }
            tr5.addMark(
              link3.from,
              link3.to,
              options.type.create({
                href: link3.href
              })
            );
          });
        }
      });
      if (!tr5.steps.length) {
        return;
      }
      return tr5;
    }
  });
}
function clickHandler(options) {
  return new Plugin({
    key: new PluginKey("handleClickLink"),
    props: {
      handleClick: (view, pos, event) => {
        var _a2, _b;
        if (event.button !== 0) {
          return false;
        }
        if (!view.editable) {
          return false;
        }
        let link3 = null;
        if (event.target instanceof HTMLAnchorElement) {
          link3 = event.target;
        } else {
          let a2 = event.target;
          const els = [];
          while (a2.nodeName !== "DIV") {
            els.push(a2);
            a2 = a2.parentNode;
          }
          link3 = els.find((value) => value.nodeName === "A");
        }
        if (!link3) {
          return false;
        }
        const attrs = getAttributes(view.state, options.type.name);
        const href = (_a2 = link3 == null ? void 0 : link3.href) != null ? _a2 : attrs.href;
        const target = (_b = link3 == null ? void 0 : link3.target) != null ? _b : attrs.target;
        if (options.enableClickSelection) {
          options.editor.commands.extendMarkRange(options.type.name);
        }
        if (link3 && href) {
          window.open(href, target);
          return true;
        }
        return false;
      }
    }
  });
}
function pasteHandler(options) {
  return new Plugin({
    key: new PluginKey("handlePasteLink"),
    props: {
      handlePaste: (view, _event, slice) => {
        const { shouldAutoLink } = options;
        const { state } = view;
        const { selection } = state;
        const { empty: empty3 } = selection;
        if (empty3) {
          return false;
        }
        let textContent = "";
        slice.content.forEach((node2) => {
          textContent += node2.textContent;
        });
        const link3 = find(textContent, { defaultProtocol: options.defaultProtocol }).find(
          (item) => item.isLink && item.value === textContent
        );
        if (!textContent || !link3 || shouldAutoLink !== void 0 && !shouldAutoLink(link3.href)) {
          return false;
        }
        return options.editor.commands.setMark(options.type, {
          href: link3.href
        });
      }
    }
  });
}
function isAllowedUri(uri, protocols) {
  const allowedProtocols = ["http", "https", "ftp", "ftps", "mailto", "tel", "callto", "sms", "cid", "xmpp"];
  if (protocols) {
    protocols.forEach((protocol) => {
      const nextProtocol = typeof protocol === "string" ? protocol : protocol.scheme;
      if (nextProtocol) {
        allowedProtocols.push(nextProtocol);
      }
    });
  }
  return !uri || uri.replace(UNICODE_WHITESPACE_REGEX_GLOBAL, "").match(
    new RegExp(
      // eslint-disable-next-line no-useless-escape
      `^(?:(?:${allowedProtocols.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
      "i"
    )
  );
}
var Link = Mark.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: false,
  exitable: true,
  onCreate() {
    if (this.options.validate && !this.options.shouldAutoLink) {
      this.options.shouldAutoLink = this.options.validate;
      console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.");
    }
    this.options.protocols.forEach((protocol) => {
      if (typeof protocol === "string") {
        registerCustomProtocol(protocol);
        return;
      }
      registerCustomProtocol(protocol.scheme, protocol.optionalSlashes);
    });
  },
  onDestroy() {
    reset();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: true,
      enableClickSelection: false,
      linkOnPaste: true,
      autolink: true,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (url, ctx) => !!isAllowedUri(url, ctx.protocols),
      validate: (url) => !!url,
      shouldAutoLink: (url) => !!url
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(element7) {
          return element7.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (dom) => {
          const href = dom.getAttribute("href");
          if (!href || !this.options.isAllowedUri(href, {
            defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          })) {
            return false;
          }
          return null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    if (!this.options.isAllowedUri(HTMLAttributes.href, {
      defaultValidate: (href) => !!isAllowedUri(href, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    })) {
      return ["a", mergeAttributes(this.options.HTMLAttributes, { ...HTMLAttributes, href: "" }), 0];
    }
    return ["a", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  markdownTokenName: "link",
  parseMarkdown: (token, helpers) => {
    return helpers.applyMark("link", helpers.parseInline(token.tokens || []), {
      href: token.href,
      title: token.title || null
    });
  },
  renderMarkdown: (node2, h4) => {
    var _a2;
    const href = ((_a2 = node2.attrs) == null ? void 0 : _a2.href) || "";
    const text10 = h4.renderChildren(node2);
    return `[${text10}](${href})`;
  },
  addCommands() {
    return {
      setLink: (attributes) => ({ chain }) => {
        const { href } = attributes;
        if (!this.options.isAllowedUri(href, {
          defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        })) {
          return false;
        }
        return chain().setMark(this.name, attributes).setMeta("preventAutolink", true).run();
      },
      toggleLink: (attributes) => ({ chain }) => {
        const { href } = attributes || {};
        if (href && !this.options.isAllowedUri(href, {
          defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        })) {
          return false;
        }
        return chain().toggleMark(this.name, attributes, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      },
      unsetLink: () => ({ chain }) => {
        return chain().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      }
    };
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: (text10) => {
          const foundLinks = [];
          if (text10) {
            const { protocols, defaultProtocol } = this.options;
            const links = find(text10).filter(
              (item) => item.isLink && this.options.isAllowedUri(item.value, {
                defaultValidate: (href) => !!isAllowedUri(href, protocols),
                protocols,
                defaultProtocol
              })
            );
            if (links.length) {
              links.forEach((link3) => {
                if (!this.options.shouldAutoLink(link3.value)) {
                  return;
                }
                foundLinks.push({
                  text: link3.value,
                  data: {
                    href: link3.href
                  },
                  index: link3.start
                });
              });
            }
          }
          return foundLinks;
        },
        type: this.type,
        getAttributes: (match) => {
          var _a2;
          return {
            href: (_a2 = match.data) == null ? void 0 : _a2.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const plugins = [];
    const { protocols, defaultProtocol } = this.options;
    if (this.options.autolink) {
      plugins.push(
        autolink({
          type: this.type,
          defaultProtocol: this.options.defaultProtocol,
          validate: (url) => this.options.isAllowedUri(url, {
            defaultValidate: (href) => !!isAllowedUri(href, protocols),
            protocols,
            defaultProtocol
          }),
          shouldAutoLink: this.options.shouldAutoLink
        })
      );
    }
    if (this.options.openOnClick === true) {
      plugins.push(
        clickHandler({
          type: this.type,
          editor: this.editor,
          enableClickSelection: this.options.enableClickSelection
        })
      );
    }
    if (this.options.linkOnPaste) {
      plugins.push(
        pasteHandler({
          editor: this.editor,
          defaultProtocol: this.options.defaultProtocol,
          type: this.type,
          shouldAutoLink: this.options.shouldAutoLink
        })
      );
    }
    return plugins;
  }
});

// ../node_modules/.pnpm/@tiptap+extension-text@3.8._fe6ec2f04c2d32cfbf78834af6f67d6f/node_modules/@tiptap/extension-text/dist/index.js
var Text = Node3.create({
  name: "text",
  group: "inline",
  parseMarkdown: (token) => {
    return {
      type: "text",
      text: token.text || ""
    };
  },
  renderMarkdown: (node2) => node2.text || ""
});

// ../node_modules/.pnpm/devlop@1.1.0/node_modules/devlop/lib/development.js
var AssertionError = class extends Error {
  name = (
    /** @type {const} */
    "Assertion"
  );
  code = (
    /** @type {const} */
    "ERR_ASSERTION"
  );
  /**
   * Create an assertion error.
   *
   * @param {string} message
   *   Message explaining error.
   * @param {unknown} actual
   *   Value.
   * @param {unknown} expected
   *   Baseline.
   * @param {string} operator
   *   Name of equality operation.
   * @param {boolean} generated
   *   Whether `message` is a custom message or not
   * @returns
   *   Instance.
   */
  // eslint-disable-next-line max-params
  constructor(message, actual, expected, operator, generated) {
    super(message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.actual = actual;
    this.expected = expected;
    this.generated = generated;
    this.operator = operator;
  }
};
function ok(value, message) {
  assert(
    Boolean(value),
    false,
    true,
    "ok",
    "Expected value to be truthy",
    message
  );
}
function assert(bool, actual, expected, operator, defaultMessage, userMessage) {
  if (!bool) {
    throw userMessage instanceof Error ? userMessage : new AssertionError(
      userMessage || defaultMessage,
      actual,
      expected,
      operator,
      !userMessage
    );
  }
}

// ../node_modules/.pnpm/property-information@7.1.0/node_modules/property-information/lib/util/schema.js
var Schema2 = class {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(property, normal, space2) {
    this.normal = normal;
    this.property = property;
    if (space2) {
      this.space = space2;
    }
  }
};
Schema2.prototype.normal = {};
Schema2.prototype.property = {};
Schema2.prototype.space = void 0;

// ../node_modules/.pnpm/property-information@7.1.0/node_modules/property-information/lib/util/merge.js
function merge(definitions, space2) {
  const property = {};
  const normal = {};
  for (const definition3 of definitions) {
    Object.assign(property, definition3.property);
    Object.assign(normal, definition3.normal);
  }
  return new Schema2(property, normal, space2);
}

// ../node_modules/.pnpm/property-information@7.1.0/node_modules/property-information/lib/normalize.js
function normalize(value) {
  return value.toLowerCase();
}

// ../node_modules/.pnpm/property-information@7.1.0/node_modules/property-information/lib/util/info.js
var Info = class {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(property, attribute) {
    this.attribute = attribute;
    this.property = property;
  }
};
Info.prototype.attribute = "";
Info.prototype.booleanish = false;
Info.prototype.boolean = false;
Info.prototype.commaOrSpaceSeparated = false;
Info.prototype.commaSeparated = false;
Info.prototype.defined = false;
Info.prototype.mustUseProperty = false;
Info.prototype.number = false;
Info.prototype.overloadedBoolean = false;
Info.prototype.property = "";
Info.prototype.spaceSeparated = false;
Info.prototype.space = void 0;

// ../node_modules/.pnpm/property-information@7.1.0/node_modules/property-information/lib/util/types.js
var types_exports = {};
__export(types_exports, {
  boolean: () => boolean,
  booleanish: () => booleanish,
  commaOrSpaceSeparated: () => commaOrSpaceSeparated,
  commaSeparated: () => commaSeparated,
  number: () => number,
  overloadedBoolean: () => overloadedBoolean,
  spaceSeparated: () => spaceSeparated
});
var powers = 0;
var boolean = increment();
var booleanish = increment();
var overloadedBoolean = increment();
var number = increment();
var spaceSeparated = increment();
var commaSeparated = increment();
var commaOrSpaceSeparated = increment();
function increment() {
  return 2 ** ++powers;
}

// ../node_modules/.pnpm/property-information@7.1.0/node_modules/property-information/lib/util/defined-info.js
var checks = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(types_exports)
);
var DefinedInfo = class extends Info {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(property, attribute, mask, space2) {
    let index4 = -1;
    super(property, attribute);
    mark(this, "space", space2);
    if (typeof mask === "number") {
      while (++index4 < checks.length) {
        const check = checks[index4];
        mark(this, checks[index4], (mask & types_exports[check]) === types_exports[check]);
      }
    }
  }
};
DefinedInfo.prototype.defined = true;
function mark(values2, key2, value) {
  if (value) {
    values2[key2] = value;
  }
}

// ../node_modules/.pnpm/property-information@7.1.0/node_modules/property-information/lib/util/create.js
function create7(definition3) {
  const properties = {};
  const normals = {};
  for (const [property, value] of Object.entries(definition3.properties)) {
    const info = new DefinedInfo(
      property,
      definition3.transform(definition3.attributes || {}, property),
      value,
      definition3.space
    );
    if (definition3.mustUseProperty && definition3.mustUseProperty.includes(property)) {
      info.mustUseProperty = true;
    }
    properties[property] = info;
    normals[normalize(property)] = property;
    normals[normalize(info.attribute)] = property;
  }
  return new Schema2(properties, normals, definition3.space);
}

// ../node_modules/.pnpm/property-information@7.1.0/node_modules/property-information/lib/aria.js
var aria = create7({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish,
    ariaAutoComplete: null,
    ariaBusy: booleanish,
    ariaChecked: booleanish,
    ariaColCount: number,
    ariaColIndex: number,
    ariaColSpan: number,
    ariaControls: spaceSeparated,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated,
    ariaDetails: null,
    ariaDisabled: booleanish,
    ariaDropEffect: spaceSeparated,
    ariaErrorMessage: null,
    ariaExpanded: booleanish,
    ariaFlowTo: spaceSeparated,
    ariaGrabbed: booleanish,
    ariaHasPopup: null,
    ariaHidden: booleanish,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated,
    ariaLevel: number,
    ariaLive: null,
    ariaModal: booleanish,
    ariaMultiLine: booleanish,
    ariaMultiSelectable: booleanish,
    ariaOrientation: null,
    ariaOwns: spaceSeparated,
    ariaPlaceholder: null,
    ariaPosInSet: number,
    ariaPressed: booleanish,
    ariaReadOnly: booleanish,
    ariaRelevant: null,
    ariaRequired: booleanish,
    ariaRoleDescription: spaceSeparated,
    ariaRowCount: number,
    ariaRowIndex: number,
    ariaRowSpan: number,
    ariaSelected: booleanish,
    ariaSetSize: number,
    ariaSort: null,
    ariaValueMax: number,
    ariaValueMin: number,
    ariaValueNow: number,
    ariaValueText: null,
    role: null
  },
  transform(_, property) {
    return property === "role" ? property : "aria-" + property.slice(4).toLowerCase();
  }
});

// ../node_modules/.pnpm/property-information@7.1.0/node_modules/property-information/lib/util/case-sensitive-transform.js
function caseSensitiveTransform(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute;
}

// ../node_modules/.pnpm/property-information@7.1.0/node_modules/property-information/lib/util/case-insensitive-transform.js
function caseInsensitiveTransform(attributes, property) {
  return caseSensitiveTransform(attributes, property.toLowerCase());
}

// ../node_modules/.pnpm/property-information@7.1.0/node_modules/property-information/lib/html.js
var html = create7({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    blocking: spaceSeparated,
    capture: null,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number,
    hidden: overloadedBoolean,
    high: number,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: boolean,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number,
    manifest: null,
    max: null,
    maxLength: number,
    media: null,
    method: null,
    min: null,
    minLength: number,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number,
    rowSpan: number,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shadowRootClonable: boolean,
    shadowRootDelegatesFocus: boolean,
    shadowRootMode: null,
    shape: null,
    size: number,
    sizes: null,
    slot: null,
    span: number,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number,
    step: null,
    style: null,
    tabIndex: number,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number,
    // `<img>` and `<object>`
    leftMargin: number,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number,
    // `<body>`
    marginWidth: number,
    // `<body>`
    noResize: boolean,
    // `<frame>`
    noHref: boolean,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: caseInsensitiveTransform
});

// ../node_modules/.pnpm/property-information@7.1.0/node_modules/property-information/lib/svg.js
var svg = create7({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number,
    amplitude: number,
    arabicForm: null,
    ascent: number,
    attributeName: null,
    attributeType: null,
    azimuth: number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number,
    by: null,
    calcMode: null,
    capHeight: number,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number,
    diffuseConstant: number,
    direction: null,
    display: null,
    dur: null,
    divisor: number,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number,
    horizOriginX: number,
    horizOriginY: number,
    id: null,
    ideographic: number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number,
    k: number,
    k1: number,
    k2: number,
    k3: number,
    k4: number,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number,
    overlineThickness: number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number,
    pointsAtY: number,
    pointsAtZ: number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number,
    specularExponent: number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number,
    strikethroughThickness: number,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number,
    strokeOpacity: number,
    strokeWidth: null,
    style: null,
    surfaceScale: number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number,
    tableValues: null,
    target: null,
    targetX: number,
    targetY: number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: number,
    underlineThickness: number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number,
    values: null,
    vAlphabetic: number,
    vMathematical: number,
    vectorEffect: null,
    vHanging: number,
    vIdeographic: number,
    version: null,
    vertAdvY: number,
    vertOriginX: number,
    vertOriginY: number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: caseSensitiveTransform
});

// ../node_modules/.pnpm/property-information@7.1.0/node_modules/property-information/lib/xlink.js
var xlink = create7({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(_, property) {
    return "xlink:" + property.slice(5).toLowerCase();
  }
});

// ../node_modules/.pnpm/property-information@7.1.0/node_modules/property-information/lib/xmlns.js
var xmlns = create7({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: caseInsensitiveTransform
});

// ../node_modules/.pnpm/property-information@7.1.0/node_modules/property-information/lib/xml.js
var xml = create7({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(_, property) {
    return "xml:" + property.slice(3).toLowerCase();
  }
});

// ../node_modules/.pnpm/property-information@7.1.0/node_modules/property-information/lib/find.js
var cap = /[A-Z]/g;
var dash = /-[a-z]/g;
var valid = /^data[-\w.:]+$/i;
function find3(schema, value) {
  const normal = normalize(value);
  let property = value;
  let Type = Info;
  if (normal in schema.normal) {
    return schema.property[schema.normal[normal]];
  }
  if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
    if (value.charAt(4) === "-") {
      const rest = value.slice(5).replace(dash, camelcase);
      property = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
    } else {
      const rest = value.slice(4);
      if (!dash.test(rest)) {
        let dashes = rest.replace(cap, kebab);
        if (dashes.charAt(0) !== "-") {
          dashes = "-" + dashes;
        }
        value = "data" + dashes;
      }
    }
    Type = DefinedInfo;
  }
  return new Type(property, value);
}
function kebab($0) {
  return "-" + $0.toLowerCase();
}
function camelcase($0) {
  return $0.charAt(1).toUpperCase();
}

// ../node_modules/.pnpm/property-information@7.1.0/node_modules/property-information/index.js
var html2 = merge([aria, html, xlink, xmlns, xml], "html");
var svg2 = merge([aria, svg, xlink, xmlns, xml], "svg");

// ../node_modules/.pnpm/comma-separated-tokens@2.0.3/node_modules/comma-separated-tokens/index.js
function parse2(value) {
  const tokens = [];
  const input2 = String(value || "");
  let index4 = input2.indexOf(",");
  let start = 0;
  let end = false;
  while (!end) {
    if (index4 === -1) {
      index4 = input2.length;
      end = true;
    }
    const token = input2.slice(start, index4).trim();
    if (token || !end) {
      tokens.push(token);
    }
    start = index4 + 1;
    index4 = input2.indexOf(",", start);
  }
  return tokens;
}
function stringify3(values2, options) {
  const settings = options || {};
  const input2 = values2[values2.length - 1] === "" ? [...values2, ""] : values2;
  return input2.join(
    (settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")
  ).trim();
}

// ../node_modules/.pnpm/hast-util-parse-selector@4.0.0/node_modules/hast-util-parse-selector/lib/index.js
var search = /[#.]/g;
function parseSelector(selector, defaultTagName) {
  const value = selector || "";
  const props = {};
  let start = 0;
  let previous3;
  let tagName;
  while (start < value.length) {
    search.lastIndex = start;
    const match = search.exec(value);
    const subvalue = value.slice(start, match ? match.index : value.length);
    if (subvalue) {
      if (!previous3) {
        tagName = subvalue;
      } else if (previous3 === "#") {
        props.id = subvalue;
      } else if (Array.isArray(props.className)) {
        props.className.push(subvalue);
      } else {
        props.className = [subvalue];
      }
      start += subvalue.length;
    }
    if (match) {
      previous3 = match[0];
      start++;
    }
  }
  return {
    type: "element",
    // @ts-expect-error: tag name is parsed.
    tagName: tagName || defaultTagName || "div",
    properties: props,
    children: []
  };
}

// ../node_modules/.pnpm/space-separated-tokens@2.0.2/node_modules/space-separated-tokens/index.js
function parse3(value) {
  const input2 = String(value || "").trim();
  return input2 ? input2.split(/[ \t\n\r\f]+/g) : [];
}
function stringify4(values2) {
  return values2.join(" ").trim();
}

// ../node_modules/.pnpm/hastscript@9.0.1/node_modules/hastscript/lib/create-h.js
function createH(schema, defaultTagName, caseSensitive) {
  const adjust = caseSensitive ? createAdjustMap(caseSensitive) : void 0;
  function h4(selector, properties, ...children) {
    let node2;
    if (selector === null || selector === void 0) {
      node2 = { type: "root", children: [] };
      const child = (
        /** @type {Child} */
        properties
      );
      children.unshift(child);
    } else {
      node2 = parseSelector(selector, defaultTagName);
      const lower = node2.tagName.toLowerCase();
      const adjusted = adjust ? adjust.get(lower) : void 0;
      node2.tagName = adjusted || lower;
      if (isChild(properties)) {
        children.unshift(properties);
      } else {
        for (const [key2, value] of Object.entries(properties)) {
          addProperty(schema, node2.properties, key2, value);
        }
      }
    }
    for (const child of children) {
      addChild(node2.children, child);
    }
    if (node2.type === "element" && node2.tagName === "template") {
      node2.content = { type: "root", children: node2.children };
      node2.children = [];
    }
    return node2;
  }
  return h4;
}
function isChild(value) {
  if (value === null || typeof value !== "object" || Array.isArray(value)) {
    return true;
  }
  if (typeof value.type !== "string") return false;
  const record = (
    /** @type {Record<string, unknown>} */
    value
  );
  const keys3 = Object.keys(value);
  for (const key2 of keys3) {
    const value2 = record[key2];
    if (value2 && typeof value2 === "object") {
      if (!Array.isArray(value2)) return true;
      const list7 = (
        /** @type {ReadonlyArray<unknown>} */
        value2
      );
      for (const item of list7) {
        if (typeof item !== "number" && typeof item !== "string") {
          return true;
        }
      }
    }
  }
  if ("children" in value && Array.isArray(value.children)) {
    return true;
  }
  return false;
}
function addProperty(schema, properties, key2, value) {
  const info = find3(schema, key2);
  let result;
  if (value === null || value === void 0) return;
  if (typeof value === "number") {
    if (Number.isNaN(value)) return;
    result = value;
  } else if (typeof value === "boolean") {
    result = value;
  } else if (typeof value === "string") {
    if (info.spaceSeparated) {
      result = parse3(value);
    } else if (info.commaSeparated) {
      result = parse2(value);
    } else if (info.commaOrSpaceSeparated) {
      result = parse3(parse2(value).join(" "));
    } else {
      result = parsePrimitive(info, info.property, value);
    }
  } else if (Array.isArray(value)) {
    result = [...value];
  } else {
    result = info.property === "style" ? style2(value) : String(value);
  }
  if (Array.isArray(result)) {
    const finalResult = [];
    for (const item of result) {
      finalResult.push(
        /** @type {number | string} */
        parsePrimitive(info, info.property, item)
      );
    }
    result = finalResult;
  }
  if (info.property === "className" && Array.isArray(properties.className)) {
    result = properties.className.concat(
      /** @type {Array<number | string> | number | string} */
      result
    );
  }
  properties[info.property] = result;
}
function addChild(nodes, value) {
  if (value === null || value === void 0) {
  } else if (typeof value === "number" || typeof value === "string") {
    nodes.push({ type: "text", value: String(value) });
  } else if (Array.isArray(value)) {
    for (const child of value) {
      addChild(nodes, child);
    }
  } else if (typeof value === "object" && "type" in value) {
    if (value.type === "root") {
      addChild(nodes, value.children);
    } else {
      nodes.push(value);
    }
  } else {
    throw new Error("Expected node, nodes, or string, got `" + value + "`");
  }
}
function parsePrimitive(info, name, value) {
  if (typeof value === "string") {
    if (info.number && value && !Number.isNaN(Number(value))) {
      return Number(value);
    }
    if ((info.boolean || info.overloadedBoolean) && (value === "" || normalize(value) === normalize(name))) {
      return true;
    }
  }
  return value;
}
function style2(styles) {
  const result = [];
  for (const [key2, value] of Object.entries(styles)) {
    result.push([key2, value].join(": "));
  }
  return result.join("; ");
}
function createAdjustMap(values2) {
  const result = /* @__PURE__ */ new Map();
  for (const value of values2) {
    result.set(value.toLowerCase(), value);
  }
  return result;
}

// ../node_modules/.pnpm/hastscript@9.0.1/node_modules/hastscript/lib/svg-case-sensitive-tag-names.js
var svgCaseSensitiveTagNames = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "solidColor",
  "textArea",
  "textPath"
];

// ../node_modules/.pnpm/hastscript@9.0.1/node_modules/hastscript/lib/index.js
var h2 = createH(html2, "div");
var s = createH(svg2, "g", svgCaseSensitiveTagNames);

// ../node_modules/.pnpm/vfile-location@5.0.3/node_modules/vfile-location/lib/index.js
function location2(file) {
  const value = String(file);
  const indices = [];
  return { toOffset, toPoint };
  function toPoint(offset4) {
    if (typeof offset4 === "number" && offset4 > -1 && offset4 <= value.length) {
      let index4 = 0;
      while (true) {
        let end = indices[index4];
        if (end === void 0) {
          const eol2 = next(value, indices[index4 - 1]);
          end = eol2 === -1 ? value.length + 1 : eol2 + 1;
          indices[index4] = end;
        }
        if (end > offset4) {
          return {
            line: index4 + 1,
            column: offset4 - (index4 > 0 ? indices[index4 - 1] : 0) + 1,
            offset: offset4
          };
        }
        index4++;
      }
    }
  }
  function toOffset(point5) {
    if (point5 && typeof point5.line === "number" && typeof point5.column === "number" && !Number.isNaN(point5.line) && !Number.isNaN(point5.column)) {
      while (indices.length < point5.line) {
        const from3 = indices[indices.length - 1];
        const eol2 = next(value, from3);
        const end = eol2 === -1 ? value.length + 1 : eol2 + 1;
        if (from3 === end) break;
        indices.push(end);
      }
      const offset4 = (point5.line > 1 ? indices[point5.line - 2] : 0) + point5.column - 1;
      if (offset4 < indices[point5.line - 1]) return offset4;
    }
  }
}
function next(value, from3) {
  const cr4 = value.indexOf("\r", from3);
  const lf = value.indexOf("\n", from3);
  if (lf === -1) return cr4;
  if (cr4 === -1 || cr4 + 1 === lf) return lf;
  return cr4 < lf ? cr4 : lf;
}

// ../node_modules/.pnpm/web-namespaces@2.0.1/node_modules/web-namespaces/index.js
var webNamespaces = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

// ../node_modules/.pnpm/hast-util-from-parse5@8.0.3/node_modules/hast-util-from-parse5/lib/index.js
var own = {}.hasOwnProperty;
var proto = Object.prototype;
function fromParse5(tree, options) {
  const settings = options || {};
  return one(
    {
      file: settings.file || void 0,
      location: false,
      schema: settings.space === "svg" ? svg2 : html2,
      verbose: settings.verbose || false
    },
    tree
  );
}
function one(state, node2) {
  let result;
  switch (node2.nodeName) {
    case "#comment": {
      const reference = (
        /** @type {DefaultTreeAdapterMap['commentNode']} */
        node2
      );
      result = { type: "comment", value: reference.data };
      patch(state, reference, result);
      return result;
    }
    case "#document":
    case "#document-fragment": {
      const reference = (
        /** @type {DefaultTreeAdapterMap['document'] | DefaultTreeAdapterMap['documentFragment']} */
        node2
      );
      const quirksMode = "mode" in reference ? reference.mode === "quirks" || reference.mode === "limited-quirks" : false;
      result = {
        type: "root",
        children: all2(state, node2.childNodes),
        data: { quirksMode }
      };
      if (state.file && state.location) {
        const document4 = String(state.file);
        const loc = location2(document4);
        const start = loc.toPoint(0);
        const end = loc.toPoint(document4.length);
        ok(start, "expected `start`");
        ok(end, "expected `end`");
        result.position = { start, end };
      }
      return result;
    }
    case "#documentType": {
      const reference = (
        /** @type {DefaultTreeAdapterMap['documentType']} */
        node2
      );
      result = { type: "doctype" };
      patch(state, reference, result);
      return result;
    }
    case "#text": {
      const reference = (
        /** @type {DefaultTreeAdapterMap['textNode']} */
        node2
      );
      result = { type: "text", value: reference.value };
      patch(state, reference, result);
      return result;
    }
    // Element.
    default: {
      const reference = (
        /** @type {DefaultTreeAdapterMap['element']} */
        node2
      );
      result = element2(state, reference);
      return result;
    }
  }
}
function all2(state, nodes) {
  let index4 = -1;
  const results = [];
  while (++index4 < nodes.length) {
    const result = (
      /** @type {RootContent} */
      one(state, nodes[index4])
    );
    results.push(result);
  }
  return results;
}
function element2(state, node2) {
  const schema = state.schema;
  state.schema = node2.namespaceURI === webNamespaces.svg ? svg2 : html2;
  let index4 = -1;
  const properties = {};
  while (++index4 < node2.attrs.length) {
    const attribute = node2.attrs[index4];
    const name = (attribute.prefix ? attribute.prefix + ":" : "") + attribute.name;
    if (!own.call(proto, name)) {
      properties[name] = attribute.value;
    }
  }
  const x4 = state.schema.space === "svg" ? s : h2;
  const result = x4(node2.tagName, properties, all2(state, node2.childNodes));
  patch(state, node2, result);
  if (result.tagName === "template") {
    const reference = (
      /** @type {DefaultTreeAdapterMap['template']} */
      node2
    );
    const pos = reference.sourceCodeLocation;
    const startTag = pos && pos.startTag && position(pos.startTag);
    const endTag = pos && pos.endTag && position(pos.endTag);
    const content5 = (
      /** @type {Root} */
      one(state, reference.content)
    );
    if (startTag && endTag && state.file) {
      content5.position = { start: startTag.end, end: endTag.start };
    }
    result.content = content5;
  }
  state.schema = schema;
  return result;
}
function patch(state, from3, to3) {
  if ("sourceCodeLocation" in from3 && from3.sourceCodeLocation && state.file) {
    const position4 = createLocation(state, to3, from3.sourceCodeLocation);
    if (position4) {
      state.location = true;
      to3.position = position4;
    }
  }
}
function createLocation(state, node2, location3) {
  const result = position(location3);
  if (node2.type === "element") {
    const tail = node2.children[node2.children.length - 1];
    if (result && !location3.endTag && tail && tail.position && tail.position.end) {
      result.end = Object.assign({}, tail.position.end);
    }
    if (state.verbose) {
      const properties = {};
      let key2;
      if (location3.attrs) {
        for (key2 in location3.attrs) {
          if (own.call(location3.attrs, key2)) {
            properties[find3(state.schema, key2).property] = position(
              location3.attrs[key2]
            );
          }
        }
      }
      ok(location3.startTag, "a start tag should exist");
      const opening2 = position(location3.startTag);
      const closing2 = location3.endTag ? position(location3.endTag) : void 0;
      const data = { opening: opening2 };
      if (closing2) data.closing = closing2;
      data.properties = properties;
      node2.data = { position: data };
    }
  }
  return result;
}
function position(loc) {
  const start = point({
    line: loc.startLine,
    column: loc.startCol,
    offset: loc.startOffset
  });
  const end = point({
    line: loc.endLine,
    column: loc.endCol,
    offset: loc.endOffset
  });
  return start || end ? { start, end } : void 0;
}
function point(point5) {
  return point5.line && point5.column ? point5 : void 0;
}

// ../node_modules/.pnpm/parse5@7.3.0/node_modules/parse5/dist/common/unicode.js
var UNDEFINED_CODE_POINTS = /* @__PURE__ */ new Set([
  65534,
  65535,
  131070,
  131071,
  196606,
  196607,
  262142,
  262143,
  327678,
  327679,
  393214,
  393215,
  458750,
  458751,
  524286,
  524287,
  589822,
  589823,
  655358,
  655359,
  720894,
  720895,
  786430,
  786431,
  851966,
  851967,
  917502,
  917503,
  983038,
  983039,
  1048574,
  1048575,
  1114110,
  1114111
]);
var REPLACEMENT_CHARACTER = "";
var CODE_POINTS;
(function(CODE_POINTS2) {
  CODE_POINTS2[CODE_POINTS2["EOF"] = -1] = "EOF";
  CODE_POINTS2[CODE_POINTS2["NULL"] = 0] = "NULL";
  CODE_POINTS2[CODE_POINTS2["TABULATION"] = 9] = "TABULATION";
  CODE_POINTS2[CODE_POINTS2["CARRIAGE_RETURN"] = 13] = "CARRIAGE_RETURN";
  CODE_POINTS2[CODE_POINTS2["LINE_FEED"] = 10] = "LINE_FEED";
  CODE_POINTS2[CODE_POINTS2["FORM_FEED"] = 12] = "FORM_FEED";
  CODE_POINTS2[CODE_POINTS2["SPACE"] = 32] = "SPACE";
  CODE_POINTS2[CODE_POINTS2["EXCLAMATION_MARK"] = 33] = "EXCLAMATION_MARK";
  CODE_POINTS2[CODE_POINTS2["QUOTATION_MARK"] = 34] = "QUOTATION_MARK";
  CODE_POINTS2[CODE_POINTS2["AMPERSAND"] = 38] = "AMPERSAND";
  CODE_POINTS2[CODE_POINTS2["APOSTROPHE"] = 39] = "APOSTROPHE";
  CODE_POINTS2[CODE_POINTS2["HYPHEN_MINUS"] = 45] = "HYPHEN_MINUS";
  CODE_POINTS2[CODE_POINTS2["SOLIDUS"] = 47] = "SOLIDUS";
  CODE_POINTS2[CODE_POINTS2["DIGIT_0"] = 48] = "DIGIT_0";
  CODE_POINTS2[CODE_POINTS2["DIGIT_9"] = 57] = "DIGIT_9";
  CODE_POINTS2[CODE_POINTS2["SEMICOLON"] = 59] = "SEMICOLON";
  CODE_POINTS2[CODE_POINTS2["LESS_THAN_SIGN"] = 60] = "LESS_THAN_SIGN";
  CODE_POINTS2[CODE_POINTS2["EQUALS_SIGN"] = 61] = "EQUALS_SIGN";
  CODE_POINTS2[CODE_POINTS2["GREATER_THAN_SIGN"] = 62] = "GREATER_THAN_SIGN";
  CODE_POINTS2[CODE_POINTS2["QUESTION_MARK"] = 63] = "QUESTION_MARK";
  CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_A"] = 65] = "LATIN_CAPITAL_A";
  CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_Z"] = 90] = "LATIN_CAPITAL_Z";
  CODE_POINTS2[CODE_POINTS2["RIGHT_SQUARE_BRACKET"] = 93] = "RIGHT_SQUARE_BRACKET";
  CODE_POINTS2[CODE_POINTS2["GRAVE_ACCENT"] = 96] = "GRAVE_ACCENT";
  CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_A"] = 97] = "LATIN_SMALL_A";
  CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_Z"] = 122] = "LATIN_SMALL_Z";
})(CODE_POINTS || (CODE_POINTS = {}));
var SEQUENCES = {
  DASH_DASH: "--",
  CDATA_START: "[CDATA[",
  DOCTYPE: "doctype",
  SCRIPT: "script",
  PUBLIC: "public",
  SYSTEM: "system"
};
function isSurrogate(cp) {
  return cp >= 55296 && cp <= 57343;
}
function isSurrogatePair(cp) {
  return cp >= 56320 && cp <= 57343;
}
function getSurrogatePairCodePoint(cp1, cp2) {
  return (cp1 - 55296) * 1024 + 9216 + cp2;
}
function isControlCodePoint(cp) {
  return cp !== 32 && cp !== 10 && cp !== 13 && cp !== 9 && cp !== 12 && cp >= 1 && cp <= 31 || cp >= 127 && cp <= 159;
}
function isUndefinedCodePoint(cp) {
  return cp >= 64976 && cp <= 65007 || UNDEFINED_CODE_POINTS.has(cp);
}

// ../node_modules/.pnpm/parse5@7.3.0/node_modules/parse5/dist/common/error-codes.js
var ERR;
(function(ERR2) {
  ERR2["controlCharacterInInputStream"] = "control-character-in-input-stream";
  ERR2["noncharacterInInputStream"] = "noncharacter-in-input-stream";
  ERR2["surrogateInInputStream"] = "surrogate-in-input-stream";
  ERR2["nonVoidHtmlElementStartTagWithTrailingSolidus"] = "non-void-html-element-start-tag-with-trailing-solidus";
  ERR2["endTagWithAttributes"] = "end-tag-with-attributes";
  ERR2["endTagWithTrailingSolidus"] = "end-tag-with-trailing-solidus";
  ERR2["unexpectedSolidusInTag"] = "unexpected-solidus-in-tag";
  ERR2["unexpectedNullCharacter"] = "unexpected-null-character";
  ERR2["unexpectedQuestionMarkInsteadOfTagName"] = "unexpected-question-mark-instead-of-tag-name";
  ERR2["invalidFirstCharacterOfTagName"] = "invalid-first-character-of-tag-name";
  ERR2["unexpectedEqualsSignBeforeAttributeName"] = "unexpected-equals-sign-before-attribute-name";
  ERR2["missingEndTagName"] = "missing-end-tag-name";
  ERR2["unexpectedCharacterInAttributeName"] = "unexpected-character-in-attribute-name";
  ERR2["unknownNamedCharacterReference"] = "unknown-named-character-reference";
  ERR2["missingSemicolonAfterCharacterReference"] = "missing-semicolon-after-character-reference";
  ERR2["unexpectedCharacterAfterDoctypeSystemIdentifier"] = "unexpected-character-after-doctype-system-identifier";
  ERR2["unexpectedCharacterInUnquotedAttributeValue"] = "unexpected-character-in-unquoted-attribute-value";
  ERR2["eofBeforeTagName"] = "eof-before-tag-name";
  ERR2["eofInTag"] = "eof-in-tag";
  ERR2["missingAttributeValue"] = "missing-attribute-value";
  ERR2["missingWhitespaceBetweenAttributes"] = "missing-whitespace-between-attributes";
  ERR2["missingWhitespaceAfterDoctypePublicKeyword"] = "missing-whitespace-after-doctype-public-keyword";
  ERR2["missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers"] = "missing-whitespace-between-doctype-public-and-system-identifiers";
  ERR2["missingWhitespaceAfterDoctypeSystemKeyword"] = "missing-whitespace-after-doctype-system-keyword";
  ERR2["missingQuoteBeforeDoctypePublicIdentifier"] = "missing-quote-before-doctype-public-identifier";
  ERR2["missingQuoteBeforeDoctypeSystemIdentifier"] = "missing-quote-before-doctype-system-identifier";
  ERR2["missingDoctypePublicIdentifier"] = "missing-doctype-public-identifier";
  ERR2["missingDoctypeSystemIdentifier"] = "missing-doctype-system-identifier";
  ERR2["abruptDoctypePublicIdentifier"] = "abrupt-doctype-public-identifier";
  ERR2["abruptDoctypeSystemIdentifier"] = "abrupt-doctype-system-identifier";
  ERR2["cdataInHtmlContent"] = "cdata-in-html-content";
  ERR2["incorrectlyOpenedComment"] = "incorrectly-opened-comment";
  ERR2["eofInScriptHtmlCommentLikeText"] = "eof-in-script-html-comment-like-text";
  ERR2["eofInDoctype"] = "eof-in-doctype";
  ERR2["nestedComment"] = "nested-comment";
  ERR2["abruptClosingOfEmptyComment"] = "abrupt-closing-of-empty-comment";
  ERR2["eofInComment"] = "eof-in-comment";
  ERR2["incorrectlyClosedComment"] = "incorrectly-closed-comment";
  ERR2["eofInCdata"] = "eof-in-cdata";
  ERR2["absenceOfDigitsInNumericCharacterReference"] = "absence-of-digits-in-numeric-character-reference";
  ERR2["nullCharacterReference"] = "null-character-reference";
  ERR2["surrogateCharacterReference"] = "surrogate-character-reference";
  ERR2["characterReferenceOutsideUnicodeRange"] = "character-reference-outside-unicode-range";
  ERR2["controlCharacterReference"] = "control-character-reference";
  ERR2["noncharacterCharacterReference"] = "noncharacter-character-reference";
  ERR2["missingWhitespaceBeforeDoctypeName"] = "missing-whitespace-before-doctype-name";
  ERR2["missingDoctypeName"] = "missing-doctype-name";
  ERR2["invalidCharacterSequenceAfterDoctypeName"] = "invalid-character-sequence-after-doctype-name";
  ERR2["duplicateAttribute"] = "duplicate-attribute";
  ERR2["nonConformingDoctype"] = "non-conforming-doctype";
  ERR2["missingDoctype"] = "missing-doctype";
  ERR2["misplacedDoctype"] = "misplaced-doctype";
  ERR2["endTagWithoutMatchingOpenElement"] = "end-tag-without-matching-open-element";
  ERR2["closingOfElementWithOpenChildElements"] = "closing-of-element-with-open-child-elements";
  ERR2["disallowedContentInNoscriptInHead"] = "disallowed-content-in-noscript-in-head";
  ERR2["openElementsLeftAfterEof"] = "open-elements-left-after-eof";
  ERR2["abandonedHeadElementChild"] = "abandoned-head-element-child";
  ERR2["misplacedStartTagForHeadElement"] = "misplaced-start-tag-for-head-element";
  ERR2["nestedNoscriptInHead"] = "nested-noscript-in-head";
  ERR2["eofInElementThatCanContainOnlyText"] = "eof-in-element-that-can-contain-only-text";
})(ERR || (ERR = {}));

// ../node_modules/.pnpm/parse5@7.3.0/node_modules/parse5/dist/tokenizer/preprocessor.js
var DEFAULT_BUFFER_WATERLINE = 1 << 16;
var Preprocessor = class {
  constructor(handler) {
    this.handler = handler;
    this.html = "";
    this.pos = -1;
    this.lastGapPos = -2;
    this.gapStack = [];
    this.skipNextNewLine = false;
    this.lastChunkWritten = false;
    this.endOfChunkHit = false;
    this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
    this.isEol = false;
    this.lineStartPos = 0;
    this.droppedBufferSize = 0;
    this.line = 1;
    this.lastErrOffset = -1;
  }
  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
  get col() {
    return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(code5, cpOffset) {
    const { line, col, offset: offset4 } = this;
    const startCol = col + cpOffset;
    const startOffset = offset4 + cpOffset;
    return {
      code: code5,
      startLine: line,
      endLine: line,
      startCol,
      endCol: startCol,
      startOffset,
      endOffset: startOffset
    };
  }
  _err(code5) {
    if (this.handler.onParseError && this.lastErrOffset !== this.offset) {
      this.lastErrOffset = this.offset;
      this.handler.onParseError(this.getError(code5, 0));
    }
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos);
    this.lastGapPos = this.pos;
  }
  _processSurrogate(cp) {
    if (this.pos !== this.html.length - 1) {
      const nextCp = this.html.charCodeAt(this.pos + 1);
      if (isSurrogatePair(nextCp)) {
        this.pos++;
        this._addGap();
        return getSurrogatePairCodePoint(cp, nextCp);
      }
    } else if (!this.lastChunkWritten) {
      this.endOfChunkHit = true;
      return CODE_POINTS.EOF;
    }
    this._err(ERR.surrogateInInputStream);
    return cp;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    if (this.willDropParsedChunk()) {
      this.html = this.html.substring(this.pos);
      this.lineStartPos -= this.pos;
      this.droppedBufferSize += this.pos;
      this.pos = 0;
      this.lastGapPos = -2;
      this.gapStack.length = 0;
    }
  }
  write(chunk, isLastChunk) {
    if (this.html.length > 0) {
      this.html += chunk;
    } else {
      this.html = chunk;
    }
    this.endOfChunkHit = false;
    this.lastChunkWritten = isLastChunk;
  }
  insertHtmlAtCurrentPos(chunk) {
    this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);
    this.endOfChunkHit = false;
  }
  startsWith(pattern, caseSensitive) {
    if (this.pos + pattern.length > this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return false;
    }
    if (caseSensitive) {
      return this.html.startsWith(pattern, this.pos);
    }
    for (let i2 = 0; i2 < pattern.length; i2++) {
      const cp = this.html.charCodeAt(this.pos + i2) | 32;
      if (cp !== pattern.charCodeAt(i2)) {
        return false;
      }
    }
    return true;
  }
  peek(offset4) {
    const pos = this.pos + offset4;
    if (pos >= this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return CODE_POINTS.EOF;
    }
    const code5 = this.html.charCodeAt(pos);
    return code5 === CODE_POINTS.CARRIAGE_RETURN ? CODE_POINTS.LINE_FEED : code5;
  }
  advance() {
    this.pos++;
    if (this.isEol) {
      this.isEol = false;
      this.line++;
      this.lineStartPos = this.pos;
    }
    if (this.pos >= this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return CODE_POINTS.EOF;
    }
    let cp = this.html.charCodeAt(this.pos);
    if (cp === CODE_POINTS.CARRIAGE_RETURN) {
      this.isEol = true;
      this.skipNextNewLine = true;
      return CODE_POINTS.LINE_FEED;
    }
    if (cp === CODE_POINTS.LINE_FEED) {
      this.isEol = true;
      if (this.skipNextNewLine) {
        this.line--;
        this.skipNextNewLine = false;
        this._addGap();
        return this.advance();
      }
    }
    this.skipNextNewLine = false;
    if (isSurrogate(cp)) {
      cp = this._processSurrogate(cp);
    }
    const isCommonValidRange = this.handler.onParseError === null || cp > 31 && cp < 127 || cp === CODE_POINTS.LINE_FEED || cp === CODE_POINTS.CARRIAGE_RETURN || cp > 159 && cp < 64976;
    if (!isCommonValidRange) {
      this._checkForProblematicCharacters(cp);
    }
    return cp;
  }
  _checkForProblematicCharacters(cp) {
    if (isControlCodePoint(cp)) {
      this._err(ERR.controlCharacterInInputStream);
    } else if (isUndefinedCodePoint(cp)) {
      this._err(ERR.noncharacterInInputStream);
    }
  }
  retreat(count2) {
    this.pos -= count2;
    while (this.pos < this.lastGapPos) {
      this.lastGapPos = this.gapStack.pop();
      this.pos--;
    }
    this.isEol = false;
  }
};

// ../node_modules/.pnpm/parse5@7.3.0/node_modules/parse5/dist/common/token.js
var TokenType;
(function(TokenType2) {
  TokenType2[TokenType2["CHARACTER"] = 0] = "CHARACTER";
  TokenType2[TokenType2["NULL_CHARACTER"] = 1] = "NULL_CHARACTER";
  TokenType2[TokenType2["WHITESPACE_CHARACTER"] = 2] = "WHITESPACE_CHARACTER";
  TokenType2[TokenType2["START_TAG"] = 3] = "START_TAG";
  TokenType2[TokenType2["END_TAG"] = 4] = "END_TAG";
  TokenType2[TokenType2["COMMENT"] = 5] = "COMMENT";
  TokenType2[TokenType2["DOCTYPE"] = 6] = "DOCTYPE";
  TokenType2[TokenType2["EOF"] = 7] = "EOF";
  TokenType2[TokenType2["HIBERNATION"] = 8] = "HIBERNATION";
})(TokenType || (TokenType = {}));
function getTokenAttr(token, attrName) {
  for (let i2 = token.attrs.length - 1; i2 >= 0; i2--) {
    if (token.attrs[i2].name === attrName) {
      return token.attrs[i2].value;
    }
  }
  return null;
}

// ../node_modules/.pnpm/entities@6.0.1/node_modules/entities/dist/esm/generated/decode-data-html.js
var htmlDecodeTree = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map((c) => c.charCodeAt(0))
);

// ../node_modules/.pnpm/entities@6.0.1/node_modules/entities/dist/esm/generated/decode-data-xml.js
var xmlDecodeTree = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map((c) => c.charCodeAt(0))
);

// ../node_modules/.pnpm/entities@6.0.1/node_modules/entities/dist/esm/decode-codepoint.js
var _a;
var decodeMap = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var fromCodePoint2 = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, n/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
);
function replaceCodePoint(codePoint) {
  var _a2;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
}

// ../node_modules/.pnpm/entities@6.0.1/node_modules/entities/dist/esm/decode.js
var CharCodes;
(function(CharCodes2) {
  CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
  CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
  CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
  CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
  CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
  CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
  CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
  CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
  CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
  CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
  CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
var TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber2(code5) {
  return code5 >= CharCodes.ZERO && code5 <= CharCodes.NINE;
}
function isHexadecimalCharacter(code5) {
  return code5 >= CharCodes.UPPER_A && code5 <= CharCodes.UPPER_F || code5 >= CharCodes.LOWER_A && code5 <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code5) {
  return code5 >= CharCodes.UPPER_A && code5 <= CharCodes.UPPER_Z || code5 >= CharCodes.LOWER_A && code5 <= CharCodes.LOWER_Z || isNumber2(code5);
}
function isEntityInAttributeInvalidEnd(code5) {
  return code5 === CharCodes.EQUALS || isAsciiAlphaNumeric(code5);
}
var EntityDecoderState;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
var EntityDecoder = class {
  constructor(decodeTree, emitCodePoint, errors2) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors2;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(input2, offset4) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (input2.charCodeAt(offset4) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(input2, offset4 + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(input2, offset4);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(input2, offset4);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(input2, offset4);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(input2, offset4);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(input2, offset4);
      }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(input2, offset4) {
    if (offset4 >= input2.length) {
      return -1;
    }
    if ((input2.charCodeAt(offset4) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(input2, offset4 + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(input2, offset4);
  }
  addToNumericResult(input2, start, end, base3) {
    if (start !== end) {
      const digitCount = end - start;
      this.result = this.result * Math.pow(base3, digitCount) + Number.parseInt(input2.substr(start, digitCount), base3);
      this.consumed += digitCount;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(input2, offset4) {
    const startIndex = offset4;
    while (offset4 < input2.length) {
      const char = input2.charCodeAt(offset4);
      if (isNumber2(char) || isHexadecimalCharacter(char)) {
        offset4 += 1;
      } else {
        this.addToNumericResult(input2, startIndex, offset4, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(input2, startIndex, offset4, 16);
    return -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(input2, offset4) {
    const startIndex = offset4;
    while (offset4 < input2.length) {
      const char = input2.charCodeAt(offset4);
      if (isNumber2(char)) {
        offset4 += 1;
      } else {
        this.addToNumericResult(input2, startIndex, offset4, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(input2, startIndex, offset4, 10);
    return -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a2;
    if (this.consumed <= expectedLength) {
      (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(input2, offset4) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; offset4 < input2.length; offset4++, this.excess++) {
      const char = input2.charCodeAt(offset4);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
        (valueLength === 0 || // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a2;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a2;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      // Otherwise, emit a numeric entity if we have one.
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
};
function getDecoder(decodeTree) {
  let returnValue = "";
  const decoder = new EntityDecoder(decodeTree, (data) => returnValue += fromCodePoint2(data));
  return function decodeWithTrie(input2, decodeMode) {
    let lastIndex = 0;
    let offset4 = 0;
    while ((offset4 = input2.indexOf("&", offset4)) >= 0) {
      returnValue += input2.slice(lastIndex, offset4);
      decoder.startEntity(decodeMode);
      const length3 = decoder.write(
        input2,
        // Skip the "&"
        offset4 + 1
      );
      if (length3 < 0) {
        lastIndex = offset4 + decoder.end();
        break;
      }
      lastIndex = offset4 + length3;
      offset4 = length3 === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = returnValue + input2.slice(lastIndex);
    returnValue = "";
    return result;
  };
}
function determineBranch(decodeTree, current, nodeIndex, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIndex : -1;
  }
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIndex + value] - 1;
  }
  let lo3 = nodeIndex;
  let hi = lo3 + branchCount - 1;
  while (lo3 <= hi) {
    const mid = lo3 + hi >>> 1;
    const midValue = decodeTree[mid];
    if (midValue < char) {
      lo3 = mid + 1;
    } else if (midValue > char) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
var htmlDecoder = getDecoder(htmlDecodeTree);
var xmlDecoder = getDecoder(xmlDecodeTree);

// ../node_modules/.pnpm/parse5@7.3.0/node_modules/parse5/dist/common/html.js
var NS;
(function(NS2) {
  NS2["HTML"] = "http://www.w3.org/1999/xhtml";
  NS2["MATHML"] = "http://www.w3.org/1998/Math/MathML";
  NS2["SVG"] = "http://www.w3.org/2000/svg";
  NS2["XLINK"] = "http://www.w3.org/1999/xlink";
  NS2["XML"] = "http://www.w3.org/XML/1998/namespace";
  NS2["XMLNS"] = "http://www.w3.org/2000/xmlns/";
})(NS || (NS = {}));
var ATTRS;
(function(ATTRS2) {
  ATTRS2["TYPE"] = "type";
  ATTRS2["ACTION"] = "action";
  ATTRS2["ENCODING"] = "encoding";
  ATTRS2["PROMPT"] = "prompt";
  ATTRS2["NAME"] = "name";
  ATTRS2["COLOR"] = "color";
  ATTRS2["FACE"] = "face";
  ATTRS2["SIZE"] = "size";
})(ATTRS || (ATTRS = {}));
var DOCUMENT_MODE;
(function(DOCUMENT_MODE2) {
  DOCUMENT_MODE2["NO_QUIRKS"] = "no-quirks";
  DOCUMENT_MODE2["QUIRKS"] = "quirks";
  DOCUMENT_MODE2["LIMITED_QUIRKS"] = "limited-quirks";
})(DOCUMENT_MODE || (DOCUMENT_MODE = {}));
var TAG_NAMES;
(function(TAG_NAMES2) {
  TAG_NAMES2["A"] = "a";
  TAG_NAMES2["ADDRESS"] = "address";
  TAG_NAMES2["ANNOTATION_XML"] = "annotation-xml";
  TAG_NAMES2["APPLET"] = "applet";
  TAG_NAMES2["AREA"] = "area";
  TAG_NAMES2["ARTICLE"] = "article";
  TAG_NAMES2["ASIDE"] = "aside";
  TAG_NAMES2["B"] = "b";
  TAG_NAMES2["BASE"] = "base";
  TAG_NAMES2["BASEFONT"] = "basefont";
  TAG_NAMES2["BGSOUND"] = "bgsound";
  TAG_NAMES2["BIG"] = "big";
  TAG_NAMES2["BLOCKQUOTE"] = "blockquote";
  TAG_NAMES2["BODY"] = "body";
  TAG_NAMES2["BR"] = "br";
  TAG_NAMES2["BUTTON"] = "button";
  TAG_NAMES2["CAPTION"] = "caption";
  TAG_NAMES2["CENTER"] = "center";
  TAG_NAMES2["CODE"] = "code";
  TAG_NAMES2["COL"] = "col";
  TAG_NAMES2["COLGROUP"] = "colgroup";
  TAG_NAMES2["DD"] = "dd";
  TAG_NAMES2["DESC"] = "desc";
  TAG_NAMES2["DETAILS"] = "details";
  TAG_NAMES2["DIALOG"] = "dialog";
  TAG_NAMES2["DIR"] = "dir";
  TAG_NAMES2["DIV"] = "div";
  TAG_NAMES2["DL"] = "dl";
  TAG_NAMES2["DT"] = "dt";
  TAG_NAMES2["EM"] = "em";
  TAG_NAMES2["EMBED"] = "embed";
  TAG_NAMES2["FIELDSET"] = "fieldset";
  TAG_NAMES2["FIGCAPTION"] = "figcaption";
  TAG_NAMES2["FIGURE"] = "figure";
  TAG_NAMES2["FONT"] = "font";
  TAG_NAMES2["FOOTER"] = "footer";
  TAG_NAMES2["FOREIGN_OBJECT"] = "foreignObject";
  TAG_NAMES2["FORM"] = "form";
  TAG_NAMES2["FRAME"] = "frame";
  TAG_NAMES2["FRAMESET"] = "frameset";
  TAG_NAMES2["H1"] = "h1";
  TAG_NAMES2["H2"] = "h2";
  TAG_NAMES2["H3"] = "h3";
  TAG_NAMES2["H4"] = "h4";
  TAG_NAMES2["H5"] = "h5";
  TAG_NAMES2["H6"] = "h6";
  TAG_NAMES2["HEAD"] = "head";
  TAG_NAMES2["HEADER"] = "header";
  TAG_NAMES2["HGROUP"] = "hgroup";
  TAG_NAMES2["HR"] = "hr";
  TAG_NAMES2["HTML"] = "html";
  TAG_NAMES2["I"] = "i";
  TAG_NAMES2["IMG"] = "img";
  TAG_NAMES2["IMAGE"] = "image";
  TAG_NAMES2["INPUT"] = "input";
  TAG_NAMES2["IFRAME"] = "iframe";
  TAG_NAMES2["KEYGEN"] = "keygen";
  TAG_NAMES2["LABEL"] = "label";
  TAG_NAMES2["LI"] = "li";
  TAG_NAMES2["LINK"] = "link";
  TAG_NAMES2["LISTING"] = "listing";
  TAG_NAMES2["MAIN"] = "main";
  TAG_NAMES2["MALIGNMARK"] = "malignmark";
  TAG_NAMES2["MARQUEE"] = "marquee";
  TAG_NAMES2["MATH"] = "math";
  TAG_NAMES2["MENU"] = "menu";
  TAG_NAMES2["META"] = "meta";
  TAG_NAMES2["MGLYPH"] = "mglyph";
  TAG_NAMES2["MI"] = "mi";
  TAG_NAMES2["MO"] = "mo";
  TAG_NAMES2["MN"] = "mn";
  TAG_NAMES2["MS"] = "ms";
  TAG_NAMES2["MTEXT"] = "mtext";
  TAG_NAMES2["NAV"] = "nav";
  TAG_NAMES2["NOBR"] = "nobr";
  TAG_NAMES2["NOFRAMES"] = "noframes";
  TAG_NAMES2["NOEMBED"] = "noembed";
  TAG_NAMES2["NOSCRIPT"] = "noscript";
  TAG_NAMES2["OBJECT"] = "object";
  TAG_NAMES2["OL"] = "ol";
  TAG_NAMES2["OPTGROUP"] = "optgroup";
  TAG_NAMES2["OPTION"] = "option";
  TAG_NAMES2["P"] = "p";
  TAG_NAMES2["PARAM"] = "param";
  TAG_NAMES2["PLAINTEXT"] = "plaintext";
  TAG_NAMES2["PRE"] = "pre";
  TAG_NAMES2["RB"] = "rb";
  TAG_NAMES2["RP"] = "rp";
  TAG_NAMES2["RT"] = "rt";
  TAG_NAMES2["RTC"] = "rtc";
  TAG_NAMES2["RUBY"] = "ruby";
  TAG_NAMES2["S"] = "s";
  TAG_NAMES2["SCRIPT"] = "script";
  TAG_NAMES2["SEARCH"] = "search";
  TAG_NAMES2["SECTION"] = "section";
  TAG_NAMES2["SELECT"] = "select";
  TAG_NAMES2["SOURCE"] = "source";
  TAG_NAMES2["SMALL"] = "small";
  TAG_NAMES2["SPAN"] = "span";
  TAG_NAMES2["STRIKE"] = "strike";
  TAG_NAMES2["STRONG"] = "strong";
  TAG_NAMES2["STYLE"] = "style";
  TAG_NAMES2["SUB"] = "sub";
  TAG_NAMES2["SUMMARY"] = "summary";
  TAG_NAMES2["SUP"] = "sup";
  TAG_NAMES2["TABLE"] = "table";
  TAG_NAMES2["TBODY"] = "tbody";
  TAG_NAMES2["TEMPLATE"] = "template";
  TAG_NAMES2["TEXTAREA"] = "textarea";
  TAG_NAMES2["TFOOT"] = "tfoot";
  TAG_NAMES2["TD"] = "td";
  TAG_NAMES2["TH"] = "th";
  TAG_NAMES2["THEAD"] = "thead";
  TAG_NAMES2["TITLE"] = "title";
  TAG_NAMES2["TR"] = "tr";
  TAG_NAMES2["TRACK"] = "track";
  TAG_NAMES2["TT"] = "tt";
  TAG_NAMES2["U"] = "u";
  TAG_NAMES2["UL"] = "ul";
  TAG_NAMES2["SVG"] = "svg";
  TAG_NAMES2["VAR"] = "var";
  TAG_NAMES2["WBR"] = "wbr";
  TAG_NAMES2["XMP"] = "xmp";
})(TAG_NAMES || (TAG_NAMES = {}));
var TAG_ID;
(function(TAG_ID2) {
  TAG_ID2[TAG_ID2["UNKNOWN"] = 0] = "UNKNOWN";
  TAG_ID2[TAG_ID2["A"] = 1] = "A";
  TAG_ID2[TAG_ID2["ADDRESS"] = 2] = "ADDRESS";
  TAG_ID2[TAG_ID2["ANNOTATION_XML"] = 3] = "ANNOTATION_XML";
  TAG_ID2[TAG_ID2["APPLET"] = 4] = "APPLET";
  TAG_ID2[TAG_ID2["AREA"] = 5] = "AREA";
  TAG_ID2[TAG_ID2["ARTICLE"] = 6] = "ARTICLE";
  TAG_ID2[TAG_ID2["ASIDE"] = 7] = "ASIDE";
  TAG_ID2[TAG_ID2["B"] = 8] = "B";
  TAG_ID2[TAG_ID2["BASE"] = 9] = "BASE";
  TAG_ID2[TAG_ID2["BASEFONT"] = 10] = "BASEFONT";
  TAG_ID2[TAG_ID2["BGSOUND"] = 11] = "BGSOUND";
  TAG_ID2[TAG_ID2["BIG"] = 12] = "BIG";
  TAG_ID2[TAG_ID2["BLOCKQUOTE"] = 13] = "BLOCKQUOTE";
  TAG_ID2[TAG_ID2["BODY"] = 14] = "BODY";
  TAG_ID2[TAG_ID2["BR"] = 15] = "BR";
  TAG_ID2[TAG_ID2["BUTTON"] = 16] = "BUTTON";
  TAG_ID2[TAG_ID2["CAPTION"] = 17] = "CAPTION";
  TAG_ID2[TAG_ID2["CENTER"] = 18] = "CENTER";
  TAG_ID2[TAG_ID2["CODE"] = 19] = "CODE";
  TAG_ID2[TAG_ID2["COL"] = 20] = "COL";
  TAG_ID2[TAG_ID2["COLGROUP"] = 21] = "COLGROUP";
  TAG_ID2[TAG_ID2["DD"] = 22] = "DD";
  TAG_ID2[TAG_ID2["DESC"] = 23] = "DESC";
  TAG_ID2[TAG_ID2["DETAILS"] = 24] = "DETAILS";
  TAG_ID2[TAG_ID2["DIALOG"] = 25] = "DIALOG";
  TAG_ID2[TAG_ID2["DIR"] = 26] = "DIR";
  TAG_ID2[TAG_ID2["DIV"] = 27] = "DIV";
  TAG_ID2[TAG_ID2["DL"] = 28] = "DL";
  TAG_ID2[TAG_ID2["DT"] = 29] = "DT";
  TAG_ID2[TAG_ID2["EM"] = 30] = "EM";
  TAG_ID2[TAG_ID2["EMBED"] = 31] = "EMBED";
  TAG_ID2[TAG_ID2["FIELDSET"] = 32] = "FIELDSET";
  TAG_ID2[TAG_ID2["FIGCAPTION"] = 33] = "FIGCAPTION";
  TAG_ID2[TAG_ID2["FIGURE"] = 34] = "FIGURE";
  TAG_ID2[TAG_ID2["FONT"] = 35] = "FONT";
  TAG_ID2[TAG_ID2["FOOTER"] = 36] = "FOOTER";
  TAG_ID2[TAG_ID2["FOREIGN_OBJECT"] = 37] = "FOREIGN_OBJECT";
  TAG_ID2[TAG_ID2["FORM"] = 38] = "FORM";
  TAG_ID2[TAG_ID2["FRAME"] = 39] = "FRAME";
  TAG_ID2[TAG_ID2["FRAMESET"] = 40] = "FRAMESET";
  TAG_ID2[TAG_ID2["H1"] = 41] = "H1";
  TAG_ID2[TAG_ID2["H2"] = 42] = "H2";
  TAG_ID2[TAG_ID2["H3"] = 43] = "H3";
  TAG_ID2[TAG_ID2["H4"] = 44] = "H4";
  TAG_ID2[TAG_ID2["H5"] = 45] = "H5";
  TAG_ID2[TAG_ID2["H6"] = 46] = "H6";
  TAG_ID2[TAG_ID2["HEAD"] = 47] = "HEAD";
  TAG_ID2[TAG_ID2["HEADER"] = 48] = "HEADER";
  TAG_ID2[TAG_ID2["HGROUP"] = 49] = "HGROUP";
  TAG_ID2[TAG_ID2["HR"] = 50] = "HR";
  TAG_ID2[TAG_ID2["HTML"] = 51] = "HTML";
  TAG_ID2[TAG_ID2["I"] = 52] = "I";
  TAG_ID2[TAG_ID2["IMG"] = 53] = "IMG";
  TAG_ID2[TAG_ID2["IMAGE"] = 54] = "IMAGE";
  TAG_ID2[TAG_ID2["INPUT"] = 55] = "INPUT";
  TAG_ID2[TAG_ID2["IFRAME"] = 56] = "IFRAME";
  TAG_ID2[TAG_ID2["KEYGEN"] = 57] = "KEYGEN";
  TAG_ID2[TAG_ID2["LABEL"] = 58] = "LABEL";
  TAG_ID2[TAG_ID2["LI"] = 59] = "LI";
  TAG_ID2[TAG_ID2["LINK"] = 60] = "LINK";
  TAG_ID2[TAG_ID2["LISTING"] = 61] = "LISTING";
  TAG_ID2[TAG_ID2["MAIN"] = 62] = "MAIN";
  TAG_ID2[TAG_ID2["MALIGNMARK"] = 63] = "MALIGNMARK";
  TAG_ID2[TAG_ID2["MARQUEE"] = 64] = "MARQUEE";
  TAG_ID2[TAG_ID2["MATH"] = 65] = "MATH";
  TAG_ID2[TAG_ID2["MENU"] = 66] = "MENU";
  TAG_ID2[TAG_ID2["META"] = 67] = "META";
  TAG_ID2[TAG_ID2["MGLYPH"] = 68] = "MGLYPH";
  TAG_ID2[TAG_ID2["MI"] = 69] = "MI";
  TAG_ID2[TAG_ID2["MO"] = 70] = "MO";
  TAG_ID2[TAG_ID2["MN"] = 71] = "MN";
  TAG_ID2[TAG_ID2["MS"] = 72] = "MS";
  TAG_ID2[TAG_ID2["MTEXT"] = 73] = "MTEXT";
  TAG_ID2[TAG_ID2["NAV"] = 74] = "NAV";
  TAG_ID2[TAG_ID2["NOBR"] = 75] = "NOBR";
  TAG_ID2[TAG_ID2["NOFRAMES"] = 76] = "NOFRAMES";
  TAG_ID2[TAG_ID2["NOEMBED"] = 77] = "NOEMBED";
  TAG_ID2[TAG_ID2["NOSCRIPT"] = 78] = "NOSCRIPT";
  TAG_ID2[TAG_ID2["OBJECT"] = 79] = "OBJECT";
  TAG_ID2[TAG_ID2["OL"] = 80] = "OL";
  TAG_ID2[TAG_ID2["OPTGROUP"] = 81] = "OPTGROUP";
  TAG_ID2[TAG_ID2["OPTION"] = 82] = "OPTION";
  TAG_ID2[TAG_ID2["P"] = 83] = "P";
  TAG_ID2[TAG_ID2["PARAM"] = 84] = "PARAM";
  TAG_ID2[TAG_ID2["PLAINTEXT"] = 85] = "PLAINTEXT";
  TAG_ID2[TAG_ID2["PRE"] = 86] = "PRE";
  TAG_ID2[TAG_ID2["RB"] = 87] = "RB";
  TAG_ID2[TAG_ID2["RP"] = 88] = "RP";
  TAG_ID2[TAG_ID2["RT"] = 89] = "RT";
  TAG_ID2[TAG_ID2["RTC"] = 90] = "RTC";
  TAG_ID2[TAG_ID2["RUBY"] = 91] = "RUBY";
  TAG_ID2[TAG_ID2["S"] = 92] = "S";
  TAG_ID2[TAG_ID2["SCRIPT"] = 93] = "SCRIPT";
  TAG_ID2[TAG_ID2["SEARCH"] = 94] = "SEARCH";
  TAG_ID2[TAG_ID2["SECTION"] = 95] = "SECTION";
  TAG_ID2[TAG_ID2["SELECT"] = 96] = "SELECT";
  TAG_ID2[TAG_ID2["SOURCE"] = 97] = "SOURCE";
  TAG_ID2[TAG_ID2["SMALL"] = 98] = "SMALL";
  TAG_ID2[TAG_ID2["SPAN"] = 99] = "SPAN";
  TAG_ID2[TAG_ID2["STRIKE"] = 100] = "STRIKE";
  TAG_ID2[TAG_ID2["STRONG"] = 101] = "STRONG";
  TAG_ID2[TAG_ID2["STYLE"] = 102] = "STYLE";
  TAG_ID2[TAG_ID2["SUB"] = 103] = "SUB";
  TAG_ID2[TAG_ID2["SUMMARY"] = 104] = "SUMMARY";
  TAG_ID2[TAG_ID2["SUP"] = 105] = "SUP";
  TAG_ID2[TAG_ID2["TABLE"] = 106] = "TABLE";
  TAG_ID2[TAG_ID2["TBODY"] = 107] = "TBODY";
  TAG_ID2[TAG_ID2["TEMPLATE"] = 108] = "TEMPLATE";
  TAG_ID2[TAG_ID2["TEXTAREA"] = 109] = "TEXTAREA";
  TAG_ID2[TAG_ID2["TFOOT"] = 110] = "TFOOT";
  TAG_ID2[TAG_ID2["TD"] = 111] = "TD";
  TAG_ID2[TAG_ID2["TH"] = 112] = "TH";
  TAG_ID2[TAG_ID2["THEAD"] = 113] = "THEAD";
  TAG_ID2[TAG_ID2["TITLE"] = 114] = "TITLE";
  TAG_ID2[TAG_ID2["TR"] = 115] = "TR";
  TAG_ID2[TAG_ID2["TRACK"] = 116] = "TRACK";
  TAG_ID2[TAG_ID2["TT"] = 117] = "TT";
  TAG_ID2[TAG_ID2["U"] = 118] = "U";
  TAG_ID2[TAG_ID2["UL"] = 119] = "UL";
  TAG_ID2[TAG_ID2["SVG"] = 120] = "SVG";
  TAG_ID2[TAG_ID2["VAR"] = 121] = "VAR";
  TAG_ID2[TAG_ID2["WBR"] = 122] = "WBR";
  TAG_ID2[TAG_ID2["XMP"] = 123] = "XMP";
})(TAG_ID || (TAG_ID = {}));
var TAG_NAME_TO_ID = /* @__PURE__ */ new Map([
  [TAG_NAMES.A, TAG_ID.A],
  [TAG_NAMES.ADDRESS, TAG_ID.ADDRESS],
  [TAG_NAMES.ANNOTATION_XML, TAG_ID.ANNOTATION_XML],
  [TAG_NAMES.APPLET, TAG_ID.APPLET],
  [TAG_NAMES.AREA, TAG_ID.AREA],
  [TAG_NAMES.ARTICLE, TAG_ID.ARTICLE],
  [TAG_NAMES.ASIDE, TAG_ID.ASIDE],
  [TAG_NAMES.B, TAG_ID.B],
  [TAG_NAMES.BASE, TAG_ID.BASE],
  [TAG_NAMES.BASEFONT, TAG_ID.BASEFONT],
  [TAG_NAMES.BGSOUND, TAG_ID.BGSOUND],
  [TAG_NAMES.BIG, TAG_ID.BIG],
  [TAG_NAMES.BLOCKQUOTE, TAG_ID.BLOCKQUOTE],
  [TAG_NAMES.BODY, TAG_ID.BODY],
  [TAG_NAMES.BR, TAG_ID.BR],
  [TAG_NAMES.BUTTON, TAG_ID.BUTTON],
  [TAG_NAMES.CAPTION, TAG_ID.CAPTION],
  [TAG_NAMES.CENTER, TAG_ID.CENTER],
  [TAG_NAMES.CODE, TAG_ID.CODE],
  [TAG_NAMES.COL, TAG_ID.COL],
  [TAG_NAMES.COLGROUP, TAG_ID.COLGROUP],
  [TAG_NAMES.DD, TAG_ID.DD],
  [TAG_NAMES.DESC, TAG_ID.DESC],
  [TAG_NAMES.DETAILS, TAG_ID.DETAILS],
  [TAG_NAMES.DIALOG, TAG_ID.DIALOG],
  [TAG_NAMES.DIR, TAG_ID.DIR],
  [TAG_NAMES.DIV, TAG_ID.DIV],
  [TAG_NAMES.DL, TAG_ID.DL],
  [TAG_NAMES.DT, TAG_ID.DT],
  [TAG_NAMES.EM, TAG_ID.EM],
  [TAG_NAMES.EMBED, TAG_ID.EMBED],
  [TAG_NAMES.FIELDSET, TAG_ID.FIELDSET],
  [TAG_NAMES.FIGCAPTION, TAG_ID.FIGCAPTION],
  [TAG_NAMES.FIGURE, TAG_ID.FIGURE],
  [TAG_NAMES.FONT, TAG_ID.FONT],
  [TAG_NAMES.FOOTER, TAG_ID.FOOTER],
  [TAG_NAMES.FOREIGN_OBJECT, TAG_ID.FOREIGN_OBJECT],
  [TAG_NAMES.FORM, TAG_ID.FORM],
  [TAG_NAMES.FRAME, TAG_ID.FRAME],
  [TAG_NAMES.FRAMESET, TAG_ID.FRAMESET],
  [TAG_NAMES.H1, TAG_ID.H1],
  [TAG_NAMES.H2, TAG_ID.H2],
  [TAG_NAMES.H3, TAG_ID.H3],
  [TAG_NAMES.H4, TAG_ID.H4],
  [TAG_NAMES.H5, TAG_ID.H5],
  [TAG_NAMES.H6, TAG_ID.H6],
  [TAG_NAMES.HEAD, TAG_ID.HEAD],
  [TAG_NAMES.HEADER, TAG_ID.HEADER],
  [TAG_NAMES.HGROUP, TAG_ID.HGROUP],
  [TAG_NAMES.HR, TAG_ID.HR],
  [TAG_NAMES.HTML, TAG_ID.HTML],
  [TAG_NAMES.I, TAG_ID.I],
  [TAG_NAMES.IMG, TAG_ID.IMG],
  [TAG_NAMES.IMAGE, TAG_ID.IMAGE],
  [TAG_NAMES.INPUT, TAG_ID.INPUT],
  [TAG_NAMES.IFRAME, TAG_ID.IFRAME],
  [TAG_NAMES.KEYGEN, TAG_ID.KEYGEN],
  [TAG_NAMES.LABEL, TAG_ID.LABEL],
  [TAG_NAMES.LI, TAG_ID.LI],
  [TAG_NAMES.LINK, TAG_ID.LINK],
  [TAG_NAMES.LISTING, TAG_ID.LISTING],
  [TAG_NAMES.MAIN, TAG_ID.MAIN],
  [TAG_NAMES.MALIGNMARK, TAG_ID.MALIGNMARK],
  [TAG_NAMES.MARQUEE, TAG_ID.MARQUEE],
  [TAG_NAMES.MATH, TAG_ID.MATH],
  [TAG_NAMES.MENU, TAG_ID.MENU],
  [TAG_NAMES.META, TAG_ID.META],
  [TAG_NAMES.MGLYPH, TAG_ID.MGLYPH],
  [TAG_NAMES.MI, TAG_ID.MI],
  [TAG_NAMES.MO, TAG_ID.MO],
  [TAG_NAMES.MN, TAG_ID.MN],
  [TAG_NAMES.MS, TAG_ID.MS],
  [TAG_NAMES.MTEXT, TAG_ID.MTEXT],
  [TAG_NAMES.NAV, TAG_ID.NAV],
  [TAG_NAMES.NOBR, TAG_ID.NOBR],
  [TAG_NAMES.NOFRAMES, TAG_ID.NOFRAMES],
  [TAG_NAMES.NOEMBED, TAG_ID.NOEMBED],
  [TAG_NAMES.NOSCRIPT, TAG_ID.NOSCRIPT],
  [TAG_NAMES.OBJECT, TAG_ID.OBJECT],
  [TAG_NAMES.OL, TAG_ID.OL],
  [TAG_NAMES.OPTGROUP, TAG_ID.OPTGROUP],
  [TAG_NAMES.OPTION, TAG_ID.OPTION],
  [TAG_NAMES.P, TAG_ID.P],
  [TAG_NAMES.PARAM, TAG_ID.PARAM],
  [TAG_NAMES.PLAINTEXT, TAG_ID.PLAINTEXT],
  [TAG_NAMES.PRE, TAG_ID.PRE],
  [TAG_NAMES.RB, TAG_ID.RB],
  [TAG_NAMES.RP, TAG_ID.RP],
  [TAG_NAMES.RT, TAG_ID.RT],
  [TAG_NAMES.RTC, TAG_ID.RTC],
  [TAG_NAMES.RUBY, TAG_ID.RUBY],
  [TAG_NAMES.S, TAG_ID.S],
  [TAG_NAMES.SCRIPT, TAG_ID.SCRIPT],
  [TAG_NAMES.SEARCH, TAG_ID.SEARCH],
  [TAG_NAMES.SECTION, TAG_ID.SECTION],
  [TAG_NAMES.SELECT, TAG_ID.SELECT],
  [TAG_NAMES.SOURCE, TAG_ID.SOURCE],
  [TAG_NAMES.SMALL, TAG_ID.SMALL],
  [TAG_NAMES.SPAN, TAG_ID.SPAN],
  [TAG_NAMES.STRIKE, TAG_ID.STRIKE],
  [TAG_NAMES.STRONG, TAG_ID.STRONG],
  [TAG_NAMES.STYLE, TAG_ID.STYLE],
  [TAG_NAMES.SUB, TAG_ID.SUB],
  [TAG_NAMES.SUMMARY, TAG_ID.SUMMARY],
  [TAG_NAMES.SUP, TAG_ID.SUP],
  [TAG_NAMES.TABLE, TAG_ID.TABLE],
  [TAG_NAMES.TBODY, TAG_ID.TBODY],
  [TAG_NAMES.TEMPLATE, TAG_ID.TEMPLATE],
  [TAG_NAMES.TEXTAREA, TAG_ID.TEXTAREA],
  [TAG_NAMES.TFOOT, TAG_ID.TFOOT],
  [TAG_NAMES.TD, TAG_ID.TD],
  [TAG_NAMES.TH, TAG_ID.TH],
  [TAG_NAMES.THEAD, TAG_ID.THEAD],
  [TAG_NAMES.TITLE, TAG_ID.TITLE],
  [TAG_NAMES.TR, TAG_ID.TR],
  [TAG_NAMES.TRACK, TAG_ID.TRACK],
  [TAG_NAMES.TT, TAG_ID.TT],
  [TAG_NAMES.U, TAG_ID.U],
  [TAG_NAMES.UL, TAG_ID.UL],
  [TAG_NAMES.SVG, TAG_ID.SVG],
  [TAG_NAMES.VAR, TAG_ID.VAR],
  [TAG_NAMES.WBR, TAG_ID.WBR],
  [TAG_NAMES.XMP, TAG_ID.XMP]
]);
function getTagID(tagName) {
  var _a2;
  return (_a2 = TAG_NAME_TO_ID.get(tagName)) !== null && _a2 !== void 0 ? _a2 : TAG_ID.UNKNOWN;
}
var $2 = TAG_ID;
var SPECIAL_ELEMENTS = {
  [NS.HTML]: /* @__PURE__ */ new Set([
    $2.ADDRESS,
    $2.APPLET,
    $2.AREA,
    $2.ARTICLE,
    $2.ASIDE,
    $2.BASE,
    $2.BASEFONT,
    $2.BGSOUND,
    $2.BLOCKQUOTE,
    $2.BODY,
    $2.BR,
    $2.BUTTON,
    $2.CAPTION,
    $2.CENTER,
    $2.COL,
    $2.COLGROUP,
    $2.DD,
    $2.DETAILS,
    $2.DIR,
    $2.DIV,
    $2.DL,
    $2.DT,
    $2.EMBED,
    $2.FIELDSET,
    $2.FIGCAPTION,
    $2.FIGURE,
    $2.FOOTER,
    $2.FORM,
    $2.FRAME,
    $2.FRAMESET,
    $2.H1,
    $2.H2,
    $2.H3,
    $2.H4,
    $2.H5,
    $2.H6,
    $2.HEAD,
    $2.HEADER,
    $2.HGROUP,
    $2.HR,
    $2.HTML,
    $2.IFRAME,
    $2.IMG,
    $2.INPUT,
    $2.LI,
    $2.LINK,
    $2.LISTING,
    $2.MAIN,
    $2.MARQUEE,
    $2.MENU,
    $2.META,
    $2.NAV,
    $2.NOEMBED,
    $2.NOFRAMES,
    $2.NOSCRIPT,
    $2.OBJECT,
    $2.OL,
    $2.P,
    $2.PARAM,
    $2.PLAINTEXT,
    $2.PRE,
    $2.SCRIPT,
    $2.SECTION,
    $2.SELECT,
    $2.SOURCE,
    $2.STYLE,
    $2.SUMMARY,
    $2.TABLE,
    $2.TBODY,
    $2.TD,
    $2.TEMPLATE,
    $2.TEXTAREA,
    $2.TFOOT,
    $2.TH,
    $2.THEAD,
    $2.TITLE,
    $2.TR,
    $2.TRACK,
    $2.UL,
    $2.WBR,
    $2.XMP
  ]),
  [NS.MATHML]: /* @__PURE__ */ new Set([$2.MI, $2.MO, $2.MN, $2.MS, $2.MTEXT, $2.ANNOTATION_XML]),
  [NS.SVG]: /* @__PURE__ */ new Set([$2.TITLE, $2.FOREIGN_OBJECT, $2.DESC]),
  [NS.XLINK]: /* @__PURE__ */ new Set(),
  [NS.XML]: /* @__PURE__ */ new Set(),
  [NS.XMLNS]: /* @__PURE__ */ new Set()
};
var NUMBERED_HEADERS = /* @__PURE__ */ new Set([$2.H1, $2.H2, $2.H3, $2.H4, $2.H5, $2.H6]);
var UNESCAPED_TEXT = /* @__PURE__ */ new Set([
  TAG_NAMES.STYLE,
  TAG_NAMES.SCRIPT,
  TAG_NAMES.XMP,
  TAG_NAMES.IFRAME,
  TAG_NAMES.NOEMBED,
  TAG_NAMES.NOFRAMES,
  TAG_NAMES.PLAINTEXT
]);

// ../node_modules/.pnpm/parse5@7.3.0/node_modules/parse5/dist/tokenizer/index.js
var State;
(function(State2) {
  State2[State2["DATA"] = 0] = "DATA";
  State2[State2["RCDATA"] = 1] = "RCDATA";
  State2[State2["RAWTEXT"] = 2] = "RAWTEXT";
  State2[State2["SCRIPT_DATA"] = 3] = "SCRIPT_DATA";
  State2[State2["PLAINTEXT"] = 4] = "PLAINTEXT";
  State2[State2["TAG_OPEN"] = 5] = "TAG_OPEN";
  State2[State2["END_TAG_OPEN"] = 6] = "END_TAG_OPEN";
  State2[State2["TAG_NAME"] = 7] = "TAG_NAME";
  State2[State2["RCDATA_LESS_THAN_SIGN"] = 8] = "RCDATA_LESS_THAN_SIGN";
  State2[State2["RCDATA_END_TAG_OPEN"] = 9] = "RCDATA_END_TAG_OPEN";
  State2[State2["RCDATA_END_TAG_NAME"] = 10] = "RCDATA_END_TAG_NAME";
  State2[State2["RAWTEXT_LESS_THAN_SIGN"] = 11] = "RAWTEXT_LESS_THAN_SIGN";
  State2[State2["RAWTEXT_END_TAG_OPEN"] = 12] = "RAWTEXT_END_TAG_OPEN";
  State2[State2["RAWTEXT_END_TAG_NAME"] = 13] = "RAWTEXT_END_TAG_NAME";
  State2[State2["SCRIPT_DATA_LESS_THAN_SIGN"] = 14] = "SCRIPT_DATA_LESS_THAN_SIGN";
  State2[State2["SCRIPT_DATA_END_TAG_OPEN"] = 15] = "SCRIPT_DATA_END_TAG_OPEN";
  State2[State2["SCRIPT_DATA_END_TAG_NAME"] = 16] = "SCRIPT_DATA_END_TAG_NAME";
  State2[State2["SCRIPT_DATA_ESCAPE_START"] = 17] = "SCRIPT_DATA_ESCAPE_START";
  State2[State2["SCRIPT_DATA_ESCAPE_START_DASH"] = 18] = "SCRIPT_DATA_ESCAPE_START_DASH";
  State2[State2["SCRIPT_DATA_ESCAPED"] = 19] = "SCRIPT_DATA_ESCAPED";
  State2[State2["SCRIPT_DATA_ESCAPED_DASH"] = 20] = "SCRIPT_DATA_ESCAPED_DASH";
  State2[State2["SCRIPT_DATA_ESCAPED_DASH_DASH"] = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH";
  State2[State2["SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN"] = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN";
  State2[State2["SCRIPT_DATA_ESCAPED_END_TAG_OPEN"] = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN";
  State2[State2["SCRIPT_DATA_ESCAPED_END_TAG_NAME"] = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPE_START"] = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPED"] = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPED_DASH"] = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH"] = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN"] = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPE_END"] = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END";
  State2[State2["BEFORE_ATTRIBUTE_NAME"] = 31] = "BEFORE_ATTRIBUTE_NAME";
  State2[State2["ATTRIBUTE_NAME"] = 32] = "ATTRIBUTE_NAME";
  State2[State2["AFTER_ATTRIBUTE_NAME"] = 33] = "AFTER_ATTRIBUTE_NAME";
  State2[State2["BEFORE_ATTRIBUTE_VALUE"] = 34] = "BEFORE_ATTRIBUTE_VALUE";
  State2[State2["ATTRIBUTE_VALUE_DOUBLE_QUOTED"] = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED";
  State2[State2["ATTRIBUTE_VALUE_SINGLE_QUOTED"] = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED";
  State2[State2["ATTRIBUTE_VALUE_UNQUOTED"] = 37] = "ATTRIBUTE_VALUE_UNQUOTED";
  State2[State2["AFTER_ATTRIBUTE_VALUE_QUOTED"] = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED";
  State2[State2["SELF_CLOSING_START_TAG"] = 39] = "SELF_CLOSING_START_TAG";
  State2[State2["BOGUS_COMMENT"] = 40] = "BOGUS_COMMENT";
  State2[State2["MARKUP_DECLARATION_OPEN"] = 41] = "MARKUP_DECLARATION_OPEN";
  State2[State2["COMMENT_START"] = 42] = "COMMENT_START";
  State2[State2["COMMENT_START_DASH"] = 43] = "COMMENT_START_DASH";
  State2[State2["COMMENT"] = 44] = "COMMENT";
  State2[State2["COMMENT_LESS_THAN_SIGN"] = 45] = "COMMENT_LESS_THAN_SIGN";
  State2[State2["COMMENT_LESS_THAN_SIGN_BANG"] = 46] = "COMMENT_LESS_THAN_SIGN_BANG";
  State2[State2["COMMENT_LESS_THAN_SIGN_BANG_DASH"] = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH";
  State2[State2["COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH"] = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH";
  State2[State2["COMMENT_END_DASH"] = 49] = "COMMENT_END_DASH";
  State2[State2["COMMENT_END"] = 50] = "COMMENT_END";
  State2[State2["COMMENT_END_BANG"] = 51] = "COMMENT_END_BANG";
  State2[State2["DOCTYPE"] = 52] = "DOCTYPE";
  State2[State2["BEFORE_DOCTYPE_NAME"] = 53] = "BEFORE_DOCTYPE_NAME";
  State2[State2["DOCTYPE_NAME"] = 54] = "DOCTYPE_NAME";
  State2[State2["AFTER_DOCTYPE_NAME"] = 55] = "AFTER_DOCTYPE_NAME";
  State2[State2["AFTER_DOCTYPE_PUBLIC_KEYWORD"] = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD";
  State2[State2["BEFORE_DOCTYPE_PUBLIC_IDENTIFIER"] = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER";
  State2[State2["DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED"] = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED";
  State2[State2["DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED"] = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED";
  State2[State2["AFTER_DOCTYPE_PUBLIC_IDENTIFIER"] = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER";
  State2[State2["BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS"] = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS";
  State2[State2["AFTER_DOCTYPE_SYSTEM_KEYWORD"] = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD";
  State2[State2["BEFORE_DOCTYPE_SYSTEM_IDENTIFIER"] = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER";
  State2[State2["DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED"] = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED";
  State2[State2["DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED"] = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED";
  State2[State2["AFTER_DOCTYPE_SYSTEM_IDENTIFIER"] = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER";
  State2[State2["BOGUS_DOCTYPE"] = 67] = "BOGUS_DOCTYPE";
  State2[State2["CDATA_SECTION"] = 68] = "CDATA_SECTION";
  State2[State2["CDATA_SECTION_BRACKET"] = 69] = "CDATA_SECTION_BRACKET";
  State2[State2["CDATA_SECTION_END"] = 70] = "CDATA_SECTION_END";
  State2[State2["CHARACTER_REFERENCE"] = 71] = "CHARACTER_REFERENCE";
  State2[State2["AMBIGUOUS_AMPERSAND"] = 72] = "AMBIGUOUS_AMPERSAND";
})(State || (State = {}));
var TokenizerMode = {
  DATA: State.DATA,
  RCDATA: State.RCDATA,
  RAWTEXT: State.RAWTEXT,
  SCRIPT_DATA: State.SCRIPT_DATA,
  PLAINTEXT: State.PLAINTEXT,
  CDATA_SECTION: State.CDATA_SECTION
};
function isAsciiDigit(cp) {
  return cp >= CODE_POINTS.DIGIT_0 && cp <= CODE_POINTS.DIGIT_9;
}
function isAsciiUpper(cp) {
  return cp >= CODE_POINTS.LATIN_CAPITAL_A && cp <= CODE_POINTS.LATIN_CAPITAL_Z;
}
function isAsciiLower(cp) {
  return cp >= CODE_POINTS.LATIN_SMALL_A && cp <= CODE_POINTS.LATIN_SMALL_Z;
}
function isAsciiLetter(cp) {
  return isAsciiLower(cp) || isAsciiUpper(cp);
}
function isAsciiAlphaNumeric2(cp) {
  return isAsciiLetter(cp) || isAsciiDigit(cp);
}
function toAsciiLower(cp) {
  return cp + 32;
}
function isWhitespace(cp) {
  return cp === CODE_POINTS.SPACE || cp === CODE_POINTS.LINE_FEED || cp === CODE_POINTS.TABULATION || cp === CODE_POINTS.FORM_FEED;
}
function isScriptDataDoubleEscapeSequenceEnd(cp) {
  return isWhitespace(cp) || cp === CODE_POINTS.SOLIDUS || cp === CODE_POINTS.GREATER_THAN_SIGN;
}
function getErrorForNumericCharacterReference(code5) {
  if (code5 === CODE_POINTS.NULL) {
    return ERR.nullCharacterReference;
  } else if (code5 > 1114111) {
    return ERR.characterReferenceOutsideUnicodeRange;
  } else if (isSurrogate(code5)) {
    return ERR.surrogateCharacterReference;
  } else if (isUndefinedCodePoint(code5)) {
    return ERR.noncharacterCharacterReference;
  } else if (isControlCodePoint(code5) || code5 === CODE_POINTS.CARRIAGE_RETURN) {
    return ERR.controlCharacterReference;
  }
  return null;
}
var Tokenizer = class {
  constructor(options, handler) {
    this.options = options;
    this.handler = handler;
    this.paused = false;
    this.inLoop = false;
    this.inForeignNode = false;
    this.lastStartTagName = "";
    this.active = false;
    this.state = State.DATA;
    this.returnState = State.DATA;
    this.entityStartPos = 0;
    this.consumedAfterSnapshot = -1;
    this.currentCharacterToken = null;
    this.currentToken = null;
    this.currentAttr = { name: "", value: "" };
    this.preprocessor = new Preprocessor(handler);
    this.currentLocation = this.getCurrentLocation(-1);
    this.entityDecoder = new EntityDecoder(htmlDecodeTree, (cp, consumed) => {
      this.preprocessor.pos = this.entityStartPos + consumed - 1;
      this._flushCodePointConsumedAsCharacterReference(cp);
    }, handler.onParseError ? {
      missingSemicolonAfterCharacterReference: () => {
        this._err(ERR.missingSemicolonAfterCharacterReference, 1);
      },
      absenceOfDigitsInNumericCharacterReference: (consumed) => {
        this._err(ERR.absenceOfDigitsInNumericCharacterReference, this.entityStartPos - this.preprocessor.pos + consumed);
      },
      validateNumericCharacterReference: (code5) => {
        const error2 = getErrorForNumericCharacterReference(code5);
        if (error2)
          this._err(error2, 1);
      }
    } : void 0);
  }
  //Errors
  _err(code5, cpOffset = 0) {
    var _a2, _b;
    (_b = (_a2 = this.handler).onParseError) === null || _b === void 0 ? void 0 : _b.call(_a2, this.preprocessor.getError(code5, cpOffset));
  }
  // NOTE: `offset` may never run across line boundaries.
  getCurrentLocation(offset4) {
    if (!this.options.sourceCodeLocationInfo) {
      return null;
    }
    return {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - offset4,
      startOffset: this.preprocessor.offset - offset4,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
  }
  _runParsingLoop() {
    if (this.inLoop)
      return;
    this.inLoop = true;
    while (this.active && !this.paused) {
      this.consumedAfterSnapshot = 0;
      const cp = this._consume();
      if (!this._ensureHibernation()) {
        this._callState(cp);
      }
    }
    this.inLoop = false;
  }
  //API
  pause() {
    this.paused = true;
  }
  resume(writeCallback) {
    if (!this.paused) {
      throw new Error("Parser was already resumed");
    }
    this.paused = false;
    if (this.inLoop)
      return;
    this._runParsingLoop();
    if (!this.paused) {
      writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
    }
  }
  write(chunk, isLastChunk, writeCallback) {
    this.active = true;
    this.preprocessor.write(chunk, isLastChunk);
    this._runParsingLoop();
    if (!this.paused) {
      writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
    }
  }
  insertHtmlAtCurrentPos(chunk) {
    this.active = true;
    this.preprocessor.insertHtmlAtCurrentPos(chunk);
    this._runParsingLoop();
  }
  //Hibernation
  _ensureHibernation() {
    if (this.preprocessor.endOfChunkHit) {
      this.preprocessor.retreat(this.consumedAfterSnapshot);
      this.consumedAfterSnapshot = 0;
      this.active = false;
      return true;
    }
    return false;
  }
  //Consumption
  _consume() {
    this.consumedAfterSnapshot++;
    return this.preprocessor.advance();
  }
  _advanceBy(count2) {
    this.consumedAfterSnapshot += count2;
    for (let i2 = 0; i2 < count2; i2++) {
      this.preprocessor.advance();
    }
  }
  _consumeSequenceIfMatch(pattern, caseSensitive) {
    if (this.preprocessor.startsWith(pattern, caseSensitive)) {
      this._advanceBy(pattern.length - 1);
      return true;
    }
    return false;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: TokenType.START_TAG,
      tagName: "",
      tagID: TAG_ID.UNKNOWN,
      selfClosing: false,
      ackSelfClosing: false,
      attrs: [],
      location: this.getCurrentLocation(1)
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: TokenType.END_TAG,
      tagName: "",
      tagID: TAG_ID.UNKNOWN,
      selfClosing: false,
      ackSelfClosing: false,
      attrs: [],
      location: this.getCurrentLocation(2)
    };
  }
  _createCommentToken(offset4) {
    this.currentToken = {
      type: TokenType.COMMENT,
      data: "",
      location: this.getCurrentLocation(offset4)
    };
  }
  _createDoctypeToken(initialName) {
    this.currentToken = {
      type: TokenType.DOCTYPE,
      name: initialName,
      forceQuirks: false,
      publicId: null,
      systemId: null,
      location: this.currentLocation
    };
  }
  _createCharacterToken(type, chars) {
    this.currentCharacterToken = {
      type,
      chars,
      location: this.currentLocation
    };
  }
  //Tag attributes
  _createAttr(attrNameFirstCh) {
    this.currentAttr = {
      name: attrNameFirstCh,
      value: ""
    };
    this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var _a2;
    var _b;
    const token = this.currentToken;
    if (getTokenAttr(token, this.currentAttr.name) === null) {
      token.attrs.push(this.currentAttr);
      if (token.location && this.currentLocation) {
        const attrLocations = (_a2 = (_b = token.location).attrs) !== null && _a2 !== void 0 ? _a2 : _b.attrs = /* @__PURE__ */ Object.create(null);
        attrLocations[this.currentAttr.name] = this.currentLocation;
        this._leaveAttrValue();
      }
    } else {
      this._err(ERR.duplicateAttribute);
    }
  }
  _leaveAttrValue() {
    if (this.currentLocation) {
      this.currentLocation.endLine = this.preprocessor.line;
      this.currentLocation.endCol = this.preprocessor.col;
      this.currentLocation.endOffset = this.preprocessor.offset;
    }
  }
  //Token emission
  prepareToken(ct3) {
    this._emitCurrentCharacterToken(ct3.location);
    this.currentToken = null;
    if (ct3.location) {
      ct3.location.endLine = this.preprocessor.line;
      ct3.location.endCol = this.preprocessor.col + 1;
      ct3.location.endOffset = this.preprocessor.offset + 1;
    }
    this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const ct3 = this.currentToken;
    this.prepareToken(ct3);
    ct3.tagID = getTagID(ct3.tagName);
    if (ct3.type === TokenType.START_TAG) {
      this.lastStartTagName = ct3.tagName;
      this.handler.onStartTag(ct3);
    } else {
      if (ct3.attrs.length > 0) {
        this._err(ERR.endTagWithAttributes);
      }
      if (ct3.selfClosing) {
        this._err(ERR.endTagWithTrailingSolidus);
      }
      this.handler.onEndTag(ct3);
    }
    this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(ct3) {
    this.prepareToken(ct3);
    this.handler.onComment(ct3);
    this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(ct3) {
    this.prepareToken(ct3);
    this.handler.onDoctype(ct3);
    this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(nextLocation) {
    if (this.currentCharacterToken) {
      if (nextLocation && this.currentCharacterToken.location) {
        this.currentCharacterToken.location.endLine = nextLocation.startLine;
        this.currentCharacterToken.location.endCol = nextLocation.startCol;
        this.currentCharacterToken.location.endOffset = nextLocation.startOffset;
      }
      switch (this.currentCharacterToken.type) {
        case TokenType.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken);
          break;
        }
        case TokenType.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken);
          break;
        }
        case TokenType.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken);
          break;
        }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const location3 = this.getCurrentLocation(0);
    if (location3) {
      location3.endLine = location3.startLine;
      location3.endCol = location3.startCol;
      location3.endOffset = location3.startOffset;
    }
    this._emitCurrentCharacterToken(location3);
    this.handler.onEof({ type: TokenType.EOF, location: location3 });
    this.active = false;
  }
  //Characters emission
  //OPTIMIZATION: The specification uses only one type of character token (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, the parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(type, ch) {
    if (this.currentCharacterToken) {
      if (this.currentCharacterToken.type === type) {
        this.currentCharacterToken.chars += ch;
        return;
      } else {
        this.currentLocation = this.getCurrentLocation(0);
        this._emitCurrentCharacterToken(this.currentLocation);
        this.preprocessor.dropParsedChunk();
      }
    }
    this._createCharacterToken(type, ch);
  }
  _emitCodePoint(cp) {
    const type = isWhitespace(cp) ? TokenType.WHITESPACE_CHARACTER : cp === CODE_POINTS.NULL ? TokenType.NULL_CHARACTER : TokenType.CHARACTER;
    this._appendCharToCurrentCharacterToken(type, String.fromCodePoint(cp));
  }
  //NOTE: used when we emit characters explicitly.
  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
  _emitChars(ch) {
    this._appendCharToCurrentCharacterToken(TokenType.CHARACTER, ch);
  }
  // Character reference helpers
  _startCharacterReference() {
    this.returnState = this.state;
    this.state = State.CHARACTER_REFERENCE;
    this.entityStartPos = this.preprocessor.pos;
    this.entityDecoder.startEntity(this._isCharacterReferenceInAttribute() ? DecodingMode.Attribute : DecodingMode.Legacy);
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === State.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === State.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === State.ATTRIBUTE_VALUE_UNQUOTED;
  }
  _flushCodePointConsumedAsCharacterReference(cp) {
    if (this._isCharacterReferenceInAttribute()) {
      this.currentAttr.value += String.fromCodePoint(cp);
    } else {
      this._emitCodePoint(cp);
    }
  }
  // Calling states this way turns out to be much faster than any other approach.
  _callState(cp) {
    switch (this.state) {
      case State.DATA: {
        this._stateData(cp);
        break;
      }
      case State.RCDATA: {
        this._stateRcdata(cp);
        break;
      }
      case State.RAWTEXT: {
        this._stateRawtext(cp);
        break;
      }
      case State.SCRIPT_DATA: {
        this._stateScriptData(cp);
        break;
      }
      case State.PLAINTEXT: {
        this._statePlaintext(cp);
        break;
      }
      case State.TAG_OPEN: {
        this._stateTagOpen(cp);
        break;
      }
      case State.END_TAG_OPEN: {
        this._stateEndTagOpen(cp);
        break;
      }
      case State.TAG_NAME: {
        this._stateTagName(cp);
        break;
      }
      case State.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(cp);
        break;
      }
      case State.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(cp);
        break;
      }
      case State.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(cp);
        break;
      }
      case State.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(cp);
        break;
      }
      case State.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(cp);
        break;
      }
      case State.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(cp);
        break;
      }
      case State.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(cp);
        break;
      }
      case State.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(cp);
        break;
      }
      case State.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(cp);
        break;
      }
      case State.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(cp);
        break;
      }
      case State.ATTRIBUTE_NAME: {
        this._stateAttributeName(cp);
        break;
      }
      case State.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(cp);
        break;
      }
      case State.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(cp);
        break;
      }
      case State.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(cp);
        break;
      }
      case State.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(cp);
        break;
      }
      case State.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(cp);
        break;
      }
      case State.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(cp);
        break;
      }
      case State.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(cp);
        break;
      }
      case State.BOGUS_COMMENT: {
        this._stateBogusComment(cp);
        break;
      }
      case State.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(cp);
        break;
      }
      case State.COMMENT_START: {
        this._stateCommentStart(cp);
        break;
      }
      case State.COMMENT_START_DASH: {
        this._stateCommentStartDash(cp);
        break;
      }
      case State.COMMENT: {
        this._stateComment(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(cp);
        break;
      }
      case State.COMMENT_END_DASH: {
        this._stateCommentEndDash(cp);
        break;
      }
      case State.COMMENT_END: {
        this._stateCommentEnd(cp);
        break;
      }
      case State.COMMENT_END_BANG: {
        this._stateCommentEndBang(cp);
        break;
      }
      case State.DOCTYPE: {
        this._stateDoctype(cp);
        break;
      }
      case State.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(cp);
        break;
      }
      case State.DOCTYPE_NAME: {
        this._stateDoctypeName(cp);
        break;
      }
      case State.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(cp);
        break;
      }
      case State.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(cp);
        break;
      }
      case State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(cp);
        break;
      }
      case State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(cp);
        break;
      }
      case State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(cp);
        break;
      }
      case State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(cp);
        break;
      }
      case State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(cp);
        break;
      }
      case State.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(cp);
        break;
      }
      case State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(cp);
        break;
      }
      case State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(cp);
        break;
      }
      case State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(cp);
        break;
      }
      case State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(cp);
        break;
      }
      case State.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(cp);
        break;
      }
      case State.CDATA_SECTION: {
        this._stateCdataSection(cp);
        break;
      }
      case State.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(cp);
        break;
      }
      case State.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(cp);
        break;
      }
      case State.CHARACTER_REFERENCE: {
        this._stateCharacterReference();
        break;
      }
      case State.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(cp);
        break;
      }
      default: {
        throw new Error("Unknown state");
      }
    }
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  _stateData(cp) {
    switch (cp) {
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.TAG_OPEN;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitCodePoint(cp);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  //  RCDATA state
  //------------------------------------------------------------------
  _stateRcdata(cp) {
    switch (cp) {
      case CODE_POINTS.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.RCDATA_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  _stateRawtext(cp) {
    switch (cp) {
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.RAWTEXT_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data state
  //------------------------------------------------------------------
  _stateScriptData(cp) {
    switch (cp) {
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  _statePlaintext(cp) {
    switch (cp) {
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Tag open state
  //------------------------------------------------------------------
  _stateTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this._createStartTagToken();
      this.state = State.TAG_NAME;
      this._stateTagName(cp);
    } else
      switch (cp) {
        case CODE_POINTS.EXCLAMATION_MARK: {
          this.state = State.MARKUP_DECLARATION_OPEN;
          break;
        }
        case CODE_POINTS.SOLIDUS: {
          this.state = State.END_TAG_OPEN;
          break;
        }
        case CODE_POINTS.QUESTION_MARK: {
          this._err(ERR.unexpectedQuestionMarkInsteadOfTagName);
          this._createCommentToken(1);
          this.state = State.BOGUS_COMMENT;
          this._stateBogusComment(cp);
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofBeforeTagName);
          this._emitChars("<");
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(ERR.invalidFirstCharacterOfTagName);
          this._emitChars("<");
          this.state = State.DATA;
          this._stateData(cp);
        }
      }
  }
  // End tag open state
  //------------------------------------------------------------------
  _stateEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this._createEndTagToken();
      this.state = State.TAG_NAME;
      this._stateTagName(cp);
    } else
      switch (cp) {
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(ERR.missingEndTagName);
          this.state = State.DATA;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofBeforeTagName);
          this._emitChars("</");
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(ERR.invalidFirstCharacterOfTagName);
          this._createCommentToken(2);
          this.state = State.BOGUS_COMMENT;
          this._stateBogusComment(cp);
        }
      }
  }
  // Tag name state
  //------------------------------------------------------------------
  _stateTagName(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case CODE_POINTS.SOLIDUS: {
        this.state = State.SELF_CLOSING_START_TAG;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.tagName += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        token.tagName += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
      }
    }
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  _stateRcdataLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State.RCDATA_END_TAG_OPEN;
    } else {
      this._emitChars("<");
      this.state = State.RCDATA;
      this._stateRcdata(cp);
    }
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  _stateRcdataEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.RCDATA_END_TAG_NAME;
      this._stateRcdataEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.RCDATA;
      this._stateRcdata(cp);
    }
  }
  handleSpecialEndTag(_cp) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, false)) {
      return !this._ensureHibernation();
    }
    this._createEndTagToken();
    const token = this.currentToken;
    token.tagName = this.lastStartTagName;
    const cp = this.preprocessor.peek(this.lastStartTagName.length);
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this._advanceBy(this.lastStartTagName.length);
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        return false;
      }
      case CODE_POINTS.SOLIDUS: {
        this._advanceBy(this.lastStartTagName.length);
        this.state = State.SELF_CLOSING_START_TAG;
        return false;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._advanceBy(this.lastStartTagName.length);
        this.emitCurrentTagToken();
        this.state = State.DATA;
        return false;
      }
      default: {
        return !this._ensureHibernation();
      }
    }
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  _stateRcdataEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.RCDATA;
      this._stateRcdata(cp);
    }
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  _stateRawtextLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State.RAWTEXT_END_TAG_OPEN;
    } else {
      this._emitChars("<");
      this.state = State.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  _stateRawtextEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.RAWTEXT_END_TAG_NAME;
      this._stateRawtextEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  _stateRawtextEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataLessThanSign(cp) {
    switch (cp) {
      case CODE_POINTS.SOLIDUS: {
        this.state = State.SCRIPT_DATA_END_TAG_OPEN;
        break;
      }
      case CODE_POINTS.EXCLAMATION_MARK: {
        this.state = State.SCRIPT_DATA_ESCAPE_START;
        this._emitChars("<!");
        break;
      }
      default: {
        this._emitChars("<");
        this.state = State.SCRIPT_DATA;
        this._stateScriptData(cp);
      }
    }
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.SCRIPT_DATA_END_TAG_NAME;
      this._stateScriptDataEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escape start state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStart(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.SCRIPT_DATA_ESCAPE_START_DASH;
      this._emitChars("-");
    } else {
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStartDash(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;
      this._emitChars("-");
    } else {
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escaped state
  //------------------------------------------------------------------
  _stateScriptDataEscaped(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_ESCAPED_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDashDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.SCRIPT_DATA;
        this._emitChars(">");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataEscapedLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN;
    } else if (isAsciiLetter(cp)) {
      this._emitChars("<");
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_START;
      this._stateScriptDataDoubleEscapeStart(cp);
    } else {
      this._emitChars("<");
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_NAME;
      this._stateScriptDataEscapedEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeStart(cp) {
    if (this.preprocessor.startsWith(SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(SEQUENCES.SCRIPT.length))) {
      this._emitCodePoint(cp);
      for (let i2 = 0; i2 < SEQUENCES.SCRIPT.length; i2++) {
        this._emitCodePoint(this._consume());
      }
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else if (!this._ensureHibernation()) {
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscaped(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDashDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.SCRIPT_DATA;
        this._emitChars(">");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_END;
      this._emitChars("/");
    } else {
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
      this._stateScriptDataDoubleEscaped(cp);
    }
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeEnd(cp) {
    if (this.preprocessor.startsWith(SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(SEQUENCES.SCRIPT.length))) {
      this._emitCodePoint(cp);
      for (let i2 = 0; i2 < SEQUENCES.SCRIPT.length; i2++) {
        this._emitCodePoint(this._consume());
      }
      this.state = State.SCRIPT_DATA_ESCAPED;
    } else if (!this._ensureHibernation()) {
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
      this._stateScriptDataDoubleEscaped(cp);
    }
  }
  // Before attribute name state
  //------------------------------------------------------------------
  _stateBeforeAttributeName(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.SOLIDUS:
      case CODE_POINTS.GREATER_THAN_SIGN:
      case CODE_POINTS.EOF: {
        this.state = State.AFTER_ATTRIBUTE_NAME;
        this._stateAfterAttributeName(cp);
        break;
      }
      case CODE_POINTS.EQUALS_SIGN: {
        this._err(ERR.unexpectedEqualsSignBeforeAttributeName);
        this._createAttr("=");
        this.state = State.ATTRIBUTE_NAME;
        break;
      }
      default: {
        this._createAttr("");
        this.state = State.ATTRIBUTE_NAME;
        this._stateAttributeName(cp);
      }
    }
  }
  // Attribute name state
  //------------------------------------------------------------------
  _stateAttributeName(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED:
      case CODE_POINTS.SOLIDUS:
      case CODE_POINTS.GREATER_THAN_SIGN:
      case CODE_POINTS.EOF: {
        this._leaveAttrName();
        this.state = State.AFTER_ATTRIBUTE_NAME;
        this._stateAfterAttributeName(cp);
        break;
      }
      case CODE_POINTS.EQUALS_SIGN: {
        this._leaveAttrName();
        this.state = State.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK:
      case CODE_POINTS.APOSTROPHE:
      case CODE_POINTS.LESS_THAN_SIGN: {
        this._err(ERR.unexpectedCharacterInAttributeName);
        this.currentAttr.name += String.fromCodePoint(cp);
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.name += REPLACEMENT_CHARACTER;
        break;
      }
      default: {
        this.currentAttr.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
      }
    }
  }
  // After attribute name state
  //------------------------------------------------------------------
  _stateAfterAttributeName(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.SOLIDUS: {
        this.state = State.SELF_CLOSING_START_TAG;
        break;
      }
      case CODE_POINTS.EQUALS_SIGN: {
        this.state = State.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._createAttr("");
        this.state = State.ATTRIBUTE_NAME;
        this._stateAttributeName(cp);
      }
    }
  }
  // Before attribute value state
  //------------------------------------------------------------------
  _stateBeforeAttributeValue(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this.state = State.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingAttributeValue);
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      default: {
        this.state = State.ATTRIBUTE_VALUE_UNQUOTED;
        this._stateAttributeValueUnquoted(cp);
      }
    }
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueDoubleQuoted(cp) {
    switch (cp) {
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.value += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueSingleQuoted(cp) {
    switch (cp) {
      case CODE_POINTS.APOSTROPHE: {
        this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.value += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  _stateAttributeValueUnquoted(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this._leaveAttrValue();
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._leaveAttrValue();
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.value += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK:
      case CODE_POINTS.APOSTROPHE:
      case CODE_POINTS.LESS_THAN_SIGN:
      case CODE_POINTS.EQUALS_SIGN:
      case CODE_POINTS.GRAVE_ACCENT: {
        this._err(ERR.unexpectedCharacterInUnquotedAttributeValue);
        this.currentAttr.value += String.fromCodePoint(cp);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  _stateAfterAttributeValueQuoted(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this._leaveAttrValue();
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case CODE_POINTS.SOLIDUS: {
        this._leaveAttrValue();
        this.state = State.SELF_CLOSING_START_TAG;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._leaveAttrValue();
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingWhitespaceBetweenAttributes);
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        this._stateBeforeAttributeName(cp);
      }
    }
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  _stateSelfClosingStartTag(cp) {
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        const token = this.currentToken;
        token.selfClosing = true;
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.unexpectedSolidusInTag);
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        this._stateBeforeAttributeName(cp);
      }
    }
  }
  // Bogus comment state
  //------------------------------------------------------------------
  _stateBogusComment(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.data += REPLACEMENT_CHARACTER;
        break;
      }
      default: {
        token.data += String.fromCodePoint(cp);
      }
    }
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  _stateMarkupDeclarationOpen(cp) {
    if (this._consumeSequenceIfMatch(SEQUENCES.DASH_DASH, true)) {
      this._createCommentToken(SEQUENCES.DASH_DASH.length + 1);
      this.state = State.COMMENT_START;
    } else if (this._consumeSequenceIfMatch(SEQUENCES.DOCTYPE, false)) {
      this.currentLocation = this.getCurrentLocation(SEQUENCES.DOCTYPE.length + 1);
      this.state = State.DOCTYPE;
    } else if (this._consumeSequenceIfMatch(SEQUENCES.CDATA_START, true)) {
      if (this.inForeignNode) {
        this.state = State.CDATA_SECTION;
      } else {
        this._err(ERR.cdataInHtmlContent);
        this._createCommentToken(SEQUENCES.CDATA_START.length + 1);
        this.currentToken.data = "[CDATA[";
        this.state = State.BOGUS_COMMENT;
      }
    } else if (!this._ensureHibernation()) {
      this._err(ERR.incorrectlyOpenedComment);
      this._createCommentToken(2);
      this.state = State.BOGUS_COMMENT;
      this._stateBogusComment(cp);
    }
  }
  // Comment start state
  //------------------------------------------------------------------
  _stateCommentStart(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_START_DASH;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptClosingOfEmptyComment);
        this.state = State.DATA;
        const token = this.currentToken;
        this.emitCurrentComment(token);
        break;
      }
      default: {
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment start dash state
  //------------------------------------------------------------------
  _stateCommentStartDash(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_END;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptClosingOfEmptyComment);
        this.state = State.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "-";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment state
  //------------------------------------------------------------------
  _stateComment(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_END_DASH;
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        token.data += "<";
        this.state = State.COMMENT_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.data += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += String.fromCodePoint(cp);
      }
    }
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  _stateCommentLessThanSign(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.EXCLAMATION_MARK: {
        token.data += "!";
        this.state = State.COMMENT_LESS_THAN_SIGN_BANG;
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        token.data += "<";
        break;
      }
      default: {
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBang(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH;
    } else {
      this.state = State.COMMENT;
      this._stateComment(cp);
    }
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDash(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH;
    } else {
      this.state = State.COMMENT_END_DASH;
      this._stateCommentEndDash(cp);
    }
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDashDash(cp) {
    if (cp !== CODE_POINTS.GREATER_THAN_SIGN && cp !== CODE_POINTS.EOF) {
      this._err(ERR.nestedComment);
    }
    this.state = State.COMMENT_END;
    this._stateCommentEnd(cp);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  _stateCommentEndDash(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_END;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "-";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment end state
  //------------------------------------------------------------------
  _stateCommentEnd(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EXCLAMATION_MARK: {
        this.state = State.COMMENT_END_BANG;
        break;
      }
      case CODE_POINTS.HYPHEN_MINUS: {
        token.data += "-";
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "--";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment end bang state
  //------------------------------------------------------------------
  _stateCommentEndBang(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        token.data += "--!";
        this.state = State.COMMENT_END_DASH;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.incorrectlyClosedComment);
        this.state = State.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "--!";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  _stateDoctype(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_DOCTYPE_NAME;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.BEFORE_DOCTYPE_NAME;
        this._stateBeforeDoctypeName(cp);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        this._createDoctypeToken(null);
        const token = this.currentToken;
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingWhitespaceBeforeDoctypeName);
        this.state = State.BEFORE_DOCTYPE_NAME;
        this._stateBeforeDoctypeName(cp);
      }
    }
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  _stateBeforeDoctypeName(cp) {
    if (isAsciiUpper(cp)) {
      this._createDoctypeToken(String.fromCharCode(toAsciiLower(cp)));
      this.state = State.DOCTYPE_NAME;
    } else
      switch (cp) {
        case CODE_POINTS.SPACE:
        case CODE_POINTS.LINE_FEED:
        case CODE_POINTS.TABULATION:
        case CODE_POINTS.FORM_FEED: {
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          this._createDoctypeToken(REPLACEMENT_CHARACTER);
          this.state = State.DOCTYPE_NAME;
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(ERR.missingDoctypeName);
          this._createDoctypeToken(null);
          const token = this.currentToken;
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this.state = State.DATA;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInDoctype);
          this._createDoctypeToken(null);
          const token = this.currentToken;
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
        default: {
          this._createDoctypeToken(String.fromCodePoint(cp));
          this.state = State.DOCTYPE_NAME;
        }
      }
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  _stateDoctypeName(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.AFTER_DOCTYPE_NAME;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.name += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
      }
    }
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  _stateAfterDoctypeName(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        if (this._consumeSequenceIfMatch(SEQUENCES.PUBLIC, false)) {
          this.state = State.AFTER_DOCTYPE_PUBLIC_KEYWORD;
        } else if (this._consumeSequenceIfMatch(SEQUENCES.SYSTEM, false)) {
          this.state = State.AFTER_DOCTYPE_SYSTEM_KEYWORD;
        } else if (!this._ensureHibernation()) {
          this._err(ERR.invalidCharacterSequenceAfterDoctypeName);
          token.forceQuirks = true;
          this.state = State.BOGUS_DOCTYPE;
          this._stateBogusDoctype(cp);
        }
      }
    }
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicKeyword(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
        token.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
        token.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypePublicIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        token.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        token.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierDoubleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.publicId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.publicId += String.fromCodePoint(cp);
      }
    }
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierSingleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.APOSTROPHE: {
        this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.publicId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.publicId += String.fromCodePoint(cp);
      }
    }
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  _stateBetweenDoctypePublicAndSystemIdentifiers(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemKeyword(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypeSystemIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierDoubleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.systemId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.systemId += String.fromCodePoint(cp);
      }
    }
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierSingleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.APOSTROPHE: {
        this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.systemId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.systemId += String.fromCodePoint(cp);
      }
    }
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.unexpectedCharacterAfterDoctypeSystemIdentifier);
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  _stateBogusDoctype(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        break;
      }
      case CODE_POINTS.EOF: {
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default:
    }
  }
  // CDATA section state
  //------------------------------------------------------------------
  _stateCdataSection(cp) {
    switch (cp) {
      case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
        this.state = State.CDATA_SECTION_BRACKET;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInCdata);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  _stateCdataSectionBracket(cp) {
    if (cp === CODE_POINTS.RIGHT_SQUARE_BRACKET) {
      this.state = State.CDATA_SECTION_END;
    } else {
      this._emitChars("]");
      this.state = State.CDATA_SECTION;
      this._stateCdataSection(cp);
    }
  }
  // CDATA section end state
  //------------------------------------------------------------------
  _stateCdataSectionEnd(cp) {
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
        this._emitChars("]");
        break;
      }
      default: {
        this._emitChars("]]");
        this.state = State.CDATA_SECTION;
        this._stateCdataSection(cp);
      }
    }
  }
  // Character reference state
  //------------------------------------------------------------------
  _stateCharacterReference() {
    let length3 = this.entityDecoder.write(this.preprocessor.html, this.preprocessor.pos);
    if (length3 < 0) {
      if (this.preprocessor.lastChunkWritten) {
        length3 = this.entityDecoder.end();
      } else {
        this.active = false;
        this.preprocessor.pos = this.preprocessor.html.length - 1;
        this.consumedAfterSnapshot = 0;
        this.preprocessor.endOfChunkHit = true;
        return;
      }
    }
    if (length3 === 0) {
      this.preprocessor.pos = this.entityStartPos;
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
      this.state = !this._isCharacterReferenceInAttribute() && isAsciiAlphaNumeric2(this.preprocessor.peek(1)) ? State.AMBIGUOUS_AMPERSAND : this.returnState;
    } else {
      this.state = this.returnState;
    }
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  _stateAmbiguousAmpersand(cp) {
    if (isAsciiAlphaNumeric2(cp)) {
      this._flushCodePointConsumedAsCharacterReference(cp);
    } else {
      if (cp === CODE_POINTS.SEMICOLON) {
        this._err(ERR.unknownNamedCharacterReference);
      }
      this.state = this.returnState;
      this._callState(cp);
    }
  }
};

// ../node_modules/.pnpm/parse5@7.3.0/node_modules/parse5/dist/parser/open-element-stack.js
var IMPLICIT_END_TAG_REQUIRED = /* @__PURE__ */ new Set([TAG_ID.DD, TAG_ID.DT, TAG_ID.LI, TAG_ID.OPTGROUP, TAG_ID.OPTION, TAG_ID.P, TAG_ID.RB, TAG_ID.RP, TAG_ID.RT, TAG_ID.RTC]);
var IMPLICIT_END_TAG_REQUIRED_THOROUGHLY = /* @__PURE__ */ new Set([
  ...IMPLICIT_END_TAG_REQUIRED,
  TAG_ID.CAPTION,
  TAG_ID.COLGROUP,
  TAG_ID.TBODY,
  TAG_ID.TD,
  TAG_ID.TFOOT,
  TAG_ID.TH,
  TAG_ID.THEAD,
  TAG_ID.TR
]);
var SCOPING_ELEMENTS_HTML = /* @__PURE__ */ new Set([
  TAG_ID.APPLET,
  TAG_ID.CAPTION,
  TAG_ID.HTML,
  TAG_ID.MARQUEE,
  TAG_ID.OBJECT,
  TAG_ID.TABLE,
  TAG_ID.TD,
  TAG_ID.TEMPLATE,
  TAG_ID.TH
]);
var SCOPING_ELEMENTS_HTML_LIST = /* @__PURE__ */ new Set([...SCOPING_ELEMENTS_HTML, TAG_ID.OL, TAG_ID.UL]);
var SCOPING_ELEMENTS_HTML_BUTTON = /* @__PURE__ */ new Set([...SCOPING_ELEMENTS_HTML, TAG_ID.BUTTON]);
var SCOPING_ELEMENTS_MATHML = /* @__PURE__ */ new Set([TAG_ID.ANNOTATION_XML, TAG_ID.MI, TAG_ID.MN, TAG_ID.MO, TAG_ID.MS, TAG_ID.MTEXT]);
var SCOPING_ELEMENTS_SVG = /* @__PURE__ */ new Set([TAG_ID.DESC, TAG_ID.FOREIGN_OBJECT, TAG_ID.TITLE]);
var TABLE_ROW_CONTEXT = /* @__PURE__ */ new Set([TAG_ID.TR, TAG_ID.TEMPLATE, TAG_ID.HTML]);
var TABLE_BODY_CONTEXT = /* @__PURE__ */ new Set([TAG_ID.TBODY, TAG_ID.TFOOT, TAG_ID.THEAD, TAG_ID.TEMPLATE, TAG_ID.HTML]);
var TABLE_CONTEXT = /* @__PURE__ */ new Set([TAG_ID.TABLE, TAG_ID.TEMPLATE, TAG_ID.HTML]);
var TABLE_CELLS = /* @__PURE__ */ new Set([TAG_ID.TD, TAG_ID.TH]);
var OpenElementStack = class {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
  }
  constructor(document4, treeAdapter, handler) {
    this.treeAdapter = treeAdapter;
    this.handler = handler;
    this.items = [];
    this.tagIDs = [];
    this.stackTop = -1;
    this.tmplCount = 0;
    this.currentTagId = TAG_ID.UNKNOWN;
    this.current = document4;
  }
  //Index of element
  _indexOf(element7) {
    return this.items.lastIndexOf(element7, this.stackTop);
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagId === TAG_ID.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop];
    this.currentTagId = this.tagIDs[this.stackTop];
  }
  //Mutations
  push(element7, tagID) {
    this.stackTop++;
    this.items[this.stackTop] = element7;
    this.current = element7;
    this.tagIDs[this.stackTop] = tagID;
    this.currentTagId = tagID;
    if (this._isInTemplate()) {
      this.tmplCount++;
    }
    this.handler.onItemPush(element7, tagID, true);
  }
  pop() {
    const popped = this.current;
    if (this.tmplCount > 0 && this._isInTemplate()) {
      this.tmplCount--;
    }
    this.stackTop--;
    this._updateCurrentElement();
    this.handler.onItemPop(popped, true);
  }
  replace(oldElement, newElement) {
    const idx = this._indexOf(oldElement);
    this.items[idx] = newElement;
    if (idx === this.stackTop) {
      this.current = newElement;
    }
  }
  insertAfter(referenceElement, newElement, newElementID) {
    const insertionIdx = this._indexOf(referenceElement) + 1;
    this.items.splice(insertionIdx, 0, newElement);
    this.tagIDs.splice(insertionIdx, 0, newElementID);
    this.stackTop++;
    if (insertionIdx === this.stackTop) {
      this._updateCurrentElement();
    }
    if (this.current && this.currentTagId !== void 0) {
      this.handler.onItemPush(this.current, this.currentTagId, insertionIdx === this.stackTop);
    }
  }
  popUntilTagNamePopped(tagName) {
    let targetIdx = this.stackTop + 1;
    do {
      targetIdx = this.tagIDs.lastIndexOf(tagName, targetIdx - 1);
    } while (targetIdx > 0 && this.treeAdapter.getNamespaceURI(this.items[targetIdx]) !== NS.HTML);
    this.shortenToLength(Math.max(targetIdx, 0));
  }
  shortenToLength(idx) {
    while (this.stackTop >= idx) {
      const popped = this.current;
      if (this.tmplCount > 0 && this._isInTemplate()) {
        this.tmplCount -= 1;
      }
      this.stackTop--;
      this._updateCurrentElement();
      this.handler.onItemPop(popped, this.stackTop < idx);
    }
  }
  popUntilElementPopped(element7) {
    const idx = this._indexOf(element7);
    this.shortenToLength(Math.max(idx, 0));
  }
  popUntilPopped(tagNames, targetNS) {
    const idx = this._indexOfTagNames(tagNames, targetNS);
    this.shortenToLength(Math.max(idx, 0));
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(NUMBERED_HEADERS, NS.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(TABLE_CELLS, NS.HTML);
  }
  popAllUpToHtmlElement() {
    this.tmplCount = 0;
    this.shortenToLength(1);
  }
  _indexOfTagNames(tagNames, namespace) {
    for (let i2 = this.stackTop; i2 >= 0; i2--) {
      if (tagNames.has(this.tagIDs[i2]) && this.treeAdapter.getNamespaceURI(this.items[i2]) === namespace) {
        return i2;
      }
    }
    return -1;
  }
  clearBackTo(tagNames, targetNS) {
    const idx = this._indexOfTagNames(tagNames, targetNS);
    this.shortenToLength(idx + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(TABLE_CONTEXT, NS.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(TABLE_BODY_CONTEXT, NS.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(TABLE_ROW_CONTEXT, NS.HTML);
  }
  remove(element7) {
    const idx = this._indexOf(element7);
    if (idx >= 0) {
      if (idx === this.stackTop) {
        this.pop();
      } else {
        this.items.splice(idx, 1);
        this.tagIDs.splice(idx, 1);
        this.stackTop--;
        this._updateCurrentElement();
        this.handler.onItemPop(element7, false);
      }
    }
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    return this.stackTop >= 1 && this.tagIDs[1] === TAG_ID.BODY ? this.items[1] : null;
  }
  contains(element7) {
    return this._indexOf(element7) > -1;
  }
  getCommonAncestor(element7) {
    const elementIdx = this._indexOf(element7) - 1;
    return elementIdx >= 0 ? this.items[elementIdx] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === TAG_ID.HTML;
  }
  //Element in scope
  hasInDynamicScope(tagName, htmlScope) {
    for (let i2 = this.stackTop; i2 >= 0; i2--) {
      const tn2 = this.tagIDs[i2];
      switch (this.treeAdapter.getNamespaceURI(this.items[i2])) {
        case NS.HTML: {
          if (tn2 === tagName)
            return true;
          if (htmlScope.has(tn2))
            return false;
          break;
        }
        case NS.SVG: {
          if (SCOPING_ELEMENTS_SVG.has(tn2))
            return false;
          break;
        }
        case NS.MATHML: {
          if (SCOPING_ELEMENTS_MATHML.has(tn2))
            return false;
          break;
        }
      }
    }
    return true;
  }
  hasInScope(tagName) {
    return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML);
  }
  hasInListItemScope(tagName) {
    return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML_LIST);
  }
  hasInButtonScope(tagName) {
    return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML_BUTTON);
  }
  hasNumberedHeaderInScope() {
    for (let i2 = this.stackTop; i2 >= 0; i2--) {
      const tn2 = this.tagIDs[i2];
      switch (this.treeAdapter.getNamespaceURI(this.items[i2])) {
        case NS.HTML: {
          if (NUMBERED_HEADERS.has(tn2))
            return true;
          if (SCOPING_ELEMENTS_HTML.has(tn2))
            return false;
          break;
        }
        case NS.SVG: {
          if (SCOPING_ELEMENTS_SVG.has(tn2))
            return false;
          break;
        }
        case NS.MATHML: {
          if (SCOPING_ELEMENTS_MATHML.has(tn2))
            return false;
          break;
        }
      }
    }
    return true;
  }
  hasInTableScope(tagName) {
    for (let i2 = this.stackTop; i2 >= 0; i2--) {
      if (this.treeAdapter.getNamespaceURI(this.items[i2]) !== NS.HTML) {
        continue;
      }
      switch (this.tagIDs[i2]) {
        case tagName: {
          return true;
        }
        case TAG_ID.TABLE:
        case TAG_ID.HTML: {
          return false;
        }
      }
    }
    return true;
  }
  hasTableBodyContextInTableScope() {
    for (let i2 = this.stackTop; i2 >= 0; i2--) {
      if (this.treeAdapter.getNamespaceURI(this.items[i2]) !== NS.HTML) {
        continue;
      }
      switch (this.tagIDs[i2]) {
        case TAG_ID.TBODY:
        case TAG_ID.THEAD:
        case TAG_ID.TFOOT: {
          return true;
        }
        case TAG_ID.TABLE:
        case TAG_ID.HTML: {
          return false;
        }
      }
    }
    return true;
  }
  hasInSelectScope(tagName) {
    for (let i2 = this.stackTop; i2 >= 0; i2--) {
      if (this.treeAdapter.getNamespaceURI(this.items[i2]) !== NS.HTML) {
        continue;
      }
      switch (this.tagIDs[i2]) {
        case tagName: {
          return true;
        }
        case TAG_ID.OPTION:
        case TAG_ID.OPTGROUP: {
          break;
        }
        default: {
          return false;
        }
      }
    }
    return true;
  }
  //Implied end tags
  generateImpliedEndTags() {
    while (this.currentTagId !== void 0 && IMPLICIT_END_TAG_REQUIRED.has(this.currentTagId)) {
      this.pop();
    }
  }
  generateImpliedEndTagsThoroughly() {
    while (this.currentTagId !== void 0 && IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
      this.pop();
    }
  }
  generateImpliedEndTagsWithExclusion(exclusionId) {
    while (this.currentTagId !== void 0 && this.currentTagId !== exclusionId && IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
      this.pop();
    }
  }
};

// ../node_modules/.pnpm/parse5@7.3.0/node_modules/parse5/dist/parser/formatting-element-list.js
var NOAH_ARK_CAPACITY = 3;
var EntryType;
(function(EntryType2) {
  EntryType2[EntryType2["Marker"] = 0] = "Marker";
  EntryType2[EntryType2["Element"] = 1] = "Element";
})(EntryType || (EntryType = {}));
var MARKER = { type: EntryType.Marker };
var FormattingElementList = class {
  constructor(treeAdapter) {
    this.treeAdapter = treeAdapter;
    this.entries = [];
    this.bookmark = null;
  }
  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(newElement, neAttrs) {
    const candidates = [];
    const neAttrsLength = neAttrs.length;
    const neTagName = this.treeAdapter.getTagName(newElement);
    const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);
    for (let i2 = 0; i2 < this.entries.length; i2++) {
      const entry = this.entries[i2];
      if (entry.type === EntryType.Marker) {
        break;
      }
      const { element: element7 } = entry;
      if (this.treeAdapter.getTagName(element7) === neTagName && this.treeAdapter.getNamespaceURI(element7) === neNamespaceURI) {
        const elementAttrs = this.treeAdapter.getAttrList(element7);
        if (elementAttrs.length === neAttrsLength) {
          candidates.push({ idx: i2, attrs: elementAttrs });
        }
      }
    }
    return candidates;
  }
  _ensureNoahArkCondition(newElement) {
    if (this.entries.length < NOAH_ARK_CAPACITY)
      return;
    const neAttrs = this.treeAdapter.getAttrList(newElement);
    const candidates = this._getNoahArkConditionCandidates(newElement, neAttrs);
    if (candidates.length < NOAH_ARK_CAPACITY)
      return;
    const neAttrsMap = new Map(neAttrs.map((neAttr) => [neAttr.name, neAttr.value]));
    let validCandidates = 0;
    for (let i2 = 0; i2 < candidates.length; i2++) {
      const candidate = candidates[i2];
      if (candidate.attrs.every((cAttr) => neAttrsMap.get(cAttr.name) === cAttr.value)) {
        validCandidates += 1;
        if (validCandidates >= NOAH_ARK_CAPACITY) {
          this.entries.splice(candidate.idx, 1);
        }
      }
    }
  }
  //Mutations
  insertMarker() {
    this.entries.unshift(MARKER);
  }
  pushElement(element7, token) {
    this._ensureNoahArkCondition(element7);
    this.entries.unshift({
      type: EntryType.Element,
      element: element7,
      token
    });
  }
  insertElementAfterBookmark(element7, token) {
    const bookmarkIdx = this.entries.indexOf(this.bookmark);
    this.entries.splice(bookmarkIdx, 0, {
      type: EntryType.Element,
      element: element7,
      token
    });
  }
  removeEntry(entry) {
    const entryIndex = this.entries.indexOf(entry);
    if (entryIndex !== -1) {
      this.entries.splice(entryIndex, 1);
    }
  }
  /**
   * Clears the list of formatting elements up to the last marker.
   *
   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
   */
  clearToLastMarker() {
    const markerIdx = this.entries.indexOf(MARKER);
    if (markerIdx === -1) {
      this.entries.length = 0;
    } else {
      this.entries.splice(0, markerIdx + 1);
    }
  }
  //Search
  getElementEntryInScopeWithTagName(tagName) {
    const entry = this.entries.find((entry2) => entry2.type === EntryType.Marker || this.treeAdapter.getTagName(entry2.element) === tagName);
    return entry && entry.type === EntryType.Element ? entry : null;
  }
  getElementEntry(element7) {
    return this.entries.find((entry) => entry.type === EntryType.Element && entry.element === element7);
  }
};

// ../node_modules/.pnpm/parse5@7.3.0/node_modules/parse5/dist/tree-adapters/default.js
var defaultTreeAdapter = {
  //Node construction
  createDocument() {
    return {
      nodeName: "#document",
      mode: DOCUMENT_MODE.NO_QUIRKS,
      childNodes: []
    };
  },
  createDocumentFragment() {
    return {
      nodeName: "#document-fragment",
      childNodes: []
    };
  },
  createElement(tagName, namespaceURI, attrs) {
    return {
      nodeName: tagName,
      tagName,
      attrs,
      namespaceURI,
      childNodes: [],
      parentNode: null
    };
  },
  createCommentNode(data) {
    return {
      nodeName: "#comment",
      data,
      parentNode: null
    };
  },
  createTextNode(value) {
    return {
      nodeName: "#text",
      value,
      parentNode: null
    };
  },
  //Tree mutation
  appendChild(parentNode, newNode) {
    parentNode.childNodes.push(newNode);
    newNode.parentNode = parentNode;
  },
  insertBefore(parentNode, newNode, referenceNode) {
    const insertionIdx = parentNode.childNodes.indexOf(referenceNode);
    parentNode.childNodes.splice(insertionIdx, 0, newNode);
    newNode.parentNode = parentNode;
  },
  setTemplateContent(templateElement, contentElement) {
    templateElement.content = contentElement;
  },
  getTemplateContent(templateElement) {
    return templateElement.content;
  },
  setDocumentType(document4, name, publicId, systemId) {
    const doctypeNode = document4.childNodes.find((node2) => node2.nodeName === "#documentType");
    if (doctypeNode) {
      doctypeNode.name = name;
      doctypeNode.publicId = publicId;
      doctypeNode.systemId = systemId;
    } else {
      const node2 = {
        nodeName: "#documentType",
        name,
        publicId,
        systemId,
        parentNode: null
      };
      defaultTreeAdapter.appendChild(document4, node2);
    }
  },
  setDocumentMode(document4, mode) {
    document4.mode = mode;
  },
  getDocumentMode(document4) {
    return document4.mode;
  },
  detachNode(node2) {
    if (node2.parentNode) {
      const idx = node2.parentNode.childNodes.indexOf(node2);
      node2.parentNode.childNodes.splice(idx, 1);
      node2.parentNode = null;
    }
  },
  insertText(parentNode, text10) {
    if (parentNode.childNodes.length > 0) {
      const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];
      if (defaultTreeAdapter.isTextNode(prevNode)) {
        prevNode.value += text10;
        return;
      }
    }
    defaultTreeAdapter.appendChild(parentNode, defaultTreeAdapter.createTextNode(text10));
  },
  insertTextBefore(parentNode, text10, referenceNode) {
    const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
    if (prevNode && defaultTreeAdapter.isTextNode(prevNode)) {
      prevNode.value += text10;
    } else {
      defaultTreeAdapter.insertBefore(parentNode, defaultTreeAdapter.createTextNode(text10), referenceNode);
    }
  },
  adoptAttributes(recipient, attrs) {
    const recipientAttrsMap = new Set(recipient.attrs.map((attr2) => attr2.name));
    for (let j5 = 0; j5 < attrs.length; j5++) {
      if (!recipientAttrsMap.has(attrs[j5].name)) {
        recipient.attrs.push(attrs[j5]);
      }
    }
  },
  //Tree traversing
  getFirstChild(node2) {
    return node2.childNodes[0];
  },
  getChildNodes(node2) {
    return node2.childNodes;
  },
  getParentNode(node2) {
    return node2.parentNode;
  },
  getAttrList(element7) {
    return element7.attrs;
  },
  //Node data
  getTagName(element7) {
    return element7.tagName;
  },
  getNamespaceURI(element7) {
    return element7.namespaceURI;
  },
  getTextNodeContent(textNode) {
    return textNode.value;
  },
  getCommentNodeContent(commentNode) {
    return commentNode.data;
  },
  getDocumentTypeNodeName(doctypeNode) {
    return doctypeNode.name;
  },
  getDocumentTypeNodePublicId(doctypeNode) {
    return doctypeNode.publicId;
  },
  getDocumentTypeNodeSystemId(doctypeNode) {
    return doctypeNode.systemId;
  },
  //Node types
  isTextNode(node2) {
    return node2.nodeName === "#text";
  },
  isCommentNode(node2) {
    return node2.nodeName === "#comment";
  },
  isDocumentTypeNode(node2) {
    return node2.nodeName === "#documentType";
  },
  isElementNode(node2) {
    return Object.prototype.hasOwnProperty.call(node2, "tagName");
  },
  // Source code location
  setNodeSourceCodeLocation(node2, location3) {
    node2.sourceCodeLocation = location3;
  },
  getNodeSourceCodeLocation(node2) {
    return node2.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(node2, endLocation) {
    node2.sourceCodeLocation = { ...node2.sourceCodeLocation, ...endLocation };
  }
};

// ../node_modules/.pnpm/parse5@7.3.0/node_modules/parse5/dist/common/doctype.js
var VALID_DOCTYPE_NAME = "html";
var VALID_SYSTEM_ID = "about:legacy-compat";
var QUIRKS_MODE_SYSTEM_ID = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";
var QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//"
];
var QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
  ...QUIRKS_MODE_PUBLIC_ID_PREFIXES,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
var QUIRKS_MODE_PUBLIC_IDS = /* @__PURE__ */ new Set([
  "-//w3o//dtd w3 html strict 3.0//en//",
  "-/w3c/dtd html 4.0 transitional/en",
  "html"
]);
var LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"];
var LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
  ...LIMITED_QUIRKS_PUBLIC_ID_PREFIXES,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
function hasPrefix(publicId, prefixes) {
  return prefixes.some((prefix3) => publicId.startsWith(prefix3));
}
function isConforming(token) {
  return token.name === VALID_DOCTYPE_NAME && token.publicId === null && (token.systemId === null || token.systemId === VALID_SYSTEM_ID);
}
function getDocumentMode(token) {
  if (token.name !== VALID_DOCTYPE_NAME) {
    return DOCUMENT_MODE.QUIRKS;
  }
  const { systemId } = token;
  if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {
    return DOCUMENT_MODE.QUIRKS;
  }
  let { publicId } = token;
  if (publicId !== null) {
    publicId = publicId.toLowerCase();
    if (QUIRKS_MODE_PUBLIC_IDS.has(publicId)) {
      return DOCUMENT_MODE.QUIRKS;
    }
    let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;
    if (hasPrefix(publicId, prefixes)) {
      return DOCUMENT_MODE.QUIRKS;
    }
    prefixes = systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;
    if (hasPrefix(publicId, prefixes)) {
      return DOCUMENT_MODE.LIMITED_QUIRKS;
    }
  }
  return DOCUMENT_MODE.NO_QUIRKS;
}

// ../node_modules/.pnpm/parse5@7.3.0/node_modules/parse5/dist/common/foreign-content.js
var MIME_TYPES = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml"
};
var DEFINITION_URL_ATTR = "definitionurl";
var ADJUSTED_DEFINITION_URL_ATTR = "definitionURL";
var SVG_ATTRS_ADJUSTMENT_MAP = new Map([
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((attr2) => [attr2.toLowerCase(), attr2]));
var XML_ATTRS_ADJUSTMENT_MAP = /* @__PURE__ */ new Map([
  ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: NS.XLINK }],
  ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: NS.XLINK }],
  ["xlink:href", { prefix: "xlink", name: "href", namespace: NS.XLINK }],
  ["xlink:role", { prefix: "xlink", name: "role", namespace: NS.XLINK }],
  ["xlink:show", { prefix: "xlink", name: "show", namespace: NS.XLINK }],
  ["xlink:title", { prefix: "xlink", name: "title", namespace: NS.XLINK }],
  ["xlink:type", { prefix: "xlink", name: "type", namespace: NS.XLINK }],
  ["xml:lang", { prefix: "xml", name: "lang", namespace: NS.XML }],
  ["xml:space", { prefix: "xml", name: "space", namespace: NS.XML }],
  ["xmlns", { prefix: "", name: "xmlns", namespace: NS.XMLNS }],
  ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: NS.XMLNS }]
]);
var SVG_TAG_NAMES_ADJUSTMENT_MAP = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((tn2) => [tn2.toLowerCase(), tn2]));
var EXITS_FOREIGN_CONTENT = /* @__PURE__ */ new Set([
  TAG_ID.B,
  TAG_ID.BIG,
  TAG_ID.BLOCKQUOTE,
  TAG_ID.BODY,
  TAG_ID.BR,
  TAG_ID.CENTER,
  TAG_ID.CODE,
  TAG_ID.DD,
  TAG_ID.DIV,
  TAG_ID.DL,
  TAG_ID.DT,
  TAG_ID.EM,
  TAG_ID.EMBED,
  TAG_ID.H1,
  TAG_ID.H2,
  TAG_ID.H3,
  TAG_ID.H4,
  TAG_ID.H5,
  TAG_ID.H6,
  TAG_ID.HEAD,
  TAG_ID.HR,
  TAG_ID.I,
  TAG_ID.IMG,
  TAG_ID.LI,
  TAG_ID.LISTING,
  TAG_ID.MENU,
  TAG_ID.META,
  TAG_ID.NOBR,
  TAG_ID.OL,
  TAG_ID.P,
  TAG_ID.PRE,
  TAG_ID.RUBY,
  TAG_ID.S,
  TAG_ID.SMALL,
  TAG_ID.SPAN,
  TAG_ID.STRONG,
  TAG_ID.STRIKE,
  TAG_ID.SUB,
  TAG_ID.SUP,
  TAG_ID.TABLE,
  TAG_ID.TT,
  TAG_ID.U,
  TAG_ID.UL,
  TAG_ID.VAR
]);
function causesExit(startTagToken) {
  const tn2 = startTagToken.tagID;
  const isFontWithAttrs = tn2 === TAG_ID.FONT && startTagToken.attrs.some(({ name }) => name === ATTRS.COLOR || name === ATTRS.SIZE || name === ATTRS.FACE);
  return isFontWithAttrs || EXITS_FOREIGN_CONTENT.has(tn2);
}
function adjustTokenMathMLAttrs(token) {
  for (let i2 = 0; i2 < token.attrs.length; i2++) {
    if (token.attrs[i2].name === DEFINITION_URL_ATTR) {
      token.attrs[i2].name = ADJUSTED_DEFINITION_URL_ATTR;
      break;
    }
  }
}
function adjustTokenSVGAttrs(token) {
  for (let i2 = 0; i2 < token.attrs.length; i2++) {
    const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i2].name);
    if (adjustedAttrName != null) {
      token.attrs[i2].name = adjustedAttrName;
    }
  }
}
function adjustTokenXMLAttrs(token) {
  for (let i2 = 0; i2 < token.attrs.length; i2++) {
    const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i2].name);
    if (adjustedAttrEntry) {
      token.attrs[i2].prefix = adjustedAttrEntry.prefix;
      token.attrs[i2].name = adjustedAttrEntry.name;
      token.attrs[i2].namespace = adjustedAttrEntry.namespace;
    }
  }
}
function adjustTokenSVGTagName(token) {
  const adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP.get(token.tagName);
  if (adjustedTagName != null) {
    token.tagName = adjustedTagName;
    token.tagID = getTagID(token.tagName);
  }
}
function isMathMLTextIntegrationPoint(tn2, ns2) {
  return ns2 === NS.MATHML && (tn2 === TAG_ID.MI || tn2 === TAG_ID.MO || tn2 === TAG_ID.MN || tn2 === TAG_ID.MS || tn2 === TAG_ID.MTEXT);
}
function isHtmlIntegrationPoint(tn2, ns2, attrs) {
  if (ns2 === NS.MATHML && tn2 === TAG_ID.ANNOTATION_XML) {
    for (let i2 = 0; i2 < attrs.length; i2++) {
      if (attrs[i2].name === ATTRS.ENCODING) {
        const value = attrs[i2].value.toLowerCase();
        return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;
      }
    }
  }
  return ns2 === NS.SVG && (tn2 === TAG_ID.FOREIGN_OBJECT || tn2 === TAG_ID.DESC || tn2 === TAG_ID.TITLE);
}
function isIntegrationPoint(tn2, ns2, attrs, foreignNS) {
  return (!foreignNS || foreignNS === NS.HTML) && isHtmlIntegrationPoint(tn2, ns2, attrs) || (!foreignNS || foreignNS === NS.MATHML) && isMathMLTextIntegrationPoint(tn2, ns2);
}

// ../node_modules/.pnpm/parse5@7.3.0/node_modules/parse5/dist/parser/index.js
var HIDDEN_INPUT_TYPE = "hidden";
var AA_OUTER_LOOP_ITER = 8;
var AA_INNER_LOOP_ITER = 3;
var InsertionMode;
(function(InsertionMode2) {
  InsertionMode2[InsertionMode2["INITIAL"] = 0] = "INITIAL";
  InsertionMode2[InsertionMode2["BEFORE_HTML"] = 1] = "BEFORE_HTML";
  InsertionMode2[InsertionMode2["BEFORE_HEAD"] = 2] = "BEFORE_HEAD";
  InsertionMode2[InsertionMode2["IN_HEAD"] = 3] = "IN_HEAD";
  InsertionMode2[InsertionMode2["IN_HEAD_NO_SCRIPT"] = 4] = "IN_HEAD_NO_SCRIPT";
  InsertionMode2[InsertionMode2["AFTER_HEAD"] = 5] = "AFTER_HEAD";
  InsertionMode2[InsertionMode2["IN_BODY"] = 6] = "IN_BODY";
  InsertionMode2[InsertionMode2["TEXT"] = 7] = "TEXT";
  InsertionMode2[InsertionMode2["IN_TABLE"] = 8] = "IN_TABLE";
  InsertionMode2[InsertionMode2["IN_TABLE_TEXT"] = 9] = "IN_TABLE_TEXT";
  InsertionMode2[InsertionMode2["IN_CAPTION"] = 10] = "IN_CAPTION";
  InsertionMode2[InsertionMode2["IN_COLUMN_GROUP"] = 11] = "IN_COLUMN_GROUP";
  InsertionMode2[InsertionMode2["IN_TABLE_BODY"] = 12] = "IN_TABLE_BODY";
  InsertionMode2[InsertionMode2["IN_ROW"] = 13] = "IN_ROW";
  InsertionMode2[InsertionMode2["IN_CELL"] = 14] = "IN_CELL";
  InsertionMode2[InsertionMode2["IN_SELECT"] = 15] = "IN_SELECT";
  InsertionMode2[InsertionMode2["IN_SELECT_IN_TABLE"] = 16] = "IN_SELECT_IN_TABLE";
  InsertionMode2[InsertionMode2["IN_TEMPLATE"] = 17] = "IN_TEMPLATE";
  InsertionMode2[InsertionMode2["AFTER_BODY"] = 18] = "AFTER_BODY";
  InsertionMode2[InsertionMode2["IN_FRAMESET"] = 19] = "IN_FRAMESET";
  InsertionMode2[InsertionMode2["AFTER_FRAMESET"] = 20] = "AFTER_FRAMESET";
  InsertionMode2[InsertionMode2["AFTER_AFTER_BODY"] = 21] = "AFTER_AFTER_BODY";
  InsertionMode2[InsertionMode2["AFTER_AFTER_FRAMESET"] = 22] = "AFTER_AFTER_FRAMESET";
})(InsertionMode || (InsertionMode = {}));
var BASE_LOC = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1
};
var TABLE_STRUCTURE_TAGS = /* @__PURE__ */ new Set([TAG_ID.TABLE, TAG_ID.TBODY, TAG_ID.TFOOT, TAG_ID.THEAD, TAG_ID.TR]);
var defaultParserOptions = {
  scriptingEnabled: true,
  sourceCodeLocationInfo: false,
  treeAdapter: defaultTreeAdapter,
  onParseError: null
};
var Parser = class {
  constructor(options, document4, fragmentContext = null, scriptHandler = null) {
    this.fragmentContext = fragmentContext;
    this.scriptHandler = scriptHandler;
    this.currentToken = null;
    this.stopped = false;
    this.insertionMode = InsertionMode.INITIAL;
    this.originalInsertionMode = InsertionMode.INITIAL;
    this.headElement = null;
    this.formElement = null;
    this.currentNotInHTML = false;
    this.tmplInsertionModeStack = [];
    this.pendingCharacterTokens = [];
    this.hasNonWhitespacePendingCharacterToken = false;
    this.framesetOk = true;
    this.skipNextNewLine = false;
    this.fosterParentingEnabled = false;
    this.options = {
      ...defaultParserOptions,
      ...options
    };
    this.treeAdapter = this.options.treeAdapter;
    this.onParseError = this.options.onParseError;
    if (this.onParseError) {
      this.options.sourceCodeLocationInfo = true;
    }
    this.document = document4 !== null && document4 !== void 0 ? document4 : this.treeAdapter.createDocument();
    this.tokenizer = new Tokenizer(this.options, this);
    this.activeFormattingElements = new FormattingElementList(this.treeAdapter);
    this.fragmentContextID = fragmentContext ? getTagID(this.treeAdapter.getTagName(fragmentContext)) : TAG_ID.UNKNOWN;
    this._setContextModes(fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : this.document, this.fragmentContextID);
    this.openElements = new OpenElementStack(this.document, this.treeAdapter, this);
  }
  // API
  static parse(html7, options) {
    const parser = new this(options);
    parser.tokenizer.write(html7, true);
    return parser.document;
  }
  static getFragmentParser(fragmentContext, options) {
    const opts = {
      ...defaultParserOptions,
      ...options
    };
    fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : fragmentContext = opts.treeAdapter.createElement(TAG_NAMES.TEMPLATE, NS.HTML, []);
    const documentMock = opts.treeAdapter.createElement("documentmock", NS.HTML, []);
    const parser = new this(opts, documentMock, fragmentContext);
    if (parser.fragmentContextID === TAG_ID.TEMPLATE) {
      parser.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
    }
    parser._initTokenizerForFragmentParsing();
    parser._insertFakeRootElement();
    parser._resetInsertionMode();
    parser._findFormInFragmentContext();
    return parser;
  }
  getFragment() {
    const rootElement = this.treeAdapter.getFirstChild(this.document);
    const fragment = this.treeAdapter.createDocumentFragment();
    this._adoptNodes(rootElement, fragment);
    return fragment;
  }
  //Errors
  /** @internal */
  _err(token, code5, beforeToken) {
    var _a2;
    if (!this.onParseError)
      return;
    const loc = (_a2 = token.location) !== null && _a2 !== void 0 ? _a2 : BASE_LOC;
    const err = {
      code: code5,
      startLine: loc.startLine,
      startCol: loc.startCol,
      startOffset: loc.startOffset,
      endLine: beforeToken ? loc.startLine : loc.endLine,
      endCol: beforeToken ? loc.startCol : loc.endCol,
      endOffset: beforeToken ? loc.startOffset : loc.endOffset
    };
    this.onParseError(err);
  }
  //Stack events
  /** @internal */
  onItemPush(node2, tid, isTop) {
    var _a2, _b;
    (_b = (_a2 = this.treeAdapter).onItemPush) === null || _b === void 0 ? void 0 : _b.call(_a2, node2);
    if (isTop && this.openElements.stackTop > 0)
      this._setContextModes(node2, tid);
  }
  /** @internal */
  onItemPop(node2, isTop) {
    var _a2, _b;
    if (this.options.sourceCodeLocationInfo) {
      this._setEndLocation(node2, this.currentToken);
    }
    (_b = (_a2 = this.treeAdapter).onItemPop) === null || _b === void 0 ? void 0 : _b.call(_a2, node2, this.openElements.current);
    if (isTop) {
      let current;
      let currentTagId;
      if (this.openElements.stackTop === 0 && this.fragmentContext) {
        current = this.fragmentContext;
        currentTagId = this.fragmentContextID;
      } else {
        ({ current, currentTagId } = this.openElements);
      }
      this._setContextModes(current, currentTagId);
    }
  }
  _setContextModes(current, tid) {
    const isHTML = current === this.document || current && this.treeAdapter.getNamespaceURI(current) === NS.HTML;
    this.currentNotInHTML = !isHTML;
    this.tokenizer.inForeignNode = !isHTML && current !== void 0 && tid !== void 0 && !this._isIntegrationPoint(tid, current);
  }
  /** @protected */
  _switchToTextParsing(currentToken, nextTokenizerState) {
    this._insertElement(currentToken, NS.HTML);
    this.tokenizer.state = nextTokenizerState;
    this.originalInsertionMode = this.insertionMode;
    this.insertionMode = InsertionMode.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = InsertionMode.TEXT;
    this.originalInsertionMode = InsertionMode.IN_BODY;
    this.tokenizer.state = TokenizerMode.PLAINTEXT;
  }
  //Fragment parsing
  /** @protected */
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  /** @protected */
  _findFormInFragmentContext() {
    let node2 = this.fragmentContext;
    while (node2) {
      if (this.treeAdapter.getTagName(node2) === TAG_NAMES.FORM) {
        this.formElement = node2;
        break;
      }
      node2 = this.treeAdapter.getParentNode(node2);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== NS.HTML) {
      return;
    }
    switch (this.fragmentContextID) {
      case TAG_ID.TITLE:
      case TAG_ID.TEXTAREA: {
        this.tokenizer.state = TokenizerMode.RCDATA;
        break;
      }
      case TAG_ID.STYLE:
      case TAG_ID.XMP:
      case TAG_ID.IFRAME:
      case TAG_ID.NOEMBED:
      case TAG_ID.NOFRAMES:
      case TAG_ID.NOSCRIPT: {
        this.tokenizer.state = TokenizerMode.RAWTEXT;
        break;
      }
      case TAG_ID.SCRIPT: {
        this.tokenizer.state = TokenizerMode.SCRIPT_DATA;
        break;
      }
      case TAG_ID.PLAINTEXT: {
        this.tokenizer.state = TokenizerMode.PLAINTEXT;
        break;
      }
      default:
    }
  }
  //Tree mutation
  /** @protected */
  _setDocumentType(token) {
    const name = token.name || "";
    const publicId = token.publicId || "";
    const systemId = token.systemId || "";
    this.treeAdapter.setDocumentType(this.document, name, publicId, systemId);
    if (token.location) {
      const documentChildren = this.treeAdapter.getChildNodes(this.document);
      const docTypeNode = documentChildren.find((node2) => this.treeAdapter.isDocumentTypeNode(node2));
      if (docTypeNode) {
        this.treeAdapter.setNodeSourceCodeLocation(docTypeNode, token.location);
      }
    }
  }
  /** @protected */
  _attachElementToTree(element7, location3) {
    if (this.options.sourceCodeLocationInfo) {
      const loc = location3 && {
        ...location3,
        startTag: location3
      };
      this.treeAdapter.setNodeSourceCodeLocation(element7, loc);
    }
    if (this._shouldFosterParentOnInsertion()) {
      this._fosterParentElement(element7);
    } else {
      const parent = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(parent !== null && parent !== void 0 ? parent : this.document, element7);
    }
  }
  /**
   * For self-closing tags. Add an element to the tree, but skip adding it
   * to the stack.
   */
  /** @protected */
  _appendElement(token, namespaceURI) {
    const element7 = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
    this._attachElementToTree(element7, token.location);
  }
  /** @protected */
  _insertElement(token, namespaceURI) {
    const element7 = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
    this._attachElementToTree(element7, token.location);
    this.openElements.push(element7, token.tagID);
  }
  /** @protected */
  _insertFakeElement(tagName, tagID) {
    const element7 = this.treeAdapter.createElement(tagName, NS.HTML, []);
    this._attachElementToTree(element7, null);
    this.openElements.push(element7, tagID);
  }
  /** @protected */
  _insertTemplate(token) {
    const tmpl = this.treeAdapter.createElement(token.tagName, NS.HTML, token.attrs);
    const content5 = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(tmpl, content5);
    this._attachElementToTree(tmpl, token.location);
    this.openElements.push(tmpl, token.tagID);
    if (this.options.sourceCodeLocationInfo)
      this.treeAdapter.setNodeSourceCodeLocation(content5, null);
  }
  /** @protected */
  _insertFakeRootElement() {
    const element7 = this.treeAdapter.createElement(TAG_NAMES.HTML, NS.HTML, []);
    if (this.options.sourceCodeLocationInfo)
      this.treeAdapter.setNodeSourceCodeLocation(element7, null);
    this.treeAdapter.appendChild(this.openElements.current, element7);
    this.openElements.push(element7, TAG_ID.HTML);
  }
  /** @protected */
  _appendCommentNode(token, parent) {
    const commentNode = this.treeAdapter.createCommentNode(token.data);
    this.treeAdapter.appendChild(parent, commentNode);
    if (this.options.sourceCodeLocationInfo) {
      this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
    }
  }
  /** @protected */
  _insertCharacters(token) {
    let parent;
    let beforeElement;
    if (this._shouldFosterParentOnInsertion()) {
      ({ parent, beforeElement } = this._findFosterParentingLocation());
      if (beforeElement) {
        this.treeAdapter.insertTextBefore(parent, token.chars, beforeElement);
      } else {
        this.treeAdapter.insertText(parent, token.chars);
      }
    } else {
      parent = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.insertText(parent, token.chars);
    }
    if (!token.location)
      return;
    const siblings2 = this.treeAdapter.getChildNodes(parent);
    const textNodeIdx = beforeElement ? siblings2.lastIndexOf(beforeElement) : siblings2.length;
    const textNode = siblings2[textNodeIdx - 1];
    const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);
    if (tnLoc) {
      const { endLine, endCol, endOffset } = token.location;
      this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });
    } else if (this.options.sourceCodeLocationInfo) {
      this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
    }
  }
  /** @protected */
  _adoptNodes(donor, recipient) {
    for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {
      this.treeAdapter.detachNode(child);
      this.treeAdapter.appendChild(recipient, child);
    }
  }
  /** @protected */
  _setEndLocation(element7, closingToken) {
    if (this.treeAdapter.getNodeSourceCodeLocation(element7) && closingToken.location) {
      const ctLoc = closingToken.location;
      const tn2 = this.treeAdapter.getTagName(element7);
      const endLoc = (
        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
        closingToken.type === TokenType.END_TAG && tn2 === closingToken.tagName ? {
          endTag: { ...ctLoc },
          endLine: ctLoc.endLine,
          endCol: ctLoc.endCol,
          endOffset: ctLoc.endOffset
        } : {
          endLine: ctLoc.startLine,
          endCol: ctLoc.startCol,
          endOffset: ctLoc.startOffset
        }
      );
      this.treeAdapter.updateNodeSourceCodeLocation(element7, endLoc);
    }
  }
  //Token processing
  shouldProcessStartTagTokenInForeignContent(token) {
    if (!this.currentNotInHTML)
      return false;
    let current;
    let currentTagId;
    if (this.openElements.stackTop === 0 && this.fragmentContext) {
      current = this.fragmentContext;
      currentTagId = this.fragmentContextID;
    } else {
      ({ current, currentTagId } = this.openElements);
    }
    if (token.tagID === TAG_ID.SVG && this.treeAdapter.getTagName(current) === TAG_NAMES.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(current) === NS.MATHML) {
      return false;
    }
    return (
      // Check that `current` is not an integration point for HTML or MathML elements.
      this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
      // integration point.
      (token.tagID === TAG_ID.MGLYPH || token.tagID === TAG_ID.MALIGNMARK) && currentTagId !== void 0 && !this._isIntegrationPoint(currentTagId, current, NS.HTML)
    );
  }
  /** @protected */
  _processToken(token) {
    switch (token.type) {
      case TokenType.CHARACTER: {
        this.onCharacter(token);
        break;
      }
      case TokenType.NULL_CHARACTER: {
        this.onNullCharacter(token);
        break;
      }
      case TokenType.COMMENT: {
        this.onComment(token);
        break;
      }
      case TokenType.DOCTYPE: {
        this.onDoctype(token);
        break;
      }
      case TokenType.START_TAG: {
        this._processStartTag(token);
        break;
      }
      case TokenType.END_TAG: {
        this.onEndTag(token);
        break;
      }
      case TokenType.EOF: {
        this.onEof(token);
        break;
      }
      case TokenType.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(token);
        break;
      }
    }
  }
  //Integration points
  /** @protected */
  _isIntegrationPoint(tid, element7, foreignNS) {
    const ns2 = this.treeAdapter.getNamespaceURI(element7);
    const attrs = this.treeAdapter.getAttrList(element7);
    return isIntegrationPoint(tid, ns2, attrs, foreignNS);
  }
  //Active formatting elements reconstruction
  /** @protected */
  _reconstructActiveFormattingElements() {
    const listLength = this.activeFormattingElements.entries.length;
    if (listLength) {
      const endIndex = this.activeFormattingElements.entries.findIndex((entry) => entry.type === EntryType.Marker || this.openElements.contains(entry.element));
      const unopenIdx = endIndex === -1 ? listLength - 1 : endIndex - 1;
      for (let i2 = unopenIdx; i2 >= 0; i2--) {
        const entry = this.activeFormattingElements.entries[i2];
        this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
        entry.element = this.openElements.current;
      }
    }
  }
  //Close elements
  /** @protected */
  _closeTableCell() {
    this.openElements.generateImpliedEndTags();
    this.openElements.popUntilTableCellPopped();
    this.activeFormattingElements.clearToLastMarker();
    this.insertionMode = InsertionMode.IN_ROW;
  }
  /** @protected */
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.P);
    this.openElements.popUntilTagNamePopped(TAG_ID.P);
  }
  //Insertion modes
  /** @protected */
  _resetInsertionMode() {
    for (let i2 = this.openElements.stackTop; i2 >= 0; i2--) {
      switch (i2 === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[i2]) {
        case TAG_ID.TR: {
          this.insertionMode = InsertionMode.IN_ROW;
          return;
        }
        case TAG_ID.TBODY:
        case TAG_ID.THEAD:
        case TAG_ID.TFOOT: {
          this.insertionMode = InsertionMode.IN_TABLE_BODY;
          return;
        }
        case TAG_ID.CAPTION: {
          this.insertionMode = InsertionMode.IN_CAPTION;
          return;
        }
        case TAG_ID.COLGROUP: {
          this.insertionMode = InsertionMode.IN_COLUMN_GROUP;
          return;
        }
        case TAG_ID.TABLE: {
          this.insertionMode = InsertionMode.IN_TABLE;
          return;
        }
        case TAG_ID.BODY: {
          this.insertionMode = InsertionMode.IN_BODY;
          return;
        }
        case TAG_ID.FRAMESET: {
          this.insertionMode = InsertionMode.IN_FRAMESET;
          return;
        }
        case TAG_ID.SELECT: {
          this._resetInsertionModeForSelect(i2);
          return;
        }
        case TAG_ID.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0];
          return;
        }
        case TAG_ID.HTML: {
          this.insertionMode = this.headElement ? InsertionMode.AFTER_HEAD : InsertionMode.BEFORE_HEAD;
          return;
        }
        case TAG_ID.TD:
        case TAG_ID.TH: {
          if (i2 > 0) {
            this.insertionMode = InsertionMode.IN_CELL;
            return;
          }
          break;
        }
        case TAG_ID.HEAD: {
          if (i2 > 0) {
            this.insertionMode = InsertionMode.IN_HEAD;
            return;
          }
          break;
        }
      }
    }
    this.insertionMode = InsertionMode.IN_BODY;
  }
  /** @protected */
  _resetInsertionModeForSelect(selectIdx) {
    if (selectIdx > 0) {
      for (let i2 = selectIdx - 1; i2 > 0; i2--) {
        const tn2 = this.openElements.tagIDs[i2];
        if (tn2 === TAG_ID.TEMPLATE) {
          break;
        } else if (tn2 === TAG_ID.TABLE) {
          this.insertionMode = InsertionMode.IN_SELECT_IN_TABLE;
          return;
        }
      }
    }
    this.insertionMode = InsertionMode.IN_SELECT;
  }
  //Foster parenting
  /** @protected */
  _isElementCausesFosterParenting(tn2) {
    return TABLE_STRUCTURE_TAGS.has(tn2);
  }
  /** @protected */
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this.openElements.currentTagId !== void 0 && this._isElementCausesFosterParenting(this.openElements.currentTagId);
  }
  /** @protected */
  _findFosterParentingLocation() {
    for (let i2 = this.openElements.stackTop; i2 >= 0; i2--) {
      const openElement = this.openElements.items[i2];
      switch (this.openElements.tagIDs[i2]) {
        case TAG_ID.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(openElement) === NS.HTML) {
            return { parent: this.treeAdapter.getTemplateContent(openElement), beforeElement: null };
          }
          break;
        }
        case TAG_ID.TABLE: {
          const parent = this.treeAdapter.getParentNode(openElement);
          if (parent) {
            return { parent, beforeElement: openElement };
          }
          return { parent: this.openElements.items[i2 - 1], beforeElement: null };
        }
        default:
      }
    }
    return { parent: this.openElements.items[0], beforeElement: null };
  }
  /** @protected */
  _fosterParentElement(element7) {
    const location3 = this._findFosterParentingLocation();
    if (location3.beforeElement) {
      this.treeAdapter.insertBefore(location3.parent, element7, location3.beforeElement);
    } else {
      this.treeAdapter.appendChild(location3.parent, element7);
    }
  }
  //Special elements
  /** @protected */
  _isSpecialElement(element7, id2) {
    const ns2 = this.treeAdapter.getNamespaceURI(element7);
    return SPECIAL_ELEMENTS[ns2].has(id2);
  }
  /** @internal */
  onCharacter(token) {
    this.skipNextNewLine = false;
    if (this.tokenizer.inForeignNode) {
      characterInForeignContent(this, token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, token);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_TEMPLATE: {
        characterInBody(this, token);
        break;
      }
      case InsertionMode.TEXT:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE: {
        this._insertCharacters(token);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        characterInTableText(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        tokenInColumnGroup(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        tokenAfterBody(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, token);
        break;
      }
      default:
    }
  }
  /** @internal */
  onNullCharacter(token) {
    this.skipNextNewLine = false;
    if (this.tokenizer.inForeignNode) {
      nullCharacterInForeignContent(this, token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, token);
        break;
      }
      case InsertionMode.TEXT: {
        this._insertCharacters(token);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        tokenInColumnGroup(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        tokenAfterBody(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, token);
        break;
      }
      default:
    }
  }
  /** @internal */
  onComment(token) {
    this.skipNextNewLine = false;
    if (this.currentNotInHTML) {
      appendComment(this, token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL:
      case InsertionMode.BEFORE_HTML:
      case InsertionMode.BEFORE_HEAD:
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD:
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE:
      case InsertionMode.IN_TEMPLATE:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET: {
        appendComment(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        appendCommentToRootHtmlElement(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        appendCommentToDocument(this, token);
        break;
      }
      default:
    }
  }
  /** @internal */
  onDoctype(token) {
    this.skipNextNewLine = false;
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        doctypeInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD:
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD: {
        this._err(token, ERR.misplacedDoctype);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      default:
    }
  }
  /** @internal */
  onStartTag(token) {
    this.skipNextNewLine = false;
    this.currentToken = token;
    this._processStartTag(token);
    if (token.selfClosing && !token.ackSelfClosing) {
      this._err(token, ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
    }
  }
  /**
   * Processes a given start tag.
   *
   * `onStartTag` checks if a self-closing tag was recognized. When a token
   * is moved inbetween multiple insertion modes, this check for self-closing
   * could lead to false positives. To avoid this, `_processStartTag` is used
   * for nested calls.
   *
   * @param token The token to process.
   * @protected
   */
  _processStartTag(token) {
    if (this.shouldProcessStartTagTokenInForeignContent(token)) {
      startTagInForeignContent(this, token);
    } else {
      this._startTagOutsideForeignContent(token);
    }
  }
  /** @protected */
  _startTagOutsideForeignContent(token) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        startTagBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        startTagBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        startTagInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        startTagInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        startTagAfterHead(this, token);
        break;
      }
      case InsertionMode.IN_BODY: {
        startTagInBody(this, token);
        break;
      }
      case InsertionMode.IN_TABLE: {
        startTagInTable(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      case InsertionMode.IN_CAPTION: {
        startTagInCaption(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        startTagInColumnGroup(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_BODY: {
        startTagInTableBody(this, token);
        break;
      }
      case InsertionMode.IN_ROW: {
        startTagInRow(this, token);
        break;
      }
      case InsertionMode.IN_CELL: {
        startTagInCell(this, token);
        break;
      }
      case InsertionMode.IN_SELECT: {
        startTagInSelect(this, token);
        break;
      }
      case InsertionMode.IN_SELECT_IN_TABLE: {
        startTagInSelectInTable(this, token);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        startTagInTemplate(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        startTagAfterBody(this, token);
        break;
      }
      case InsertionMode.IN_FRAMESET: {
        startTagInFrameset(this, token);
        break;
      }
      case InsertionMode.AFTER_FRAMESET: {
        startTagAfterFrameset(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        startTagAfterAfterBody(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        startTagAfterAfterFrameset(this, token);
        break;
      }
      default:
    }
  }
  /** @internal */
  onEndTag(token) {
    this.skipNextNewLine = false;
    this.currentToken = token;
    if (this.currentNotInHTML) {
      endTagInForeignContent(this, token);
    } else {
      this._endTagOutsideForeignContent(token);
    }
  }
  /** @protected */
  _endTagOutsideForeignContent(token) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        endTagBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        endTagBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        endTagInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        endTagInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        endTagAfterHead(this, token);
        break;
      }
      case InsertionMode.IN_BODY: {
        endTagInBody(this, token);
        break;
      }
      case InsertionMode.TEXT: {
        endTagInText(this, token);
        break;
      }
      case InsertionMode.IN_TABLE: {
        endTagInTable(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      case InsertionMode.IN_CAPTION: {
        endTagInCaption(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        endTagInColumnGroup(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_BODY: {
        endTagInTableBody(this, token);
        break;
      }
      case InsertionMode.IN_ROW: {
        endTagInRow(this, token);
        break;
      }
      case InsertionMode.IN_CELL: {
        endTagInCell(this, token);
        break;
      }
      case InsertionMode.IN_SELECT: {
        endTagInSelect(this, token);
        break;
      }
      case InsertionMode.IN_SELECT_IN_TABLE: {
        endTagInSelectInTable(this, token);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        endTagInTemplate(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        endTagAfterBody(this, token);
        break;
      }
      case InsertionMode.IN_FRAMESET: {
        endTagInFrameset(this, token);
        break;
      }
      case InsertionMode.AFTER_FRAMESET: {
        endTagAfterFrameset(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, token);
        break;
      }
      default:
    }
  }
  /** @internal */
  onEof(token) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, token);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE: {
        eofInBody(this, token);
        break;
      }
      case InsertionMode.TEXT: {
        eofInText(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        eofInTemplate(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET:
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        stopParsing(this, token);
        break;
      }
      default:
    }
  }
  /** @internal */
  onWhitespaceCharacter(token) {
    if (this.skipNextNewLine) {
      this.skipNextNewLine = false;
      if (token.chars.charCodeAt(0) === CODE_POINTS.LINE_FEED) {
        if (token.chars.length === 1) {
          return;
        }
        token.chars = token.chars.substr(1);
      }
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD:
      case InsertionMode.TEXT:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET: {
        this._insertCharacters(token);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_TEMPLATE:
      case InsertionMode.AFTER_BODY:
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        whitespaceCharacterInBody(this, token);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        whitespaceCharacterInTableText(this, token);
        break;
      }
      default:
    }
  }
};
function aaObtainFormattingElementEntry(p5, token) {
  let formattingElementEntry = p5.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);
  if (formattingElementEntry) {
    if (!p5.openElements.contains(formattingElementEntry.element)) {
      p5.activeFormattingElements.removeEntry(formattingElementEntry);
      formattingElementEntry = null;
    } else if (!p5.openElements.hasInScope(token.tagID)) {
      formattingElementEntry = null;
    }
  } else {
    genericEndTagInBody(p5, token);
  }
  return formattingElementEntry;
}
function aaObtainFurthestBlock(p5, formattingElementEntry) {
  let furthestBlock = null;
  let idx = p5.openElements.stackTop;
  for (; idx >= 0; idx--) {
    const element7 = p5.openElements.items[idx];
    if (element7 === formattingElementEntry.element) {
      break;
    }
    if (p5._isSpecialElement(element7, p5.openElements.tagIDs[idx])) {
      furthestBlock = element7;
    }
  }
  if (!furthestBlock) {
    p5.openElements.shortenToLength(Math.max(idx, 0));
    p5.activeFormattingElements.removeEntry(formattingElementEntry);
  }
  return furthestBlock;
}
function aaInnerLoop(p5, furthestBlock, formattingElement) {
  let lastElement = furthestBlock;
  let nextElement = p5.openElements.getCommonAncestor(furthestBlock);
  for (let i2 = 0, element7 = nextElement; element7 !== formattingElement; i2++, element7 = nextElement) {
    nextElement = p5.openElements.getCommonAncestor(element7);
    const elementEntry = p5.activeFormattingElements.getElementEntry(element7);
    const counterOverflow = elementEntry && i2 >= AA_INNER_LOOP_ITER;
    const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;
    if (shouldRemoveFromOpenElements) {
      if (counterOverflow) {
        p5.activeFormattingElements.removeEntry(elementEntry);
      }
      p5.openElements.remove(element7);
    } else {
      element7 = aaRecreateElementFromEntry(p5, elementEntry);
      if (lastElement === furthestBlock) {
        p5.activeFormattingElements.bookmark = elementEntry;
      }
      p5.treeAdapter.detachNode(lastElement);
      p5.treeAdapter.appendChild(element7, lastElement);
      lastElement = element7;
    }
  }
  return lastElement;
}
function aaRecreateElementFromEntry(p5, elementEntry) {
  const ns2 = p5.treeAdapter.getNamespaceURI(elementEntry.element);
  const newElement = p5.treeAdapter.createElement(elementEntry.token.tagName, ns2, elementEntry.token.attrs);
  p5.openElements.replace(elementEntry.element, newElement);
  elementEntry.element = newElement;
  return newElement;
}
function aaInsertLastNodeInCommonAncestor(p5, commonAncestor, lastElement) {
  const tn2 = p5.treeAdapter.getTagName(commonAncestor);
  const tid = getTagID(tn2);
  if (p5._isElementCausesFosterParenting(tid)) {
    p5._fosterParentElement(lastElement);
  } else {
    const ns2 = p5.treeAdapter.getNamespaceURI(commonAncestor);
    if (tid === TAG_ID.TEMPLATE && ns2 === NS.HTML) {
      commonAncestor = p5.treeAdapter.getTemplateContent(commonAncestor);
    }
    p5.treeAdapter.appendChild(commonAncestor, lastElement);
  }
}
function aaReplaceFormattingElement(p5, furthestBlock, formattingElementEntry) {
  const ns2 = p5.treeAdapter.getNamespaceURI(formattingElementEntry.element);
  const { token } = formattingElementEntry;
  const newElement = p5.treeAdapter.createElement(token.tagName, ns2, token.attrs);
  p5._adoptNodes(furthestBlock, newElement);
  p5.treeAdapter.appendChild(furthestBlock, newElement);
  p5.activeFormattingElements.insertElementAfterBookmark(newElement, token);
  p5.activeFormattingElements.removeEntry(formattingElementEntry);
  p5.openElements.remove(formattingElementEntry.element);
  p5.openElements.insertAfter(furthestBlock, newElement, token.tagID);
}
function callAdoptionAgency(p5, token) {
  for (let i2 = 0; i2 < AA_OUTER_LOOP_ITER; i2++) {
    const formattingElementEntry = aaObtainFormattingElementEntry(p5, token);
    if (!formattingElementEntry) {
      break;
    }
    const furthestBlock = aaObtainFurthestBlock(p5, formattingElementEntry);
    if (!furthestBlock) {
      break;
    }
    p5.activeFormattingElements.bookmark = formattingElementEntry;
    const lastElement = aaInnerLoop(p5, furthestBlock, formattingElementEntry.element);
    const commonAncestor = p5.openElements.getCommonAncestor(formattingElementEntry.element);
    p5.treeAdapter.detachNode(lastElement);
    if (commonAncestor)
      aaInsertLastNodeInCommonAncestor(p5, commonAncestor, lastElement);
    aaReplaceFormattingElement(p5, furthestBlock, formattingElementEntry);
  }
}
function appendComment(p5, token) {
  p5._appendCommentNode(token, p5.openElements.currentTmplContentOrNode);
}
function appendCommentToRootHtmlElement(p5, token) {
  p5._appendCommentNode(token, p5.openElements.items[0]);
}
function appendCommentToDocument(p5, token) {
  p5._appendCommentNode(token, p5.document);
}
function stopParsing(p5, token) {
  p5.stopped = true;
  if (token.location) {
    const target = p5.fragmentContext ? 0 : 2;
    for (let i2 = p5.openElements.stackTop; i2 >= target; i2--) {
      p5._setEndLocation(p5.openElements.items[i2], token);
    }
    if (!p5.fragmentContext && p5.openElements.stackTop >= 0) {
      const htmlElement = p5.openElements.items[0];
      const htmlLocation = p5.treeAdapter.getNodeSourceCodeLocation(htmlElement);
      if (htmlLocation && !htmlLocation.endTag) {
        p5._setEndLocation(htmlElement, token);
        if (p5.openElements.stackTop >= 1) {
          const bodyElement = p5.openElements.items[1];
          const bodyLocation = p5.treeAdapter.getNodeSourceCodeLocation(bodyElement);
          if (bodyLocation && !bodyLocation.endTag) {
            p5._setEndLocation(bodyElement, token);
          }
        }
      }
    }
  }
}
function doctypeInInitialMode(p5, token) {
  p5._setDocumentType(token);
  const mode = token.forceQuirks ? DOCUMENT_MODE.QUIRKS : getDocumentMode(token);
  if (!isConforming(token)) {
    p5._err(token, ERR.nonConformingDoctype);
  }
  p5.treeAdapter.setDocumentMode(p5.document, mode);
  p5.insertionMode = InsertionMode.BEFORE_HTML;
}
function tokenInInitialMode(p5, token) {
  p5._err(token, ERR.missingDoctype, true);
  p5.treeAdapter.setDocumentMode(p5.document, DOCUMENT_MODE.QUIRKS);
  p5.insertionMode = InsertionMode.BEFORE_HTML;
  p5._processToken(token);
}
function startTagBeforeHtml(p5, token) {
  if (token.tagID === TAG_ID.HTML) {
    p5._insertElement(token, NS.HTML);
    p5.insertionMode = InsertionMode.BEFORE_HEAD;
  } else {
    tokenBeforeHtml(p5, token);
  }
}
function endTagBeforeHtml(p5, token) {
  const tn2 = token.tagID;
  if (tn2 === TAG_ID.HTML || tn2 === TAG_ID.HEAD || tn2 === TAG_ID.BODY || tn2 === TAG_ID.BR) {
    tokenBeforeHtml(p5, token);
  }
}
function tokenBeforeHtml(p5, token) {
  p5._insertFakeRootElement();
  p5.insertionMode = InsertionMode.BEFORE_HEAD;
  p5._processToken(token);
}
function startTagBeforeHead(p5, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p5, token);
      break;
    }
    case TAG_ID.HEAD: {
      p5._insertElement(token, NS.HTML);
      p5.headElement = p5.openElements.current;
      p5.insertionMode = InsertionMode.IN_HEAD;
      break;
    }
    default: {
      tokenBeforeHead(p5, token);
    }
  }
}
function endTagBeforeHead(p5, token) {
  const tn2 = token.tagID;
  if (tn2 === TAG_ID.HEAD || tn2 === TAG_ID.BODY || tn2 === TAG_ID.HTML || tn2 === TAG_ID.BR) {
    tokenBeforeHead(p5, token);
  } else {
    p5._err(token, ERR.endTagWithoutMatchingOpenElement);
  }
}
function tokenBeforeHead(p5, token) {
  p5._insertFakeElement(TAG_NAMES.HEAD, TAG_ID.HEAD);
  p5.headElement = p5.openElements.current;
  p5.insertionMode = InsertionMode.IN_HEAD;
  p5._processToken(token);
}
function startTagInHead(p5, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p5, token);
      break;
    }
    case TAG_ID.BASE:
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.LINK:
    case TAG_ID.META: {
      p5._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
      break;
    }
    case TAG_ID.TITLE: {
      p5._switchToTextParsing(token, TokenizerMode.RCDATA);
      break;
    }
    case TAG_ID.NOSCRIPT: {
      if (p5.options.scriptingEnabled) {
        p5._switchToTextParsing(token, TokenizerMode.RAWTEXT);
      } else {
        p5._insertElement(token, NS.HTML);
        p5.insertionMode = InsertionMode.IN_HEAD_NO_SCRIPT;
      }
      break;
    }
    case TAG_ID.NOFRAMES:
    case TAG_ID.STYLE: {
      p5._switchToTextParsing(token, TokenizerMode.RAWTEXT);
      break;
    }
    case TAG_ID.SCRIPT: {
      p5._switchToTextParsing(token, TokenizerMode.SCRIPT_DATA);
      break;
    }
    case TAG_ID.TEMPLATE: {
      p5._insertTemplate(token);
      p5.activeFormattingElements.insertMarker();
      p5.framesetOk = false;
      p5.insertionMode = InsertionMode.IN_TEMPLATE;
      p5.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
      break;
    }
    case TAG_ID.HEAD: {
      p5._err(token, ERR.misplacedStartTagForHeadElement);
      break;
    }
    default: {
      tokenInHead(p5, token);
    }
  }
}
function endTagInHead(p5, token) {
  switch (token.tagID) {
    case TAG_ID.HEAD: {
      p5.openElements.pop();
      p5.insertionMode = InsertionMode.AFTER_HEAD;
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.BR:
    case TAG_ID.HTML: {
      tokenInHead(p5, token);
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p5, token);
      break;
    }
    default: {
      p5._err(token, ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function templateEndTagInHead(p5, token) {
  if (p5.openElements.tmplCount > 0) {
    p5.openElements.generateImpliedEndTagsThoroughly();
    if (p5.openElements.currentTagId !== TAG_ID.TEMPLATE) {
      p5._err(token, ERR.closingOfElementWithOpenChildElements);
    }
    p5.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE);
    p5.activeFormattingElements.clearToLastMarker();
    p5.tmplInsertionModeStack.shift();
    p5._resetInsertionMode();
  } else {
    p5._err(token, ERR.endTagWithoutMatchingOpenElement);
  }
}
function tokenInHead(p5, token) {
  p5.openElements.pop();
  p5.insertionMode = InsertionMode.AFTER_HEAD;
  p5._processToken(token);
}
function startTagInHeadNoScript(p5, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p5, token);
      break;
    }
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.HEAD:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.NOFRAMES:
    case TAG_ID.STYLE: {
      startTagInHead(p5, token);
      break;
    }
    case TAG_ID.NOSCRIPT: {
      p5._err(token, ERR.nestedNoscriptInHead);
      break;
    }
    default: {
      tokenInHeadNoScript(p5, token);
    }
  }
}
function endTagInHeadNoScript(p5, token) {
  switch (token.tagID) {
    case TAG_ID.NOSCRIPT: {
      p5.openElements.pop();
      p5.insertionMode = InsertionMode.IN_HEAD;
      break;
    }
    case TAG_ID.BR: {
      tokenInHeadNoScript(p5, token);
      break;
    }
    default: {
      p5._err(token, ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function tokenInHeadNoScript(p5, token) {
  const errCode = token.type === TokenType.EOF ? ERR.openElementsLeftAfterEof : ERR.disallowedContentInNoscriptInHead;
  p5._err(token, errCode);
  p5.openElements.pop();
  p5.insertionMode = InsertionMode.IN_HEAD;
  p5._processToken(token);
}
function startTagAfterHead(p5, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p5, token);
      break;
    }
    case TAG_ID.BODY: {
      p5._insertElement(token, NS.HTML);
      p5.framesetOk = false;
      p5.insertionMode = InsertionMode.IN_BODY;
      break;
    }
    case TAG_ID.FRAMESET: {
      p5._insertElement(token, NS.HTML);
      p5.insertionMode = InsertionMode.IN_FRAMESET;
      break;
    }
    case TAG_ID.BASE:
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.NOFRAMES:
    case TAG_ID.SCRIPT:
    case TAG_ID.STYLE:
    case TAG_ID.TEMPLATE:
    case TAG_ID.TITLE: {
      p5._err(token, ERR.abandonedHeadElementChild);
      p5.openElements.push(p5.headElement, TAG_ID.HEAD);
      startTagInHead(p5, token);
      p5.openElements.remove(p5.headElement);
      break;
    }
    case TAG_ID.HEAD: {
      p5._err(token, ERR.misplacedStartTagForHeadElement);
      break;
    }
    default: {
      tokenAfterHead(p5, token);
    }
  }
}
function endTagAfterHead(p5, token) {
  switch (token.tagID) {
    case TAG_ID.BODY:
    case TAG_ID.HTML:
    case TAG_ID.BR: {
      tokenAfterHead(p5, token);
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p5, token);
      break;
    }
    default: {
      p5._err(token, ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function tokenAfterHead(p5, token) {
  p5._insertFakeElement(TAG_NAMES.BODY, TAG_ID.BODY);
  p5.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p5, token);
}
function modeInBody(p5, token) {
  switch (token.type) {
    case TokenType.CHARACTER: {
      characterInBody(p5, token);
      break;
    }
    case TokenType.WHITESPACE_CHARACTER: {
      whitespaceCharacterInBody(p5, token);
      break;
    }
    case TokenType.COMMENT: {
      appendComment(p5, token);
      break;
    }
    case TokenType.START_TAG: {
      startTagInBody(p5, token);
      break;
    }
    case TokenType.END_TAG: {
      endTagInBody(p5, token);
      break;
    }
    case TokenType.EOF: {
      eofInBody(p5, token);
      break;
    }
    default:
  }
}
function whitespaceCharacterInBody(p5, token) {
  p5._reconstructActiveFormattingElements();
  p5._insertCharacters(token);
}
function characterInBody(p5, token) {
  p5._reconstructActiveFormattingElements();
  p5._insertCharacters(token);
  p5.framesetOk = false;
}
function htmlStartTagInBody(p5, token) {
  if (p5.openElements.tmplCount === 0) {
    p5.treeAdapter.adoptAttributes(p5.openElements.items[0], token.attrs);
  }
}
function bodyStartTagInBody(p5, token) {
  const bodyElement = p5.openElements.tryPeekProperlyNestedBodyElement();
  if (bodyElement && p5.openElements.tmplCount === 0) {
    p5.framesetOk = false;
    p5.treeAdapter.adoptAttributes(bodyElement, token.attrs);
  }
}
function framesetStartTagInBody(p5, token) {
  const bodyElement = p5.openElements.tryPeekProperlyNestedBodyElement();
  if (p5.framesetOk && bodyElement) {
    p5.treeAdapter.detachNode(bodyElement);
    p5.openElements.popAllUpToHtmlElement();
    p5._insertElement(token, NS.HTML);
    p5.insertionMode = InsertionMode.IN_FRAMESET;
  }
}
function addressStartTagInBody(p5, token) {
  if (p5.openElements.hasInButtonScope(TAG_ID.P)) {
    p5._closePElement();
  }
  p5._insertElement(token, NS.HTML);
}
function numberedHeaderStartTagInBody(p5, token) {
  if (p5.openElements.hasInButtonScope(TAG_ID.P)) {
    p5._closePElement();
  }
  if (p5.openElements.currentTagId !== void 0 && NUMBERED_HEADERS.has(p5.openElements.currentTagId)) {
    p5.openElements.pop();
  }
  p5._insertElement(token, NS.HTML);
}
function preStartTagInBody(p5, token) {
  if (p5.openElements.hasInButtonScope(TAG_ID.P)) {
    p5._closePElement();
  }
  p5._insertElement(token, NS.HTML);
  p5.skipNextNewLine = true;
  p5.framesetOk = false;
}
function formStartTagInBody(p5, token) {
  const inTemplate = p5.openElements.tmplCount > 0;
  if (!p5.formElement || inTemplate) {
    if (p5.openElements.hasInButtonScope(TAG_ID.P)) {
      p5._closePElement();
    }
    p5._insertElement(token, NS.HTML);
    if (!inTemplate) {
      p5.formElement = p5.openElements.current;
    }
  }
}
function listItemStartTagInBody(p5, token) {
  p5.framesetOk = false;
  const tn2 = token.tagID;
  for (let i2 = p5.openElements.stackTop; i2 >= 0; i2--) {
    const elementId = p5.openElements.tagIDs[i2];
    if (tn2 === TAG_ID.LI && elementId === TAG_ID.LI || (tn2 === TAG_ID.DD || tn2 === TAG_ID.DT) && (elementId === TAG_ID.DD || elementId === TAG_ID.DT)) {
      p5.openElements.generateImpliedEndTagsWithExclusion(elementId);
      p5.openElements.popUntilTagNamePopped(elementId);
      break;
    }
    if (elementId !== TAG_ID.ADDRESS && elementId !== TAG_ID.DIV && elementId !== TAG_ID.P && p5._isSpecialElement(p5.openElements.items[i2], elementId)) {
      break;
    }
  }
  if (p5.openElements.hasInButtonScope(TAG_ID.P)) {
    p5._closePElement();
  }
  p5._insertElement(token, NS.HTML);
}
function plaintextStartTagInBody(p5, token) {
  if (p5.openElements.hasInButtonScope(TAG_ID.P)) {
    p5._closePElement();
  }
  p5._insertElement(token, NS.HTML);
  p5.tokenizer.state = TokenizerMode.PLAINTEXT;
}
function buttonStartTagInBody(p5, token) {
  if (p5.openElements.hasInScope(TAG_ID.BUTTON)) {
    p5.openElements.generateImpliedEndTags();
    p5.openElements.popUntilTagNamePopped(TAG_ID.BUTTON);
  }
  p5._reconstructActiveFormattingElements();
  p5._insertElement(token, NS.HTML);
  p5.framesetOk = false;
}
function aStartTagInBody(p5, token) {
  const activeElementEntry = p5.activeFormattingElements.getElementEntryInScopeWithTagName(TAG_NAMES.A);
  if (activeElementEntry) {
    callAdoptionAgency(p5, token);
    p5.openElements.remove(activeElementEntry.element);
    p5.activeFormattingElements.removeEntry(activeElementEntry);
  }
  p5._reconstructActiveFormattingElements();
  p5._insertElement(token, NS.HTML);
  p5.activeFormattingElements.pushElement(p5.openElements.current, token);
}
function bStartTagInBody(p5, token) {
  p5._reconstructActiveFormattingElements();
  p5._insertElement(token, NS.HTML);
  p5.activeFormattingElements.pushElement(p5.openElements.current, token);
}
function nobrStartTagInBody(p5, token) {
  p5._reconstructActiveFormattingElements();
  if (p5.openElements.hasInScope(TAG_ID.NOBR)) {
    callAdoptionAgency(p5, token);
    p5._reconstructActiveFormattingElements();
  }
  p5._insertElement(token, NS.HTML);
  p5.activeFormattingElements.pushElement(p5.openElements.current, token);
}
function appletStartTagInBody(p5, token) {
  p5._reconstructActiveFormattingElements();
  p5._insertElement(token, NS.HTML);
  p5.activeFormattingElements.insertMarker();
  p5.framesetOk = false;
}
function tableStartTagInBody(p5, token) {
  if (p5.treeAdapter.getDocumentMode(p5.document) !== DOCUMENT_MODE.QUIRKS && p5.openElements.hasInButtonScope(TAG_ID.P)) {
    p5._closePElement();
  }
  p5._insertElement(token, NS.HTML);
  p5.framesetOk = false;
  p5.insertionMode = InsertionMode.IN_TABLE;
}
function areaStartTagInBody(p5, token) {
  p5._reconstructActiveFormattingElements();
  p5._appendElement(token, NS.HTML);
  p5.framesetOk = false;
  token.ackSelfClosing = true;
}
function isHiddenInput3(token) {
  const inputType = getTokenAttr(token, ATTRS.TYPE);
  return inputType != null && inputType.toLowerCase() === HIDDEN_INPUT_TYPE;
}
function inputStartTagInBody(p5, token) {
  p5._reconstructActiveFormattingElements();
  p5._appendElement(token, NS.HTML);
  if (!isHiddenInput3(token)) {
    p5.framesetOk = false;
  }
  token.ackSelfClosing = true;
}
function paramStartTagInBody(p5, token) {
  p5._appendElement(token, NS.HTML);
  token.ackSelfClosing = true;
}
function hrStartTagInBody(p5, token) {
  if (p5.openElements.hasInButtonScope(TAG_ID.P)) {
    p5._closePElement();
  }
  p5._appendElement(token, NS.HTML);
  p5.framesetOk = false;
  token.ackSelfClosing = true;
}
function imageStartTagInBody(p5, token) {
  token.tagName = TAG_NAMES.IMG;
  token.tagID = TAG_ID.IMG;
  areaStartTagInBody(p5, token);
}
function textareaStartTagInBody(p5, token) {
  p5._insertElement(token, NS.HTML);
  p5.skipNextNewLine = true;
  p5.tokenizer.state = TokenizerMode.RCDATA;
  p5.originalInsertionMode = p5.insertionMode;
  p5.framesetOk = false;
  p5.insertionMode = InsertionMode.TEXT;
}
function xmpStartTagInBody(p5, token) {
  if (p5.openElements.hasInButtonScope(TAG_ID.P)) {
    p5._closePElement();
  }
  p5._reconstructActiveFormattingElements();
  p5.framesetOk = false;
  p5._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function iframeStartTagInBody(p5, token) {
  p5.framesetOk = false;
  p5._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function rawTextStartTagInBody(p5, token) {
  p5._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function selectStartTagInBody(p5, token) {
  p5._reconstructActiveFormattingElements();
  p5._insertElement(token, NS.HTML);
  p5.framesetOk = false;
  p5.insertionMode = p5.insertionMode === InsertionMode.IN_TABLE || p5.insertionMode === InsertionMode.IN_CAPTION || p5.insertionMode === InsertionMode.IN_TABLE_BODY || p5.insertionMode === InsertionMode.IN_ROW || p5.insertionMode === InsertionMode.IN_CELL ? InsertionMode.IN_SELECT_IN_TABLE : InsertionMode.IN_SELECT;
}
function optgroupStartTagInBody(p5, token) {
  if (p5.openElements.currentTagId === TAG_ID.OPTION) {
    p5.openElements.pop();
  }
  p5._reconstructActiveFormattingElements();
  p5._insertElement(token, NS.HTML);
}
function rbStartTagInBody(p5, token) {
  if (p5.openElements.hasInScope(TAG_ID.RUBY)) {
    p5.openElements.generateImpliedEndTags();
  }
  p5._insertElement(token, NS.HTML);
}
function rtStartTagInBody(p5, token) {
  if (p5.openElements.hasInScope(TAG_ID.RUBY)) {
    p5.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.RTC);
  }
  p5._insertElement(token, NS.HTML);
}
function mathStartTagInBody(p5, token) {
  p5._reconstructActiveFormattingElements();
  adjustTokenMathMLAttrs(token);
  adjustTokenXMLAttrs(token);
  if (token.selfClosing) {
    p5._appendElement(token, NS.MATHML);
  } else {
    p5._insertElement(token, NS.MATHML);
  }
  token.ackSelfClosing = true;
}
function svgStartTagInBody(p5, token) {
  p5._reconstructActiveFormattingElements();
  adjustTokenSVGAttrs(token);
  adjustTokenXMLAttrs(token);
  if (token.selfClosing) {
    p5._appendElement(token, NS.SVG);
  } else {
    p5._insertElement(token, NS.SVG);
  }
  token.ackSelfClosing = true;
}
function genericStartTagInBody(p5, token) {
  p5._reconstructActiveFormattingElements();
  p5._insertElement(token, NS.HTML);
}
function startTagInBody(p5, token) {
  switch (token.tagID) {
    case TAG_ID.I:
    case TAG_ID.S:
    case TAG_ID.B:
    case TAG_ID.U:
    case TAG_ID.EM:
    case TAG_ID.TT:
    case TAG_ID.BIG:
    case TAG_ID.CODE:
    case TAG_ID.FONT:
    case TAG_ID.SMALL:
    case TAG_ID.STRIKE:
    case TAG_ID.STRONG: {
      bStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.A: {
      aStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.H1:
    case TAG_ID.H2:
    case TAG_ID.H3:
    case TAG_ID.H4:
    case TAG_ID.H5:
    case TAG_ID.H6: {
      numberedHeaderStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.P:
    case TAG_ID.DL:
    case TAG_ID.OL:
    case TAG_ID.UL:
    case TAG_ID.DIV:
    case TAG_ID.DIR:
    case TAG_ID.NAV:
    case TAG_ID.MAIN:
    case TAG_ID.MENU:
    case TAG_ID.ASIDE:
    case TAG_ID.CENTER:
    case TAG_ID.FIGURE:
    case TAG_ID.FOOTER:
    case TAG_ID.HEADER:
    case TAG_ID.HGROUP:
    case TAG_ID.DIALOG:
    case TAG_ID.DETAILS:
    case TAG_ID.ADDRESS:
    case TAG_ID.ARTICLE:
    case TAG_ID.SEARCH:
    case TAG_ID.SECTION:
    case TAG_ID.SUMMARY:
    case TAG_ID.FIELDSET:
    case TAG_ID.BLOCKQUOTE:
    case TAG_ID.FIGCAPTION: {
      addressStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.LI:
    case TAG_ID.DD:
    case TAG_ID.DT: {
      listItemStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.BR:
    case TAG_ID.IMG:
    case TAG_ID.WBR:
    case TAG_ID.AREA:
    case TAG_ID.EMBED:
    case TAG_ID.KEYGEN: {
      areaStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.HR: {
      hrStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.RB:
    case TAG_ID.RTC: {
      rbStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.RT:
    case TAG_ID.RP: {
      rtStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.PRE:
    case TAG_ID.LISTING: {
      preStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.XMP: {
      xmpStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.SVG: {
      svgStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.HTML: {
      htmlStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.BASE:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.STYLE:
    case TAG_ID.TITLE:
    case TAG_ID.SCRIPT:
    case TAG_ID.BGSOUND:
    case TAG_ID.BASEFONT:
    case TAG_ID.TEMPLATE: {
      startTagInHead(p5, token);
      break;
    }
    case TAG_ID.BODY: {
      bodyStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.FORM: {
      formStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.NOBR: {
      nobrStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.MATH: {
      mathStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.TABLE: {
      tableStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.INPUT: {
      inputStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.PARAM:
    case TAG_ID.TRACK:
    case TAG_ID.SOURCE: {
      paramStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.IMAGE: {
      imageStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.BUTTON: {
      buttonStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.APPLET:
    case TAG_ID.OBJECT:
    case TAG_ID.MARQUEE: {
      appletStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.IFRAME: {
      iframeStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.SELECT: {
      selectStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.OPTION:
    case TAG_ID.OPTGROUP: {
      optgroupStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.NOEMBED:
    case TAG_ID.NOFRAMES: {
      rawTextStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.FRAMESET: {
      framesetStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.TEXTAREA: {
      textareaStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.NOSCRIPT: {
      if (p5.options.scriptingEnabled) {
        rawTextStartTagInBody(p5, token);
      } else {
        genericStartTagInBody(p5, token);
      }
      break;
    }
    case TAG_ID.PLAINTEXT: {
      plaintextStartTagInBody(p5, token);
      break;
    }
    case TAG_ID.COL:
    case TAG_ID.TH:
    case TAG_ID.TD:
    case TAG_ID.TR:
    case TAG_ID.HEAD:
    case TAG_ID.FRAME:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD:
    case TAG_ID.CAPTION:
    case TAG_ID.COLGROUP: {
      break;
    }
    default: {
      genericStartTagInBody(p5, token);
    }
  }
}
function bodyEndTagInBody(p5, token) {
  if (p5.openElements.hasInScope(TAG_ID.BODY)) {
    p5.insertionMode = InsertionMode.AFTER_BODY;
    if (p5.options.sourceCodeLocationInfo) {
      const bodyElement = p5.openElements.tryPeekProperlyNestedBodyElement();
      if (bodyElement) {
        p5._setEndLocation(bodyElement, token);
      }
    }
  }
}
function htmlEndTagInBody(p5, token) {
  if (p5.openElements.hasInScope(TAG_ID.BODY)) {
    p5.insertionMode = InsertionMode.AFTER_BODY;
    endTagAfterBody(p5, token);
  }
}
function addressEndTagInBody(p5, token) {
  const tn2 = token.tagID;
  if (p5.openElements.hasInScope(tn2)) {
    p5.openElements.generateImpliedEndTags();
    p5.openElements.popUntilTagNamePopped(tn2);
  }
}
function formEndTagInBody(p5) {
  const inTemplate = p5.openElements.tmplCount > 0;
  const { formElement } = p5;
  if (!inTemplate) {
    p5.formElement = null;
  }
  if ((formElement || inTemplate) && p5.openElements.hasInScope(TAG_ID.FORM)) {
    p5.openElements.generateImpliedEndTags();
    if (inTemplate) {
      p5.openElements.popUntilTagNamePopped(TAG_ID.FORM);
    } else if (formElement) {
      p5.openElements.remove(formElement);
    }
  }
}
function pEndTagInBody(p5) {
  if (!p5.openElements.hasInButtonScope(TAG_ID.P)) {
    p5._insertFakeElement(TAG_NAMES.P, TAG_ID.P);
  }
  p5._closePElement();
}
function liEndTagInBody(p5) {
  if (p5.openElements.hasInListItemScope(TAG_ID.LI)) {
    p5.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.LI);
    p5.openElements.popUntilTagNamePopped(TAG_ID.LI);
  }
}
function ddEndTagInBody(p5, token) {
  const tn2 = token.tagID;
  if (p5.openElements.hasInScope(tn2)) {
    p5.openElements.generateImpliedEndTagsWithExclusion(tn2);
    p5.openElements.popUntilTagNamePopped(tn2);
  }
}
function numberedHeaderEndTagInBody(p5) {
  if (p5.openElements.hasNumberedHeaderInScope()) {
    p5.openElements.generateImpliedEndTags();
    p5.openElements.popUntilNumberedHeaderPopped();
  }
}
function appletEndTagInBody(p5, token) {
  const tn2 = token.tagID;
  if (p5.openElements.hasInScope(tn2)) {
    p5.openElements.generateImpliedEndTags();
    p5.openElements.popUntilTagNamePopped(tn2);
    p5.activeFormattingElements.clearToLastMarker();
  }
}
function brEndTagInBody(p5) {
  p5._reconstructActiveFormattingElements();
  p5._insertFakeElement(TAG_NAMES.BR, TAG_ID.BR);
  p5.openElements.pop();
  p5.framesetOk = false;
}
function genericEndTagInBody(p5, token) {
  const tn2 = token.tagName;
  const tid = token.tagID;
  for (let i2 = p5.openElements.stackTop; i2 > 0; i2--) {
    const element7 = p5.openElements.items[i2];
    const elementId = p5.openElements.tagIDs[i2];
    if (tid === elementId && (tid !== TAG_ID.UNKNOWN || p5.treeAdapter.getTagName(element7) === tn2)) {
      p5.openElements.generateImpliedEndTagsWithExclusion(tid);
      if (p5.openElements.stackTop >= i2)
        p5.openElements.shortenToLength(i2);
      break;
    }
    if (p5._isSpecialElement(element7, elementId)) {
      break;
    }
  }
}
function endTagInBody(p5, token) {
  switch (token.tagID) {
    case TAG_ID.A:
    case TAG_ID.B:
    case TAG_ID.I:
    case TAG_ID.S:
    case TAG_ID.U:
    case TAG_ID.EM:
    case TAG_ID.TT:
    case TAG_ID.BIG:
    case TAG_ID.CODE:
    case TAG_ID.FONT:
    case TAG_ID.NOBR:
    case TAG_ID.SMALL:
    case TAG_ID.STRIKE:
    case TAG_ID.STRONG: {
      callAdoptionAgency(p5, token);
      break;
    }
    case TAG_ID.P: {
      pEndTagInBody(p5);
      break;
    }
    case TAG_ID.DL:
    case TAG_ID.UL:
    case TAG_ID.OL:
    case TAG_ID.DIR:
    case TAG_ID.DIV:
    case TAG_ID.NAV:
    case TAG_ID.PRE:
    case TAG_ID.MAIN:
    case TAG_ID.MENU:
    case TAG_ID.ASIDE:
    case TAG_ID.BUTTON:
    case TAG_ID.CENTER:
    case TAG_ID.FIGURE:
    case TAG_ID.FOOTER:
    case TAG_ID.HEADER:
    case TAG_ID.HGROUP:
    case TAG_ID.DIALOG:
    case TAG_ID.ADDRESS:
    case TAG_ID.ARTICLE:
    case TAG_ID.DETAILS:
    case TAG_ID.SEARCH:
    case TAG_ID.SECTION:
    case TAG_ID.SUMMARY:
    case TAG_ID.LISTING:
    case TAG_ID.FIELDSET:
    case TAG_ID.BLOCKQUOTE:
    case TAG_ID.FIGCAPTION: {
      addressEndTagInBody(p5, token);
      break;
    }
    case TAG_ID.LI: {
      liEndTagInBody(p5);
      break;
    }
    case TAG_ID.DD:
    case TAG_ID.DT: {
      ddEndTagInBody(p5, token);
      break;
    }
    case TAG_ID.H1:
    case TAG_ID.H2:
    case TAG_ID.H3:
    case TAG_ID.H4:
    case TAG_ID.H5:
    case TAG_ID.H6: {
      numberedHeaderEndTagInBody(p5);
      break;
    }
    case TAG_ID.BR: {
      brEndTagInBody(p5);
      break;
    }
    case TAG_ID.BODY: {
      bodyEndTagInBody(p5, token);
      break;
    }
    case TAG_ID.HTML: {
      htmlEndTagInBody(p5, token);
      break;
    }
    case TAG_ID.FORM: {
      formEndTagInBody(p5);
      break;
    }
    case TAG_ID.APPLET:
    case TAG_ID.OBJECT:
    case TAG_ID.MARQUEE: {
      appletEndTagInBody(p5, token);
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p5, token);
      break;
    }
    default: {
      genericEndTagInBody(p5, token);
    }
  }
}
function eofInBody(p5, token) {
  if (p5.tmplInsertionModeStack.length > 0) {
    eofInTemplate(p5, token);
  } else {
    stopParsing(p5, token);
  }
}
function endTagInText(p5, token) {
  var _a2;
  if (token.tagID === TAG_ID.SCRIPT) {
    (_a2 = p5.scriptHandler) === null || _a2 === void 0 ? void 0 : _a2.call(p5, p5.openElements.current);
  }
  p5.openElements.pop();
  p5.insertionMode = p5.originalInsertionMode;
}
function eofInText(p5, token) {
  p5._err(token, ERR.eofInElementThatCanContainOnlyText);
  p5.openElements.pop();
  p5.insertionMode = p5.originalInsertionMode;
  p5.onEof(token);
}
function characterInTable(p5, token) {
  if (p5.openElements.currentTagId !== void 0 && TABLE_STRUCTURE_TAGS.has(p5.openElements.currentTagId)) {
    p5.pendingCharacterTokens.length = 0;
    p5.hasNonWhitespacePendingCharacterToken = false;
    p5.originalInsertionMode = p5.insertionMode;
    p5.insertionMode = InsertionMode.IN_TABLE_TEXT;
    switch (token.type) {
      case TokenType.CHARACTER: {
        characterInTableText(p5, token);
        break;
      }
      case TokenType.WHITESPACE_CHARACTER: {
        whitespaceCharacterInTableText(p5, token);
        break;
      }
    }
  } else {
    tokenInTable(p5, token);
  }
}
function captionStartTagInTable(p5, token) {
  p5.openElements.clearBackToTableContext();
  p5.activeFormattingElements.insertMarker();
  p5._insertElement(token, NS.HTML);
  p5.insertionMode = InsertionMode.IN_CAPTION;
}
function colgroupStartTagInTable(p5, token) {
  p5.openElements.clearBackToTableContext();
  p5._insertElement(token, NS.HTML);
  p5.insertionMode = InsertionMode.IN_COLUMN_GROUP;
}
function colStartTagInTable(p5, token) {
  p5.openElements.clearBackToTableContext();
  p5._insertFakeElement(TAG_NAMES.COLGROUP, TAG_ID.COLGROUP);
  p5.insertionMode = InsertionMode.IN_COLUMN_GROUP;
  startTagInColumnGroup(p5, token);
}
function tbodyStartTagInTable(p5, token) {
  p5.openElements.clearBackToTableContext();
  p5._insertElement(token, NS.HTML);
  p5.insertionMode = InsertionMode.IN_TABLE_BODY;
}
function tdStartTagInTable(p5, token) {
  p5.openElements.clearBackToTableContext();
  p5._insertFakeElement(TAG_NAMES.TBODY, TAG_ID.TBODY);
  p5.insertionMode = InsertionMode.IN_TABLE_BODY;
  startTagInTableBody(p5, token);
}
function tableStartTagInTable(p5, token) {
  if (p5.openElements.hasInTableScope(TAG_ID.TABLE)) {
    p5.openElements.popUntilTagNamePopped(TAG_ID.TABLE);
    p5._resetInsertionMode();
    p5._processStartTag(token);
  }
}
function inputStartTagInTable(p5, token) {
  if (isHiddenInput3(token)) {
    p5._appendElement(token, NS.HTML);
  } else {
    tokenInTable(p5, token);
  }
  token.ackSelfClosing = true;
}
function formStartTagInTable(p5, token) {
  if (!p5.formElement && p5.openElements.tmplCount === 0) {
    p5._insertElement(token, NS.HTML);
    p5.formElement = p5.openElements.current;
    p5.openElements.pop();
  }
}
function startTagInTable(p5, token) {
  switch (token.tagID) {
    case TAG_ID.TD:
    case TAG_ID.TH:
    case TAG_ID.TR: {
      tdStartTagInTable(p5, token);
      break;
    }
    case TAG_ID.STYLE:
    case TAG_ID.SCRIPT:
    case TAG_ID.TEMPLATE: {
      startTagInHead(p5, token);
      break;
    }
    case TAG_ID.COL: {
      colStartTagInTable(p5, token);
      break;
    }
    case TAG_ID.FORM: {
      formStartTagInTable(p5, token);
      break;
    }
    case TAG_ID.TABLE: {
      tableStartTagInTable(p5, token);
      break;
    }
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      tbodyStartTagInTable(p5, token);
      break;
    }
    case TAG_ID.INPUT: {
      inputStartTagInTable(p5, token);
      break;
    }
    case TAG_ID.CAPTION: {
      captionStartTagInTable(p5, token);
      break;
    }
    case TAG_ID.COLGROUP: {
      colgroupStartTagInTable(p5, token);
      break;
    }
    default: {
      tokenInTable(p5, token);
    }
  }
}
function endTagInTable(p5, token) {
  switch (token.tagID) {
    case TAG_ID.TABLE: {
      if (p5.openElements.hasInTableScope(TAG_ID.TABLE)) {
        p5.openElements.popUntilTagNamePopped(TAG_ID.TABLE);
        p5._resetInsertionMode();
      }
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p5, token);
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TBODY:
    case TAG_ID.TD:
    case TAG_ID.TFOOT:
    case TAG_ID.TH:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      break;
    }
    default: {
      tokenInTable(p5, token);
    }
  }
}
function tokenInTable(p5, token) {
  const savedFosterParentingState = p5.fosterParentingEnabled;
  p5.fosterParentingEnabled = true;
  modeInBody(p5, token);
  p5.fosterParentingEnabled = savedFosterParentingState;
}
function whitespaceCharacterInTableText(p5, token) {
  p5.pendingCharacterTokens.push(token);
}
function characterInTableText(p5, token) {
  p5.pendingCharacterTokens.push(token);
  p5.hasNonWhitespacePendingCharacterToken = true;
}
function tokenInTableText(p5, token) {
  let i2 = 0;
  if (p5.hasNonWhitespacePendingCharacterToken) {
    for (; i2 < p5.pendingCharacterTokens.length; i2++) {
      tokenInTable(p5, p5.pendingCharacterTokens[i2]);
    }
  } else {
    for (; i2 < p5.pendingCharacterTokens.length; i2++) {
      p5._insertCharacters(p5.pendingCharacterTokens[i2]);
    }
  }
  p5.insertionMode = p5.originalInsertionMode;
  p5._processToken(token);
}
var TABLE_VOID_ELEMENTS = /* @__PURE__ */ new Set([TAG_ID.CAPTION, TAG_ID.COL, TAG_ID.COLGROUP, TAG_ID.TBODY, TAG_ID.TD, TAG_ID.TFOOT, TAG_ID.TH, TAG_ID.THEAD, TAG_ID.TR]);
function startTagInCaption(p5, token) {
  const tn2 = token.tagID;
  if (TABLE_VOID_ELEMENTS.has(tn2)) {
    if (p5.openElements.hasInTableScope(TAG_ID.CAPTION)) {
      p5.openElements.generateImpliedEndTags();
      p5.openElements.popUntilTagNamePopped(TAG_ID.CAPTION);
      p5.activeFormattingElements.clearToLastMarker();
      p5.insertionMode = InsertionMode.IN_TABLE;
      startTagInTable(p5, token);
    }
  } else {
    startTagInBody(p5, token);
  }
}
function endTagInCaption(p5, token) {
  const tn2 = token.tagID;
  switch (tn2) {
    case TAG_ID.CAPTION:
    case TAG_ID.TABLE: {
      if (p5.openElements.hasInTableScope(TAG_ID.CAPTION)) {
        p5.openElements.generateImpliedEndTags();
        p5.openElements.popUntilTagNamePopped(TAG_ID.CAPTION);
        p5.activeFormattingElements.clearToLastMarker();
        p5.insertionMode = InsertionMode.IN_TABLE;
        if (tn2 === TAG_ID.TABLE) {
          endTagInTable(p5, token);
        }
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TBODY:
    case TAG_ID.TD:
    case TAG_ID.TFOOT:
    case TAG_ID.TH:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      break;
    }
    default: {
      endTagInBody(p5, token);
    }
  }
}
function startTagInColumnGroup(p5, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p5, token);
      break;
    }
    case TAG_ID.COL: {
      p5._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
      break;
    }
    case TAG_ID.TEMPLATE: {
      startTagInHead(p5, token);
      break;
    }
    default: {
      tokenInColumnGroup(p5, token);
    }
  }
}
function endTagInColumnGroup(p5, token) {
  switch (token.tagID) {
    case TAG_ID.COLGROUP: {
      if (p5.openElements.currentTagId === TAG_ID.COLGROUP) {
        p5.openElements.pop();
        p5.insertionMode = InsertionMode.IN_TABLE;
      }
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p5, token);
      break;
    }
    case TAG_ID.COL: {
      break;
    }
    default: {
      tokenInColumnGroup(p5, token);
    }
  }
}
function tokenInColumnGroup(p5, token) {
  if (p5.openElements.currentTagId === TAG_ID.COLGROUP) {
    p5.openElements.pop();
    p5.insertionMode = InsertionMode.IN_TABLE;
    p5._processToken(token);
  }
}
function startTagInTableBody(p5, token) {
  switch (token.tagID) {
    case TAG_ID.TR: {
      p5.openElements.clearBackToTableBodyContext();
      p5._insertElement(token, NS.HTML);
      p5.insertionMode = InsertionMode.IN_ROW;
      break;
    }
    case TAG_ID.TH:
    case TAG_ID.TD: {
      p5.openElements.clearBackToTableBodyContext();
      p5._insertFakeElement(TAG_NAMES.TR, TAG_ID.TR);
      p5.insertionMode = InsertionMode.IN_ROW;
      startTagInRow(p5, token);
      break;
    }
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      if (p5.openElements.hasTableBodyContextInTableScope()) {
        p5.openElements.clearBackToTableBodyContext();
        p5.openElements.pop();
        p5.insertionMode = InsertionMode.IN_TABLE;
        startTagInTable(p5, token);
      }
      break;
    }
    default: {
      startTagInTable(p5, token);
    }
  }
}
function endTagInTableBody(p5, token) {
  const tn2 = token.tagID;
  switch (token.tagID) {
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      if (p5.openElements.hasInTableScope(tn2)) {
        p5.openElements.clearBackToTableBodyContext();
        p5.openElements.pop();
        p5.insertionMode = InsertionMode.IN_TABLE;
      }
      break;
    }
    case TAG_ID.TABLE: {
      if (p5.openElements.hasTableBodyContextInTableScope()) {
        p5.openElements.clearBackToTableBodyContext();
        p5.openElements.pop();
        p5.insertionMode = InsertionMode.IN_TABLE;
        endTagInTable(p5, token);
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TD:
    case TAG_ID.TH:
    case TAG_ID.TR: {
      break;
    }
    default: {
      endTagInTable(p5, token);
    }
  }
}
function startTagInRow(p5, token) {
  switch (token.tagID) {
    case TAG_ID.TH:
    case TAG_ID.TD: {
      p5.openElements.clearBackToTableRowContext();
      p5._insertElement(token, NS.HTML);
      p5.insertionMode = InsertionMode.IN_CELL;
      p5.activeFormattingElements.insertMarker();
      break;
    }
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      if (p5.openElements.hasInTableScope(TAG_ID.TR)) {
        p5.openElements.clearBackToTableRowContext();
        p5.openElements.pop();
        p5.insertionMode = InsertionMode.IN_TABLE_BODY;
        startTagInTableBody(p5, token);
      }
      break;
    }
    default: {
      startTagInTable(p5, token);
    }
  }
}
function endTagInRow(p5, token) {
  switch (token.tagID) {
    case TAG_ID.TR: {
      if (p5.openElements.hasInTableScope(TAG_ID.TR)) {
        p5.openElements.clearBackToTableRowContext();
        p5.openElements.pop();
        p5.insertionMode = InsertionMode.IN_TABLE_BODY;
      }
      break;
    }
    case TAG_ID.TABLE: {
      if (p5.openElements.hasInTableScope(TAG_ID.TR)) {
        p5.openElements.clearBackToTableRowContext();
        p5.openElements.pop();
        p5.insertionMode = InsertionMode.IN_TABLE_BODY;
        endTagInTableBody(p5, token);
      }
      break;
    }
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      if (p5.openElements.hasInTableScope(token.tagID) || p5.openElements.hasInTableScope(TAG_ID.TR)) {
        p5.openElements.clearBackToTableRowContext();
        p5.openElements.pop();
        p5.insertionMode = InsertionMode.IN_TABLE_BODY;
        endTagInTableBody(p5, token);
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TD:
    case TAG_ID.TH: {
      break;
    }
    default: {
      endTagInTable(p5, token);
    }
  }
}
function startTagInCell(p5, token) {
  const tn2 = token.tagID;
  if (TABLE_VOID_ELEMENTS.has(tn2)) {
    if (p5.openElements.hasInTableScope(TAG_ID.TD) || p5.openElements.hasInTableScope(TAG_ID.TH)) {
      p5._closeTableCell();
      startTagInRow(p5, token);
    }
  } else {
    startTagInBody(p5, token);
  }
}
function endTagInCell(p5, token) {
  const tn2 = token.tagID;
  switch (tn2) {
    case TAG_ID.TD:
    case TAG_ID.TH: {
      if (p5.openElements.hasInTableScope(tn2)) {
        p5.openElements.generateImpliedEndTags();
        p5.openElements.popUntilTagNamePopped(tn2);
        p5.activeFormattingElements.clearToLastMarker();
        p5.insertionMode = InsertionMode.IN_ROW;
      }
      break;
    }
    case TAG_ID.TABLE:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      if (p5.openElements.hasInTableScope(tn2)) {
        p5._closeTableCell();
        endTagInRow(p5, token);
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML: {
      break;
    }
    default: {
      endTagInBody(p5, token);
    }
  }
}
function startTagInSelect(p5, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p5, token);
      break;
    }
    case TAG_ID.OPTION: {
      if (p5.openElements.currentTagId === TAG_ID.OPTION) {
        p5.openElements.pop();
      }
      p5._insertElement(token, NS.HTML);
      break;
    }
    case TAG_ID.OPTGROUP: {
      if (p5.openElements.currentTagId === TAG_ID.OPTION) {
        p5.openElements.pop();
      }
      if (p5.openElements.currentTagId === TAG_ID.OPTGROUP) {
        p5.openElements.pop();
      }
      p5._insertElement(token, NS.HTML);
      break;
    }
    case TAG_ID.HR: {
      if (p5.openElements.currentTagId === TAG_ID.OPTION) {
        p5.openElements.pop();
      }
      if (p5.openElements.currentTagId === TAG_ID.OPTGROUP) {
        p5.openElements.pop();
      }
      p5._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
      break;
    }
    case TAG_ID.INPUT:
    case TAG_ID.KEYGEN:
    case TAG_ID.TEXTAREA:
    case TAG_ID.SELECT: {
      if (p5.openElements.hasInSelectScope(TAG_ID.SELECT)) {
        p5.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
        p5._resetInsertionMode();
        if (token.tagID !== TAG_ID.SELECT) {
          p5._processStartTag(token);
        }
      }
      break;
    }
    case TAG_ID.SCRIPT:
    case TAG_ID.TEMPLATE: {
      startTagInHead(p5, token);
      break;
    }
    default:
  }
}
function endTagInSelect(p5, token) {
  switch (token.tagID) {
    case TAG_ID.OPTGROUP: {
      if (p5.openElements.stackTop > 0 && p5.openElements.currentTagId === TAG_ID.OPTION && p5.openElements.tagIDs[p5.openElements.stackTop - 1] === TAG_ID.OPTGROUP) {
        p5.openElements.pop();
      }
      if (p5.openElements.currentTagId === TAG_ID.OPTGROUP) {
        p5.openElements.pop();
      }
      break;
    }
    case TAG_ID.OPTION: {
      if (p5.openElements.currentTagId === TAG_ID.OPTION) {
        p5.openElements.pop();
      }
      break;
    }
    case TAG_ID.SELECT: {
      if (p5.openElements.hasInSelectScope(TAG_ID.SELECT)) {
        p5.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
        p5._resetInsertionMode();
      }
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p5, token);
      break;
    }
    default:
  }
}
function startTagInSelectInTable(p5, token) {
  const tn2 = token.tagID;
  if (tn2 === TAG_ID.CAPTION || tn2 === TAG_ID.TABLE || tn2 === TAG_ID.TBODY || tn2 === TAG_ID.TFOOT || tn2 === TAG_ID.THEAD || tn2 === TAG_ID.TR || tn2 === TAG_ID.TD || tn2 === TAG_ID.TH) {
    p5.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
    p5._resetInsertionMode();
    p5._processStartTag(token);
  } else {
    startTagInSelect(p5, token);
  }
}
function endTagInSelectInTable(p5, token) {
  const tn2 = token.tagID;
  if (tn2 === TAG_ID.CAPTION || tn2 === TAG_ID.TABLE || tn2 === TAG_ID.TBODY || tn2 === TAG_ID.TFOOT || tn2 === TAG_ID.THEAD || tn2 === TAG_ID.TR || tn2 === TAG_ID.TD || tn2 === TAG_ID.TH) {
    if (p5.openElements.hasInTableScope(tn2)) {
      p5.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
      p5._resetInsertionMode();
      p5.onEndTag(token);
    }
  } else {
    endTagInSelect(p5, token);
  }
}
function startTagInTemplate(p5, token) {
  switch (token.tagID) {
    // First, handle tags that can start without a mode change
    case TAG_ID.BASE:
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.NOFRAMES:
    case TAG_ID.SCRIPT:
    case TAG_ID.STYLE:
    case TAG_ID.TEMPLATE:
    case TAG_ID.TITLE: {
      startTagInHead(p5, token);
      break;
    }
    // Re-process the token in the appropriate mode
    case TAG_ID.CAPTION:
    case TAG_ID.COLGROUP:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      p5.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE;
      p5.insertionMode = InsertionMode.IN_TABLE;
      startTagInTable(p5, token);
      break;
    }
    case TAG_ID.COL: {
      p5.tmplInsertionModeStack[0] = InsertionMode.IN_COLUMN_GROUP;
      p5.insertionMode = InsertionMode.IN_COLUMN_GROUP;
      startTagInColumnGroup(p5, token);
      break;
    }
    case TAG_ID.TR: {
      p5.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE_BODY;
      p5.insertionMode = InsertionMode.IN_TABLE_BODY;
      startTagInTableBody(p5, token);
      break;
    }
    case TAG_ID.TD:
    case TAG_ID.TH: {
      p5.tmplInsertionModeStack[0] = InsertionMode.IN_ROW;
      p5.insertionMode = InsertionMode.IN_ROW;
      startTagInRow(p5, token);
      break;
    }
    default: {
      p5.tmplInsertionModeStack[0] = InsertionMode.IN_BODY;
      p5.insertionMode = InsertionMode.IN_BODY;
      startTagInBody(p5, token);
    }
  }
}
function endTagInTemplate(p5, token) {
  if (token.tagID === TAG_ID.TEMPLATE) {
    templateEndTagInHead(p5, token);
  }
}
function eofInTemplate(p5, token) {
  if (p5.openElements.tmplCount > 0) {
    p5.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE);
    p5.activeFormattingElements.clearToLastMarker();
    p5.tmplInsertionModeStack.shift();
    p5._resetInsertionMode();
    p5.onEof(token);
  } else {
    stopParsing(p5, token);
  }
}
function startTagAfterBody(p5, token) {
  if (token.tagID === TAG_ID.HTML) {
    startTagInBody(p5, token);
  } else {
    tokenAfterBody(p5, token);
  }
}
function endTagAfterBody(p5, token) {
  var _a2;
  if (token.tagID === TAG_ID.HTML) {
    if (!p5.fragmentContext) {
      p5.insertionMode = InsertionMode.AFTER_AFTER_BODY;
    }
    if (p5.options.sourceCodeLocationInfo && p5.openElements.tagIDs[0] === TAG_ID.HTML) {
      p5._setEndLocation(p5.openElements.items[0], token);
      const bodyElement = p5.openElements.items[1];
      if (bodyElement && !((_a2 = p5.treeAdapter.getNodeSourceCodeLocation(bodyElement)) === null || _a2 === void 0 ? void 0 : _a2.endTag)) {
        p5._setEndLocation(bodyElement, token);
      }
    }
  } else {
    tokenAfterBody(p5, token);
  }
}
function tokenAfterBody(p5, token) {
  p5.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p5, token);
}
function startTagInFrameset(p5, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p5, token);
      break;
    }
    case TAG_ID.FRAMESET: {
      p5._insertElement(token, NS.HTML);
      break;
    }
    case TAG_ID.FRAME: {
      p5._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
      break;
    }
    case TAG_ID.NOFRAMES: {
      startTagInHead(p5, token);
      break;
    }
    default:
  }
}
function endTagInFrameset(p5, token) {
  if (token.tagID === TAG_ID.FRAMESET && !p5.openElements.isRootHtmlElementCurrent()) {
    p5.openElements.pop();
    if (!p5.fragmentContext && p5.openElements.currentTagId !== TAG_ID.FRAMESET) {
      p5.insertionMode = InsertionMode.AFTER_FRAMESET;
    }
  }
}
function startTagAfterFrameset(p5, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p5, token);
      break;
    }
    case TAG_ID.NOFRAMES: {
      startTagInHead(p5, token);
      break;
    }
    default:
  }
}
function endTagAfterFrameset(p5, token) {
  if (token.tagID === TAG_ID.HTML) {
    p5.insertionMode = InsertionMode.AFTER_AFTER_FRAMESET;
  }
}
function startTagAfterAfterBody(p5, token) {
  if (token.tagID === TAG_ID.HTML) {
    startTagInBody(p5, token);
  } else {
    tokenAfterAfterBody(p5, token);
  }
}
function tokenAfterAfterBody(p5, token) {
  p5.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p5, token);
}
function startTagAfterAfterFrameset(p5, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p5, token);
      break;
    }
    case TAG_ID.NOFRAMES: {
      startTagInHead(p5, token);
      break;
    }
    default:
  }
}
function nullCharacterInForeignContent(p5, token) {
  token.chars = REPLACEMENT_CHARACTER;
  p5._insertCharacters(token);
}
function characterInForeignContent(p5, token) {
  p5._insertCharacters(token);
  p5.framesetOk = false;
}
function popUntilHtmlOrIntegrationPoint(p5) {
  while (p5.treeAdapter.getNamespaceURI(p5.openElements.current) !== NS.HTML && p5.openElements.currentTagId !== void 0 && !p5._isIntegrationPoint(p5.openElements.currentTagId, p5.openElements.current)) {
    p5.openElements.pop();
  }
}
function startTagInForeignContent(p5, token) {
  if (causesExit(token)) {
    popUntilHtmlOrIntegrationPoint(p5);
    p5._startTagOutsideForeignContent(token);
  } else {
    const current = p5._getAdjustedCurrentElement();
    const currentNs = p5.treeAdapter.getNamespaceURI(current);
    if (currentNs === NS.MATHML) {
      adjustTokenMathMLAttrs(token);
    } else if (currentNs === NS.SVG) {
      adjustTokenSVGTagName(token);
      adjustTokenSVGAttrs(token);
    }
    adjustTokenXMLAttrs(token);
    if (token.selfClosing) {
      p5._appendElement(token, currentNs);
    } else {
      p5._insertElement(token, currentNs);
    }
    token.ackSelfClosing = true;
  }
}
function endTagInForeignContent(p5, token) {
  if (token.tagID === TAG_ID.P || token.tagID === TAG_ID.BR) {
    popUntilHtmlOrIntegrationPoint(p5);
    p5._endTagOutsideForeignContent(token);
    return;
  }
  for (let i2 = p5.openElements.stackTop; i2 > 0; i2--) {
    const element7 = p5.openElements.items[i2];
    if (p5.treeAdapter.getNamespaceURI(element7) === NS.HTML) {
      p5._endTagOutsideForeignContent(token);
      break;
    }
    const tagName = p5.treeAdapter.getTagName(element7);
    if (tagName.toLowerCase() === token.tagName) {
      token.tagName = tagName;
      p5.openElements.shortenToLength(i2);
      break;
    }
  }
}

// ../node_modules/.pnpm/entities@6.0.1/node_modules/entities/dist/esm/escape.js
var xmlCodeMap = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
var getCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt == null ? (c, index4) => (c.charCodeAt(index4) & 64512) === 55296 ? (c.charCodeAt(index4) - 55296) * 1024 + c.charCodeAt(index4 + 1) - 56320 + 65536 : c.charCodeAt(index4) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (input2, index4) => input2.codePointAt(index4)
  )
);
function getEscaper(regex, map6) {
  return function escape2(data) {
    let match;
    let lastIndex = 0;
    let result = "";
    while (match = regex.exec(data)) {
      if (lastIndex !== match.index) {
        result += data.substring(lastIndex, match.index);
      }
      result += map6.get(match[0].charCodeAt(0));
      lastIndex = match.index + 1;
    }
    return result + data.substring(lastIndex);
  };
}
var escapeUTF8 = getEscaper(/["&'<>]/g, xmlCodeMap);
var escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));

// ../node_modules/.pnpm/parse5@7.3.0/node_modules/parse5/dist/serializer/index.js
var VOID_ELEMENTS = /* @__PURE__ */ new Set([
  TAG_NAMES.AREA,
  TAG_NAMES.BASE,
  TAG_NAMES.BASEFONT,
  TAG_NAMES.BGSOUND,
  TAG_NAMES.BR,
  TAG_NAMES.COL,
  TAG_NAMES.EMBED,
  TAG_NAMES.FRAME,
  TAG_NAMES.HR,
  TAG_NAMES.IMG,
  TAG_NAMES.INPUT,
  TAG_NAMES.KEYGEN,
  TAG_NAMES.LINK,
  TAG_NAMES.META,
  TAG_NAMES.PARAM,
  TAG_NAMES.SOURCE,
  TAG_NAMES.TRACK,
  TAG_NAMES.WBR
]);

// ../node_modules/.pnpm/parse5@7.3.0/node_modules/parse5/dist/index.js
function parse4(html7, options) {
  return Parser.parse(html7, options);
}
function parseFragment(fragmentContext, html7, options) {
  if (typeof fragmentContext === "string") {
    options = html7;
    html7 = fragmentContext;
    fragmentContext = null;
  }
  const parser = Parser.getFragmentParser(fragmentContext, options);
  parser.tokenizer.write(html7, true);
  return parser.getFragment();
}

// ../node_modules/.pnpm/unist-util-stringify-position@4.0.0/node_modules/unist-util-stringify-position/lib/index.js
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position2(value.position);
  }
  if ("start" in value || "end" in value) {
    return position2(value);
  }
  if ("line" in value || "column" in value) {
    return point2(value);
  }
  return "";
}
function point2(point5) {
  return index3(point5 && point5.line) + ":" + index3(point5 && point5.column);
}
function position2(pos) {
  return point2(pos && pos.start) + "-" + point2(pos && pos.end);
}
function index3(value) {
  return value && typeof value === "number" ? value : 1;
}

// ../node_modules/.pnpm/vfile-message@4.0.3/node_modules/vfile-message/lib/index.js
var VFileMessage = class extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(causeOrReason, optionsOrParentOrPlace, origin) {
    super();
    if (typeof optionsOrParentOrPlace === "string") {
      origin = optionsOrParentOrPlace;
      optionsOrParentOrPlace = void 0;
    }
    let reason = "";
    let options = {};
    let legacyCause = false;
    if (optionsOrParentOrPlace) {
      if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("type" in optionsOrParentOrPlace) {
        options = {
          ancestors: [optionsOrParentOrPlace],
          place: optionsOrParentOrPlace.position
        };
      } else {
        options = { ...optionsOrParentOrPlace };
      }
    }
    if (typeof causeOrReason === "string") {
      reason = causeOrReason;
    } else if (!options.cause && causeOrReason) {
      legacyCause = true;
      reason = causeOrReason.message;
      options.cause = causeOrReason;
    }
    if (!options.ruleId && !options.source && typeof origin === "string") {
      const index4 = origin.indexOf(":");
      if (index4 === -1) {
        options.ruleId = origin;
      } else {
        options.source = origin.slice(0, index4);
        options.ruleId = origin.slice(index4 + 1);
      }
    }
    if (!options.place && options.ancestors && options.ancestors) {
      const parent = options.ancestors[options.ancestors.length - 1];
      if (parent) {
        options.place = parent.position;
      }
    }
    const start = options.place && "start" in options.place ? options.place.start : options.place;
    this.ancestors = options.ancestors || void 0;
    this.cause = options.cause || void 0;
    this.column = start ? start.column : void 0;
    this.fatal = void 0;
    this.file = "";
    this.message = reason;
    this.line = start ? start.line : void 0;
    this.name = stringifyPosition(options.place) || "1:1";
    this.place = options.place || void 0;
    this.reason = this.message;
    this.ruleId = options.ruleId || void 0;
    this.source = options.source || void 0;
    this.stack = legacyCause && options.cause && typeof options.cause.stack === "string" ? options.cause.stack : "";
    this.actual = void 0;
    this.expected = void 0;
    this.note = void 0;
    this.url = void 0;
  }
};
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.column = void 0;
VFileMessage.prototype.line = void 0;
VFileMessage.prototype.ancestors = void 0;
VFileMessage.prototype.cause = void 0;
VFileMessage.prototype.fatal = void 0;
VFileMessage.prototype.place = void 0;
VFileMessage.prototype.ruleId = void 0;
VFileMessage.prototype.source = void 0;

// ../node_modules/.pnpm/vfile@6.0.3/node_modules/vfile/lib/minpath.browser.js
var minpath = { basename, dirname, extname, join, sep: "/" };
function basename(path2, extname2) {
  if (extname2 !== void 0 && typeof extname2 !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath(path2);
  let start = 0;
  let end = -1;
  let index4 = path2.length;
  let seenNonSlash;
  if (extname2 === void 0 || extname2.length === 0 || extname2.length > path2.length) {
    while (index4--) {
      if (path2.codePointAt(index4) === 47) {
        if (seenNonSlash) {
          start = index4 + 1;
          break;
        }
      } else if (end < 0) {
        seenNonSlash = true;
        end = index4 + 1;
      }
    }
    return end < 0 ? "" : path2.slice(start, end);
  }
  if (extname2 === path2) {
    return "";
  }
  let firstNonSlashEnd = -1;
  let extnameIndex = extname2.length - 1;
  while (index4--) {
    if (path2.codePointAt(index4) === 47) {
      if (seenNonSlash) {
        start = index4 + 1;
        break;
      }
    } else {
      if (firstNonSlashEnd < 0) {
        seenNonSlash = true;
        firstNonSlashEnd = index4 + 1;
      }
      if (extnameIndex > -1) {
        if (path2.codePointAt(index4) === extname2.codePointAt(extnameIndex--)) {
          if (extnameIndex < 0) {
            end = index4;
          }
        } else {
          extnameIndex = -1;
          end = firstNonSlashEnd;
        }
      }
    }
  }
  if (start === end) {
    end = firstNonSlashEnd;
  } else if (end < 0) {
    end = path2.length;
  }
  return path2.slice(start, end);
}
function dirname(path2) {
  assertPath(path2);
  if (path2.length === 0) {
    return ".";
  }
  let end = -1;
  let index4 = path2.length;
  let unmatchedSlash;
  while (--index4) {
    if (path2.codePointAt(index4) === 47) {
      if (unmatchedSlash) {
        end = index4;
        break;
      }
    } else if (!unmatchedSlash) {
      unmatchedSlash = true;
    }
  }
  return end < 0 ? path2.codePointAt(0) === 47 ? "/" : "." : end === 1 && path2.codePointAt(0) === 47 ? "//" : path2.slice(0, end);
}
function extname(path2) {
  assertPath(path2);
  let index4 = path2.length;
  let end = -1;
  let startPart = 0;
  let startDot = -1;
  let preDotState = 0;
  let unmatchedSlash;
  while (index4--) {
    const code5 = path2.codePointAt(index4);
    if (code5 === 47) {
      if (unmatchedSlash) {
        startPart = index4 + 1;
        break;
      }
      continue;
    }
    if (end < 0) {
      unmatchedSlash = true;
      end = index4 + 1;
    }
    if (code5 === 46) {
      if (startDot < 0) {
        startDot = index4;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      preDotState = -1;
    }
  }
  if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
  preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path2.slice(startDot, end);
}
function join(...segments) {
  let index4 = -1;
  let joined;
  while (++index4 < segments.length) {
    assertPath(segments[index4]);
    if (segments[index4]) {
      joined = joined === void 0 ? segments[index4] : joined + "/" + segments[index4];
    }
  }
  return joined === void 0 ? "." : normalize2(joined);
}
function normalize2(path2) {
  assertPath(path2);
  const absolute = path2.codePointAt(0) === 47;
  let value = normalizeString(path2, !absolute);
  if (value.length === 0 && !absolute) {
    value = ".";
  }
  if (value.length > 0 && path2.codePointAt(path2.length - 1) === 47) {
    value += "/";
  }
  return absolute ? "/" + value : value;
}
function normalizeString(path2, allowAboveRoot) {
  let result = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let index4 = -1;
  let code5;
  let lastSlashIndex;
  while (++index4 <= path2.length) {
    if (index4 < path2.length) {
      code5 = path2.codePointAt(index4);
    } else if (code5 === 47) {
      break;
    } else {
      code5 = 47;
    }
    if (code5 === 47) {
      if (lastSlash === index4 - 1 || dots === 1) {
      } else if (lastSlash !== index4 - 1 && dots === 2) {
        if (result.length < 2 || lastSegmentLength !== 2 || result.codePointAt(result.length - 1) !== 46 || result.codePointAt(result.length - 2) !== 46) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf("/");
            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = "";
                lastSegmentLength = 0;
              } else {
                result = result.slice(0, lastSlashIndex);
                lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
              }
              lastSlash = index4;
              dots = 0;
              continue;
            }
          } else if (result.length > 0) {
            result = "";
            lastSegmentLength = 0;
            lastSlash = index4;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          result = result.length > 0 ? result + "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (result.length > 0) {
          result += "/" + path2.slice(lastSlash + 1, index4);
        } else {
          result = path2.slice(lastSlash + 1, index4);
        }
        lastSegmentLength = index4 - lastSlash - 1;
      }
      lastSlash = index4;
      dots = 0;
    } else if (code5 === 46 && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }
  return result;
}
function assertPath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(path2)
    );
  }
}

// ../node_modules/.pnpm/vfile@6.0.3/node_modules/vfile/lib/minproc.browser.js
var minproc = { cwd };
function cwd() {
  return "/";
}

// ../node_modules/.pnpm/vfile@6.0.3/node_modules/vfile/lib/minurl.shared.js
function isUrl(fileUrlOrPath) {
  return Boolean(
    fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && // @ts-expect-error: indexing is fine.
    fileUrlOrPath.auth === void 0
  );
}

// ../node_modules/.pnpm/vfile@6.0.3/node_modules/vfile/lib/minurl.browser.js
function urlToPath(path2) {
  if (typeof path2 === "string") {
    path2 = new URL(path2);
  } else if (!isUrl(path2)) {
    const error2 = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
    );
    error2.code = "ERR_INVALID_ARG_TYPE";
    throw error2;
  }
  if (path2.protocol !== "file:") {
    const error2 = new TypeError("The URL must be of scheme file");
    error2.code = "ERR_INVALID_URL_SCHEME";
    throw error2;
  }
  return getPathFromURLPosix(path2);
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    const error2 = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    error2.code = "ERR_INVALID_FILE_URL_HOST";
    throw error2;
  }
  const pathname = url.pathname;
  let index4 = -1;
  while (++index4 < pathname.length) {
    if (pathname.codePointAt(index4) === 37 && pathname.codePointAt(index4 + 1) === 50) {
      const third = pathname.codePointAt(index4 + 2);
      if (third === 70 || third === 102) {
        const error2 = new TypeError(
          "File URL path must not include encoded / characters"
        );
        error2.code = "ERR_INVALID_FILE_URL_PATH";
        throw error2;
      }
    }
  }
  return decodeURIComponent(pathname);
}

// ../node_modules/.pnpm/vfile@6.0.3/node_modules/vfile/lib/index.js
var order = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
var VFile = class {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(value) {
    let options;
    if (!value) {
      options = {};
    } else if (isUrl(value)) {
      options = { path: value };
    } else if (typeof value === "string" || isUint8Array(value)) {
      options = { value };
    } else {
      options = value;
    }
    this.cwd = "cwd" in options ? "" : minproc.cwd();
    this.data = {};
    this.history = [];
    this.messages = [];
    this.value;
    this.map;
    this.result;
    this.stored;
    let index4 = -1;
    while (++index4 < order.length) {
      const field2 = order[index4];
      if (field2 in options && options[field2] !== void 0 && options[field2] !== null) {
        this[field2] = field2 === "history" ? [...options[field2]] : options[field2];
      }
    }
    let field;
    for (field in options) {
      if (!order.includes(field)) {
        this[field] = options[field];
      }
    }
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path === "string" ? minpath.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(basename2) {
    assertNonEmpty(basename2, "basename");
    assertPart(basename2, "basename");
    this.path = minpath.join(this.dirname || "", basename2);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path === "string" ? minpath.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(dirname2) {
    assertPath2(this.basename, "dirname");
    this.path = minpath.join(dirname2 || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path === "string" ? minpath.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(extname2) {
    assertPart(extname2, "extname");
    assertPath2(this.dirname, "extname");
    if (extname2) {
      if (extname2.codePointAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname2.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = minpath.join(this.dirname, this.stem + (extname2 || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(path2) {
    if (isUrl(path2)) {
      path2 = urlToPath(path2);
    }
    assertNonEmpty(path2, "path");
    if (this.path !== path2) {
      this.history.push(path2);
    }
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path === "string" ? minpath.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(stem) {
    assertNonEmpty(stem, "stem");
    assertPart(stem, "stem");
    this.path = minpath.join(this.dirname || "", stem + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message.fatal = true;
    throw message;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message.fatal = void 0;
    return message;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = new VFileMessage(
      // @ts-expect-error: the overloads are fine.
      causeOrReason,
      optionsOrParentOrPlace,
      origin
    );
    if (this.path) {
      message.name = this.path + ":" + message.name;
      message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(encoding) {
    if (this.value === void 0) {
      return "";
    }
    if (typeof this.value === "string") {
      return this.value;
    }
    const decoder = new TextDecoder(encoding || void 0);
    return decoder.decode(this.value);
  }
};
function assertPart(part, name) {
  if (part && part.includes(minpath.sep)) {
    throw new Error(
      "`" + name + "` cannot be a path: did not expect `" + minpath.sep + "`"
    );
  }
}
function assertNonEmpty(part, name) {
  if (!part) {
    throw new Error("`" + name + "` cannot be empty");
  }
}
function assertPath2(path2, name) {
  if (!path2) {
    throw new Error("Setting `" + name + "` requires `path` to be set too");
  }
}
function isUint8Array(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}

// ../node_modules/.pnpm/hast-util-from-html@2.0.3/node_modules/hast-util-from-html/lib/errors.js
var errors = {
  /** @type {ErrorInfo} */
  abandonedHeadElementChild: {
    reason: "Unexpected metadata element after head",
    description: "Unexpected element after head. Expected the element before `</head>`",
    url: false
  },
  /** @type {ErrorInfo} */
  abruptClosingOfEmptyComment: {
    reason: "Unexpected abruptly closed empty comment",
    description: "Unexpected `>` or `->`. Expected `-->` to close comments"
  },
  /** @type {ErrorInfo} */
  abruptDoctypePublicIdentifier: {
    reason: "Unexpected abruptly closed public identifier",
    description: "Unexpected `>`. Expected a closing `\"` or `'` after the public identifier"
  },
  /** @type {ErrorInfo} */
  abruptDoctypeSystemIdentifier: {
    reason: "Unexpected abruptly closed system identifier",
    description: "Unexpected `>`. Expected a closing `\"` or `'` after the identifier identifier"
  },
  /** @type {ErrorInfo} */
  absenceOfDigitsInNumericCharacterReference: {
    reason: "Unexpected non-digit at start of numeric character reference",
    description: "Unexpected `%c`. Expected `[0-9]` for decimal references or `[0-9a-fA-F]` for hexadecimal references"
  },
  /** @type {ErrorInfo} */
  cdataInHtmlContent: {
    reason: "Unexpected CDATA section in HTML",
    description: "Unexpected `<![CDATA[` in HTML. Remove it, use a comment, or encode special characters instead"
  },
  /** @type {ErrorInfo} */
  characterReferenceOutsideUnicodeRange: {
    reason: "Unexpected too big numeric character reference",
    description: "Unexpectedly high character reference. Expected character references to be at most hexadecimal 10ffff (or decimal 1114111)"
  },
  /** @type {ErrorInfo} */
  closingOfElementWithOpenChildElements: {
    reason: "Unexpected closing tag with open child elements",
    description: "Unexpectedly closing tag. Expected other tags to be closed first",
    url: false
  },
  /** @type {ErrorInfo} */
  controlCharacterInInputStream: {
    reason: "Unexpected control character",
    description: "Unexpected control character `%x`. Expected a non-control code point, 0x00, or ASCII whitespace"
  },
  /** @type {ErrorInfo} */
  controlCharacterReference: {
    reason: "Unexpected control character reference",
    description: "Unexpectedly control character in reference. Expected a non-control code point, 0x00, or ASCII whitespace"
  },
  /** @type {ErrorInfo} */
  disallowedContentInNoscriptInHead: {
    reason: "Disallowed content inside `<noscript>` in `<head>`",
    description: "Unexpected text character `%c`. Only use text in `<noscript>`s in `<body>`",
    url: false
  },
  /** @type {ErrorInfo} */
  duplicateAttribute: {
    reason: "Unexpected duplicate attribute",
    description: "Unexpectedly double attribute. Expected attributes to occur only once"
  },
  /** @type {ErrorInfo} */
  endTagWithAttributes: {
    reason: "Unexpected attribute on closing tag",
    description: "Unexpected attribute. Expected `>` instead"
  },
  /** @type {ErrorInfo} */
  endTagWithTrailingSolidus: {
    reason: "Unexpected slash at end of closing tag",
    description: "Unexpected `%c-1`. Expected `>` instead"
  },
  /** @type {ErrorInfo} */
  endTagWithoutMatchingOpenElement: {
    reason: "Unexpected unopened end tag",
    description: "Unexpected end tag. Expected no end tag or another end tag",
    url: false
  },
  /** @type {ErrorInfo} */
  eofBeforeTagName: {
    reason: "Unexpected end of file",
    description: "Unexpected end of file. Expected tag name instead"
  },
  /** @type {ErrorInfo} */
  eofInCdata: {
    reason: "Unexpected end of file in CDATA",
    description: "Unexpected end of file. Expected `]]>` to close the CDATA"
  },
  /** @type {ErrorInfo} */
  eofInComment: {
    reason: "Unexpected end of file in comment",
    description: "Unexpected end of file. Expected `-->` to close the comment"
  },
  /** @type {ErrorInfo} */
  eofInDoctype: {
    reason: "Unexpected end of file in doctype",
    description: "Unexpected end of file. Expected a valid doctype (such as `<!doctype html>`)"
  },
  /** @type {ErrorInfo} */
  eofInElementThatCanContainOnlyText: {
    reason: "Unexpected end of file in element that can only contain text",
    description: "Unexpected end of file. Expected text or a closing tag",
    url: false
  },
  /** @type {ErrorInfo} */
  eofInScriptHtmlCommentLikeText: {
    reason: "Unexpected end of file in comment inside script",
    description: "Unexpected end of file. Expected `-->` to close the comment"
  },
  /** @type {ErrorInfo} */
  eofInTag: {
    reason: "Unexpected end of file in tag",
    description: "Unexpected end of file. Expected `>` to close the tag"
  },
  /** @type {ErrorInfo} */
  incorrectlyClosedComment: {
    reason: "Incorrectly closed comment",
    description: "Unexpected `%c-1`. Expected `-->` to close the comment"
  },
  /** @type {ErrorInfo} */
  incorrectlyOpenedComment: {
    reason: "Incorrectly opened comment",
    description: "Unexpected `%c`. Expected `<!--` to open the comment"
  },
  /** @type {ErrorInfo} */
  invalidCharacterSequenceAfterDoctypeName: {
    reason: "Invalid sequence after doctype name",
    description: "Unexpected sequence at `%c`. Expected `public` or `system`"
  },
  /** @type {ErrorInfo} */
  invalidFirstCharacterOfTagName: {
    reason: "Invalid first character in tag name",
    description: "Unexpected `%c`. Expected an ASCII letter instead"
  },
  /** @type {ErrorInfo} */
  misplacedDoctype: {
    reason: "Misplaced doctype",
    description: "Unexpected doctype. Expected doctype before head",
    url: false
  },
  /** @type {ErrorInfo} */
  misplacedStartTagForHeadElement: {
    reason: "Misplaced `<head>` start tag",
    description: "Unexpected start tag `<head>`. Expected `<head>` directly after doctype",
    url: false
  },
  /** @type {ErrorInfo} */
  missingAttributeValue: {
    reason: "Missing attribute value",
    description: "Unexpected `%c-1`. Expected an attribute value or no `%c-1` instead"
  },
  /** @type {ErrorInfo} */
  missingDoctype: {
    reason: "Missing doctype before other content",
    description: "Expected a `<!doctype html>` before anything else",
    url: false
  },
  /** @type {ErrorInfo} */
  missingDoctypeName: {
    reason: "Missing doctype name",
    description: "Unexpected doctype end at `%c`. Expected `html` instead"
  },
  /** @type {ErrorInfo} */
  missingDoctypePublicIdentifier: {
    reason: "Missing public identifier in doctype",
    description: "Unexpected `%c`. Expected identifier for `public` instead"
  },
  /** @type {ErrorInfo} */
  missingDoctypeSystemIdentifier: {
    reason: "Missing system identifier in doctype",
    description: 'Unexpected `%c`. Expected identifier for `system` instead (suggested: `"about:legacy-compat"`)'
  },
  /** @type {ErrorInfo} */
  missingEndTagName: {
    reason: "Missing name in end tag",
    description: "Unexpected `%c`. Expected an ASCII letter instead"
  },
  /** @type {ErrorInfo} */
  missingQuoteBeforeDoctypePublicIdentifier: {
    reason: "Missing quote before public identifier in doctype",
    description: "Unexpected `%c`. Expected `\"` or `'` instead"
  },
  /** @type {ErrorInfo} */
  missingQuoteBeforeDoctypeSystemIdentifier: {
    reason: "Missing quote before system identifier in doctype",
    description: "Unexpected `%c`. Expected `\"` or `'` instead"
  },
  /** @type {ErrorInfo} */
  missingSemicolonAfterCharacterReference: {
    reason: "Missing semicolon after character reference",
    description: "Unexpected `%c`. Expected `;` instead"
  },
  /** @type {ErrorInfo} */
  missingWhitespaceAfterDoctypePublicKeyword: {
    reason: "Missing whitespace after public identifier in doctype",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  /** @type {ErrorInfo} */
  missingWhitespaceAfterDoctypeSystemKeyword: {
    reason: "Missing whitespace after system identifier in doctype",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  /** @type {ErrorInfo} */
  missingWhitespaceBeforeDoctypeName: {
    reason: "Missing whitespace before doctype name",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  /** @type {ErrorInfo} */
  missingWhitespaceBetweenAttributes: {
    reason: "Missing whitespace between attributes",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  /** @type {ErrorInfo} */
  missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers: {
    reason: "Missing whitespace between public and system identifiers in doctype",
    description: "Unexpected `%c`. Expected ASCII whitespace instead"
  },
  /** @type {ErrorInfo} */
  nestedComment: {
    reason: "Unexpected nested comment",
    description: "Unexpected `<!--`. Expected `-->`"
  },
  /** @type {ErrorInfo} */
  nestedNoscriptInHead: {
    reason: "Unexpected nested `<noscript>` in `<head>`",
    description: "Unexpected `<noscript>`. Expected a closing tag or a meta element",
    url: false
  },
  /** @type {ErrorInfo} */
  nonConformingDoctype: {
    reason: "Unexpected non-conforming doctype declaration",
    description: 'Expected `<!doctype html>` or `<!doctype html system "about:legacy-compat">`',
    url: false
  },
  /** @type {ErrorInfo} */
  nonVoidHtmlElementStartTagWithTrailingSolidus: {
    reason: "Unexpected trailing slash on start tag of non-void element",
    description: "Unexpected `/`. Expected `>` instead"
  },
  /** @type {ErrorInfo} */
  noncharacterCharacterReference: {
    reason: "Unexpected noncharacter code point referenced by character reference",
    description: "Unexpected code point. Do not use noncharacters in HTML"
  },
  /** @type {ErrorInfo} */
  noncharacterInInputStream: {
    reason: "Unexpected noncharacter character",
    description: "Unexpected code point `%x`. Do not use noncharacters in HTML"
  },
  /** @type {ErrorInfo} */
  nullCharacterReference: {
    reason: "Unexpected NULL character referenced by character reference",
    description: "Unexpected code point. Do not use NULL characters in HTML"
  },
  /** @type {ErrorInfo} */
  openElementsLeftAfterEof: {
    reason: "Unexpected end of file",
    description: "Unexpected end of file. Expected closing tag instead",
    url: false
  },
  /** @type {ErrorInfo} */
  surrogateCharacterReference: {
    reason: "Unexpected surrogate character referenced by character reference",
    description: "Unexpected code point. Do not use lone surrogate characters in HTML"
  },
  /** @type {ErrorInfo} */
  surrogateInInputStream: {
    reason: "Unexpected surrogate character",
    description: "Unexpected code point `%x`. Do not use lone surrogate characters in HTML"
  },
  /** @type {ErrorInfo} */
  unexpectedCharacterAfterDoctypeSystemIdentifier: {
    reason: "Invalid character after system identifier in doctype",
    description: "Unexpected character at `%c`. Expected `>`"
  },
  /** @type {ErrorInfo} */
  unexpectedCharacterInAttributeName: {
    reason: "Unexpected character in attribute name",
    description: "Unexpected `%c`. Expected whitespace, `/`, `>`, `=`, or probably an ASCII letter"
  },
  /** @type {ErrorInfo} */
  unexpectedCharacterInUnquotedAttributeValue: {
    reason: "Unexpected character in unquoted attribute value",
    description: "Unexpected `%c`. Quote the attribute value to include it"
  },
  /** @type {ErrorInfo} */
  unexpectedEqualsSignBeforeAttributeName: {
    reason: "Unexpected equals sign before attribute name",
    description: "Unexpected `%c`. Add an attribute name before it"
  },
  /** @type {ErrorInfo} */
  unexpectedNullCharacter: {
    reason: "Unexpected NULL character",
    description: "Unexpected code point `%x`. Do not use NULL characters in HTML"
  },
  /** @type {ErrorInfo} */
  unexpectedQuestionMarkInsteadOfTagName: {
    reason: "Unexpected question mark instead of tag name",
    description: "Unexpected `%c`. Expected an ASCII letter instead"
  },
  /** @type {ErrorInfo} */
  unexpectedSolidusInTag: {
    reason: "Unexpected slash in tag",
    description: "Unexpected `%c-1`. Expected it followed by `>` or in a quoted attribute value"
  },
  /** @type {ErrorInfo} */
  unknownNamedCharacterReference: {
    reason: "Unexpected unknown named character reference",
    description: "Unexpected character reference. Expected known named character references"
  }
};

// ../node_modules/.pnpm/hast-util-from-html@2.0.3/node_modules/hast-util-from-html/lib/index.js
var base = "https://html.spec.whatwg.org/multipage/parsing.html#parse-error-";
var dashToCamelRe = /-[a-z]/g;
var formatCRe = /%c(?:([-+])(\d+))?/g;
var formatXRe = /%x/g;
var fatalities = { 2: true, 1: false, 0: null };
var emptyOptions = {};
function fromHtml(value, options) {
  const settings = options || emptyOptions;
  const onerror = settings.onerror;
  const file = value instanceof VFile ? value : new VFile(value);
  const parseFunction = settings.fragment ? parseFragment : parse4;
  const document4 = String(file);
  const p5Document = parseFunction(document4, {
    sourceCodeLocationInfo: true,
    // Note `parse5` types currently do not allow `undefined`.
    onParseError: settings.onerror ? internalOnerror : null,
    scriptingEnabled: false
  });
  return (
    /** @type {Root} */
    fromParse5(p5Document, {
      file,
      space: settings.space,
      verbose: settings.verbose
    })
  );
  function internalOnerror(error2) {
    const code5 = error2.code;
    const name = camelcase2(code5);
    const setting = settings[name];
    const config = setting === null || setting === void 0 ? true : setting;
    const level = typeof config === "number" ? config : config ? 1 : 0;
    if (level) {
      const info = errors[name];
      ok(info, "expected known error from `parse5`");
      const message = new VFileMessage(format(info.reason), {
        place: {
          start: {
            line: error2.startLine,
            column: error2.startCol,
            offset: error2.startOffset
          },
          end: {
            line: error2.endLine,
            column: error2.endCol,
            offset: error2.endOffset
          }
        },
        ruleId: code5,
        source: "hast-util-from-html"
      });
      if (file.path) {
        message.file = file.path;
        message.name = file.path + ":" + message.name;
      }
      message.fatal = fatalities[level];
      message.note = format(info.description);
      message.url = info.url === false ? void 0 : base + code5;
      ok(onerror, "`internalOnerror` is not passed if `onerror` is not set");
      onerror(message);
    }
    function format(value2) {
      return value2.replace(formatCRe, formatC).replace(formatXRe, formatX);
      function formatC(_, $1, $22) {
        const offset4 = ($22 ? Number.parseInt($22, 10) : 0) * ($1 === "-" ? -1 : 1);
        const char = document4.charAt(error2.startOffset + offset4);
        return visualizeCharacter(char);
      }
      function formatX() {
        return visualizeCharacterCode(document4.charCodeAt(error2.startOffset));
      }
    }
  }
}
function camelcase2(value) {
  return (
    /** @type {ErrorCode} */
    value.replace(dashToCamelRe, dashToCamel)
  );
}
function dashToCamel($0) {
  return $0.charAt(1).toUpperCase();
}
function visualizeCharacter(char) {
  return char === "`" ? "` ` `" : char;
}
function visualizeCharacterCode(charCode) {
  return "0x" + charCode.toString(16).toUpperCase();
}

// ../node_modules/.pnpm/rehype-parse@9.0.1/node_modules/rehype-parse/lib/index.js
function rehypeParse(options) {
  const self2 = this;
  const { emitParseErrors, ...settings } = { ...self2.data("settings"), ...options };
  self2.parser = parser;
  function parser(document4, file) {
    return fromHtml(document4, {
      ...settings,
      onerror: emitParseErrors ? function(message) {
        if (file.path) {
          message.name = file.path + ":" + message.name;
          message.file = file.path;
        }
        file.messages.push(message);
      } : void 0
    });
  }
}

// ../node_modules/.pnpm/@ungap+structured-clone@1.3.0/node_modules/@ungap/structured-clone/esm/types.js
var VOID = -1;
var PRIMITIVE = 0;
var ARRAY = 1;
var OBJECT = 2;
var DATE = 3;
var REGEXP = 4;
var MAP = 5;
var SET = 6;
var ERROR = 7;
var BIGINT = 8;

// ../node_modules/.pnpm/@ungap+structured-clone@1.3.0/node_modules/@ungap/structured-clone/esm/deserialize.js
var env = typeof self === "object" ? self : globalThis;
var deserializer = ($3, _) => {
  const as2 = (out, index4) => {
    $3.set(index4, out);
    return out;
  };
  const unpair = (index4) => {
    if ($3.has(index4))
      return $3.get(index4);
    const [type, value] = _[index4];
    switch (type) {
      case PRIMITIVE:
      case VOID:
        return as2(value, index4);
      case ARRAY: {
        const arr = as2([], index4);
        for (const index5 of value)
          arr.push(unpair(index5));
        return arr;
      }
      case OBJECT: {
        const object = as2({}, index4);
        for (const [key2, index5] of value)
          object[unpair(key2)] = unpair(index5);
        return object;
      }
      case DATE:
        return as2(new Date(value), index4);
      case REGEXP: {
        const { source, flags } = value;
        return as2(new RegExp(source, flags), index4);
      }
      case MAP: {
        const map6 = as2(/* @__PURE__ */ new Map(), index4);
        for (const [key2, index5] of value)
          map6.set(unpair(key2), unpair(index5));
        return map6;
      }
      case SET: {
        const set = as2(/* @__PURE__ */ new Set(), index4);
        for (const index5 of value)
          set.add(unpair(index5));
        return set;
      }
      case ERROR: {
        const { name, message } = value;
        return as2(new env[name](message), index4);
      }
      case BIGINT:
        return as2(BigInt(value), index4);
      case "BigInt":
        return as2(Object(BigInt(value)), index4);
      case "ArrayBuffer":
        return as2(new Uint8Array(value).buffer, value);
      case "DataView": {
        const { buffer } = new Uint8Array(value);
        return as2(new DataView(buffer), value);
      }
    }
    return as2(new env[type](value), index4);
  };
  return unpair;
};
var deserialize = (serialized) => deserializer(/* @__PURE__ */ new Map(), serialized)(0);

// ../node_modules/.pnpm/@ungap+structured-clone@1.3.0/node_modules/@ungap/structured-clone/esm/serialize.js
var EMPTY = "";
var { toString } = {};
var { keys: keys2 } = Object;
var typeOf = (value) => {
  const type = typeof value;
  if (type !== "object" || !value)
    return [PRIMITIVE, type];
  const asString = toString.call(value).slice(8, -1);
  switch (asString) {
    case "Array":
      return [ARRAY, EMPTY];
    case "Object":
      return [OBJECT, EMPTY];
    case "Date":
      return [DATE, EMPTY];
    case "RegExp":
      return [REGEXP, EMPTY];
    case "Map":
      return [MAP, EMPTY];
    case "Set":
      return [SET, EMPTY];
    case "DataView":
      return [ARRAY, asString];
  }
  if (asString.includes("Array"))
    return [ARRAY, asString];
  if (asString.includes("Error"))
    return [ERROR, asString];
  return [OBJECT, asString];
};
var shouldSkip = ([TYPE, type]) => TYPE === PRIMITIVE && (type === "function" || type === "symbol");
var serializer = (strict, json, $3, _) => {
  const as2 = (out, value) => {
    const index4 = _.push(out) - 1;
    $3.set(value, index4);
    return index4;
  };
  const pair = (value) => {
    if ($3.has(value))
      return $3.get(value);
    let [TYPE, type] = typeOf(value);
    switch (TYPE) {
      case PRIMITIVE: {
        let entry = value;
        switch (type) {
          case "bigint":
            TYPE = BIGINT;
            entry = value.toString();
            break;
          case "function":
          case "symbol":
            if (strict)
              throw new TypeError("unable to serialize " + type);
            entry = null;
            break;
          case "undefined":
            return as2([VOID], value);
        }
        return as2([TYPE, entry], value);
      }
      case ARRAY: {
        if (type) {
          let spread = value;
          if (type === "DataView") {
            spread = new Uint8Array(value.buffer);
          } else if (type === "ArrayBuffer") {
            spread = new Uint8Array(value);
          }
          return as2([type, [...spread]], value);
        }
        const arr = [];
        const index4 = as2([TYPE, arr], value);
        for (const entry of value)
          arr.push(pair(entry));
        return index4;
      }
      case OBJECT: {
        if (type) {
          switch (type) {
            case "BigInt":
              return as2([type, value.toString()], value);
            case "Boolean":
            case "Number":
            case "String":
              return as2([type, value.valueOf()], value);
          }
        }
        if (json && "toJSON" in value)
          return pair(value.toJSON());
        const entries = [];
        const index4 = as2([TYPE, entries], value);
        for (const key2 of keys2(value)) {
          if (strict || !shouldSkip(typeOf(value[key2])))
            entries.push([pair(key2), pair(value[key2])]);
        }
        return index4;
      }
      case DATE:
        return as2([TYPE, value.toISOString()], value);
      case REGEXP: {
        const { source, flags } = value;
        return as2([TYPE, { source, flags }], value);
      }
      case MAP: {
        const entries = [];
        const index4 = as2([TYPE, entries], value);
        for (const [key2, entry] of value) {
          if (strict || !(shouldSkip(typeOf(key2)) || shouldSkip(typeOf(entry))))
            entries.push([pair(key2), pair(entry)]);
        }
        return index4;
      }
      case SET: {
        const entries = [];
        const index4 = as2([TYPE, entries], value);
        for (const entry of value) {
          if (strict || !shouldSkip(typeOf(entry)))
            entries.push(pair(entry));
        }
        return index4;
      }
    }
    const { message } = value;
    return as2([TYPE, { name: type, message }], value);
  };
  return pair;
};
var serialize2 = (value, { json, lossy } = {}) => {
  const _ = [];
  return serializer(!(json || lossy), !!json, /* @__PURE__ */ new Map(), _)(value), _;
};

// ../node_modules/.pnpm/@ungap+structured-clone@1.3.0/node_modules/@ungap/structured-clone/esm/index.js
var esm_default = typeof structuredClone === "function" ? (
  /* c8 ignore start */
  (any2, options) => options && ("json" in options || "lossy" in options) ? deserialize(serialize2(any2, options)) : structuredClone(any2)
) : (any2, options) => deserialize(serialize2(any2, options));

// ../node_modules/.pnpm/hast-util-is-element@3.0.0/node_modules/hast-util-is-element/lib/index.js
var isElement2 = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends TestFunction>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &
   *   (<Condition extends string>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &
   *   ((element?: null | undefined) => false) &
   *   ((element: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &
   *   ((element: unknown, test?: Test, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => boolean)
   * )}
   */
  /**
   * @param {unknown} [element]
   * @param {Test | undefined} [test]
   * @param {number | null | undefined} [index]
   * @param {Parents | null | undefined} [parent]
   * @param {unknown} [context]
   * @returns {boolean}
   */
  // eslint-disable-next-line max-params
  (function(element7, test, index4, parent, context) {
    const check = convertElement(test);
    if (index4 !== null && index4 !== void 0 && (typeof index4 !== "number" || index4 < 0 || index4 === Number.POSITIVE_INFINITY)) {
      throw new Error("Expected positive finite `index`");
    }
    if (parent !== null && parent !== void 0 && (!parent.type || !parent.children)) {
      throw new Error("Expected valid `parent`");
    }
    if ((index4 === null || index4 === void 0) !== (parent === null || parent === void 0)) {
      throw new Error("Expected both `index` and `parent`");
    }
    return looksLikeAnElement(element7) ? check.call(context, element7, index4, parent) : false;
  })
);
var convertElement = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends TestFunction>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &
   *   (<Condition extends string>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &
   *   ((test?: null | undefined) => (element?: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test | null | undefined} [test]
   * @returns {Check}
   */
  (function(test) {
    if (test === null || test === void 0) {
      return element3;
    }
    if (typeof test === "string") {
      return tagNameFactory(test);
    }
    if (typeof test === "object") {
      return anyFactory(test);
    }
    if (typeof test === "function") {
      return castFactory(test);
    }
    throw new Error("Expected function, string, or array as `test`");
  })
);
function anyFactory(tests) {
  const checks2 = [];
  let index4 = -1;
  while (++index4 < tests.length) {
    checks2[index4] = convertElement(tests[index4]);
  }
  return castFactory(any2);
  function any2(...parameters) {
    let index5 = -1;
    while (++index5 < checks2.length) {
      if (checks2[index5].apply(this, parameters)) return true;
    }
    return false;
  }
}
function tagNameFactory(check) {
  return castFactory(tagName);
  function tagName(element7) {
    return element7.tagName === check;
  }
}
function castFactory(testFunction) {
  return check;
  function check(value, index4, parent) {
    return Boolean(
      looksLikeAnElement(value) && testFunction.call(
        this,
        value,
        typeof index4 === "number" ? index4 : void 0,
        parent || void 0
      )
    );
  }
}
function element3(element7) {
  return Boolean(
    element7 && typeof element7 === "object" && "type" in element7 && element7.type === "element" && "tagName" in element7 && typeof element7.tagName === "string"
  );
}
function looksLikeAnElement(value) {
  return value !== null && typeof value === "object" && "type" in value && "tagName" in value;
}

// ../node_modules/.pnpm/hast-util-embedded@3.0.0/node_modules/hast-util-embedded/lib/index.js
var embedded = convertElement(
  /**
   * @param element
   * @returns {element is {tagName: 'audio' | 'canvas' | 'embed' | 'iframe' | 'img' | 'math' | 'object' | 'picture' | 'svg' | 'video'}}
   */
  function(element7) {
    return element7.tagName === "audio" || element7.tagName === "canvas" || element7.tagName === "embed" || element7.tagName === "iframe" || element7.tagName === "img" || element7.tagName === "math" || element7.tagName === "object" || element7.tagName === "picture" || element7.tagName === "svg" || element7.tagName === "video";
  }
);

// ../node_modules/.pnpm/hast-util-whitespace@3.0.0/node_modules/hast-util-whitespace/lib/index.js
var re2 = /[ \t\n\f\r]/g;
function whitespace(thing) {
  return typeof thing === "object" ? thing.type === "text" ? empty(thing.value) : false : empty(thing);
}
function empty(value) {
  return value.replace(re2, "") === "";
}

// ../node_modules/.pnpm/unist-util-is@6.0.1/node_modules/unist-util-is/lib/index.js
var convert = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  (function(test) {
    if (test === null || test === void 0) {
      return ok2;
    }
    if (typeof test === "function") {
      return castFactory2(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory2(test) : (
        // Cast because `ReadonlyArray` goes into the above but `isArray`
        // narrows to `Array`.
        propertiesFactory(
          /** @type {Props} */
          test
        )
      );
    }
    if (typeof test === "string") {
      return typeFactory(test);
    }
    throw new Error("Expected function, string, or object as test");
  })
);
function anyFactory2(tests) {
  const checks2 = [];
  let index4 = -1;
  while (++index4 < tests.length) {
    checks2[index4] = convert(tests[index4]);
  }
  return castFactory2(any2);
  function any2(...parameters) {
    let index5 = -1;
    while (++index5 < checks2.length) {
      if (checks2[index5].apply(this, parameters)) return true;
    }
    return false;
  }
}
function propertiesFactory(check) {
  const checkAsRecord = (
    /** @type {Record<string, unknown>} */
    check
  );
  return castFactory2(all9);
  function all9(node2) {
    const nodeAsRecord = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      node2
    );
    let key2;
    for (key2 in check) {
      if (nodeAsRecord[key2] !== checkAsRecord[key2]) return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory2(type);
  function type(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory2(testFunction) {
  return check;
  function check(value, index4, parent) {
    return Boolean(
      looksLikeANode(value) && testFunction.call(
        this,
        value,
        typeof index4 === "number" ? index4 : void 0,
        parent || void 0
      )
    );
  }
}
function ok2() {
  return true;
}
function looksLikeANode(value) {
  return value !== null && typeof value === "object" && "type" in value;
}

// ../node_modules/.pnpm/hast-util-minify-whitespace@1.0.1/node_modules/hast-util-minify-whitespace/lib/block.js
var blocks = [
  "address",
  // Flow content.
  "article",
  // Sections and headings.
  "aside",
  // Sections and headings.
  "blockquote",
  // Flow content.
  "body",
  // Page.
  "br",
  // Contribute whitespace intrinsically.
  "caption",
  // Similar to block.
  "center",
  // Flow content, legacy.
  "col",
  // Similar to block.
  "colgroup",
  // Similar to block.
  "dd",
  // Lists.
  "dialog",
  // Flow content.
  "dir",
  // Lists, legacy.
  "div",
  // Flow content.
  "dl",
  // Lists.
  "dt",
  // Lists.
  "figcaption",
  // Flow content.
  "figure",
  // Flow content.
  "footer",
  // Flow content.
  "form",
  // Flow content.
  "h1",
  // Sections and headings.
  "h2",
  // Sections and headings.
  "h3",
  // Sections and headings.
  "h4",
  // Sections and headings.
  "h5",
  // Sections and headings.
  "h6",
  // Sections and headings.
  "head",
  // Page.
  "header",
  // Flow content.
  "hgroup",
  // Sections and headings.
  "hr",
  // Flow content.
  "html",
  // Page.
  "legend",
  // Flow content.
  "li",
  // Block-like.
  "li",
  // Similar to block.
  "listing",
  // Flow content, legacy
  "main",
  // Flow content.
  "menu",
  // Lists.
  "nav",
  // Sections and headings.
  "ol",
  // Lists.
  "optgroup",
  // Similar to block.
  "option",
  // Similar to block.
  "p",
  // Flow content.
  "plaintext",
  // Flow content, legacy
  "pre",
  // Flow content.
  "section",
  // Sections and headings.
  "summary",
  // Similar to block.
  "table",
  // Similar to block.
  "tbody",
  // Similar to block.
  "td",
  // Block-like.
  "td",
  // Similar to block.
  "tfoot",
  // Similar to block.
  "th",
  // Block-like.
  "th",
  // Similar to block.
  "thead",
  // Similar to block.
  "tr",
  // Similar to block.
  "ul",
  // Lists.
  "wbr",
  // Contribute whitespace intrinsically.
  "xmp"
  // Flow content, legacy
];

// ../node_modules/.pnpm/hast-util-minify-whitespace@1.0.1/node_modules/hast-util-minify-whitespace/lib/content.js
var content = [
  // Form.
  "button",
  "input",
  "select",
  "textarea"
];

// ../node_modules/.pnpm/hast-util-minify-whitespace@1.0.1/node_modules/hast-util-minify-whitespace/lib/skippable.js
var skippable = [
  "area",
  "base",
  "basefont",
  "dialog",
  "datalist",
  "head",
  "link",
  "meta",
  "noembed",
  "noframes",
  "param",
  "rp",
  "script",
  "source",
  "style",
  "template",
  "track",
  "title"
];

// ../node_modules/.pnpm/hast-util-minify-whitespace@1.0.1/node_modules/hast-util-minify-whitespace/lib/index.js
var emptyOptions2 = {};
var ignorableNode = convert(["comment", "doctype"]);
function minifyWhitespace(tree, options) {
  const settings = options || emptyOptions2;
  minify(tree, {
    collapse: collapseFactory(
      settings.newlines ? replaceNewlines : replaceWhitespace
    ),
    whitespace: "normal"
  });
}
function minify(node2, state) {
  if ("children" in node2) {
    const settings = { ...state };
    if (node2.type === "root" || blocklike(node2)) {
      settings.before = true;
      settings.after = true;
    }
    settings.whitespace = inferWhiteSpace(node2, state);
    return all3(node2, settings);
  }
  if (node2.type === "text") {
    if (state.whitespace === "normal") {
      return minifyText(node2, state);
    }
    if (state.whitespace === "nowrap") {
      node2.value = state.collapse(node2.value);
    }
  }
  return { ignore: ignorableNode(node2), stripAtStart: false, remove: false };
}
function minifyText(node2, state) {
  const value = state.collapse(node2.value);
  const result = { ignore: false, stripAtStart: false, remove: false };
  let start = 0;
  let end = value.length;
  if (state.before && removable(value.charAt(0))) {
    start++;
  }
  if (start !== end && removable(value.charAt(end - 1))) {
    if (state.after) {
      end--;
    } else {
      result.stripAtStart = true;
    }
  }
  if (start === end) {
    result.remove = true;
  } else {
    node2.value = value.slice(start, end);
  }
  return result;
}
function all3(parent, state) {
  let before = state.before;
  const after = state.after;
  const children = parent.children;
  let length3 = children.length;
  let index4 = -1;
  while (++index4 < length3) {
    const result = minify(children[index4], {
      ...state,
      after: collapsableAfter(children, index4, after),
      before
    });
    if (result.remove) {
      children.splice(index4, 1);
      index4--;
      length3--;
    } else if (!result.ignore) {
      before = result.stripAtStart;
    }
    if (content2(children[index4])) {
      before = false;
    }
  }
  return { ignore: false, stripAtStart: Boolean(before || after), remove: false };
}
function collapsableAfter(nodes, index4, after) {
  while (++index4 < nodes.length) {
    const node2 = nodes[index4];
    let result = inferBoundary(node2);
    if (result === void 0 && "children" in node2 && !skippable2(node2)) {
      result = collapsableAfter(node2.children, -1);
    }
    if (typeof result === "boolean") {
      return result;
    }
  }
  return after;
}
function inferBoundary(node2) {
  if (node2.type === "element") {
    if (content2(node2)) {
      return false;
    }
    if (blocklike(node2)) {
      return true;
    }
  } else if (node2.type === "text") {
    if (!whitespace(node2)) {
      return false;
    }
  } else if (!ignorableNode(node2)) {
    return false;
  }
}
function content2(node2) {
  return embedded(node2) || isElement2(node2, content);
}
function blocklike(node2) {
  return isElement2(node2, blocks);
}
function skippable2(node2) {
  return Boolean(node2.type === "element" && node2.properties.hidden) || ignorableNode(node2) || isElement2(node2, skippable);
}
function removable(character) {
  return character === " " || character === "\n";
}
function replaceNewlines(value) {
  const match = /\r?\n|\r/.exec(value);
  return match ? match[0] : " ";
}
function replaceWhitespace() {
  return " ";
}
function collapseFactory(replace2) {
  return collapse;
  function collapse(value) {
    return String(value).replace(/[\t\n\v\f\r ]+/g, replace2);
  }
}
function inferWhiteSpace(node2, state) {
  if ("tagName" in node2 && node2.properties) {
    switch (node2.tagName) {
      // Whitespace in script/style, while not displayed by CSS as significant,
      // could have some meaning in JS/CSS, so we cant touch them.
      case "listing":
      case "plaintext":
      case "script":
      case "style":
      case "xmp": {
        return "pre";
      }
      case "nobr": {
        return "nowrap";
      }
      case "pre": {
        return node2.properties.wrap ? "pre-wrap" : "pre";
      }
      case "td":
      case "th": {
        return node2.properties.noWrap ? "nowrap" : state.whitespace;
      }
      case "textarea": {
        return "pre-wrap";
      }
      default:
    }
  }
  return state.whitespace;
}

// ../node_modules/.pnpm/rehype-minify-whitespace@6.0.2/node_modules/rehype-minify-whitespace/lib/index.js
function rehypeMinifyWhitespace(options) {
  return function(tree) {
    minifyWhitespace(tree, options);
  };
}

// ../node_modules/.pnpm/unist-util-visit-parents@6.0.2/node_modules/unist-util-visit-parents/lib/color.js
function color(d) {
  return d;
}

// ../node_modules/.pnpm/unist-util-visit-parents@6.0.2/node_modules/unist-util-visit-parents/lib/index.js
var empty2 = [];
var CONTINUE = true;
var EXIT = false;
var SKIP = "skip";
function visitParents(tree, test, visitor, reverse) {
  let check;
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
  } else {
    check = test;
  }
  const is3 = convert(check);
  const step = reverse ? -1 : 1;
  factory(tree, void 0, [])();
  function factory(node2, index4, parents) {
    const value = (
      /** @type {Record<string, unknown>} */
      node2 && typeof node2 === "object" ? node2 : {}
    );
    if (typeof value.type === "string") {
      const name = (
        // `hast`
        typeof value.tagName === "string" ? value.tagName : (
          // `xast`
          typeof value.name === "string" ? value.name : void 0
        )
      );
      Object.defineProperty(visit2, "name", {
        value: "node (" + color(node2.type + (name ? "<" + name + ">" : "")) + ")"
      });
    }
    return visit2;
    function visit2() {
      let result = empty2;
      let subresult;
      let offset4;
      let grandparents;
      if (!test || is3(node2, index4, parents[parents.length - 1] || void 0)) {
        result = toResult(visitor(node2, parents));
        if (result[0] === EXIT) {
          return result;
        }
      }
      if ("children" in node2 && node2.children) {
        const nodeAsParent = (
          /** @type {UnistParent} */
          node2
        );
        if (nodeAsParent.children && result[0] !== SKIP) {
          offset4 = (reverse ? nodeAsParent.children.length : -1) + step;
          grandparents = parents.concat(nodeAsParent);
          while (offset4 > -1 && offset4 < nodeAsParent.children.length) {
            const child = nodeAsParent.children[offset4];
            subresult = factory(child, offset4, grandparents)();
            if (subresult[0] === EXIT) {
              return subresult;
            }
            offset4 = typeof subresult[1] === "number" ? subresult[1] : offset4 + step;
          }
        }
      }
      return result;
    }
  }
}
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return value === null || value === void 0 ? empty2 : [value];
}

// ../node_modules/.pnpm/unist-util-visit@5.0.0/node_modules/unist-util-visit/lib/index.js
function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
  let reverse;
  let test;
  let visitor;
  if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
    test = void 0;
    visitor = testOrVisitor;
    reverse = visitorOrReverse;
  } else {
    test = testOrVisitor;
    visitor = visitorOrReverse;
    reverse = maybeReverse;
  }
  visitParents(tree, test, overload, reverse);
  function overload(node2, parents) {
    const parent = parents[parents.length - 1];
    const index4 = parent ? parent.children.indexOf(node2) : void 0;
    return visitor(node2, index4, parent);
  }
}

// ../node_modules/.pnpm/unist-util-position@5.0.0/node_modules/unist-util-position/lib/index.js
var pointEnd = point3("end");
var pointStart = point3("start");
function point3(type) {
  return point5;
  function point5(node2) {
    const point6 = node2 && node2.position && node2.position[type] || {};
    if (typeof point6.line === "number" && point6.line > 0 && typeof point6.column === "number" && point6.column > 0) {
      return {
        line: point6.line,
        column: point6.column,
        offset: typeof point6.offset === "number" && point6.offset > -1 ? point6.offset : void 0
      };
    }
  }
}
function position3(node2) {
  const start = pointStart(node2);
  const end = pointEnd(node2);
  if (start && end) {
    return { start, end };
  }
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/a.js
function a(state, node2) {
  const properties = node2.properties || {};
  const children = (
    /** @type {Array<PhrasingContent>} */
    state.all(node2)
  );
  const result = {
    type: "link",
    url: state.resolve(String(properties.href || "") || null),
    title: properties.title ? String(properties.title) : null,
    children
  };
  state.patch(node2, result);
  return result;
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/base.js
function base2(state, node2) {
  if (!state.baseFound) {
    state.frozenBaseUrl = String(node2.properties && node2.properties.href || "") || void 0;
    state.baseFound = true;
  }
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/blockquote.js
function blockquote(state, node2) {
  const result = { type: "blockquote", children: state.toFlow(state.all(node2)) };
  state.patch(node2, result);
  return result;
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/br.js
function br2(state, node2) {
  const result = { type: "break" };
  state.patch(node2, result);
  return result;
}

// ../node_modules/.pnpm/unist-util-find-after@5.0.0/node_modules/unist-util-find-after/lib/index.js
var findAfter = (
  // Note: overloads like this are needed to support optional generics.
  /**
   * @type {(
   *   (<Kind extends UnistParent, Check extends Test>(parent: Kind, index: Child<Kind> | number, test: Check) => Matches<Child<Kind>, Check> | undefined) &
   *   (<Kind extends UnistParent>(parent: Kind, index: Child<Kind> | number, test?: null | undefined) => Child<Kind> | undefined)
   * )}
   */
  /**
   * @param {UnistParent} parent
   * @param {UnistNode | number} index
   * @param {Test} [test]
   * @returns {UnistNode | undefined}
   */
  (function(parent, index4, test) {
    const is3 = convert(test);
    if (!parent || !parent.type || !parent.children) {
      throw new Error("Expected parent node");
    }
    if (typeof index4 === "number") {
      if (index4 < 0 || index4 === Number.POSITIVE_INFINITY) {
        throw new Error("Expected positive finite number as index");
      }
    } else {
      index4 = parent.children.indexOf(index4);
      if (index4 < 0) {
        throw new Error("Expected child node or index");
      }
    }
    while (++index4 < parent.children.length) {
      if (is3(parent.children[index4], index4, parent)) {
        return parent.children[index4];
      }
    }
    return void 0;
  })
);

// ../node_modules/.pnpm/hast-util-to-text@4.0.2/node_modules/hast-util-to-text/lib/index.js
var searchLineFeeds = /\n/g;
var searchTabOrSpaces = /[\t ]+/g;
var br3 = convertElement("br");
var cell = convertElement(isCell);
var p = convertElement("p");
var row = convertElement("tr");
var notRendered = convertElement([
  // List from: <https://html.spec.whatwg.org/multipage/rendering.html#hidden-elements>
  "datalist",
  "head",
  "noembed",
  "noframes",
  "noscript",
  // Act as if we support scripting.
  "rp",
  "script",
  "style",
  "template",
  "title",
  // Hidden attribute.
  hidden,
  // From: <https://html.spec.whatwg.org/multipage/rendering.html#flow-content-3>
  closedDialog
]);
var blockOrCaption = convertElement([
  "address",
  // Flow content
  "article",
  // Sections and headings
  "aside",
  // Sections and headings
  "blockquote",
  // Flow content
  "body",
  // Page
  "caption",
  // `table-caption`
  "center",
  // Flow content (legacy)
  "dd",
  // Lists
  "dialog",
  // Flow content
  "dir",
  // Lists (legacy)
  "dl",
  // Lists
  "dt",
  // Lists
  "div",
  // Flow content
  "figure",
  // Flow content
  "figcaption",
  // Flow content
  "footer",
  // Flow content
  "form,",
  // Flow content
  "h1",
  // Sections and headings
  "h2",
  // Sections and headings
  "h3",
  // Sections and headings
  "h4",
  // Sections and headings
  "h5",
  // Sections and headings
  "h6",
  // Sections and headings
  "header",
  // Flow content
  "hgroup",
  // Sections and headings
  "hr",
  // Flow content
  "html",
  // Page
  "legend",
  // Flow content
  "li",
  // Lists (as `display: list-item`)
  "listing",
  // Flow content (legacy)
  "main",
  // Flow content
  "menu",
  // Lists
  "nav",
  // Sections and headings
  "ol",
  // Lists
  "p",
  // Flow content
  "plaintext",
  // Flow content (legacy)
  "pre",
  // Flow content
  "section",
  // Sections and headings
  "ul",
  // Lists
  "xmp"
  // Flow content (legacy)
]);
function toText(tree, options) {
  const options_ = options || {};
  const children = "children" in tree ? tree.children : [];
  const block = blockOrCaption(tree);
  const whitespace2 = inferWhitespace(tree, {
    whitespace: options_.whitespace || "normal",
    breakBefore: false,
    breakAfter: false
  });
  const results = [];
  if (tree.type === "text" || tree.type === "comment") {
    results.push(
      ...collectText(tree, {
        whitespace: whitespace2,
        breakBefore: true,
        breakAfter: true
      })
    );
  }
  let index4 = -1;
  while (++index4 < children.length) {
    results.push(
      ...renderedTextCollection(
        children[index4],
        // @ts-expect-error: `tree` is a parent if were here.
        tree,
        {
          whitespace: whitespace2,
          breakBefore: index4 ? void 0 : block,
          breakAfter: index4 < children.length - 1 ? br3(children[index4 + 1]) : block
        }
      )
    );
  }
  const result = [];
  let count2;
  index4 = -1;
  while (++index4 < results.length) {
    const value = results[index4];
    if (typeof value === "number") {
      if (count2 !== void 0 && value > count2) count2 = value;
    } else if (value) {
      if (count2 !== void 0 && count2 > -1) {
        result.push("\n".repeat(count2) || " ");
      }
      count2 = -1;
      result.push(value);
    }
  }
  return result.join("");
}
function renderedTextCollection(node2, parent, info) {
  if (node2.type === "element") {
    return collectElement(node2, parent, info);
  }
  if (node2.type === "text") {
    return info.whitespace === "normal" ? collectText(node2, info) : collectPreText(node2);
  }
  return [];
}
function collectElement(node2, parent, info) {
  const whitespace2 = inferWhitespace(node2, info);
  const children = node2.children || [];
  let index4 = -1;
  let items = [];
  if (notRendered(node2)) {
    return items;
  }
  let prefix3;
  let suffix;
  if (br3(node2)) {
    suffix = "\n";
  } else if (row(node2) && // @ts-expect-error: something up with types of parents.
  findAfter(parent, node2, row)) {
    suffix = "\n";
  } else if (p(node2)) {
    prefix3 = 2;
    suffix = 2;
  } else if (blockOrCaption(node2)) {
    prefix3 = 1;
    suffix = 1;
  }
  while (++index4 < children.length) {
    items = items.concat(
      renderedTextCollection(children[index4], node2, {
        whitespace: whitespace2,
        breakBefore: index4 ? void 0 : prefix3,
        breakAfter: index4 < children.length - 1 ? br3(children[index4 + 1]) : suffix
      })
    );
  }
  if (cell(node2) && // @ts-expect-error: something up with types of parents.
  findAfter(parent, node2, cell)) {
    items.push("	");
  }
  if (prefix3) items.unshift(prefix3);
  if (suffix) items.push(suffix);
  return items;
}
function collectText(node2, info) {
  const value = String(node2.value);
  const lines = [];
  const result = [];
  let start = 0;
  while (start <= value.length) {
    searchLineFeeds.lastIndex = start;
    const match = searchLineFeeds.exec(value);
    const end = match && "index" in match ? match.index : value.length;
    lines.push(
      // Any sequence of collapsible spaces and tabs immediately preceding or
      // following a segment break is removed.
      trimAndCollapseSpacesAndTabs(
        // [] ignoring bidi formatting characters (characters with the
        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if
        // they were not there.
        value.slice(start, end).replace(/[\u061C\u200E\u200F\u202A-\u202E\u2066-\u2069]/g, ""),
        start === 0 ? info.breakBefore : true,
        end === value.length ? info.breakAfter : true
      )
    );
    start = end + 1;
  }
  let index4 = -1;
  let join3;
  while (++index4 < lines.length) {
    if (lines[index4].charCodeAt(lines[index4].length - 1) === 8203 || index4 < lines.length - 1 && lines[index4 + 1].charCodeAt(0) === 8203) {
      result.push(lines[index4]);
      join3 = void 0;
    } else if (lines[index4]) {
      if (typeof join3 === "number") result.push(join3);
      result.push(lines[index4]);
      join3 = 0;
    } else if (index4 === 0 || index4 === lines.length - 1) {
      result.push(0);
    }
  }
  return result;
}
function collectPreText(node2) {
  return [String(node2.value)];
}
function trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {
  const result = [];
  let start = 0;
  let end;
  while (start < value.length) {
    searchTabOrSpaces.lastIndex = start;
    const match = searchTabOrSpaces.exec(value);
    end = match ? match.index : value.length;
    if (!start && !end && match && !breakBefore) {
      result.push("");
    }
    if (start !== end) {
      result.push(value.slice(start, end));
    }
    start = match ? end + match[0].length : end;
  }
  if (start !== end && !breakAfter) {
    result.push("");
  }
  return result.join(" ");
}
function inferWhitespace(node2, info) {
  if (node2.type === "element") {
    const properties = node2.properties || {};
    switch (node2.tagName) {
      case "listing":
      case "plaintext":
      case "xmp": {
        return "pre";
      }
      case "nobr": {
        return "nowrap";
      }
      case "pre": {
        return properties.wrap ? "pre-wrap" : "pre";
      }
      case "td":
      case "th": {
        return properties.noWrap ? "nowrap" : info.whitespace;
      }
      case "textarea": {
        return "pre-wrap";
      }
      default:
    }
  }
  return info.whitespace;
}
function hidden(node2) {
  return Boolean((node2.properties || {}).hidden);
}
function isCell(node2) {
  return node2.tagName === "td" || node2.tagName === "th";
}
function closedDialog(node2) {
  return node2.tagName === "dialog" && !(node2.properties || {}).open;
}

// ../node_modules/.pnpm/trim-trailing-lines@2.1.0/node_modules/trim-trailing-lines/index.js
function trimTrailingLines(value) {
  const input2 = String(value);
  let end = input2.length;
  while (end > 0) {
    const code5 = input2.codePointAt(end - 1);
    if (code5 !== void 0 && (code5 === 10 || code5 === 13)) {
      end--;
    } else {
      break;
    }
  }
  return input2.slice(0, end);
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/code.js
var prefix2 = "language-";
function code(state, node2) {
  const children = node2.children;
  let index4 = -1;
  let classList;
  let lang;
  if (node2.tagName === "pre") {
    while (++index4 < children.length) {
      const child = children[index4];
      if (child.type === "element" && child.tagName === "code" && child.properties && child.properties.className && Array.isArray(child.properties.className)) {
        classList = child.properties.className;
        break;
      }
    }
  }
  if (classList) {
    index4 = -1;
    while (++index4 < classList.length) {
      if (String(classList[index4]).slice(0, prefix2.length) === prefix2) {
        lang = String(classList[index4]).slice(prefix2.length);
        break;
      }
    }
  }
  const result = {
    type: "code",
    lang: lang || null,
    meta: null,
    value: trimTrailingLines(toText(node2))
  };
  state.patch(node2, result);
  return result;
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/comment.js
function comment(state, node2) {
  const result = {
    type: "html",
    value: "<!--" + node2.value + "-->"
  };
  state.patch(node2, result);
  return result;
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/del.js
function del(state, node2) {
  const children = (
    /** @type {Array<PhrasingContent>} */
    state.all(node2)
  );
  const result = { type: "delete", children };
  state.patch(node2, result);
  return result;
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/util/list-items-spread.js
function listItemsSpread(children) {
  let index4 = -1;
  if (children.length > 1) {
    while (++index4 < children.length) {
      if (children[index4].spread) {
        return true;
      }
    }
  }
  return false;
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/dl.js
function dl(state, node2) {
  const clean = [];
  const groups = [];
  let index4 = -1;
  while (++index4 < node2.children.length) {
    const child = node2.children[index4];
    if (child.type === "element" && child.tagName === "div") {
      clean.push(...child.children);
    } else {
      clean.push(child);
    }
  }
  let group = { definitions: [], titles: [] };
  index4 = -1;
  while (++index4 < clean.length) {
    const child = clean[index4];
    if (child.type === "element" && child.tagName === "dt") {
      const previous3 = clean[index4 - 1];
      if (previous3 && previous3.type === "element" && previous3.tagName === "dd") {
        groups.push(group);
        group = { definitions: [], titles: [] };
      }
      group.titles.push(child);
    } else {
      group.definitions.push(child);
    }
  }
  groups.push(group);
  index4 = -1;
  const content5 = [];
  while (++index4 < groups.length) {
    const result = [
      ...handle(state, groups[index4].titles),
      ...handle(state, groups[index4].definitions)
    ];
    if (result.length > 0) {
      content5.push({
        type: "listItem",
        spread: result.length > 1,
        checked: null,
        children: result
      });
    }
  }
  if (content5.length > 0) {
    const result = {
      type: "list",
      ordered: false,
      start: null,
      spread: listItemsSpread(content5),
      children: content5
    };
    state.patch(node2, result);
    return result;
  }
}
function handle(state, children) {
  const nodes = state.all({ type: "root", children });
  const listItems = state.toSpecificContent(nodes, create8);
  if (listItems.length === 0) {
    return [];
  }
  if (listItems.length === 1) {
    return listItems[0].children;
  }
  return [
    {
      type: "list",
      ordered: false,
      start: null,
      spread: listItemsSpread(listItems),
      children: listItems
    }
  ];
}
function create8() {
  return { type: "listItem", spread: false, checked: null, children: [] };
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/em.js
function em(state, node2) {
  const children = (
    /** @type {Array<PhrasingContent>} */
    state.all(node2)
  );
  const result = { type: "emphasis", children };
  state.patch(node2, result);
  return result;
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/util/drop-surrounding-breaks.js
function dropSurroundingBreaks(nodes) {
  let start = 0;
  let end = nodes.length;
  while (start < end && nodes[start].type === "break") start++;
  while (end > start && nodes[end - 1].type === "break") end--;
  return start === 0 && end === nodes.length ? nodes : nodes.slice(start, end);
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/heading.js
function heading(state, node2) {
  const depth = (
    /** @type {Heading['depth']} */
    /* c8 ignore next */
    Number(node2.tagName.charAt(1)) || 1
  );
  const children = dropSurroundingBreaks(
    /** @type {Array<PhrasingContent>} */
    state.all(node2)
  );
  const result = { type: "heading", depth, children };
  state.patch(node2, result);
  return result;
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/hr.js
function hr2(state, node2) {
  const result = { type: "thematicBreak" };
  state.patch(node2, result);
  return result;
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/iframe.js
function iframe(state, node2) {
  const properties = node2.properties || {};
  const source = String(properties.src || "");
  const title = String(properties.title || "");
  if (source && title) {
    const result = {
      type: "link",
      title: null,
      url: state.resolve(source),
      children: [{ type: "text", value: title }]
    };
    state.patch(node2, result);
    return result;
  }
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/img.js
function img(state, node2) {
  const properties = node2.properties || {};
  const result = {
    type: "image",
    url: state.resolve(String(properties.src || "") || null),
    title: properties.title ? String(properties.title) : null,
    alt: properties.alt ? String(properties.alt) : ""
  };
  state.patch(node2, result);
  return result;
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/inline-code.js
function inlineCode(state, node2) {
  const result = { type: "inlineCode", value: toText(node2) };
  state.patch(node2, result);
  return result;
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/util/find-selected-options.js
function findSelectedOptions(node2, explicitProperties) {
  const selectedOptions = [];
  const values2 = [];
  const properties = explicitProperties || node2.properties || {};
  const options = findOptions(node2);
  const size5 = Math.min(Number.parseInt(String(properties.size), 10), 0) || (properties.multiple ? 4 : 1);
  let index4 = -1;
  while (++index4 < options.length) {
    const option2 = options[index4];
    if (option2 && option2.properties && option2.properties.selected) {
      selectedOptions.push(option2);
    }
  }
  const list7 = selectedOptions.length > 0 ? selectedOptions : options;
  const max3 = Math.min(list7.length, size5);
  index4 = -1;
  while (++index4 < max3) {
    const option2 = list7[index4];
    const properties2 = option2.properties || {};
    const content5 = toText(option2);
    const label = content5 || String(properties2.label || "");
    const value = String(properties2.value || "") || content5;
    values2.push([value, label === value ? void 0 : label]);
  }
  return values2;
}
function findOptions(node2) {
  const results = [];
  let index4 = -1;
  while (++index4 < node2.children.length) {
    const child = node2.children[index4];
    if ("children" in child && Array.isArray(child.children)) {
      results.push(...findOptions(child));
    }
    if (child.type === "element" && child.tagName === "option" && (!child.properties || !child.properties.disabled)) {
      results.push(child);
    }
  }
  return results;
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/input.js
var defaultChecked = "[x]";
var defaultUnchecked = "[ ]";
function input(state, node2) {
  const properties = node2.properties || {};
  const value = String(properties.value || properties.placeholder || "");
  if (properties.disabled || properties.type === "hidden" || properties.type === "file") {
    return;
  }
  if (properties.type === "checkbox" || properties.type === "radio") {
    const result2 = {
      type: "text",
      value: properties.checked ? state.options.checked || defaultChecked : state.options.unchecked || defaultUnchecked
    };
    state.patch(node2, result2);
    return result2;
  }
  if (properties.type === "image") {
    const alt = properties.alt || value;
    if (alt) {
      const result2 = {
        type: "image",
        url: state.resolve(String(properties.src || "") || null),
        title: String(properties.title || "") || null,
        alt: String(alt)
      };
      state.patch(node2, result2);
      return result2;
    }
    return;
  }
  let values2 = [];
  if (value) {
    values2 = [[value, void 0]];
  } else if (
    // `list` is not supported on these types:
    properties.type !== "button" && properties.type !== "file" && properties.type !== "password" && properties.type !== "reset" && properties.type !== "submit" && properties.list
  ) {
    const list7 = String(properties.list);
    const datalist = state.elementById.get(list7);
    if (datalist && datalist.tagName === "datalist") {
      values2 = findSelectedOptions(datalist, properties);
    }
  }
  if (values2.length === 0) {
    return;
  }
  if (properties.type === "password") {
    values2[0] = ["".repeat(values2[0][0].length), void 0];
  }
  if (properties.type === "email" || properties.type === "url") {
    const results = [];
    let index5 = -1;
    while (++index5 < values2.length) {
      const value2 = state.resolve(values2[index5][0]);
      const result2 = {
        type: "link",
        title: null,
        url: properties.type === "email" ? "mailto:" + value2 : value2,
        children: [{ type: "text", value: values2[index5][1] || value2 }]
      };
      results.push(result2);
      if (index5 !== values2.length - 1) {
        results.push({ type: "text", value: ", " });
      }
    }
    return results;
  }
  const texts = [];
  let index4 = -1;
  while (++index4 < values2.length) {
    texts.push(
      values2[index4][1] ? values2[index4][1] + " (" + values2[index4][0] + ")" : values2[index4][0]
    );
  }
  const result = { type: "text", value: texts.join(", ") };
  state.patch(node2, result);
  return result;
}

// ../node_modules/.pnpm/hast-util-has-property@3.0.0/node_modules/hast-util-has-property/lib/index.js
var own2 = {}.hasOwnProperty;
function hasProperty2(node2, name) {
  const value = node2.type === "element" && own2.call(node2.properties, name) && node2.properties[name];
  return value !== null && value !== void 0 && value !== false;
}

// ../node_modules/.pnpm/hast-util-is-body-ok-link@3.0.1/node_modules/hast-util-is-body-ok-link/lib/index.js
var list = /* @__PURE__ */ new Set(["pingback", "prefetch", "stylesheet"]);
function isBodyOkLink(node2) {
  if (node2.type !== "element" || node2.tagName !== "link") {
    return false;
  }
  if (node2.properties.itemProp) {
    return true;
  }
  const value = node2.properties.rel;
  let index4 = -1;
  if (!Array.isArray(value) || value.length === 0) {
    return false;
  }
  while (++index4 < value.length) {
    if (!list.has(String(value[index4]))) {
      return false;
    }
  }
  return true;
}

// ../node_modules/.pnpm/hast-util-phrasing@3.0.1/node_modules/hast-util-phrasing/lib/index.js
var basic = convertElement([
  "a",
  "abbr",
  // `area` is in fact only phrasing if it is inside a `map` element.
  // However, since `area`s are required to be inside a `map` element, and its
  // a rather involved check, its ignored here for now.
  "area",
  "b",
  "bdi",
  "bdo",
  "br",
  "button",
  "cite",
  "code",
  "data",
  "datalist",
  "del",
  "dfn",
  "em",
  "i",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "map",
  "mark",
  "meter",
  "noscript",
  "output",
  "progress",
  "q",
  "ruby",
  "s",
  "samp",
  "script",
  "select",
  "small",
  "span",
  "strong",
  "sub",
  "sup",
  "template",
  "textarea",
  "time",
  "u",
  "var",
  "wbr"
]);
var meta = convertElement("meta");
function phrasing(value) {
  return Boolean(
    value.type === "text" || basic(value) || embedded(value) || isBodyOkLink(value) || meta(value) && hasProperty2(value, "itemProp")
  );
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/li.js
function li(state, node2) {
  const { rest, checkbox } = extractLeadingCheckbox(node2);
  const checked = checkbox ? Boolean(checkbox.properties.checked) : null;
  const spread = spreadout(rest);
  const children = state.toFlow(state.all(rest));
  const result = { type: "listItem", spread, checked, children };
  state.patch(node2, result);
  return result;
}
function spreadout(node2) {
  let index4 = -1;
  let seenFlow = false;
  while (++index4 < node2.children.length) {
    const child = node2.children[index4];
    if (child.type === "element") {
      if (phrasing(child)) continue;
      if (child.tagName === "p" || seenFlow || spreadout(child)) {
        return true;
      }
      seenFlow = true;
    }
  }
  return false;
}
function extractLeadingCheckbox(node2) {
  const head2 = node2.children[0];
  if (head2 && head2.type === "element" && head2.tagName === "input" && head2.properties && (head2.properties.type === "checkbox" || head2.properties.type === "radio")) {
    const rest = { ...node2, children: node2.children.slice(1) };
    return { checkbox: head2, rest };
  }
  if (head2 && head2.type === "element" && head2.tagName === "p") {
    const { checkbox, rest: restHead } = extractLeadingCheckbox(head2);
    if (checkbox) {
      const rest = { ...node2, children: [restHead, ...node2.children.slice(1)] };
      return { checkbox, rest };
    }
  }
  return { checkbox: void 0, rest: node2 };
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/list.js
function list2(state, node2) {
  const ordered = node2.tagName === "ol";
  const children = state.toSpecificContent(state.all(node2), create9);
  let start = null;
  if (ordered) {
    start = node2.properties && node2.properties.start ? Number.parseInt(String(node2.properties.start), 10) : 1;
  }
  const result = {
    type: "list",
    ordered,
    start,
    spread: listItemsSpread(children),
    children
  };
  state.patch(node2, result);
  return result;
}
function create9() {
  return { type: "listItem", spread: false, checked: null, children: [] };
}

// ../node_modules/.pnpm/mdast-util-to-string@4.0.0/node_modules/mdast-util-to-string/lib/index.js
var emptyOptions3 = {};
function toString2(value, options) {
  const settings = options || emptyOptions3;
  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
  return one2(value, includeImageAlt, includeHtml);
}
function one2(value, includeImageAlt, includeHtml) {
  if (node(value)) {
    if ("value" in value) {
      return value.type === "html" && !includeHtml ? "" : value.value;
    }
    if (includeImageAlt && "alt" in value && value.alt) {
      return value.alt;
    }
    if ("children" in value) {
      return all4(value.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value)) {
    return all4(value, includeImageAlt, includeHtml);
  }
  return "";
}
function all4(values2, includeImageAlt, includeHtml) {
  const result = [];
  let index4 = -1;
  while (++index4 < values2.length) {
    result[index4] = one2(values2[index4], includeImageAlt, includeHtml);
  }
  return result.join("");
}
function node(value) {
  return Boolean(value && typeof value === "object");
}

// ../node_modules/.pnpm/mdast-util-phrasing@4.1.0/node_modules/mdast-util-phrasing/lib/index.js
var phrasing2 = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  convert([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/util/wrap.js
function wrapNeeded(nodes) {
  let index4 = -1;
  while (++index4 < nodes.length) {
    const node2 = nodes[index4];
    if (!phrasing3(node2) || "children" in node2 && wrapNeeded(node2.children)) {
      return true;
    }
  }
  return false;
}
function wrap(nodes) {
  return runs(nodes, onphrasing, function(d) {
    return d;
  });
  function onphrasing(nodes2) {
    return nodes2.every(function(d) {
      return d.type === "text" ? whitespace(d.value) : false;
    }) ? [] : [{ type: "paragraph", children: dropSurroundingBreaks(nodes2) }];
  }
}
function split(node2) {
  return runs(node2.children, onphrasing, onnonphrasing);
  function onphrasing(nodes) {
    const newParent = cloneWithoutChildren(node2);
    newParent.children = nodes;
    return [newParent];
  }
  function onnonphrasing(child) {
    if ("children" in child && "children" in node2) {
      const newParent = cloneWithoutChildren(node2);
      const newChild = cloneWithoutChildren(child);
      newParent.children = child.children;
      newChild.children.push(newParent);
      return newChild;
    }
    return { ...child };
  }
}
function runs(nodes, onphrasing, onnonphrasing) {
  const flattened = flatten(nodes);
  const result = [];
  let queue = [];
  let index4 = -1;
  while (++index4 < flattened.length) {
    const node2 = flattened[index4];
    if (phrasing3(node2)) {
      queue.push(node2);
    } else {
      if (queue.length > 0) {
        result.push(...onphrasing(queue));
        queue = [];
      }
      result.push(onnonphrasing(node2));
    }
  }
  if (queue.length > 0) {
    result.push(...onphrasing(queue));
    queue = [];
  }
  return result;
}
function flatten(nodes) {
  const flattened = [];
  let index4 = -1;
  while (++index4 < nodes.length) {
    const node2 = nodes[index4];
    if ((node2.type === "delete" || node2.type === "link") && wrapNeeded(node2.children)) {
      flattened.push(...split(node2));
    } else {
      flattened.push(node2);
    }
  }
  return flattened;
}
function phrasing3(node2) {
  const tagName = node2.data && node2.data.hName;
  return tagName ? phrasing({ type: "element", tagName, properties: {}, children: [] }) : phrasing2(node2);
}
function cloneWithoutChildren(node2) {
  return esm_default({ ...node2, children: [] });
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/media.js
function media(state, node2) {
  const properties = node2.properties || {};
  const poster = node2.tagName === "video" ? String(properties.poster || "") : "";
  let source = String(properties.src || "");
  let index4 = -1;
  let linkInFallbackContent = false;
  let nodes = state.all(node2);
  const fragment = { type: "root", children: nodes };
  visit(fragment, function(node3) {
    if (node3.type === "link") {
      linkInFallbackContent = true;
      return EXIT;
    }
  });
  if (linkInFallbackContent || wrapNeeded(nodes)) {
    return nodes;
  }
  while (!source && ++index4 < node2.children.length) {
    const child = node2.children[index4];
    if (child.type === "element" && child.tagName === "source" && child.properties) {
      source = String(child.properties.src || "");
    }
  }
  if (poster) {
    const image3 = {
      type: "image",
      title: null,
      url: state.resolve(poster),
      alt: toString2(nodes)
    };
    state.patch(node2, image3);
    nodes = [image3];
  }
  const children = (
    /** @type {Array<PhrasingContent>} */
    nodes
  );
  const result = {
    type: "link",
    title: properties.title ? String(properties.title) : null,
    url: state.resolve(source),
    children
  };
  state.patch(node2, result);
  return result;
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/p.js
function p2(state, node2) {
  const children = dropSurroundingBreaks(
    // Allow potentially invalid nodes, they might be unknown.
    // We also support straddling later.
    /** @type {Array<PhrasingContent>} */
    state.all(node2)
  );
  if (children.length > 0) {
    const result = { type: "paragraph", children };
    state.patch(node2, result);
    return result;
  }
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/q.js
var defaultQuotes = ['"'];
function q2(state, node2) {
  const quotes = state.options.quotes || defaultQuotes;
  state.qNesting++;
  const contents = state.all(node2);
  state.qNesting--;
  const quote = quotes[state.qNesting % quotes.length];
  const head2 = contents[0];
  const tail = contents[contents.length - 1];
  const open = quote.charAt(0);
  const close = quote.length > 1 ? quote.charAt(1) : quote;
  if (head2 && head2.type === "text") {
    head2.value = open + head2.value;
  } else {
    contents.unshift({ type: "text", value: open });
  }
  if (tail && tail.type === "text") {
    tail.value += close;
  } else {
    contents.push({ type: "text", value: close });
  }
  return contents;
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/root.js
function root(state, node2) {
  let children = state.all(node2);
  if (state.options.document || wrapNeeded(children)) {
    children = wrap(children);
  }
  const result = { type: "root", children };
  state.patch(node2, result);
  return result;
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/select.js
function select(state, node2) {
  const values2 = findSelectedOptions(node2);
  let index4 = -1;
  const results = [];
  while (++index4 < values2.length) {
    const value = values2[index4];
    results.push(value[1] ? value[1] + " (" + value[0] + ")" : value[0]);
  }
  if (results.length > 0) {
    const result = { type: "text", value: results.join(", ") };
    state.patch(node2, result);
    return result;
  }
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/strong.js
function strong(state, node2) {
  const children = (
    /** @type {Array<PhrasingContent>} */
    state.all(node2)
  );
  const result = { type: "strong", children };
  state.patch(node2, result);
  return result;
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/table-cell.js
function tableCell(state, node2) {
  const children = (
    /** @type {Array<PhrasingContent>} */
    state.all(node2)
  );
  const result = { type: "tableCell", children };
  state.patch(node2, result);
  if (node2.properties) {
    const rowSpan = node2.properties.rowSpan;
    const colSpan = node2.properties.colSpan;
    if (rowSpan || colSpan) {
      const data = (
        /** @type {Record<string, unknown>} */
        result.data || (result.data = {})
      );
      if (rowSpan) data.hastUtilToMdastTemporaryRowSpan = rowSpan;
      if (colSpan) data.hastUtilToMdastTemporaryColSpan = colSpan;
    }
  }
  return result;
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/table-row.js
function tableRow(state, node2) {
  const children = state.toSpecificContent(state.all(node2), create10);
  const result = { type: "tableRow", children };
  state.patch(node2, result);
  return result;
}
function create10() {
  return { type: "tableCell", children: [] };
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/table.js
function table(state, node2) {
  if (state.inTable) {
    const result2 = { type: "text", value: toText(node2) };
    state.patch(node2, result2);
    return result2;
  }
  state.inTable = true;
  const { align, headless } = inspect(node2);
  const rows = state.toSpecificContent(state.all(node2), createRow);
  if (headless) {
    rows.unshift(createRow());
  }
  let rowIndex = -1;
  while (++rowIndex < rows.length) {
    const row2 = rows[rowIndex];
    const cells2 = state.toSpecificContent(row2.children, createCell);
    row2.children = cells2;
  }
  let columns = 1;
  rowIndex = -1;
  while (++rowIndex < rows.length) {
    const cells2 = rows[rowIndex].children;
    let cellIndex = -1;
    while (++cellIndex < cells2.length) {
      const cell2 = cells2[cellIndex];
      if (cell2.data) {
        const data = (
          /** @type {Record<string, unknown>} */
          cell2.data
        );
        const colSpan = Number.parseInt(String(data.hastUtilToMdastTemporaryColSpan), 10) || 1;
        const rowSpan = Number.parseInt(String(data.hastUtilToMdastTemporaryRowSpan), 10) || 1;
        if (colSpan > 1 || rowSpan > 1) {
          let otherRowIndex = rowIndex - 1;
          while (++otherRowIndex < rowIndex + rowSpan) {
            let colIndex = cellIndex - 1;
            while (++colIndex < cellIndex + colSpan) {
              if (!rows[otherRowIndex]) {
                break;
              }
              const newCells = [];
              if (otherRowIndex !== rowIndex || colIndex !== cellIndex) {
                newCells.push({ type: "tableCell", children: [] });
              }
              rows[otherRowIndex].children.splice(colIndex, 0, ...newCells);
            }
          }
        }
        if ("hastUtilToMdastTemporaryColSpan" in cell2.data)
          delete cell2.data.hastUtilToMdastTemporaryColSpan;
        if ("hastUtilToMdastTemporaryRowSpan" in cell2.data)
          delete cell2.data.hastUtilToMdastTemporaryRowSpan;
        if (Object.keys(cell2.data).length === 0) delete cell2.data;
      }
    }
    if (cells2.length > columns) columns = cells2.length;
  }
  rowIndex = -1;
  while (++rowIndex < rows.length) {
    const cells2 = rows[rowIndex].children;
    let cellIndex = cells2.length - 1;
    while (++cellIndex < columns) {
      cells2.push({ type: "tableCell", children: [] });
    }
  }
  let alignIndex = align.length - 1;
  while (++alignIndex < columns) {
    align.push(null);
  }
  state.inTable = false;
  const result = { type: "table", align, children: rows };
  state.patch(node2, result);
  return result;
}
function inspect(node2) {
  const info = { align: [null], headless: true };
  let rowIndex = 0;
  let cellIndex = 0;
  visit(node2, function(child) {
    if (child.type === "element") {
      if (child.tagName === "table" && node2 !== child) {
        return SKIP;
      }
      if ((child.tagName === "th" || child.tagName === "td") && child.properties) {
        if (!info.align[cellIndex]) {
          const value = String(child.properties.align || "") || null;
          if (value === "center" || value === "left" || value === "right" || value === null) {
            info.align[cellIndex] = value;
          }
        }
        if (info.headless && rowIndex < 2 && child.tagName === "th") {
          info.headless = false;
        }
        cellIndex++;
      } else if (child.tagName === "thead") {
        info.headless = false;
      } else if (child.tagName === "tr") {
        rowIndex++;
        cellIndex = 0;
      }
    }
  });
  return info;
}
function createCell() {
  return { type: "tableCell", children: [] };
}
function createRow() {
  return { type: "tableRow", children: [] };
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/text.js
function text2(state, node2) {
  const result = { type: "text", value: node2.value };
  state.patch(node2, result);
  return result;
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/textarea.js
function textarea(state, node2) {
  const result = { type: "text", value: toText(node2) };
  state.patch(node2, result);
  return result;
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/wbr.js
function wbr(state, node2) {
  const result = { type: "text", value: "" };
  state.patch(node2, result);
  return result;
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/handlers/index.js
var nodeHandlers = {
  comment,
  doctype: ignore,
  root,
  text: text2
};
var handlers = {
  // Ignore:
  applet: ignore,
  area: ignore,
  basefont: ignore,
  bgsound: ignore,
  caption: ignore,
  col: ignore,
  colgroup: ignore,
  command: ignore,
  content: ignore,
  datalist: ignore,
  dialog: ignore,
  element: ignore,
  embed: ignore,
  frame: ignore,
  frameset: ignore,
  isindex: ignore,
  keygen: ignore,
  link: ignore,
  math: ignore,
  menu: ignore,
  menuitem: ignore,
  meta: ignore,
  nextid: ignore,
  noembed: ignore,
  noframes: ignore,
  optgroup: ignore,
  option: ignore,
  param: ignore,
  script: ignore,
  shadow: ignore,
  source: ignore,
  spacer: ignore,
  style: ignore,
  svg: ignore,
  template: ignore,
  title: ignore,
  track: ignore,
  // Use children:
  abbr: all5,
  acronym: all5,
  bdi: all5,
  bdo: all5,
  big: all5,
  blink: all5,
  button: all5,
  canvas: all5,
  cite: all5,
  data: all5,
  details: all5,
  dfn: all5,
  font: all5,
  ins: all5,
  label: all5,
  map: all5,
  marquee: all5,
  meter: all5,
  nobr: all5,
  noscript: all5,
  object: all5,
  output: all5,
  progress: all5,
  rb: all5,
  rbc: all5,
  rp: all5,
  rt: all5,
  rtc: all5,
  ruby: all5,
  slot: all5,
  small: all5,
  span: all5,
  sup: all5,
  sub: all5,
  tbody: all5,
  tfoot: all5,
  thead: all5,
  time: all5,
  // Use children as flow.
  address: flow,
  article: flow,
  aside: flow,
  body: flow,
  center: flow,
  div: flow,
  fieldset: flow,
  figcaption: flow,
  figure: flow,
  form: flow,
  footer: flow,
  header: flow,
  hgroup: flow,
  html: flow,
  legend: flow,
  main: flow,
  multicol: flow,
  nav: flow,
  picture: flow,
  section: flow,
  // Handle.
  a,
  audio: media,
  b: strong,
  base: base2,
  blockquote,
  br: br2,
  code: inlineCode,
  dir: list2,
  dl,
  dt: li,
  dd: li,
  del,
  em,
  h1: heading,
  h2: heading,
  h3: heading,
  h4: heading,
  h5: heading,
  h6: heading,
  hr: hr2,
  i: em,
  iframe,
  img,
  image: img,
  input,
  kbd: inlineCode,
  li,
  listing: code,
  mark: em,
  ol: list2,
  p: p2,
  plaintext: code,
  pre: code,
  q: q2,
  s: del,
  samp: inlineCode,
  select,
  strike: del,
  strong,
  summary: p2,
  table,
  td: tableCell,
  textarea,
  th: tableCell,
  tr: tableRow,
  tt: inlineCode,
  u: em,
  ul: list2,
  var: inlineCode,
  video: media,
  wbr,
  xmp: code
};
function all5(state, node2) {
  return state.all(node2);
}
function flow(state, node2) {
  return state.toFlow(state.all(node2));
}
function ignore() {
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/state.js
var own3 = {}.hasOwnProperty;
function createState(options) {
  return {
    all: all6,
    baseFound: false,
    elementById: /* @__PURE__ */ new Map(),
    frozenBaseUrl: void 0,
    handlers: { ...handlers, ...options.handlers },
    inTable: false,
    nodeHandlers: { ...nodeHandlers, ...options.nodeHandlers },
    one: one3,
    options,
    patch: patch2,
    qNesting: 0,
    resolve,
    toFlow,
    toSpecificContent
  };
}
function all6(parent) {
  const children = parent.children || [];
  const results = [];
  let index4 = -1;
  while (++index4 < children.length) {
    const child = children[index4];
    const result = (
      /** @type {Array<MdastRootContent> | MdastRootContent | undefined} */
      this.one(child, parent)
    );
    if (Array.isArray(result)) {
      results.push(...result);
    } else if (result) {
      results.push(result);
    }
  }
  return results;
}
function one3(node2, parent) {
  if (node2.type === "element") {
    if (node2.properties && node2.properties.dataMdast === "ignore") {
      return;
    }
    if (own3.call(this.handlers, node2.tagName)) {
      return this.handlers[node2.tagName](this, node2, parent) || void 0;
    }
  } else if (own3.call(this.nodeHandlers, node2.type)) {
    return this.nodeHandlers[node2.type](this, node2, parent) || void 0;
  }
  if ("value" in node2 && typeof node2.value === "string") {
    const result = { type: "text", value: node2.value };
    this.patch(node2, result);
    return result;
  }
  if ("children" in node2) {
    return this.all(node2);
  }
}
function patch2(origin, node2) {
  if (origin.position) node2.position = position3(origin);
}
function resolve(url) {
  const base3 = this.frozenBaseUrl;
  if (url === null || url === void 0) {
    return "";
  }
  if (base3) {
    return String(new URL(url, base3));
  }
  return url;
}
function toFlow(nodes) {
  return wrap(nodes);
}
function toSpecificContent(nodes, build) {
  const reference = build();
  const results = [];
  let queue = [];
  let index4 = -1;
  while (++index4 < nodes.length) {
    const node2 = nodes[index4];
    if (expectedParent(node2)) {
      if (queue.length > 0) {
        node2.children.unshift(...queue);
        queue = [];
      }
      results.push(node2);
    } else {
      const child = (
        /** @type {ChildType} */
        node2
      );
      queue.push(child);
    }
  }
  if (queue.length > 0) {
    let node2 = results[results.length - 1];
    if (!node2) {
      node2 = build();
      results.push(node2);
    }
    node2.children.push(...queue);
    queue = [];
  }
  return results;
  function expectedParent(node2) {
    return node2.type === reference.type;
  }
}

// ../node_modules/.pnpm/hast-util-to-mdast@10.1.2/node_modules/hast-util-to-mdast/lib/index.js
var emptyOptions4 = {};
function toMdast(tree, options) {
  const cleanTree = esm_default(tree);
  const settings = options || emptyOptions4;
  const transformWhitespace = rehypeMinifyWhitespace({
    newlines: settings.newlines === true
  });
  const state = createState(settings);
  let mdast;
  transformWhitespace(cleanTree);
  visit(cleanTree, function(node2) {
    if (node2 && node2.type === "element" && node2.properties) {
      const id2 = String(node2.properties.id || "") || void 0;
      if (id2 && !state.elementById.has(id2)) {
        state.elementById.set(id2, node2);
      }
    }
  });
  const result = state.one(cleanTree, void 0);
  if (!result) {
    mdast = { type: "root", children: [] };
  } else if (Array.isArray(result)) {
    const children = (
      /** @type {Array<MdastRootContent>} */
      result
    );
    mdast = { type: "root", children };
  } else {
    mdast = result;
  }
  visit(mdast, function(node2, index4, parent) {
    if (node2.type === "text" && index4 !== void 0 && parent) {
      const previous3 = parent.children[index4 - 1];
      if (previous3 && previous3.type === node2.type) {
        previous3.value += node2.value;
        parent.children.splice(index4, 1);
        if (previous3.position && node2.position) {
          previous3.position.end = node2.position.end;
        }
        return index4 - 1;
      }
      node2.value = node2.value.replace(/[\t ]*(\r?\n|\r)[\t ]*/, "$1");
      if (parent && (parent.type === "heading" || parent.type === "paragraph" || parent.type === "root")) {
        if (!index4) {
          node2.value = node2.value.replace(/^[\t ]+/, "");
        }
        if (index4 === parent.children.length - 1) {
          node2.value = node2.value.replace(/[\t ]+$/, "");
        }
      }
      if (!node2.value) {
        parent.children.splice(index4, 1);
        return index4;
      }
    }
  });
  return mdast;
}

// ../node_modules/.pnpm/rehype-remark@10.0.1/node_modules/rehype-remark/lib/index.js
var defaults = { document: true };
function rehypeRemark(destination, options) {
  if (destination && "run" in destination) {
    return async function(tree, file) {
      const mdastTree = toMdast(tree, { ...defaults, ...options });
      await destination.run(mdastTree, file);
    };
  }
  return function(tree) {
    return (
      /** @type {MdastRoot} */
      toMdast(tree, { ...defaults, ...destination })
    );
  };
}

// ../node_modules/.pnpm/ccount@2.0.1/node_modules/ccount/index.js
function ccount(value, character) {
  const source = String(value);
  if (typeof character !== "string") {
    throw new TypeError("Expected character");
  }
  let count2 = 0;
  let index4 = source.indexOf(character);
  while (index4 !== -1) {
    count2++;
    index4 = source.indexOf(character, index4 + character.length);
  }
  return count2;
}

// ../node_modules/.pnpm/micromark-util-symbol@2.0.1/node_modules/micromark-util-symbol/lib/codes.js
var codes = (
  /** @type {const} */
  {
    carriageReturn: -5,
    lineFeed: -4,
    carriageReturnLineFeed: -3,
    horizontalTab: -2,
    virtualSpace: -1,
    eof: null,
    nul: 0,
    soh: 1,
    stx: 2,
    etx: 3,
    eot: 4,
    enq: 5,
    ack: 6,
    bel: 7,
    bs: 8,
    ht: 9,
    // `\t`
    lf: 10,
    // `\n`
    vt: 11,
    // `\v`
    ff: 12,
    // `\f`
    cr: 13,
    // `\r`
    so: 14,
    si: 15,
    dle: 16,
    dc1: 17,
    dc2: 18,
    dc3: 19,
    dc4: 20,
    nak: 21,
    syn: 22,
    etb: 23,
    can: 24,
    em: 25,
    sub: 26,
    esc: 27,
    fs: 28,
    gs: 29,
    rs: 30,
    us: 31,
    space: 32,
    exclamationMark: 33,
    // `!`
    quotationMark: 34,
    // `"`
    numberSign: 35,
    // `#`
    dollarSign: 36,
    // `$`
    percentSign: 37,
    // `%`
    ampersand: 38,
    // `&`
    apostrophe: 39,
    // `'`
    leftParenthesis: 40,
    // `(`
    rightParenthesis: 41,
    // `)`
    asterisk: 42,
    // `*`
    plusSign: 43,
    // `+`
    comma: 44,
    // `,`
    dash: 45,
    // `-`
    dot: 46,
    // `.`
    slash: 47,
    // `/`
    digit0: 48,
    // `0`
    digit1: 49,
    // `1`
    digit2: 50,
    // `2`
    digit3: 51,
    // `3`
    digit4: 52,
    // `4`
    digit5: 53,
    // `5`
    digit6: 54,
    // `6`
    digit7: 55,
    // `7`
    digit8: 56,
    // `8`
    digit9: 57,
    // `9`
    colon: 58,
    // `:`
    semicolon: 59,
    // `;`
    lessThan: 60,
    // `<`
    equalsTo: 61,
    // `=`
    greaterThan: 62,
    // `>`
    questionMark: 63,
    // `?`
    atSign: 64,
    // `@`
    uppercaseA: 65,
    // `A`
    uppercaseB: 66,
    // `B`
    uppercaseC: 67,
    // `C`
    uppercaseD: 68,
    // `D`
    uppercaseE: 69,
    // `E`
    uppercaseF: 70,
    // `F`
    uppercaseG: 71,
    // `G`
    uppercaseH: 72,
    // `H`
    uppercaseI: 73,
    // `I`
    uppercaseJ: 74,
    // `J`
    uppercaseK: 75,
    // `K`
    uppercaseL: 76,
    // `L`
    uppercaseM: 77,
    // `M`
    uppercaseN: 78,
    // `N`
    uppercaseO: 79,
    // `O`
    uppercaseP: 80,
    // `P`
    uppercaseQ: 81,
    // `Q`
    uppercaseR: 82,
    // `R`
    uppercaseS: 83,
    // `S`
    uppercaseT: 84,
    // `T`
    uppercaseU: 85,
    // `U`
    uppercaseV: 86,
    // `V`
    uppercaseW: 87,
    // `W`
    uppercaseX: 88,
    // `X`
    uppercaseY: 89,
    // `Y`
    uppercaseZ: 90,
    // `Z`
    leftSquareBracket: 91,
    // `[`
    backslash: 92,
    // `\`
    rightSquareBracket: 93,
    // `]`
    caret: 94,
    // `^`
    underscore: 95,
    // `_`
    graveAccent: 96,
    // `` ` ``
    lowercaseA: 97,
    // `a`
    lowercaseB: 98,
    // `b`
    lowercaseC: 99,
    // `c`
    lowercaseD: 100,
    // `d`
    lowercaseE: 101,
    // `e`
    lowercaseF: 102,
    // `f`
    lowercaseG: 103,
    // `g`
    lowercaseH: 104,
    // `h`
    lowercaseI: 105,
    // `i`
    lowercaseJ: 106,
    // `j`
    lowercaseK: 107,
    // `k`
    lowercaseL: 108,
    // `l`
    lowercaseM: 109,
    // `m`
    lowercaseN: 110,
    // `n`
    lowercaseO: 111,
    // `o`
    lowercaseP: 112,
    // `p`
    lowercaseQ: 113,
    // `q`
    lowercaseR: 114,
    // `r`
    lowercaseS: 115,
    // `s`
    lowercaseT: 116,
    // `t`
    lowercaseU: 117,
    // `u`
    lowercaseV: 118,
    // `v`
    lowercaseW: 119,
    // `w`
    lowercaseX: 120,
    // `x`
    lowercaseY: 121,
    // `y`
    lowercaseZ: 122,
    // `z`
    leftCurlyBrace: 123,
    // `{`
    verticalBar: 124,
    // `|`
    rightCurlyBrace: 125,
    // `}`
    tilde: 126,
    // `~`
    del: 127,
    // Unicode Specials block.
    byteOrderMarker: 65279,
    // Unicode Specials block.
    replacementCharacter: 65533
    // ``
  }
);

// ../node_modules/.pnpm/micromark-util-symbol@2.0.1/node_modules/micromark-util-symbol/lib/constants.js
var constants = (
  /** @type {const} */
  {
    attentionSideAfter: 2,
    // Symbol to mark an attention sequence as after content: `a*`
    attentionSideBefore: 1,
    // Symbol to mark an attention sequence as before content: `*a`
    atxHeadingOpeningFenceSizeMax: 6,
    // 6 number signs is fine, 7 isnt.
    autolinkDomainSizeMax: 63,
    // 63 characters is fine, 64 is too many.
    autolinkSchemeSizeMax: 32,
    // 32 characters is fine, 33 is too many.
    cdataOpeningString: "CDATA[",
    // And preceded by `<![`.
    characterGroupPunctuation: 2,
    // Symbol used to indicate a character is punctuation
    characterGroupWhitespace: 1,
    // Symbol used to indicate a character is whitespace
    characterReferenceDecimalSizeMax: 7,
    // `&#9999999;`.
    characterReferenceHexadecimalSizeMax: 6,
    // `&#xff9999;`.
    characterReferenceNamedSizeMax: 31,
    // `&CounterClockwiseContourIntegral;`.
    codeFencedSequenceSizeMin: 3,
    // At least 3 ticks or tildes are needed.
    contentTypeContent: "content",
    contentTypeDocument: "document",
    contentTypeFlow: "flow",
    contentTypeString: "string",
    contentTypeText: "text",
    hardBreakPrefixSizeMin: 2,
    // At least 2 trailing spaces are needed.
    htmlBasic: 6,
    // Symbol for `<div`
    htmlCdata: 5,
    // Symbol for `<![CDATA[]]>`
    htmlComment: 2,
    // Symbol for `<!---->`
    htmlComplete: 7,
    // Symbol for `<x>`
    htmlDeclaration: 4,
    // Symbol for `<!doctype>`
    htmlInstruction: 3,
    // Symbol for `<?php?>`
    htmlRawSizeMax: 8,
    // Length of `textarea`.
    htmlRaw: 1,
    // Symbol for `<script>`
    linkResourceDestinationBalanceMax: 32,
    // See: <https://spec.commonmark.org/0.30/#link-destination>, <https://github.com/remarkjs/react-markdown/issues/658#issuecomment-984345577>
    linkReferenceSizeMax: 999,
    // See: <https://spec.commonmark.org/0.30/#link-label>
    listItemValueSizeMax: 10,
    // See: <https://spec.commonmark.org/0.30/#ordered-list-marker>
    numericBaseDecimal: 10,
    numericBaseHexadecimal: 16,
    tabSize: 4,
    // Tabs have a hard-coded size of 4, per CommonMark.
    thematicBreakMarkerCountMin: 3,
    // At least 3 asterisks, dashes, or underscores are needed.
    v8MaxSafeChunkSize: 1e4
    // V8 (and potentially others) have problems injecting giant arrays into other arrays, hence we operate in chunks.
  }
);

// ../node_modules/.pnpm/micromark-util-symbol@2.0.1/node_modules/micromark-util-symbol/lib/types.js
var types = (
  /** @type {const} */
  {
    // Generic type for data, such as in a title, a destination, etc.
    data: "data",
    // Generic type for syntactic whitespace (tabs, virtual spaces, spaces).
    // Such as, between a fenced code fence and an info string.
    whitespace: "whitespace",
    // Generic type for line endings (line feed, carriage return, carriage return +
    // line feed).
    lineEnding: "lineEnding",
    // A line ending, but ending a blank line.
    lineEndingBlank: "lineEndingBlank",
    // Generic type for whitespace (tabs, virtual spaces, spaces) at the start of a
    // line.
    linePrefix: "linePrefix",
    // Generic type for whitespace (tabs, virtual spaces, spaces) at the end of a
    // line.
    lineSuffix: "lineSuffix",
    // Whole ATX heading:
    //
    // ```markdown
    // #
    // ## Alpha
    // ### Bravo ###
    // ```
    //
    // Includes `atxHeadingSequence`, `whitespace`, `atxHeadingText`.
    atxHeading: "atxHeading",
    // Sequence of number signs in an ATX heading (`###`).
    atxHeadingSequence: "atxHeadingSequence",
    // Content in an ATX heading (`alpha`).
    // Includes text.
    atxHeadingText: "atxHeadingText",
    // Whole autolink (`<https://example.com>` or `<admin@example.com>`)
    // Includes `autolinkMarker` and `autolinkProtocol` or `autolinkEmail`.
    autolink: "autolink",
    // Email autolink w/o markers (`admin@example.com`)
    autolinkEmail: "autolinkEmail",
    // Marker around an `autolinkProtocol` or `autolinkEmail` (`<` or `>`).
    autolinkMarker: "autolinkMarker",
    // Protocol autolink w/o markers (`https://example.com`)
    autolinkProtocol: "autolinkProtocol",
    // A whole character escape (`\-`).
    // Includes `escapeMarker` and `characterEscapeValue`.
    characterEscape: "characterEscape",
    // The escaped character (`-`).
    characterEscapeValue: "characterEscapeValue",
    // A whole character reference (`&amp;`, `&#8800;`, or `&#x1D306;`).
    // Includes `characterReferenceMarker`, an optional
    // `characterReferenceMarkerNumeric`, in which case an optional
    // `characterReferenceMarkerHexadecimal`, and a `characterReferenceValue`.
    characterReference: "characterReference",
    // The start or end marker (`&` or `;`).
    characterReferenceMarker: "characterReferenceMarker",
    // Mark reference as numeric (`#`).
    characterReferenceMarkerNumeric: "characterReferenceMarkerNumeric",
    // Mark reference as numeric (`x` or `X`).
    characterReferenceMarkerHexadecimal: "characterReferenceMarkerHexadecimal",
    // Value of character reference w/o markers (`amp`, `8800`, or `1D306`).
    characterReferenceValue: "characterReferenceValue",
    // Whole fenced code:
    //
    // ````markdown
    // ```js
    // alert(1)
    // ```
    // ````
    codeFenced: "codeFenced",
    // A fenced code fence, including whitespace, sequence, info, and meta
    // (` ```js `).
    codeFencedFence: "codeFencedFence",
    // Sequence of grave accent or tilde characters (` ``` `) in a fence.
    codeFencedFenceSequence: "codeFencedFenceSequence",
    // Info word (`js`) in a fence.
    // Includes string.
    codeFencedFenceInfo: "codeFencedFenceInfo",
    // Meta words (`highlight="1"`) in a fence.
    // Includes string.
    codeFencedFenceMeta: "codeFencedFenceMeta",
    // A line of code.
    codeFlowValue: "codeFlowValue",
    // Whole indented code:
    //
    // ```markdown
    //     alert(1)
    // ```
    //
    // Includes `lineEnding`, `linePrefix`, and `codeFlowValue`.
    codeIndented: "codeIndented",
    // A text code (``` `alpha` ```).
    // Includes `codeTextSequence`, `codeTextData`, `lineEnding`, and can include
    // `codeTextPadding`.
    codeText: "codeText",
    codeTextData: "codeTextData",
    // A space or line ending right after or before a tick.
    codeTextPadding: "codeTextPadding",
    // A text code fence (` `` `).
    codeTextSequence: "codeTextSequence",
    // Whole content:
    //
    // ```markdown
    // [a]: b
    // c
    // =
    // d
    // ```
    //
    // Includes `paragraph` and `definition`.
    content: "content",
    // Whole definition:
    //
    // ```markdown
    // [micromark]: https://github.com/micromark/micromark
    // ```
    //
    // Includes `definitionLabel`, `definitionMarker`, `whitespace`,
    // `definitionDestination`, and optionally `lineEnding` and `definitionTitle`.
    definition: "definition",
    // Destination of a definition (`https://github.com/micromark/micromark` or
    // `<https://github.com/micromark/micromark>`).
    // Includes `definitionDestinationLiteral` or `definitionDestinationRaw`.
    definitionDestination: "definitionDestination",
    // Enclosed destination of a definition
    // (`<https://github.com/micromark/micromark>`).
    // Includes `definitionDestinationLiteralMarker` and optionally
    // `definitionDestinationString`.
    definitionDestinationLiteral: "definitionDestinationLiteral",
    // Markers of an enclosed definition destination (`<` or `>`).
    definitionDestinationLiteralMarker: "definitionDestinationLiteralMarker",
    // Unenclosed destination of a definition
    // (`https://github.com/micromark/micromark`).
    // Includes `definitionDestinationString`.
    definitionDestinationRaw: "definitionDestinationRaw",
    // Text in an destination (`https://github.com/micromark/micromark`).
    // Includes string.
    definitionDestinationString: "definitionDestinationString",
    // Label of a definition (`[micromark]`).
    // Includes `definitionLabelMarker` and `definitionLabelString`.
    definitionLabel: "definitionLabel",
    // Markers of a definition label (`[` or `]`).
    definitionLabelMarker: "definitionLabelMarker",
    // Value of a definition label (`micromark`).
    // Includes string.
    definitionLabelString: "definitionLabelString",
    // Marker between a label and a destination (`:`).
    definitionMarker: "definitionMarker",
    // Title of a definition (`"x"`, `'y'`, or `(z)`).
    // Includes `definitionTitleMarker` and optionally `definitionTitleString`.
    definitionTitle: "definitionTitle",
    // Marker around a title of a definition (`"`, `'`, `(`, or `)`).
    definitionTitleMarker: "definitionTitleMarker",
    // Data without markers in a title (`z`).
    // Includes string.
    definitionTitleString: "definitionTitleString",
    // Emphasis (`*alpha*`).
    // Includes `emphasisSequence` and `emphasisText`.
    emphasis: "emphasis",
    // Sequence of emphasis markers (`*` or `_`).
    emphasisSequence: "emphasisSequence",
    // Emphasis text (`alpha`).
    // Includes text.
    emphasisText: "emphasisText",
    // The character escape marker (`\`).
    escapeMarker: "escapeMarker",
    // A hard break created with a backslash (`\\n`).
    // Note: does not include the line ending.
    hardBreakEscape: "hardBreakEscape",
    // A hard break created with trailing spaces (`  \n`).
    // Does not include the line ending.
    hardBreakTrailing: "hardBreakTrailing",
    // Flow HTML:
    //
    // ```markdown
    // <div
    // ```
    //
    // Inlcudes `lineEnding`, `htmlFlowData`.
    htmlFlow: "htmlFlow",
    htmlFlowData: "htmlFlowData",
    // HTML in text (the tag in `a <i> b`).
    // Includes `lineEnding`, `htmlTextData`.
    htmlText: "htmlText",
    htmlTextData: "htmlTextData",
    // Whole image (`![alpha](bravo)`, `![alpha][bravo]`, `![alpha][]`, or
    // `![alpha]`).
    // Includes `label` and an optional `resource` or `reference`.
    image: "image",
    // Whole link label (`[*alpha*]`).
    // Includes `labelLink` or `labelImage`, `labelText`, and `labelEnd`.
    label: "label",
    // Text in an label (`*alpha*`).
    // Includes text.
    labelText: "labelText",
    // Start a link label (`[`).
    // Includes a `labelMarker`.
    labelLink: "labelLink",
    // Start an image label (`![`).
    // Includes `labelImageMarker` and `labelMarker`.
    labelImage: "labelImage",
    // Marker of a label (`[` or `]`).
    labelMarker: "labelMarker",
    // Marker to start an image (`!`).
    labelImageMarker: "labelImageMarker",
    // End a label (`]`).
    // Includes `labelMarker`.
    labelEnd: "labelEnd",
    // Whole link (`[alpha](bravo)`, `[alpha][bravo]`, `[alpha][]`, or `[alpha]`).
    // Includes `label` and an optional `resource` or `reference`.
    link: "link",
    // Whole paragraph:
    //
    // ```markdown
    // alpha
    // bravo.
    // ```
    //
    // Includes text.
    paragraph: "paragraph",
    // A reference (`[alpha]` or `[]`).
    // Includes `referenceMarker` and an optional `referenceString`.
    reference: "reference",
    // A reference marker (`[` or `]`).
    referenceMarker: "referenceMarker",
    // Reference text (`alpha`).
    // Includes string.
    referenceString: "referenceString",
    // A resource (`(https://example.com "alpha")`).
    // Includes `resourceMarker`, an optional `resourceDestination` with an optional
    // `whitespace` and `resourceTitle`.
    resource: "resource",
    // A resource destination (`https://example.com`).
    // Includes `resourceDestinationLiteral` or `resourceDestinationRaw`.
    resourceDestination: "resourceDestination",
    // A literal resource destination (`<https://example.com>`).
    // Includes `resourceDestinationLiteralMarker` and optionally
    // `resourceDestinationString`.
    resourceDestinationLiteral: "resourceDestinationLiteral",
    // A resource destination marker (`<` or `>`).
    resourceDestinationLiteralMarker: "resourceDestinationLiteralMarker",
    // A raw resource destination (`https://example.com`).
    // Includes `resourceDestinationString`.
    resourceDestinationRaw: "resourceDestinationRaw",
    // Resource destination text (`https://example.com`).
    // Includes string.
    resourceDestinationString: "resourceDestinationString",
    // A resource marker (`(` or `)`).
    resourceMarker: "resourceMarker",
    // A resource title (`"alpha"`, `'alpha'`, or `(alpha)`).
    // Includes `resourceTitleMarker` and optionally `resourceTitleString`.
    resourceTitle: "resourceTitle",
    // A resource title marker (`"`, `'`, `(`, or `)`).
    resourceTitleMarker: "resourceTitleMarker",
    // Resource destination title (`alpha`).
    // Includes string.
    resourceTitleString: "resourceTitleString",
    // Whole setext heading:
    //
    // ```markdown
    // alpha
    // bravo
    // =====
    // ```
    //
    // Includes `setextHeadingText`, `lineEnding`, `linePrefix`, and
    // `setextHeadingLine`.
    setextHeading: "setextHeading",
    // Content in a setext heading (`alpha\nbravo`).
    // Includes text.
    setextHeadingText: "setextHeadingText",
    // Underline in a setext heading, including whitespace suffix (`==`).
    // Includes `setextHeadingLineSequence`.
    setextHeadingLine: "setextHeadingLine",
    // Sequence of equals or dash characters in underline in a setext heading (`-`).
    setextHeadingLineSequence: "setextHeadingLineSequence",
    // Strong (`**alpha**`).
    // Includes `strongSequence` and `strongText`.
    strong: "strong",
    // Sequence of strong markers (`**` or `__`).
    strongSequence: "strongSequence",
    // Strong text (`alpha`).
    // Includes text.
    strongText: "strongText",
    // Whole thematic break:
    //
    // ```markdown
    // * * *
    // ```
    //
    // Includes `thematicBreakSequence` and `whitespace`.
    thematicBreak: "thematicBreak",
    // A sequence of one or more thematic break markers (`***`).
    thematicBreakSequence: "thematicBreakSequence",
    // Whole block quote:
    //
    // ```markdown
    // > a
    // >
    // > b
    // ```
    //
    // Includes `blockQuotePrefix` and flow.
    blockQuote: "blockQuote",
    // The `>` or `> ` of a block quote.
    blockQuotePrefix: "blockQuotePrefix",
    // The `>` of a block quote prefix.
    blockQuoteMarker: "blockQuoteMarker",
    // The optional ` ` of a block quote prefix.
    blockQuotePrefixWhitespace: "blockQuotePrefixWhitespace",
    // Whole ordered list:
    //
    // ```markdown
    // 1. a
    //    b
    // ```
    //
    // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
    // lines.
    listOrdered: "listOrdered",
    // Whole unordered list:
    //
    // ```markdown
    // - a
    //   b
    // ```
    //
    // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
    // lines.
    listUnordered: "listUnordered",
    // The indent of further list item lines.
    listItemIndent: "listItemIndent",
    // A marker, as in, `*`, `+`, `-`, `.`, or `)`.
    listItemMarker: "listItemMarker",
    // The thing that starts a list item, such as `1. `.
    // Includes `listItemValue` if ordered, `listItemMarker`, and
    // `listItemPrefixWhitespace` (unless followed by a line ending).
    listItemPrefix: "listItemPrefix",
    // The whitespace after a marker.
    listItemPrefixWhitespace: "listItemPrefixWhitespace",
    // The numerical value of an ordered item.
    listItemValue: "listItemValue",
    // Internal types used for subtokenizers, compiled away
    chunkDocument: "chunkDocument",
    chunkContent: "chunkContent",
    chunkFlow: "chunkFlow",
    chunkText: "chunkText",
    chunkString: "chunkString"
  }
);

// ../node_modules/.pnpm/micromark-util-symbol@2.0.1/node_modules/micromark-util-symbol/lib/values.js
var values = (
  /** @type {const} */
  {
    ht: "	",
    lf: "\n",
    cr: "\r",
    space: " ",
    exclamationMark: "!",
    quotationMark: '"',
    numberSign: "#",
    dollarSign: "$",
    percentSign: "%",
    ampersand: "&",
    apostrophe: "'",
    leftParenthesis: "(",
    rightParenthesis: ")",
    asterisk: "*",
    plusSign: "+",
    comma: ",",
    dash: "-",
    dot: ".",
    slash: "/",
    digit0: "0",
    digit1: "1",
    digit2: "2",
    digit3: "3",
    digit4: "4",
    digit5: "5",
    digit6: "6",
    digit7: "7",
    digit8: "8",
    digit9: "9",
    colon: ":",
    semicolon: ";",
    lessThan: "<",
    equalsTo: "=",
    greaterThan: ">",
    questionMark: "?",
    atSign: "@",
    uppercaseA: "A",
    uppercaseB: "B",
    uppercaseC: "C",
    uppercaseD: "D",
    uppercaseE: "E",
    uppercaseF: "F",
    uppercaseG: "G",
    uppercaseH: "H",
    uppercaseI: "I",
    uppercaseJ: "J",
    uppercaseK: "K",
    uppercaseL: "L",
    uppercaseM: "M",
    uppercaseN: "N",
    uppercaseO: "O",
    uppercaseP: "P",
    uppercaseQ: "Q",
    uppercaseR: "R",
    uppercaseS: "S",
    uppercaseT: "T",
    uppercaseU: "U",
    uppercaseV: "V",
    uppercaseW: "W",
    uppercaseX: "X",
    uppercaseY: "Y",
    uppercaseZ: "Z",
    leftSquareBracket: "[",
    backslash: "\\",
    rightSquareBracket: "]",
    caret: "^",
    underscore: "_",
    graveAccent: "`",
    lowercaseA: "a",
    lowercaseB: "b",
    lowercaseC: "c",
    lowercaseD: "d",
    lowercaseE: "e",
    lowercaseF: "f",
    lowercaseG: "g",
    lowercaseH: "h",
    lowercaseI: "i",
    lowercaseJ: "j",
    lowercaseK: "k",
    lowercaseL: "l",
    lowercaseM: "m",
    lowercaseN: "n",
    lowercaseO: "o",
    lowercaseP: "p",
    lowercaseQ: "q",
    lowercaseR: "r",
    lowercaseS: "s",
    lowercaseT: "t",
    lowercaseU: "u",
    lowercaseV: "v",
    lowercaseW: "w",
    lowercaseX: "x",
    lowercaseY: "y",
    lowercaseZ: "z",
    leftCurlyBrace: "{",
    verticalBar: "|",
    rightCurlyBrace: "}",
    tilde: "~",
    replacementCharacter: ""
  }
);

// ../node_modules/.pnpm/micromark-util-character@2.1.1/node_modules/micromark-util-character/dev/index.js
var asciiAlpha = regexCheck(/[A-Za-z]/);
var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code5) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code5 !== null && (code5 < codes.space || code5 === codes.del)
  );
}
var asciiDigit = regexCheck(/\d/);
var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(code5) {
  return code5 !== null && code5 < codes.horizontalTab;
}
function markdownLineEndingOrSpace(code5) {
  return code5 !== null && (code5 < codes.nul || code5 === codes.space);
}
function markdownSpace(code5) {
  return code5 === codes.horizontalTab || code5 === codes.virtualSpace || code5 === codes.space;
}
var unicodePunctuation = regexCheck(new RegExp("\\p{P}|\\p{S}", "u"));
var unicodeWhitespace = regexCheck(/\s/);
function regexCheck(regex) {
  return check;
  function check(code5) {
    return code5 !== null && code5 > -1 && regex.test(String.fromCharCode(code5));
  }
}

// ../node_modules/.pnpm/escape-string-regexp@5.0.0/node_modules/escape-string-regexp/index.js
function escapeStringRegexp(string3) {
  if (typeof string3 !== "string") {
    throw new TypeError("Expected a string");
  }
  return string3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}

// ../node_modules/.pnpm/mdast-util-find-and-replace@3.0.2/node_modules/mdast-util-find-and-replace/lib/index.js
function findAndReplace(tree, list7, options) {
  const settings = options || {};
  const ignored = convert(settings.ignore || []);
  const pairs = toPairs(list7);
  let pairIndex = -1;
  while (++pairIndex < pairs.length) {
    visitParents(tree, "text", visitor);
  }
  function visitor(node2, parents) {
    let index4 = -1;
    let grandparent;
    while (++index4 < parents.length) {
      const parent = parents[index4];
      const siblings2 = grandparent ? grandparent.children : void 0;
      if (ignored(
        parent,
        siblings2 ? siblings2.indexOf(parent) : void 0,
        grandparent
      )) {
        return;
      }
      grandparent = parent;
    }
    if (grandparent) {
      return handler(node2, parents);
    }
  }
  function handler(node2, parents) {
    const parent = parents[parents.length - 1];
    const find4 = pairs[pairIndex][0];
    const replace2 = pairs[pairIndex][1];
    let start = 0;
    const siblings2 = parent.children;
    const index4 = siblings2.indexOf(node2);
    let change = false;
    let nodes = [];
    find4.lastIndex = 0;
    let match = find4.exec(node2.value);
    while (match) {
      const position4 = match.index;
      const matchObject = {
        index: match.index,
        input: match.input,
        stack: [...parents, node2]
      };
      let value = replace2(...match, matchObject);
      if (typeof value === "string") {
        value = value.length > 0 ? { type: "text", value } : void 0;
      }
      if (value === false) {
        find4.lastIndex = position4 + 1;
      } else {
        if (start !== position4) {
          nodes.push({
            type: "text",
            value: node2.value.slice(start, position4)
          });
        }
        if (Array.isArray(value)) {
          nodes.push(...value);
        } else if (value) {
          nodes.push(value);
        }
        start = position4 + match[0].length;
        change = true;
      }
      if (!find4.global) {
        break;
      }
      match = find4.exec(node2.value);
    }
    if (change) {
      if (start < node2.value.length) {
        nodes.push({ type: "text", value: node2.value.slice(start) });
      }
      parent.children.splice(index4, 1, ...nodes);
    } else {
      nodes = [node2];
    }
    return index4 + nodes.length;
  }
}
function toPairs(tupleOrList) {
  const result = [];
  if (!Array.isArray(tupleOrList)) {
    throw new TypeError("Expected find and replace tuple or list of tuples");
  }
  const list7 = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList];
  let index4 = -1;
  while (++index4 < list7.length) {
    const tuple = list7[index4];
    result.push([toExpression(tuple[0]), toFunction(tuple[1])]);
  }
  return result;
}
function toExpression(find4) {
  return typeof find4 === "string" ? new RegExp(escapeStringRegexp(find4), "g") : find4;
}
function toFunction(replace2) {
  return typeof replace2 === "function" ? replace2 : function() {
    return replace2;
  };
}

// ../node_modules/.pnpm/mdast-util-gfm-autolink-literal@2.0.1/node_modules/mdast-util-gfm-autolink-literal/lib/index.js
var inConstruct = "phrasing";
var notInConstruct = ["autolink", "link", "image", "label"];
function gfmAutolinkLiteralFromMarkdown() {
  return {
    transforms: [transformGfmAutolinkLiterals],
    enter: {
      literalAutolink: enterLiteralAutolink,
      literalAutolinkEmail: enterLiteralAutolinkValue,
      literalAutolinkHttp: enterLiteralAutolinkValue,
      literalAutolinkWww: enterLiteralAutolinkValue
    },
    exit: {
      literalAutolink: exitLiteralAutolink,
      literalAutolinkEmail: exitLiteralAutolinkEmail,
      literalAutolinkHttp: exitLiteralAutolinkHttp,
      literalAutolinkWww: exitLiteralAutolinkWww
    }
  };
}
function gfmAutolinkLiteralToMarkdown() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct,
        notInConstruct
      }
    ]
  };
}
function enterLiteralAutolink(token) {
  this.enter({ type: "link", title: null, url: "", children: [] }, token);
}
function enterLiteralAutolinkValue(token) {
  this.config.enter.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkHttp(token) {
  this.config.exit.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkWww(token) {
  this.config.exit.data.call(this, token);
  const node2 = this.stack[this.stack.length - 1];
  ok(node2.type === "link");
  node2.url = "http://" + this.sliceSerialize(token);
}
function exitLiteralAutolinkEmail(token) {
  this.config.exit.autolinkEmail.call(this, token);
}
function exitLiteralAutolink(token) {
  this.exit(token);
}
function transformGfmAutolinkLiterals(tree) {
  findAndReplace(
    tree,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), findEmail]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function findUrl(_, protocol, domain2, path2, match) {
  let prefix3 = "";
  if (!previous(match)) {
    return false;
  }
  if (/^w/i.test(protocol)) {
    domain2 = protocol + domain2;
    protocol = "";
    prefix3 = "http://";
  }
  if (!isCorrectDomain(domain2)) {
    return false;
  }
  const parts = splitUrl(domain2 + path2);
  if (!parts[0]) return false;
  const result = {
    type: "link",
    title: null,
    url: prefix3 + protocol + parts[0],
    children: [{ type: "text", value: protocol + parts[0] }]
  };
  if (parts[1]) {
    return [result, { type: "text", value: parts[1] }];
  }
  return result;
}
function findEmail(_, atext, label, match) {
  if (
    // Not an expected previous character.
    !previous(match, true) || // Label ends in not allowed character.
    /[-\d_]$/.test(label)
  ) {
    return false;
  }
  return {
    type: "link",
    title: null,
    url: "mailto:" + atext + "@" + label,
    children: [{ type: "text", value: atext + "@" + label }]
  };
}
function isCorrectDomain(domain2) {
  const parts = domain2.split(".");
  if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
    return false;
  }
  return true;
}
function splitUrl(url) {
  const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
  if (!trailExec) {
    return [url, void 0];
  }
  url = url.slice(0, trailExec.index);
  let trail2 = trailExec[0];
  let closingParenIndex = trail2.indexOf(")");
  const openingParens = ccount(url, "(");
  let closingParens = ccount(url, ")");
  while (closingParenIndex !== -1 && openingParens > closingParens) {
    url += trail2.slice(0, closingParenIndex + 1);
    trail2 = trail2.slice(closingParenIndex + 1);
    closingParenIndex = trail2.indexOf(")");
    closingParens++;
  }
  return [url, trail2];
}
function previous(match, email) {
  const code5 = match.input.charCodeAt(match.index - 1);
  return (match.index === 0 || unicodeWhitespace(code5) || unicodePunctuation(code5)) && // If its an email, the previous character should not be a slash.
  (!email || code5 !== 47);
}

// ../node_modules/.pnpm/micromark-util-normalize-identifier@2.0.1/node_modules/micromark-util-normalize-identifier/dev/index.js
function normalizeIdentifier(value) {
  return value.replace(/[\t\n\r ]+/g, values.space).replace(/^ | $/g, "").toLowerCase().toUpperCase();
}

// ../node_modules/.pnpm/mdast-util-gfm-footnote@2.1.0/node_modules/mdast-util-gfm-footnote/lib/index.js
footnoteReference.peek = footnoteReferencePeek;
function enterFootnoteCallString() {
  this.buffer();
}
function enterFootnoteCall(token) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, token);
}
function enterFootnoteDefinitionLabelString() {
  this.buffer();
}
function enterFootnoteDefinition(token) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    token
  );
}
function exitFootnoteCallString(token) {
  const label = this.resume();
  const node2 = this.stack[this.stack.length - 1];
  ok(node2.type === "footnoteReference");
  node2.identifier = normalizeIdentifier(
    this.sliceSerialize(token)
  ).toLowerCase();
  node2.label = label;
}
function exitFootnoteCall(token) {
  this.exit(token);
}
function exitFootnoteDefinitionLabelString(token) {
  const label = this.resume();
  const node2 = this.stack[this.stack.length - 1];
  ok(node2.type === "footnoteDefinition");
  node2.identifier = normalizeIdentifier(
    this.sliceSerialize(token)
  ).toLowerCase();
  node2.label = label;
}
function exitFootnoteDefinition(token) {
  this.exit(token);
}
function footnoteReferencePeek() {
  return "[";
}
function footnoteReference(node2, _, state, info) {
  const tracker = state.createTracker(info);
  let value = tracker.move("[^");
  const exit3 = state.enter("footnoteReference");
  const subexit = state.enter("reference");
  value += tracker.move(
    state.safe(state.associationId(node2), { after: "]", before: value })
  );
  subexit();
  exit3();
  value += tracker.move("]");
  return value;
}
function gfmFootnoteFromMarkdown() {
  return {
    enter: {
      gfmFootnoteCallString: enterFootnoteCallString,
      gfmFootnoteCall: enterFootnoteCall,
      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
      gfmFootnoteDefinition: enterFootnoteDefinition
    },
    exit: {
      gfmFootnoteCallString: exitFootnoteCallString,
      gfmFootnoteCall: exitFootnoteCall,
      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
      gfmFootnoteDefinition: exitFootnoteDefinition
    }
  };
}
function gfmFootnoteToMarkdown(options) {
  let firstLineBlank = false;
  if (options && options.firstLineBlank) {
    firstLineBlank = true;
  }
  return {
    handlers: { footnoteDefinition, footnoteReference },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function footnoteDefinition(node2, _, state, info) {
    const tracker = state.createTracker(info);
    let value = tracker.move("[^");
    const exit3 = state.enter("footnoteDefinition");
    const subexit = state.enter("label");
    value += tracker.move(
      state.safe(state.associationId(node2), { before: value, after: "]" })
    );
    subexit();
    value += tracker.move("]:");
    if (node2.children && node2.children.length > 0) {
      tracker.shift(4);
      value += tracker.move(
        (firstLineBlank ? "\n" : " ") + state.indentLines(
          state.containerFlow(node2, tracker.current()),
          firstLineBlank ? mapAll : mapExceptFirst
        )
      );
    }
    exit3();
    return value;
  }
}
function mapExceptFirst(line, index4, blank) {
  return index4 === 0 ? line : mapAll(line, index4, blank);
}
function mapAll(line, index4, blank) {
  return (blank ? "" : "    ") + line;
}

// ../node_modules/.pnpm/mdast-util-gfm-strikethrough@2.0.0/node_modules/mdast-util-gfm-strikethrough/lib/index.js
var constructsWithoutStrikethrough = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
handleDelete.peek = peekDelete;
function gfmStrikethroughFromMarkdown() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: enterStrikethrough },
    exit: { strikethrough: exitStrikethrough }
  };
}
function gfmStrikethroughToMarkdown() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: constructsWithoutStrikethrough
      }
    ],
    handlers: { delete: handleDelete }
  };
}
function enterStrikethrough(token) {
  this.enter({ type: "delete", children: [] }, token);
}
function exitStrikethrough(token) {
  this.exit(token);
}
function handleDelete(node2, _, state, info) {
  const tracker = state.createTracker(info);
  const exit3 = state.enter("strikethrough");
  let value = tracker.move("~~");
  value += state.containerPhrasing(node2, {
    ...tracker.current(),
    before: value,
    after: "~"
  });
  value += tracker.move("~~");
  exit3();
  return value;
}
function peekDelete() {
  return "~";
}

// ../node_modules/.pnpm/markdown-table@3.0.4/node_modules/markdown-table/index.js
function defaultStringLength(value) {
  return value.length;
}
function markdownTable(table3, options) {
  const settings = options || {};
  const align = (settings.align || []).concat();
  const stringLength = settings.stringLength || defaultStringLength;
  const alignments2 = [];
  const cellMatrix = [];
  const sizeMatrix = [];
  const longestCellByColumn = [];
  let mostCellsPerRow = 0;
  let rowIndex = -1;
  while (++rowIndex < table3.length) {
    const row3 = [];
    const sizes2 = [];
    let columnIndex2 = -1;
    if (table3[rowIndex].length > mostCellsPerRow) {
      mostCellsPerRow = table3[rowIndex].length;
    }
    while (++columnIndex2 < table3[rowIndex].length) {
      const cell2 = serialize3(table3[rowIndex][columnIndex2]);
      if (settings.alignDelimiters !== false) {
        const size5 = stringLength(cell2);
        sizes2[columnIndex2] = size5;
        if (longestCellByColumn[columnIndex2] === void 0 || size5 > longestCellByColumn[columnIndex2]) {
          longestCellByColumn[columnIndex2] = size5;
        }
      }
      row3.push(cell2);
    }
    cellMatrix[rowIndex] = row3;
    sizeMatrix[rowIndex] = sizes2;
  }
  let columnIndex = -1;
  if (typeof align === "object" && "length" in align) {
    while (++columnIndex < mostCellsPerRow) {
      alignments2[columnIndex] = toAlignment(align[columnIndex]);
    }
  } else {
    const code5 = toAlignment(align);
    while (++columnIndex < mostCellsPerRow) {
      alignments2[columnIndex] = code5;
    }
  }
  columnIndex = -1;
  const row2 = [];
  const sizes = [];
  while (++columnIndex < mostCellsPerRow) {
    const code5 = alignments2[columnIndex];
    let before = "";
    let after = "";
    if (code5 === 99) {
      before = ":";
      after = ":";
    } else if (code5 === 108) {
      before = ":";
    } else if (code5 === 114) {
      after = ":";
    }
    let size5 = settings.alignDelimiters === false ? 1 : Math.max(
      1,
      longestCellByColumn[columnIndex] - before.length - after.length
    );
    const cell2 = before + "-".repeat(size5) + after;
    if (settings.alignDelimiters !== false) {
      size5 = before.length + size5 + after.length;
      if (size5 > longestCellByColumn[columnIndex]) {
        longestCellByColumn[columnIndex] = size5;
      }
      sizes[columnIndex] = size5;
    }
    row2[columnIndex] = cell2;
  }
  cellMatrix.splice(1, 0, row2);
  sizeMatrix.splice(1, 0, sizes);
  rowIndex = -1;
  const lines = [];
  while (++rowIndex < cellMatrix.length) {
    const row3 = cellMatrix[rowIndex];
    const sizes2 = sizeMatrix[rowIndex];
    columnIndex = -1;
    const line = [];
    while (++columnIndex < mostCellsPerRow) {
      const cell2 = row3[columnIndex] || "";
      let before = "";
      let after = "";
      if (settings.alignDelimiters !== false) {
        const size5 = longestCellByColumn[columnIndex] - (sizes2[columnIndex] || 0);
        const code5 = alignments2[columnIndex];
        if (code5 === 114) {
          before = " ".repeat(size5);
        } else if (code5 === 99) {
          if (size5 % 2) {
            before = " ".repeat(size5 / 2 + 0.5);
            after = " ".repeat(size5 / 2 - 0.5);
          } else {
            before = " ".repeat(size5 / 2);
            after = before;
          }
        } else {
          after = " ".repeat(size5);
        }
      }
      if (settings.delimiterStart !== false && !columnIndex) {
        line.push("|");
      }
      if (settings.padding !== false && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(settings.alignDelimiters === false && cell2 === "") && (settings.delimiterStart !== false || columnIndex)) {
        line.push(" ");
      }
      if (settings.alignDelimiters !== false) {
        line.push(before);
      }
      line.push(cell2);
      if (settings.alignDelimiters !== false) {
        line.push(after);
      }
      if (settings.padding !== false) {
        line.push(" ");
      }
      if (settings.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
        line.push("|");
      }
    }
    lines.push(
      settings.delimiterEnd === false ? line.join("").replace(/ +$/, "") : line.join("")
    );
  }
  return lines.join("\n");
}
function serialize3(value) {
  return value === null || value === void 0 ? "" : String(value);
}
function toAlignment(value) {
  const code5 = typeof value === "string" ? value.codePointAt(0) : 0;
  return code5 === 67 || code5 === 99 ? 99 : code5 === 76 || code5 === 108 ? 108 : code5 === 82 || code5 === 114 ? 114 : 0;
}

// ../node_modules/.pnpm/zwitch@2.0.4/node_modules/zwitch/index.js
var own4 = {}.hasOwnProperty;
function zwitch(key2, options) {
  const settings = options || {};
  function one6(value, ...parameters) {
    let fn3 = one6.invalid;
    const handlers3 = one6.handlers;
    if (value && own4.call(value, key2)) {
      const id2 = String(value[key2]);
      fn3 = own4.call(handlers3, id2) ? handlers3[id2] : one6.unknown;
    }
    if (fn3) {
      return fn3.call(this, value, ...parameters);
    }
  }
  one6.handlers = settings.handlers || {};
  one6.invalid = settings.invalid;
  one6.unknown = settings.unknown;
  return one6;
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/configure.js
var own5 = {}.hasOwnProperty;
function configure(base3, extension2) {
  let index4 = -1;
  let key2;
  if (extension2.extensions) {
    while (++index4 < extension2.extensions.length) {
      configure(base3, extension2.extensions[index4]);
    }
  }
  for (key2 in extension2) {
    if (own5.call(extension2, key2)) {
      switch (key2) {
        case "extensions": {
          break;
        }
        /* c8 ignore next 4 */
        case "unsafe": {
          list3(base3[key2], extension2[key2]);
          break;
        }
        case "join": {
          list3(base3[key2], extension2[key2]);
          break;
        }
        case "handlers": {
          map3(base3[key2], extension2[key2]);
          break;
        }
        default: {
          base3.options[key2] = extension2[key2];
        }
      }
    }
  }
  return base3;
}
function list3(left, right) {
  if (right) {
    left.push(...right);
  }
}
function map3(left, right) {
  if (right) {
    Object.assign(left, right);
  }
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/handle/blockquote.js
function blockquote2(node2, _, state, info) {
  const exit3 = state.enter("blockquote");
  const tracker = state.createTracker(info);
  tracker.move("> ");
  tracker.shift(2);
  const value = state.indentLines(
    state.containerFlow(node2, tracker.current()),
    map4
  );
  exit3();
  return value;
}
function map4(line, _, blank) {
  return ">" + (blank ? "" : " ") + line;
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js
function patternInScope(stack, pattern) {
  return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
}
function listInScope(stack, list7, none) {
  if (typeof list7 === "string") {
    list7 = [list7];
  }
  if (!list7 || list7.length === 0) {
    return none;
  }
  let index4 = -1;
  while (++index4 < list7.length) {
    if (stack.includes(list7[index4])) {
      return true;
    }
  }
  return false;
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/handle/break.js
function hardBreak(_, _1, state, info) {
  let index4 = -1;
  while (++index4 < state.unsafe.length) {
    if (state.unsafe[index4].character === "\n" && patternInScope(state.stack, state.unsafe[index4])) {
      return /[ \t]/.test(info.before) ? "" : " ";
    }
  }
  return "\\\n";
}

// ../node_modules/.pnpm/longest-streak@3.1.0/node_modules/longest-streak/index.js
function longestStreak(value, substring) {
  const source = String(value);
  let index4 = source.indexOf(substring);
  let expected = index4;
  let count2 = 0;
  let max3 = 0;
  if (typeof substring !== "string") {
    throw new TypeError("Expected substring");
  }
  while (index4 !== -1) {
    if (index4 === expected) {
      if (++count2 > max3) {
        max3 = count2;
      }
    } else {
      count2 = 1;
    }
    expected = index4 + substring.length;
    index4 = source.indexOf(substring, expected);
  }
  return max3;
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js
function formatCodeAsIndented(node2, state) {
  return Boolean(
    state.options.fences === false && node2.value && // If theres no info
    !node2.lang && // And theres a non-whitespace character
    /[^ \r\n]/.test(node2.value) && // And the value doesnt start or end in a blank
    !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node2.value)
  );
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/check-fence.js
function checkFence(state) {
  const marker = state.options.fence || "`";
  if (marker !== "`" && marker !== "~") {
    throw new Error(
      "Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`"
    );
  }
  return marker;
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/handle/code.js
function code2(node2, _, state, info) {
  const marker = checkFence(state);
  const raw2 = node2.value || "";
  const suffix = marker === "`" ? "GraveAccent" : "Tilde";
  if (formatCodeAsIndented(node2, state)) {
    const exit4 = state.enter("codeIndented");
    const value2 = state.indentLines(raw2, map5);
    exit4();
    return value2;
  }
  const tracker = state.createTracker(info);
  const sequence = marker.repeat(Math.max(longestStreak(raw2, marker) + 1, 3));
  const exit3 = state.enter("codeFenced");
  let value = tracker.move(sequence);
  if (node2.lang) {
    const subexit = state.enter(`codeFencedLang${suffix}`);
    value += tracker.move(
      state.safe(node2.lang, {
        before: value,
        after: " ",
        encode: ["`"],
        ...tracker.current()
      })
    );
    subexit();
  }
  if (node2.lang && node2.meta) {
    const subexit = state.enter(`codeFencedMeta${suffix}`);
    value += tracker.move(" ");
    value += tracker.move(
      state.safe(node2.meta, {
        before: value,
        after: "\n",
        encode: ["`"],
        ...tracker.current()
      })
    );
    subexit();
  }
  value += tracker.move("\n");
  if (raw2) {
    value += tracker.move(raw2 + "\n");
  }
  value += tracker.move(sequence);
  exit3();
  return value;
}
function map5(line, _, blank) {
  return (blank ? "" : "    ") + line;
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/check-quote.js
function checkQuote(state) {
  const marker = state.options.quote || '"';
  if (marker !== '"' && marker !== "'") {
    throw new Error(
      "Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`"
    );
  }
  return marker;
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/handle/definition.js
function definition(node2, _, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit3 = state.enter("definition");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("[");
  value += tracker.move(
    state.safe(state.associationId(node2), {
      before: value,
      after: "]",
      ...tracker.current()
    })
  );
  value += tracker.move("]: ");
  subexit();
  if (
    // If theres no url, or
    !node2.url || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : "\n",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  exit3();
  return value;
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js
function checkEmphasis(state) {
  const marker = state.options.emphasis || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error(
      "Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`"
    );
  }
  return marker;
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/encode-character-reference.js
function encodeCharacterReference(code5) {
  return "&#x" + code5.toString(16).toUpperCase() + ";";
}

// ../node_modules/.pnpm/micromark-util-classify-character@2.0.1/node_modules/micromark-util-classify-character/dev/index.js
function classifyCharacter(code5) {
  if (code5 === codes.eof || markdownLineEndingOrSpace(code5) || unicodeWhitespace(code5)) {
    return constants.characterGroupWhitespace;
  }
  if (unicodePunctuation(code5)) {
    return constants.characterGroupPunctuation;
  }
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/encode-info.js
function encodeInfo(outside, inside, marker) {
  const outsideKind = classifyCharacter(outside);
  const insideKind = classifyCharacter(inside);
  if (outsideKind === void 0) {
    return insideKind === void 0 ? (
      // Letter inside:
      // we have to encode *both* letters for `_` as it is looser.
      // it already forms for `*` (and GFMs `~`).
      marker === "_" ? { inside: true, outside: true } : { inside: false, outside: false }
    ) : insideKind === 1 ? (
      // Whitespace inside: encode both (letter, whitespace).
      { inside: true, outside: true }
    ) : (
      // Punctuation inside: encode outer (letter)
      { inside: false, outside: true }
    );
  }
  if (outsideKind === 1) {
    return insideKind === void 0 ? (
      // Letter inside: already forms.
      { inside: false, outside: false }
    ) : insideKind === 1 ? (
      // Whitespace inside: encode both (whitespace).
      { inside: true, outside: true }
    ) : (
      // Punctuation inside: already forms.
      { inside: false, outside: false }
    );
  }
  return insideKind === void 0 ? (
    // Letter inside: already forms.
    { inside: false, outside: false }
  ) : insideKind === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: true, outside: false }
  ) : (
    // Punctuation inside: already forms.
    { inside: false, outside: false }
  );
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/handle/emphasis.js
emphasis.peek = emphasisPeek;
function emphasis(node2, _, state, info) {
  const marker = checkEmphasis(state);
  const exit3 = state.enter("emphasis");
  const tracker = state.createTracker(info);
  const before = tracker.move(marker);
  let between2 = tracker.move(
    state.containerPhrasing(node2, {
      after: marker,
      before,
      ...tracker.current()
    })
  );
  const betweenHead = between2.charCodeAt(0);
  const open = encodeInfo(
    info.before.charCodeAt(info.before.length - 1),
    betweenHead,
    marker
  );
  if (open.inside) {
    between2 = encodeCharacterReference(betweenHead) + between2.slice(1);
  }
  const betweenTail = between2.charCodeAt(between2.length - 1);
  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker);
  if (close.inside) {
    between2 = between2.slice(0, -1) + encodeCharacterReference(betweenTail);
  }
  const after = tracker.move(marker);
  exit3();
  state.attentionEncodeSurroundingInfo = {
    after: close.outside,
    before: open.outside
  };
  return before + between2 + after;
}
function emphasisPeek(_, _1, state) {
  return state.options.emphasis || "*";
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js
function formatHeadingAsSetext(node2, state) {
  let literalWithBreak = false;
  visit(node2, function(node3) {
    if ("value" in node3 && /\r?\n|\r/.test(node3.value) || node3.type === "break") {
      literalWithBreak = true;
      return EXIT;
    }
  });
  return Boolean(
    (!node2.depth || node2.depth < 3) && toString2(node2) && (state.options.setext || literalWithBreak)
  );
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/handle/heading.js
function heading2(node2, _, state, info) {
  const rank = Math.max(Math.min(6, node2.depth || 1), 1);
  const tracker = state.createTracker(info);
  if (formatHeadingAsSetext(node2, state)) {
    const exit4 = state.enter("headingSetext");
    const subexit2 = state.enter("phrasing");
    const value2 = state.containerPhrasing(node2, {
      ...tracker.current(),
      before: "\n",
      after: "\n"
    });
    subexit2();
    exit4();
    return value2 + "\n" + (rank === 1 ? "=" : "-").repeat(
      // The whole size
      value2.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(value2.lastIndexOf("\r"), value2.lastIndexOf("\n")) + 1)
    );
  }
  const sequence = "#".repeat(rank);
  const exit3 = state.enter("headingAtx");
  const subexit = state.enter("phrasing");
  tracker.move(sequence + " ");
  let value = state.containerPhrasing(node2, {
    before: "# ",
    after: "\n",
    ...tracker.current()
  });
  if (/^[\t ]/.test(value)) {
    value = encodeCharacterReference(value.charCodeAt(0)) + value.slice(1);
  }
  value = value ? sequence + " " + value : sequence;
  if (state.options.closeAtx) {
    value += " " + sequence;
  }
  subexit();
  exit3();
  return value;
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/handle/html.js
html3.peek = htmlPeek;
function html3(node2) {
  return node2.value || "";
}
function htmlPeek() {
  return "<";
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/handle/image.js
image.peek = imagePeek;
function image(node2, _, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit3 = state.enter("image");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("![");
  value += tracker.move(
    state.safe(node2.alt, { before: value, after: "]", ...tracker.current() })
  );
  value += tracker.move("](");
  subexit();
  if (
    // If theres no url but there is a title
    !node2.url && node2.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  value += tracker.move(")");
  exit3();
  return value;
}
function imagePeek() {
  return "!";
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/handle/image-reference.js
imageReference.peek = imageReferencePeek;
function imageReference(node2, _, state, info) {
  const type = node2.referenceType;
  const exit3 = state.enter("imageReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("![");
  const alt = state.safe(node2.alt, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(alt + "][");
  subexit();
  const stack = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node2), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack;
  exit3();
  if (type === "full" || !alt || alt !== reference) {
    value += tracker.move(reference + "]");
  } else if (type === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function imageReferencePeek() {
  return "!";
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/handle/inline-code.js
inlineCode2.peek = inlineCodePeek;
function inlineCode2(node2, _, state) {
  let value = node2.value || "";
  let sequence = "`";
  let index4 = -1;
  while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
    sequence += "`";
  }
  if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
    value = " " + value + " ";
  }
  while (++index4 < state.unsafe.length) {
    const pattern = state.unsafe[index4];
    const expression = state.compilePattern(pattern);
    let match;
    if (!pattern.atBreak) continue;
    while (match = expression.exec(value)) {
      let position4 = match.index;
      if (value.charCodeAt(position4) === 10 && value.charCodeAt(position4 - 1) === 13) {
        position4--;
      }
      value = value.slice(0, position4) + " " + value.slice(match.index + 1);
    }
  }
  return sequence + value + sequence;
}
function inlineCodePeek() {
  return "`";
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js
function formatLinkAsAutolink(node2, state) {
  const raw2 = toString2(node2);
  return Boolean(
    !state.options.resourceLink && // If theres a url
    node2.url && // And theres a no title
    !node2.title && // And the content of `node` is a single text node
    node2.children && node2.children.length === 1 && node2.children[0].type === "text" && // And if the url is the same as the content
    (raw2 === node2.url || "mailto:" + raw2 === node2.url) && // And that starts w/ a protocol
    /^[a-z][a-z+.-]+:/i.test(node2.url) && // And that doesnt contain ASCII control codes (character escapes and
    // references dont work), space, or angle brackets
    !/[\0- <>\u007F]/.test(node2.url)
  );
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/handle/link.js
link.peek = linkPeek;
function link(node2, _, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const tracker = state.createTracker(info);
  let exit3;
  let subexit;
  if (formatLinkAsAutolink(node2, state)) {
    const stack = state.stack;
    state.stack = [];
    exit3 = state.enter("autolink");
    let value2 = tracker.move("<");
    value2 += tracker.move(
      state.containerPhrasing(node2, {
        before: value2,
        after: ">",
        ...tracker.current()
      })
    );
    value2 += tracker.move(">");
    exit3();
    state.stack = stack;
    return value2;
  }
  exit3 = state.enter("link");
  subexit = state.enter("label");
  let value = tracker.move("[");
  value += tracker.move(
    state.containerPhrasing(node2, {
      before: value,
      after: "](",
      ...tracker.current()
    })
  );
  value += tracker.move("](");
  subexit();
  if (
    // If theres no url but there is a title
    !node2.url && node2.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  value += tracker.move(")");
  exit3();
  return value;
}
function linkPeek(node2, _, state) {
  return formatLinkAsAutolink(node2, state) ? "<" : "[";
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/handle/link-reference.js
linkReference.peek = linkReferencePeek;
function linkReference(node2, _, state, info) {
  const type = node2.referenceType;
  const exit3 = state.enter("linkReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("[");
  const text10 = state.containerPhrasing(node2, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(text10 + "][");
  subexit();
  const stack = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node2), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack;
  exit3();
  if (type === "full" || !text10 || text10 !== reference) {
    value += tracker.move(reference + "]");
  } else if (type === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function linkReferencePeek() {
  return "[";
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/check-bullet.js
function checkBullet(state) {
  const marker = state.options.bullet || "*";
  if (marker !== "*" && marker !== "+" && marker !== "-") {
    throw new Error(
      "Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  }
  return marker;
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js
function checkBulletOther(state) {
  const bullet = checkBullet(state);
  const bulletOther = state.options.bulletOther;
  if (!bulletOther) {
    return bullet === "*" ? "-" : "*";
  }
  if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
    throw new Error(
      "Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  }
  if (bulletOther === bullet) {
    throw new Error(
      "Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different"
    );
  }
  return bulletOther;
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js
function checkBulletOrdered(state) {
  const marker = state.options.bulletOrdered || ".";
  if (marker !== "." && marker !== ")") {
    throw new Error(
      "Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  }
  return marker;
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/check-rule.js
function checkRule(state) {
  const marker = state.options.rule || "*";
  if (marker !== "*" && marker !== "-" && marker !== "_") {
    throw new Error(
      "Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  }
  return marker;
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/handle/list.js
function list4(node2, parent, state, info) {
  const exit3 = state.enter("list");
  const bulletCurrent = state.bulletCurrent;
  let bullet = node2.ordered ? checkBulletOrdered(state) : checkBullet(state);
  const bulletOther = node2.ordered ? bullet === "." ? ")" : "." : checkBulletOther(state);
  let useDifferentMarker = parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false;
  if (!node2.ordered) {
    const firstListItem = node2.children ? node2.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (bullet === "*" || bullet === "-") && // Empty first list item:
      firstListItem && (!firstListItem.children || !firstListItem.children[0]) && // Directly in two other list items:
      state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && // That are each the first child.
      state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0
    ) {
      useDifferentMarker = true;
    }
    if (checkRule(state) === bullet && firstListItem) {
      let index4 = -1;
      while (++index4 < node2.children.length) {
        const item = node2.children[index4];
        if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
          useDifferentMarker = true;
          break;
        }
      }
    }
  }
  if (useDifferentMarker) {
    bullet = bulletOther;
  }
  state.bulletCurrent = bullet;
  const value = state.containerFlow(node2, info);
  state.bulletLastUsed = bullet;
  state.bulletCurrent = bulletCurrent;
  exit3();
  return value;
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js
function checkListItemIndent(state) {
  const style3 = state.options.listItemIndent || "one";
  if (style3 !== "tab" && style3 !== "one" && style3 !== "mixed") {
    throw new Error(
      "Cannot serialize items with `" + style3 + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  }
  return style3;
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/handle/list-item.js
function listItem(node2, parent, state, info) {
  const listItemIndent = checkListItemIndent(state);
  let bullet = state.bulletCurrent || checkBullet(state);
  if (parent && parent.type === "list" && parent.ordered) {
    bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node2)) + bullet;
  }
  let size5 = bullet.length + 1;
  if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node2.spread)) {
    size5 = Math.ceil(size5 / 4) * 4;
  }
  const tracker = state.createTracker(info);
  tracker.move(bullet + " ".repeat(size5 - bullet.length));
  tracker.shift(size5);
  const exit3 = state.enter("listItem");
  const value = state.indentLines(
    state.containerFlow(node2, tracker.current()),
    map6
  );
  exit3();
  return value;
  function map6(line, index4, blank) {
    if (index4) {
      return (blank ? "" : " ".repeat(size5)) + line;
    }
    return (blank ? bullet : bullet + " ".repeat(size5 - bullet.length)) + line;
  }
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/handle/paragraph.js
function paragraph(node2, _, state, info) {
  const exit3 = state.enter("paragraph");
  const subexit = state.enter("phrasing");
  const value = state.containerPhrasing(node2, info);
  subexit();
  exit3();
  return value;
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/handle/root.js
function root2(node2, _, state, info) {
  const hasPhrasing = node2.children.some(function(d) {
    return phrasing2(d);
  });
  const container = hasPhrasing ? state.containerPhrasing : state.containerFlow;
  return container.call(state, node2, info);
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/check-strong.js
function checkStrong(state) {
  const marker = state.options.strong || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error(
      "Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`"
    );
  }
  return marker;
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/handle/strong.js
strong2.peek = strongPeek;
function strong2(node2, _, state, info) {
  const marker = checkStrong(state);
  const exit3 = state.enter("strong");
  const tracker = state.createTracker(info);
  const before = tracker.move(marker + marker);
  let between2 = tracker.move(
    state.containerPhrasing(node2, {
      after: marker,
      before,
      ...tracker.current()
    })
  );
  const betweenHead = between2.charCodeAt(0);
  const open = encodeInfo(
    info.before.charCodeAt(info.before.length - 1),
    betweenHead,
    marker
  );
  if (open.inside) {
    between2 = encodeCharacterReference(betweenHead) + between2.slice(1);
  }
  const betweenTail = between2.charCodeAt(between2.length - 1);
  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker);
  if (close.inside) {
    between2 = between2.slice(0, -1) + encodeCharacterReference(betweenTail);
  }
  const after = tracker.move(marker + marker);
  exit3();
  state.attentionEncodeSurroundingInfo = {
    after: close.outside,
    before: open.outside
  };
  return before + between2 + after;
}
function strongPeek(_, _1, state) {
  return state.options.strong || "*";
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/handle/text.js
function text3(node2, _, state, info) {
  return state.safe(node2.value, info);
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js
function checkRuleRepetition(state) {
  const repetition = state.options.ruleRepetition || 3;
  if (repetition < 3) {
    throw new Error(
      "Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more"
    );
  }
  return repetition;
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js
function thematicBreak(_, _1, state) {
  const value = (checkRule(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state));
  return state.options.ruleSpaces ? value.slice(0, -1) : value;
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/handle/index.js
var handle2 = {
  blockquote: blockquote2,
  break: hardBreak,
  code: code2,
  definition,
  emphasis,
  hardBreak,
  heading: heading2,
  html: html3,
  image,
  imageReference,
  inlineCode: inlineCode2,
  link,
  linkReference,
  list: list4,
  listItem,
  paragraph,
  root: root2,
  strong: strong2,
  text: text3,
  thematicBreak
};

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/join.js
var join2 = [joinDefaults];
function joinDefaults(left, right, parent, state) {
  if (right.type === "code" && formatCodeAsIndented(right, state) && (left.type === "list" || left.type === right.type && formatCodeAsIndented(left, state))) {
    return false;
  }
  if ("spread" in parent && typeof parent.spread === "boolean") {
    if (left.type === "paragraph" && // Two paragraphs.
    (left.type === right.type || right.type === "definition" || // Paragraph followed by a setext heading.
    right.type === "heading" && formatHeadingAsSetext(right, state))) {
      return;
    }
    return parent.spread ? 1 : 0;
  }
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/unsafe.js
var fullPhrasingSpans = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
var unsafe = [
  { character: "	", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: "	", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: "	",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  {
    character: "\r",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  {
    character: "\n",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  { character: " ", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: " ", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: " ",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  // An exclamation mark can start an image, if it is followed by a link or
  // a link reference.
  {
    character: "!",
    after: "\\[",
    inConstruct: "phrasing",
    notInConstruct: fullPhrasingSpans
  },
  // A quote can break out of a title.
  { character: '"', inConstruct: "titleQuote" },
  // A number sign could start an ATX heading if it starts a line.
  { atBreak: true, character: "#" },
  { character: "#", inConstruct: "headingAtx", after: "(?:[\r\n]|$)" },
  // Dollar sign and percentage are not used in markdown.
  // An ampersand could start a character reference.
  { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
  // An apostrophe can break out of a title.
  { character: "'", inConstruct: "titleApostrophe" },
  // A left paren could break out of a destination raw.
  { character: "(", inConstruct: "destinationRaw" },
  // A left paren followed by `]` could make something into a link or image.
  {
    before: "\\]",
    character: "(",
    inConstruct: "phrasing",
    notInConstruct: fullPhrasingSpans
  },
  // A right paren could start a list item or break out of a destination
  // raw.
  { atBreak: true, before: "\\d+", character: ")" },
  { character: ")", inConstruct: "destinationRaw" },
  // An asterisk can start thematic breaks, list items, emphasis, strong.
  { atBreak: true, character: "*", after: "(?:[ 	\r\n*])" },
  { character: "*", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  // A plus sign could start a list item.
  { atBreak: true, character: "+", after: "(?:[ 	\r\n])" },
  // A dash can start thematic breaks, list items, and setext heading
  // underlines.
  { atBreak: true, character: "-", after: "(?:[ 	\r\n-])" },
  // A dot could start a list item.
  { atBreak: true, before: "\\d+", character: ".", after: "(?:[ 	\r\n]|$)" },
  // Slash, colon, and semicolon are not used in markdown for constructs.
  // A less than can start html (flow or text) or an autolink.
  // HTML could start with an exclamation mark (declaration, cdata, comment),
  // slash (closing tag), question mark (instruction), or a letter (tag).
  // An autolink also starts with a letter.
  // Finally, it could break out of a destination literal.
  { atBreak: true, character: "<", after: "[!/?A-Za-z]" },
  {
    character: "<",
    after: "[!/?A-Za-z]",
    inConstruct: "phrasing",
    notInConstruct: fullPhrasingSpans
  },
  { character: "<", inConstruct: "destinationLiteral" },
  // An equals to can start setext heading underlines.
  { atBreak: true, character: "=" },
  // A greater than can start block quotes and it can break out of a
  // destination literal.
  { atBreak: true, character: ">" },
  { character: ">", inConstruct: "destinationLiteral" },
  // Question mark and at sign are not used in markdown for constructs.
  // A left bracket can start definitions, references, labels,
  { atBreak: true, character: "[" },
  { character: "[", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  { character: "[", inConstruct: ["label", "reference"] },
  // A backslash can start an escape (when followed by punctuation) or a
  // hard break (when followed by an eol).
  // Note: typical escapes are handled in `safe`!
  { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
  // A right bracket can exit labels.
  { character: "]", inConstruct: ["label", "reference"] },
  // Caret is not used in markdown for constructs.
  // An underscore can start emphasis, strong, or a thematic break.
  { atBreak: true, character: "_" },
  { character: "_", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  // A grave accent can start code (fenced or text), or it can break out of
  // a grave accent code fence.
  { atBreak: true, character: "`" },
  {
    character: "`",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedMetaGraveAccent"]
  },
  { character: "`", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  // Left brace, vertical bar, right brace are not used in markdown for
  // constructs.
  // A tilde can start code (fenced).
  { atBreak: true, character: "~" }
];

// ../node_modules/.pnpm/decode-named-character-reference@1.2.0/node_modules/decode-named-character-reference/index.dom.js
var element4 = document.createElement("i");
function decodeNamedCharacterReference(value) {
  const characterReference2 = "&" + value + ";";
  element4.innerHTML = characterReference2;
  const character = element4.textContent;
  if (
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    character.charCodeAt(character.length - 1) === 59 && value !== "semi"
  ) {
    return false;
  }
  return character === characterReference2 ? false : character;
}

// ../node_modules/.pnpm/micromark-util-decode-numeric-character-reference@2.0.2/node_modules/micromark-util-decode-numeric-character-reference/dev/index.js
function decodeNumericCharacterReference(value, base3) {
  const code5 = Number.parseInt(value, base3);
  if (
    // C0 except for HT, LF, FF, CR, space.
    code5 < codes.ht || code5 === codes.vt || code5 > codes.cr && code5 < codes.space || // Control character (DEL) of C0, and C1 controls.
    code5 > codes.tilde && code5 < 160 || // Lone high surrogates and low surrogates.
    code5 > 55295 && code5 < 57344 || // Noncharacters.
    code5 > 64975 && code5 < 65008 || /* eslint-disable no-bitwise */
    (code5 & 65535) === 65535 || (code5 & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    code5 > 1114111
  ) {
    return values.replacementCharacter;
  }
  return String.fromCodePoint(code5);
}

// ../node_modules/.pnpm/micromark-util-decode-string@2.0.1/node_modules/micromark-util-decode-string/dev/index.js
var characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value) {
  return value.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $22) {
  if ($1) {
    return $1;
  }
  const head2 = $22.charCodeAt(0);
  if (head2 === codes.numberSign) {
    const head3 = $22.charCodeAt(1);
    const hex = head3 === codes.lowercaseX || head3 === codes.uppercaseX;
    return decodeNumericCharacterReference(
      $22.slice(hex ? 2 : 1),
      hex ? constants.numericBaseHexadecimal : constants.numericBaseDecimal
    );
  }
  return decodeNamedCharacterReference($22) || $0;
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/association.js
function association(node2) {
  if (node2.label || !node2.identifier) {
    return node2.label || "";
  }
  return decodeString(node2.identifier);
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/compile-pattern.js
function compilePattern(pattern) {
  if (!pattern._compiled) {
    const before = (pattern.atBreak ? "[\\r\\n][\\t ]*" : "") + (pattern.before ? "(?:" + pattern.before + ")" : "");
    pattern._compiled = new RegExp(
      (before ? "(" + before + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? "\\" : "") + pattern.character + (pattern.after ? "(?:" + pattern.after + ")" : ""),
      "g"
    );
  }
  return pattern._compiled;
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js
function containerPhrasing(parent, state, info) {
  const indexStack = state.indexStack;
  const children = parent.children || [];
  const results = [];
  let index4 = -1;
  let before = info.before;
  let encodeAfter;
  indexStack.push(-1);
  let tracker = state.createTracker(info);
  while (++index4 < children.length) {
    const child = children[index4];
    let after;
    indexStack[indexStack.length - 1] = index4;
    if (index4 + 1 < children.length) {
      let handle4 = state.handle.handlers[children[index4 + 1].type];
      if (handle4 && handle4.peek) handle4 = handle4.peek;
      after = handle4 ? handle4(children[index4 + 1], parent, state, {
        before: "",
        after: "",
        ...tracker.current()
      }).charAt(0) : "";
    } else {
      after = info.after;
    }
    if (results.length > 0 && (before === "\r" || before === "\n") && child.type === "html") {
      results[results.length - 1] = results[results.length - 1].replace(
        /(\r?\n|\r)$/,
        " "
      );
      before = " ";
      tracker = state.createTracker(info);
      tracker.move(results.join(""));
    }
    let value = state.handle(child, parent, state, {
      ...tracker.current(),
      after,
      before
    });
    if (encodeAfter && encodeAfter === value.slice(0, 1)) {
      value = encodeCharacterReference(encodeAfter.charCodeAt(0)) + value.slice(1);
    }
    const encodingInfo = state.attentionEncodeSurroundingInfo;
    state.attentionEncodeSurroundingInfo = void 0;
    encodeAfter = void 0;
    if (encodingInfo) {
      if (results.length > 0 && encodingInfo.before && before === results[results.length - 1].slice(-1)) {
        results[results.length - 1] = results[results.length - 1].slice(0, -1) + encodeCharacterReference(before.charCodeAt(0));
      }
      if (encodingInfo.after) encodeAfter = after;
    }
    tracker.move(value);
    results.push(value);
    before = value.slice(-1);
  }
  indexStack.pop();
  return results.join("");
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/container-flow.js
function containerFlow(parent, state, info) {
  const indexStack = state.indexStack;
  const children = parent.children || [];
  const tracker = state.createTracker(info);
  const results = [];
  let index4 = -1;
  indexStack.push(-1);
  while (++index4 < children.length) {
    const child = children[index4];
    indexStack[indexStack.length - 1] = index4;
    results.push(
      tracker.move(
        state.handle(child, parent, state, {
          before: "\n",
          after: "\n",
          ...tracker.current()
        })
      )
    );
    if (child.type !== "list") {
      state.bulletLastUsed = void 0;
    }
    if (index4 < children.length - 1) {
      results.push(
        tracker.move(between(child, children[index4 + 1], parent, state))
      );
    }
  }
  indexStack.pop();
  return results.join("");
}
function between(left, right, parent, state) {
  let index4 = state.join.length;
  while (index4--) {
    const result = state.join[index4](left, right, parent, state);
    if (result === true || result === 1) {
      break;
    }
    if (typeof result === "number") {
      return "\n".repeat(1 + result);
    }
    if (result === false) {
      return "\n\n<!---->\n\n";
    }
  }
  return "\n\n";
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/indent-lines.js
var eol = /\r?\n|\r/g;
function indentLines(value, map6) {
  const result = [];
  let start = 0;
  let line = 0;
  let match;
  while (match = eol.exec(value)) {
    one6(value.slice(start, match.index));
    result.push(match[0]);
    start = match.index + match[0].length;
    line++;
  }
  one6(value.slice(start));
  return result.join("");
  function one6(value2) {
    result.push(map6(value2, line, !value2));
  }
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/safe.js
function safe(state, input2, config) {
  const value = (config.before || "") + (input2 || "") + (config.after || "");
  const positions = [];
  const result = [];
  const infos = {};
  let index4 = -1;
  while (++index4 < state.unsafe.length) {
    const pattern = state.unsafe[index4];
    if (!patternInScope(state.stack, pattern)) {
      continue;
    }
    const expression = state.compilePattern(pattern);
    let match;
    while (match = expression.exec(value)) {
      const before = "before" in pattern || Boolean(pattern.atBreak);
      const after = "after" in pattern;
      const position4 = match.index + (before ? match[1].length : 0);
      if (positions.includes(position4)) {
        if (infos[position4].before && !before) {
          infos[position4].before = false;
        }
        if (infos[position4].after && !after) {
          infos[position4].after = false;
        }
      } else {
        positions.push(position4);
        infos[position4] = { before, after };
      }
    }
  }
  positions.sort(numerical);
  let start = config.before ? config.before.length : 0;
  const end = value.length - (config.after ? config.after.length : 0);
  index4 = -1;
  while (++index4 < positions.length) {
    const position4 = positions[index4];
    if (position4 < start || position4 >= end) {
      continue;
    }
    if (position4 + 1 < end && positions[index4 + 1] === position4 + 1 && infos[position4].after && !infos[position4 + 1].before && !infos[position4 + 1].after || positions[index4 - 1] === position4 - 1 && infos[position4].before && !infos[position4 - 1].before && !infos[position4 - 1].after) {
      continue;
    }
    if (start !== position4) {
      result.push(escapeBackslashes(value.slice(start, position4), "\\"));
    }
    start = position4;
    if (/[!-/:-@[-`{-~]/.test(value.charAt(position4)) && (!config.encode || !config.encode.includes(value.charAt(position4)))) {
      result.push("\\");
    } else {
      result.push(encodeCharacterReference(value.charCodeAt(position4)));
      start++;
    }
  }
  result.push(escapeBackslashes(value.slice(start, end), config.after));
  return result.join("");
}
function numerical(a2, b2) {
  return a2 - b2;
}
function escapeBackslashes(value, after) {
  const expression = /\\(?=[!-/:-@[-`{-~])/g;
  const positions = [];
  const results = [];
  const whole = value + after;
  let index4 = -1;
  let start = 0;
  let match;
  while (match = expression.exec(whole)) {
    positions.push(match.index);
  }
  while (++index4 < positions.length) {
    if (start !== positions[index4]) {
      results.push(value.slice(start, positions[index4]));
    }
    results.push("\\");
    start = positions[index4];
  }
  results.push(value.slice(start));
  return results.join("");
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/util/track.js
function track(config) {
  const options = config || {};
  const now = options.now || {};
  let lineShift = options.lineShift || 0;
  let line = now.line || 1;
  let column = now.column || 1;
  return { move, current, shift: shift4 };
  function current() {
    return { now: { line, column }, lineShift };
  }
  function shift4(value) {
    lineShift += value;
  }
  function move(input2) {
    const value = input2 || "";
    const chunks = value.split(/\r?\n|\r/g);
    const tail = chunks[chunks.length - 1];
    line += chunks.length - 1;
    column = chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift;
    return value;
  }
}

// ../node_modules/.pnpm/mdast-util-to-markdown@2.1.2/node_modules/mdast-util-to-markdown/lib/index.js
function toMarkdown(tree, options) {
  const settings = options || {};
  const state = {
    associationId: association,
    containerPhrasing: containerPhrasingBound,
    containerFlow: containerFlowBound,
    createTracker: track,
    compilePattern,
    enter: enter2,
    // @ts-expect-error: GFM / frontmatter are typed in `mdast` but not defined
    // here.
    handlers: { ...handle2 },
    // @ts-expect-error: add `handle` in a second.
    handle: void 0,
    indentLines,
    indexStack: [],
    join: [...join2],
    options: {},
    safe: safeBound,
    stack: [],
    unsafe: [...unsafe]
  };
  configure(state, settings);
  if (state.options.tightDefinitions) {
    state.join.push(joinDefinition);
  }
  state.handle = zwitch("type", {
    invalid,
    unknown,
    handlers: state.handlers
  });
  let result = state.handle(tree, void 0, state, {
    before: "\n",
    after: "\n",
    now: { line: 1, column: 1 },
    lineShift: 0
  });
  if (result && result.charCodeAt(result.length - 1) !== 10 && result.charCodeAt(result.length - 1) !== 13) {
    result += "\n";
  }
  return result;
  function enter2(name) {
    state.stack.push(name);
    return exit3;
    function exit3() {
      state.stack.pop();
    }
  }
}
function invalid(value) {
  throw new Error("Cannot handle value `" + value + "`, expected node");
}
function unknown(value) {
  const node2 = (
    /** @type {Nodes} */
    value
  );
  throw new Error("Cannot handle unknown node `" + node2.type + "`");
}
function joinDefinition(left, right) {
  if (left.type === "definition" && left.type === right.type) {
    return 0;
  }
}
function containerPhrasingBound(parent, info) {
  return containerPhrasing(parent, this, info);
}
function containerFlowBound(parent, info) {
  return containerFlow(parent, this, info);
}
function safeBound(value, config) {
  return safe(this, value, config);
}

// ../node_modules/.pnpm/mdast-util-gfm-table@2.0.0/node_modules/mdast-util-gfm-table/lib/index.js
function gfmTableFromMarkdown() {
  return {
    enter: {
      table: enterTable,
      tableData: enterCell,
      tableHeader: enterCell,
      tableRow: enterRow
    },
    exit: {
      codeText: exitCodeText,
      table: exitTable,
      tableData: exit,
      tableHeader: exit,
      tableRow: exit
    }
  };
}
function enterTable(token) {
  const align = token._align;
  ok(align, "expected `_align` on table");
  this.enter(
    {
      type: "table",
      align: align.map(function(d) {
        return d === "none" ? null : d;
      }),
      children: []
    },
    token
  );
  this.data.inTable = true;
}
function exitTable(token) {
  this.exit(token);
  this.data.inTable = void 0;
}
function enterRow(token) {
  this.enter({ type: "tableRow", children: [] }, token);
}
function exit(token) {
  this.exit(token);
}
function enterCell(token) {
  this.enter({ type: "tableCell", children: [] }, token);
}
function exitCodeText(token) {
  let value = this.resume();
  if (this.data.inTable) {
    value = value.replace(/\\([\\|])/g, replace);
  }
  const node2 = this.stack[this.stack.length - 1];
  ok(node2.type === "inlineCode");
  node2.value = value;
  this.exit(token);
}
function replace($0, $1) {
  return $1 === "|" ? $1 : $0;
}
function gfmTableToMarkdown(options) {
  const settings = options || {};
  const padding = settings.tableCellPadding;
  const alignDelimiters = settings.tablePipeAlign;
  const stringLength = settings.stringLength;
  const around = padding ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: "\n", inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: true, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: true, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: true, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: inlineCodeWithTable,
      table: handleTable,
      tableCell: handleTableCell,
      tableRow: handleTableRow
    }
  };
  function handleTable(node2, _, state, info) {
    return serializeData(handleTableAsData(node2, state, info), node2.align);
  }
  function handleTableRow(node2, _, state, info) {
    const row2 = handleTableRowAsData(node2, state, info);
    const value = serializeData([row2]);
    return value.slice(0, value.indexOf("\n"));
  }
  function handleTableCell(node2, _, state, info) {
    const exit3 = state.enter("tableCell");
    const subexit = state.enter("phrasing");
    const value = state.containerPhrasing(node2, {
      ...info,
      before: around,
      after: around
    });
    subexit();
    exit3();
    return value;
  }
  function serializeData(matrix, align) {
    return markdownTable(matrix, {
      align,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength
    });
  }
  function handleTableAsData(node2, state, info) {
    const children = node2.children;
    let index4 = -1;
    const result = [];
    const subexit = state.enter("table");
    while (++index4 < children.length) {
      result[index4] = handleTableRowAsData(children[index4], state, info);
    }
    subexit();
    return result;
  }
  function handleTableRowAsData(node2, state, info) {
    const children = node2.children;
    let index4 = -1;
    const result = [];
    const subexit = state.enter("tableRow");
    while (++index4 < children.length) {
      result[index4] = handleTableCell(children[index4], node2, state, info);
    }
    subexit();
    return result;
  }
  function inlineCodeWithTable(node2, parent, state) {
    let value = handle2.inlineCode(node2, parent, state);
    if (state.stack.includes("tableCell")) {
      value = value.replace(/\|/g, "\\$&");
    }
    return value;
  }
}

// ../node_modules/.pnpm/mdast-util-gfm-task-list-item@2.0.0/node_modules/mdast-util-gfm-task-list-item/lib/index.js
function gfmTaskListItemFromMarkdown() {
  return {
    exit: {
      taskListCheckValueChecked: exitCheck,
      taskListCheckValueUnchecked: exitCheck,
      paragraph: exitParagraphWithTaskListItem
    }
  };
}
function gfmTaskListItemToMarkdown() {
  return {
    unsafe: [{ atBreak: true, character: "-", after: "[:|-]" }],
    handlers: { listItem: listItemWithTaskListItem }
  };
}
function exitCheck(token) {
  const node2 = this.stack[this.stack.length - 2];
  ok(node2.type === "listItem");
  node2.checked = token.type === "taskListCheckValueChecked";
}
function exitParagraphWithTaskListItem(token) {
  const parent = this.stack[this.stack.length - 2];
  if (parent && parent.type === "listItem" && typeof parent.checked === "boolean") {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2.type === "paragraph");
    const head2 = node2.children[0];
    if (head2 && head2.type === "text") {
      const siblings2 = parent.children;
      let index4 = -1;
      let firstParaghraph;
      while (++index4 < siblings2.length) {
        const sibling = siblings2[index4];
        if (sibling.type === "paragraph") {
          firstParaghraph = sibling;
          break;
        }
      }
      if (firstParaghraph === node2) {
        head2.value = head2.value.slice(1);
        if (head2.value.length === 0) {
          node2.children.shift();
        } else if (node2.position && head2.position && typeof head2.position.start.offset === "number") {
          head2.position.start.column++;
          head2.position.start.offset++;
          node2.position.start = Object.assign({}, head2.position.start);
        }
      }
    }
  }
  this.exit(token);
}
function listItemWithTaskListItem(node2, parent, state, info) {
  const head2 = node2.children[0];
  const checkable = typeof node2.checked === "boolean" && head2 && head2.type === "paragraph";
  const checkbox = "[" + (node2.checked ? "x" : " ") + "] ";
  const tracker = state.createTracker(info);
  if (checkable) {
    tracker.move(checkbox);
  }
  let value = handle2.listItem(node2, parent, state, {
    ...info,
    ...tracker.current()
  });
  if (checkable) {
    value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
  }
  return value;
  function check($0) {
    return $0 + checkbox;
  }
}

// ../node_modules/.pnpm/mdast-util-gfm@3.1.0/node_modules/mdast-util-gfm/lib/index.js
function gfmFromMarkdown() {
  return [
    gfmAutolinkLiteralFromMarkdown(),
    gfmFootnoteFromMarkdown(),
    gfmStrikethroughFromMarkdown(),
    gfmTableFromMarkdown(),
    gfmTaskListItemFromMarkdown()
  ];
}
function gfmToMarkdown(options) {
  return {
    extensions: [
      gfmAutolinkLiteralToMarkdown(),
      gfmFootnoteToMarkdown(options),
      gfmStrikethroughToMarkdown(),
      gfmTableToMarkdown(options),
      gfmTaskListItemToMarkdown()
    ]
  };
}

// ../node_modules/.pnpm/micromark-util-chunked@2.0.1/node_modules/micromark-util-chunked/dev/index.js
function splice(list7, start, remove, items) {
  const end = list7.length;
  let chunkStart = 0;
  let parameters;
  if (start < 0) {
    start = -start > end ? 0 : end + start;
  } else {
    start = start > end ? end : start;
  }
  remove = remove > 0 ? remove : 0;
  if (items.length < constants.v8MaxSafeChunkSize) {
    parameters = Array.from(items);
    parameters.unshift(start, remove);
    list7.splice(...parameters);
  } else {
    if (remove) list7.splice(start, remove);
    while (chunkStart < items.length) {
      parameters = items.slice(
        chunkStart,
        chunkStart + constants.v8MaxSafeChunkSize
      );
      parameters.unshift(start, 0);
      list7.splice(...parameters);
      chunkStart += constants.v8MaxSafeChunkSize;
      start += constants.v8MaxSafeChunkSize;
    }
  }
}
function push(list7, items) {
  if (list7.length > 0) {
    splice(list7, list7.length, 0, items);
    return list7;
  }
  return items;
}

// ../node_modules/.pnpm/micromark-util-combine-extensions@2.0.1/node_modules/micromark-util-combine-extensions/index.js
var hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all9 = {};
  let index4 = -1;
  while (++index4 < extensions.length) {
    syntaxExtension(all9, extensions[index4]);
  }
  return all9;
}
function syntaxExtension(all9, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty.call(all9, hook) ? all9[hook] : void 0;
    const left = maybe || (all9[hook] = {});
    const right = extension2[hook];
    let code5;
    if (right) {
      for (code5 in right) {
        if (!hasOwnProperty.call(left, code5)) left[code5] = [];
        const value = right[code5];
        constructs(
          // @ts-expect-error Looks like a list.
          left[code5],
          Array.isArray(value) ? value : value ? [value] : []
        );
      }
    }
  }
}
function constructs(existing, list7) {
  let index4 = -1;
  const before = [];
  while (++index4 < list7.length) {
    ;
    (list7[index4].add === "after" ? existing : before).push(list7[index4]);
  }
  splice(existing, 0, 0, before);
}

// ../node_modules/.pnpm/micromark-extension-gfm-autolink-literal@2.1.0/node_modules/micromark-extension-gfm-autolink-literal/dev/lib/syntax.js
var wwwPrefix = { tokenize: tokenizeWwwPrefix, partial: true };
var domain = { tokenize: tokenizeDomain, partial: true };
var path = { tokenize: tokenizePath, partial: true };
var trail = { tokenize: tokenizeTrail, partial: true };
var emailDomainDotTrail = {
  tokenize: tokenizeEmailDomainDotTrail,
  partial: true
};
var wwwAutolink = {
  name: "wwwAutolink",
  tokenize: tokenizeWwwAutolink,
  previous: previousWww
};
var protocolAutolink = {
  name: "protocolAutolink",
  tokenize: tokenizeProtocolAutolink,
  previous: previousProtocol
};
var emailAutolink = {
  name: "emailAutolink",
  tokenize: tokenizeEmailAutolink,
  previous: previousEmail
};
var text4 = {};
function gfmAutolinkLiteral() {
  return { text: text4 };
}
var code3 = codes.digit0;
while (code3 < codes.leftCurlyBrace) {
  text4[code3] = emailAutolink;
  code3++;
  if (code3 === codes.colon) code3 = codes.uppercaseA;
  else if (code3 === codes.leftSquareBracket) code3 = codes.lowercaseA;
}
text4[codes.plusSign] = emailAutolink;
text4[codes.dash] = emailAutolink;
text4[codes.dot] = emailAutolink;
text4[codes.underscore] = emailAutolink;
text4[codes.uppercaseH] = [emailAutolink, protocolAutolink];
text4[codes.lowercaseH] = [emailAutolink, protocolAutolink];
text4[codes.uppercaseW] = [emailAutolink, wwwAutolink];
text4[codes.lowercaseW] = [emailAutolink, wwwAutolink];
function tokenizeEmailAutolink(effects, ok3, nok) {
  const self2 = this;
  let dot;
  let data;
  return start;
  function start(code5) {
    if (!gfmAtext(code5) || !previousEmail.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
      return nok(code5);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkEmail");
    return atext(code5);
  }
  function atext(code5) {
    if (gfmAtext(code5)) {
      effects.consume(code5);
      return atext;
    }
    if (code5 === codes.atSign) {
      effects.consume(code5);
      return emailDomain;
    }
    return nok(code5);
  }
  function emailDomain(code5) {
    if (code5 === codes.dot) {
      return effects.check(
        emailDomainDotTrail,
        emailDomainAfter,
        emailDomainDot
      )(code5);
    }
    if (code5 === codes.dash || code5 === codes.underscore || asciiAlphanumeric(code5)) {
      data = true;
      effects.consume(code5);
      return emailDomain;
    }
    return emailDomainAfter(code5);
  }
  function emailDomainDot(code5) {
    effects.consume(code5);
    dot = true;
    return emailDomain;
  }
  function emailDomainAfter(code5) {
    if (data && dot && asciiAlpha(self2.previous)) {
      effects.exit("literalAutolinkEmail");
      effects.exit("literalAutolink");
      return ok3(code5);
    }
    return nok(code5);
  }
}
function tokenizeWwwAutolink(effects, ok3, nok) {
  const self2 = this;
  return wwwStart;
  function wwwStart(code5) {
    if (code5 !== codes.uppercaseW && code5 !== codes.lowercaseW || !previousWww.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
      return nok(code5);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkWww");
    return effects.check(
      wwwPrefix,
      effects.attempt(domain, effects.attempt(path, wwwAfter), nok),
      nok
    )(code5);
  }
  function wwwAfter(code5) {
    effects.exit("literalAutolinkWww");
    effects.exit("literalAutolink");
    return ok3(code5);
  }
}
function tokenizeProtocolAutolink(effects, ok3, nok) {
  const self2 = this;
  let buffer = "";
  let seen = false;
  return protocolStart;
  function protocolStart(code5) {
    if ((code5 === codes.uppercaseH || code5 === codes.lowercaseH) && previousProtocol.call(self2, self2.previous) && !previousUnbalanced(self2.events)) {
      effects.enter("literalAutolink");
      effects.enter("literalAutolinkHttp");
      buffer += String.fromCodePoint(code5);
      effects.consume(code5);
      return protocolPrefixInside;
    }
    return nok(code5);
  }
  function protocolPrefixInside(code5) {
    if (asciiAlpha(code5) && buffer.length < 5) {
      buffer += String.fromCodePoint(code5);
      effects.consume(code5);
      return protocolPrefixInside;
    }
    if (code5 === codes.colon) {
      const protocol = buffer.toLowerCase();
      if (protocol === "http" || protocol === "https") {
        effects.consume(code5);
        return protocolSlashesInside;
      }
    }
    return nok(code5);
  }
  function protocolSlashesInside(code5) {
    if (code5 === codes.slash) {
      effects.consume(code5);
      if (seen) {
        return afterProtocol;
      }
      seen = true;
      return protocolSlashesInside;
    }
    return nok(code5);
  }
  function afterProtocol(code5) {
    return code5 === codes.eof || asciiControl(code5) || markdownLineEndingOrSpace(code5) || unicodeWhitespace(code5) || unicodePunctuation(code5) ? nok(code5) : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code5);
  }
  function protocolAfter(code5) {
    effects.exit("literalAutolinkHttp");
    effects.exit("literalAutolink");
    return ok3(code5);
  }
}
function tokenizeWwwPrefix(effects, ok3, nok) {
  let size5 = 0;
  return wwwPrefixInside;
  function wwwPrefixInside(code5) {
    if ((code5 === codes.uppercaseW || code5 === codes.lowercaseW) && size5 < 3) {
      size5++;
      effects.consume(code5);
      return wwwPrefixInside;
    }
    if (code5 === codes.dot && size5 === 3) {
      effects.consume(code5);
      return wwwPrefixAfter;
    }
    return nok(code5);
  }
  function wwwPrefixAfter(code5) {
    return code5 === codes.eof ? nok(code5) : ok3(code5);
  }
}
function tokenizeDomain(effects, ok3, nok) {
  let underscoreInLastSegment;
  let underscoreInLastLastSegment;
  let seen;
  return domainInside;
  function domainInside(code5) {
    if (code5 === codes.dot || code5 === codes.underscore) {
      return effects.check(trail, domainAfter, domainAtPunctuation)(code5);
    }
    if (code5 === codes.eof || markdownLineEndingOrSpace(code5) || unicodeWhitespace(code5) || code5 !== codes.dash && unicodePunctuation(code5)) {
      return domainAfter(code5);
    }
    seen = true;
    effects.consume(code5);
    return domainInside;
  }
  function domainAtPunctuation(code5) {
    if (code5 === codes.underscore) {
      underscoreInLastSegment = true;
    } else {
      underscoreInLastLastSegment = underscoreInLastSegment;
      underscoreInLastSegment = void 0;
    }
    effects.consume(code5);
    return domainInside;
  }
  function domainAfter(code5) {
    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {
      return nok(code5);
    }
    return ok3(code5);
  }
}
function tokenizePath(effects, ok3) {
  let sizeOpen = 0;
  let sizeClose = 0;
  return pathInside;
  function pathInside(code5) {
    if (code5 === codes.leftParenthesis) {
      sizeOpen++;
      effects.consume(code5);
      return pathInside;
    }
    if (code5 === codes.rightParenthesis && sizeClose < sizeOpen) {
      return pathAtPunctuation(code5);
    }
    if (code5 === codes.exclamationMark || code5 === codes.quotationMark || code5 === codes.ampersand || code5 === codes.apostrophe || code5 === codes.rightParenthesis || code5 === codes.asterisk || code5 === codes.comma || code5 === codes.dot || code5 === codes.colon || code5 === codes.semicolon || code5 === codes.lessThan || code5 === codes.questionMark || code5 === codes.rightSquareBracket || code5 === codes.underscore || code5 === codes.tilde) {
      return effects.check(trail, ok3, pathAtPunctuation)(code5);
    }
    if (code5 === codes.eof || markdownLineEndingOrSpace(code5) || unicodeWhitespace(code5)) {
      return ok3(code5);
    }
    effects.consume(code5);
    return pathInside;
  }
  function pathAtPunctuation(code5) {
    if (code5 === codes.rightParenthesis) {
      sizeClose++;
    }
    effects.consume(code5);
    return pathInside;
  }
}
function tokenizeTrail(effects, ok3, nok) {
  return trail2;
  function trail2(code5) {
    if (code5 === codes.exclamationMark || code5 === codes.quotationMark || code5 === codes.apostrophe || code5 === codes.rightParenthesis || code5 === codes.asterisk || code5 === codes.comma || code5 === codes.dot || code5 === codes.colon || code5 === codes.semicolon || code5 === codes.questionMark || code5 === codes.underscore || code5 === codes.tilde) {
      effects.consume(code5);
      return trail2;
    }
    if (code5 === codes.ampersand) {
      effects.consume(code5);
      return trailCharacterReferenceStart;
    }
    if (code5 === codes.rightSquareBracket) {
      effects.consume(code5);
      return trailBracketAfter;
    }
    if (
      // `<` is an end.
      code5 === codes.lessThan || // So is whitespace.
      code5 === codes.eof || markdownLineEndingOrSpace(code5) || unicodeWhitespace(code5)
    ) {
      return ok3(code5);
    }
    return nok(code5);
  }
  function trailBracketAfter(code5) {
    if (code5 === codes.eof || code5 === codes.leftParenthesis || code5 === codes.leftSquareBracket || markdownLineEndingOrSpace(code5) || unicodeWhitespace(code5)) {
      return ok3(code5);
    }
    return trail2(code5);
  }
  function trailCharacterReferenceStart(code5) {
    return asciiAlpha(code5) ? trailCharacterReferenceInside(code5) : nok(code5);
  }
  function trailCharacterReferenceInside(code5) {
    if (code5 === codes.semicolon) {
      effects.consume(code5);
      return trail2;
    }
    if (asciiAlpha(code5)) {
      effects.consume(code5);
      return trailCharacterReferenceInside;
    }
    return nok(code5);
  }
}
function tokenizeEmailDomainDotTrail(effects, ok3, nok) {
  return start;
  function start(code5) {
    effects.consume(code5);
    return after;
  }
  function after(code5) {
    return asciiAlphanumeric(code5) ? nok(code5) : ok3(code5);
  }
}
function previousWww(code5) {
  return code5 === codes.eof || code5 === codes.leftParenthesis || code5 === codes.asterisk || code5 === codes.underscore || code5 === codes.leftSquareBracket || code5 === codes.rightSquareBracket || code5 === codes.tilde || markdownLineEndingOrSpace(code5);
}
function previousProtocol(code5) {
  return !asciiAlpha(code5);
}
function previousEmail(code5) {
  return !(code5 === codes.slash || gfmAtext(code5));
}
function gfmAtext(code5) {
  return code5 === codes.plusSign || code5 === codes.dash || code5 === codes.dot || code5 === codes.underscore || asciiAlphanumeric(code5);
}
function previousUnbalanced(events) {
  let index4 = events.length;
  let result = false;
  while (index4--) {
    const token = events[index4][1];
    if ((token.type === "labelLink" || token.type === "labelImage") && !token._balanced) {
      result = true;
      break;
    }
    if (token._gfmAutolinkLiteralWalkedInto) {
      result = false;
      break;
    }
  }
  if (events.length > 0 && !result) {
    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
  }
  return result;
}

// ../node_modules/.pnpm/micromark-util-sanitize-uri@2.0.1/node_modules/micromark-util-sanitize-uri/dev/index.js
function normalizeUri(value) {
  const result = [];
  let index4 = -1;
  let start = 0;
  let skip = 0;
  while (++index4 < value.length) {
    const code5 = value.charCodeAt(index4);
    let replace2 = "";
    if (code5 === codes.percentSign && asciiAlphanumeric(value.charCodeAt(index4 + 1)) && asciiAlphanumeric(value.charCodeAt(index4 + 2))) {
      skip = 2;
    } else if (code5 < 128) {
      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code5))) {
        replace2 = String.fromCharCode(code5);
      }
    } else if (code5 > 55295 && code5 < 57344) {
      const next2 = value.charCodeAt(index4 + 1);
      if (code5 < 56320 && next2 > 56319 && next2 < 57344) {
        replace2 = String.fromCharCode(code5, next2);
        skip = 1;
      } else {
        replace2 = values.replacementCharacter;
      }
    } else {
      replace2 = String.fromCharCode(code5);
    }
    if (replace2) {
      result.push(value.slice(start, index4), encodeURIComponent(replace2));
      start = index4 + skip + 1;
      replace2 = "";
    }
    if (skip) {
      index4 += skip;
      skip = 0;
    }
  }
  return result.join("") + value.slice(start);
}

// ../node_modules/.pnpm/micromark-util-resolve-all@2.0.1/node_modules/micromark-util-resolve-all/index.js
function resolveAll(constructs2, events, context) {
  const called = [];
  let index4 = -1;
  while (++index4 < constructs2.length) {
    const resolve2 = constructs2[index4].resolveAll;
    if (resolve2 && !called.includes(resolve2)) {
      events = resolve2(events, context);
      called.push(resolve2);
    }
  }
  return events;
}

// ../node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/dev/lib/attention.js
var attention = {
  name: "attention",
  resolveAll: resolveAllAttention,
  tokenize: tokenizeAttention
};
function resolveAllAttention(events, context) {
  let index4 = -1;
  let open;
  let group;
  let text10;
  let openingSequence;
  let closingSequence;
  let use;
  let nextEvents;
  let offset4;
  while (++index4 < events.length) {
    if (events[index4][0] === "enter" && events[index4][1].type === "attentionSequence" && events[index4][1]._close) {
      open = index4;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:
        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index4][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index4][1]._open) && (events[index4][1].end.offset - events[index4][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index4][1].end.offset - events[index4][1].start.offset) % 3)) {
            continue;
          }
          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index4][1].end.offset - events[index4][1].start.offset > 1 ? 2 : 1;
          const start = { ...events[open][1].end };
          const end = { ...events[index4][1].start };
          movePoint(start, -use);
          movePoint(end, use);
          openingSequence = {
            type: use > 1 ? types.strongSequence : types.emphasisSequence,
            start,
            end: { ...events[open][1].end }
          };
          closingSequence = {
            type: use > 1 ? types.strongSequence : types.emphasisSequence,
            start: { ...events[index4][1].start },
            end
          };
          text10 = {
            type: use > 1 ? types.strongText : types.emphasisText,
            start: { ...events[open][1].end },
            end: { ...events[index4][1].start }
          };
          group = {
            type: use > 1 ? types.strong : types.emphasis,
            start: { ...openingSequence.start },
            end: { ...closingSequence.end }
          };
          events[open][1].end = { ...openingSequence.start };
          events[index4][1].start = { ...closingSequence.end };
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push(nextEvents, [
              ["enter", events[open][1], context],
              ["exit", events[open][1], context]
            ]);
          }
          nextEvents = push(nextEvents, [
            ["enter", group, context],
            ["enter", openingSequence, context],
            ["exit", openingSequence, context],
            ["enter", text10, context]
          ]);
          ok(
            context.parser.constructs.insideSpan.null,
            "expected `insideSpan` to be populated"
          );
          nextEvents = push(
            nextEvents,
            resolveAll(
              context.parser.constructs.insideSpan.null,
              events.slice(open + 1, index4),
              context
            )
          );
          nextEvents = push(nextEvents, [
            ["exit", text10, context],
            ["enter", closingSequence, context],
            ["exit", closingSequence, context],
            ["exit", group, context]
          ]);
          if (events[index4][1].end.offset - events[index4][1].start.offset) {
            offset4 = 2;
            nextEvents = push(nextEvents, [
              ["enter", events[index4][1], context],
              ["exit", events[index4][1], context]
            ]);
          } else {
            offset4 = 0;
          }
          splice(events, open - 1, index4 - open + 3, nextEvents);
          index4 = open + nextEvents.length - offset4 - 2;
          break;
        }
      }
    }
  }
  index4 = -1;
  while (++index4 < events.length) {
    if (events[index4][1].type === "attentionSequence") {
      events[index4][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok3) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous3 = this.previous;
  const before = classifyCharacter(previous3);
  let marker;
  return start;
  function start(code5) {
    ok(
      code5 === codes.asterisk || code5 === codes.underscore,
      "expected asterisk or underscore"
    );
    marker = code5;
    effects.enter("attentionSequence");
    return inside(code5);
  }
  function inside(code5) {
    if (code5 === marker) {
      effects.consume(code5);
      return inside;
    }
    const token = effects.exit("attentionSequence");
    const after = classifyCharacter(code5);
    ok(attentionMarkers2, "expected `attentionMarkers` to be populated");
    const open = !after || after === constants.characterGroupPunctuation && before || attentionMarkers2.includes(code5);
    const close = !before || before === constants.characterGroupPunctuation && after || attentionMarkers2.includes(previous3);
    token._open = Boolean(
      marker === codes.asterisk ? open : open && (before || !close)
    );
    token._close = Boolean(
      marker === codes.asterisk ? close : close && (after || !open)
    );
    return ok3(code5);
  }
}
function movePoint(point5, offset4) {
  point5.column += offset4;
  point5.offset += offset4;
  point5._bufferIndex += offset4;
}

// ../node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/dev/lib/autolink.js
var autolink2 = { name: "autolink", tokenize: tokenizeAutolink };
function tokenizeAutolink(effects, ok3, nok) {
  let size5 = 0;
  return start;
  function start(code5) {
    ok(code5 === codes.lessThan, "expected `<`");
    effects.enter(types.autolink);
    effects.enter(types.autolinkMarker);
    effects.consume(code5);
    effects.exit(types.autolinkMarker);
    effects.enter(types.autolinkProtocol);
    return open;
  }
  function open(code5) {
    if (asciiAlpha(code5)) {
      effects.consume(code5);
      return schemeOrEmailAtext;
    }
    if (code5 === codes.atSign) {
      return nok(code5);
    }
    return emailAtext(code5);
  }
  function schemeOrEmailAtext(code5) {
    if (code5 === codes.plusSign || code5 === codes.dash || code5 === codes.dot || asciiAlphanumeric(code5)) {
      size5 = 1;
      return schemeInsideOrEmailAtext(code5);
    }
    return emailAtext(code5);
  }
  function schemeInsideOrEmailAtext(code5) {
    if (code5 === codes.colon) {
      effects.consume(code5);
      size5 = 0;
      return urlInside;
    }
    if ((code5 === codes.plusSign || code5 === codes.dash || code5 === codes.dot || asciiAlphanumeric(code5)) && size5++ < constants.autolinkSchemeSizeMax) {
      effects.consume(code5);
      return schemeInsideOrEmailAtext;
    }
    size5 = 0;
    return emailAtext(code5);
  }
  function urlInside(code5) {
    if (code5 === codes.greaterThan) {
      effects.exit(types.autolinkProtocol);
      effects.enter(types.autolinkMarker);
      effects.consume(code5);
      effects.exit(types.autolinkMarker);
      effects.exit(types.autolink);
      return ok3;
    }
    if (code5 === codes.eof || code5 === codes.space || code5 === codes.lessThan || asciiControl(code5)) {
      return nok(code5);
    }
    effects.consume(code5);
    return urlInside;
  }
  function emailAtext(code5) {
    if (code5 === codes.atSign) {
      effects.consume(code5);
      return emailAtSignOrDot;
    }
    if (asciiAtext(code5)) {
      effects.consume(code5);
      return emailAtext;
    }
    return nok(code5);
  }
  function emailAtSignOrDot(code5) {
    return asciiAlphanumeric(code5) ? emailLabel(code5) : nok(code5);
  }
  function emailLabel(code5) {
    if (code5 === codes.dot) {
      effects.consume(code5);
      size5 = 0;
      return emailAtSignOrDot;
    }
    if (code5 === codes.greaterThan) {
      effects.exit(types.autolinkProtocol).type = types.autolinkEmail;
      effects.enter(types.autolinkMarker);
      effects.consume(code5);
      effects.exit(types.autolinkMarker);
      effects.exit(types.autolink);
      return ok3;
    }
    return emailValue(code5);
  }
  function emailValue(code5) {
    if ((code5 === codes.dash || asciiAlphanumeric(code5)) && size5++ < constants.autolinkDomainSizeMax) {
      const next2 = code5 === codes.dash ? emailValue : emailLabel;
      effects.consume(code5);
      return next2;
    }
    return nok(code5);
  }
}

// ../node_modules/.pnpm/micromark-factory-space@2.0.1/node_modules/micromark-factory-space/dev/index.js
function factorySpace(effects, ok3, type, max3) {
  const limit = max3 ? max3 - 1 : Number.POSITIVE_INFINITY;
  let size5 = 0;
  return start;
  function start(code5) {
    if (markdownSpace(code5)) {
      effects.enter(type);
      return prefix3(code5);
    }
    return ok3(code5);
  }
  function prefix3(code5) {
    if (markdownSpace(code5) && size5++ < limit) {
      effects.consume(code5);
      return prefix3;
    }
    effects.exit(type);
    return ok3(code5);
  }
}

// ../node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/dev/lib/blank-line.js
var blankLine = { partial: true, tokenize: tokenizeBlankLine };
function tokenizeBlankLine(effects, ok3, nok) {
  return start;
  function start(code5) {
    return markdownSpace(code5) ? factorySpace(effects, after, types.linePrefix)(code5) : after(code5);
  }
  function after(code5) {
    return code5 === codes.eof || markdownLineEnding(code5) ? ok3(code5) : nok(code5);
  }
}

// ../node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/dev/lib/block-quote.js
var blockQuote = {
  continuation: { tokenize: tokenizeBlockQuoteContinuation },
  exit: exit2,
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart
};
function tokenizeBlockQuoteStart(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code5) {
    if (code5 === codes.greaterThan) {
      const state = self2.containerState;
      ok(state, "expected `containerState` to be defined in container");
      if (!state.open) {
        effects.enter(types.blockQuote, { _container: true });
        state.open = true;
      }
      effects.enter(types.blockQuotePrefix);
      effects.enter(types.blockQuoteMarker);
      effects.consume(code5);
      effects.exit(types.blockQuoteMarker);
      return after;
    }
    return nok(code5);
  }
  function after(code5) {
    if (markdownSpace(code5)) {
      effects.enter(types.blockQuotePrefixWhitespace);
      effects.consume(code5);
      effects.exit(types.blockQuotePrefixWhitespace);
      effects.exit(types.blockQuotePrefix);
      return ok3;
    }
    effects.exit(types.blockQuotePrefix);
    return ok3(code5);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok3, nok) {
  const self2 = this;
  return contStart;
  function contStart(code5) {
    if (markdownSpace(code5)) {
      ok(
        self2.parser.constructs.disable.null,
        "expected `disable.null` to be populated"
      );
      return factorySpace(
        effects,
        contBefore,
        types.linePrefix,
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
      )(code5);
    }
    return contBefore(code5);
  }
  function contBefore(code5) {
    return effects.attempt(blockQuote, ok3, nok)(code5);
  }
}
function exit2(effects) {
  effects.exit(types.blockQuote);
}

// ../node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/dev/lib/character-escape.js
var characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok3, nok) {
  return start;
  function start(code5) {
    ok(code5 === codes.backslash, "expected `\\`");
    effects.enter(types.characterEscape);
    effects.enter(types.escapeMarker);
    effects.consume(code5);
    effects.exit(types.escapeMarker);
    return inside;
  }
  function inside(code5) {
    if (asciiPunctuation(code5)) {
      effects.enter(types.characterEscapeValue);
      effects.consume(code5);
      effects.exit(types.characterEscapeValue);
      effects.exit(types.characterEscape);
      return ok3;
    }
    return nok(code5);
  }
}

// ../node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/dev/lib/character-reference.js
var characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok3, nok) {
  const self2 = this;
  let size5 = 0;
  let max3;
  let test;
  return start;
  function start(code5) {
    ok(code5 === codes.ampersand, "expected `&`");
    effects.enter(types.characterReference);
    effects.enter(types.characterReferenceMarker);
    effects.consume(code5);
    effects.exit(types.characterReferenceMarker);
    return open;
  }
  function open(code5) {
    if (code5 === codes.numberSign) {
      effects.enter(types.characterReferenceMarkerNumeric);
      effects.consume(code5);
      effects.exit(types.characterReferenceMarkerNumeric);
      return numeric;
    }
    effects.enter(types.characterReferenceValue);
    max3 = constants.characterReferenceNamedSizeMax;
    test = asciiAlphanumeric;
    return value(code5);
  }
  function numeric(code5) {
    if (code5 === codes.uppercaseX || code5 === codes.lowercaseX) {
      effects.enter(types.characterReferenceMarkerHexadecimal);
      effects.consume(code5);
      effects.exit(types.characterReferenceMarkerHexadecimal);
      effects.enter(types.characterReferenceValue);
      max3 = constants.characterReferenceHexadecimalSizeMax;
      test = asciiHexDigit;
      return value;
    }
    effects.enter(types.characterReferenceValue);
    max3 = constants.characterReferenceDecimalSizeMax;
    test = asciiDigit;
    return value(code5);
  }
  function value(code5) {
    if (code5 === codes.semicolon && size5) {
      const token = effects.exit(types.characterReferenceValue);
      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {
        return nok(code5);
      }
      effects.enter(types.characterReferenceMarker);
      effects.consume(code5);
      effects.exit(types.characterReferenceMarker);
      effects.exit(types.characterReference);
      return ok3;
    }
    if (test(code5) && size5++ < max3) {
      effects.consume(code5);
      return value;
    }
    return nok(code5);
  }
}

// ../node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/dev/lib/code-fenced.js
var nonLazyContinuation = {
  partial: true,
  tokenize: tokenizeNonLazyContinuation
};
var codeFenced = {
  concrete: true,
  name: "codeFenced",
  tokenize: tokenizeCodeFenced
};
function tokenizeCodeFenced(effects, ok3, nok) {
  const self2 = this;
  const closeStart = { partial: true, tokenize: tokenizeCloseStart };
  let initialPrefix = 0;
  let sizeOpen = 0;
  let marker;
  return start;
  function start(code5) {
    return beforeSequenceOpen(code5);
  }
  function beforeSequenceOpen(code5) {
    ok(
      code5 === codes.graveAccent || code5 === codes.tilde,
      "expected `` ` `` or `~`"
    );
    const tail = self2.events[self2.events.length - 1];
    initialPrefix = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;
    marker = code5;
    effects.enter(types.codeFenced);
    effects.enter(types.codeFencedFence);
    effects.enter(types.codeFencedFenceSequence);
    return sequenceOpen(code5);
  }
  function sequenceOpen(code5) {
    if (code5 === marker) {
      sizeOpen++;
      effects.consume(code5);
      return sequenceOpen;
    }
    if (sizeOpen < constants.codeFencedSequenceSizeMin) {
      return nok(code5);
    }
    effects.exit(types.codeFencedFenceSequence);
    return markdownSpace(code5) ? factorySpace(effects, infoBefore, types.whitespace)(code5) : infoBefore(code5);
  }
  function infoBefore(code5) {
    if (code5 === codes.eof || markdownLineEnding(code5)) {
      effects.exit(types.codeFencedFence);
      return self2.interrupt ? ok3(code5) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code5);
    }
    effects.enter(types.codeFencedFenceInfo);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return info(code5);
  }
  function info(code5) {
    if (code5 === codes.eof || markdownLineEnding(code5)) {
      effects.exit(types.chunkString);
      effects.exit(types.codeFencedFenceInfo);
      return infoBefore(code5);
    }
    if (markdownSpace(code5)) {
      effects.exit(types.chunkString);
      effects.exit(types.codeFencedFenceInfo);
      return factorySpace(effects, metaBefore, types.whitespace)(code5);
    }
    if (code5 === codes.graveAccent && code5 === marker) {
      return nok(code5);
    }
    effects.consume(code5);
    return info;
  }
  function metaBefore(code5) {
    if (code5 === codes.eof || markdownLineEnding(code5)) {
      return infoBefore(code5);
    }
    effects.enter(types.codeFencedFenceMeta);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return meta2(code5);
  }
  function meta2(code5) {
    if (code5 === codes.eof || markdownLineEnding(code5)) {
      effects.exit(types.chunkString);
      effects.exit(types.codeFencedFenceMeta);
      return infoBefore(code5);
    }
    if (code5 === codes.graveAccent && code5 === marker) {
      return nok(code5);
    }
    effects.consume(code5);
    return meta2;
  }
  function atNonLazyBreak(code5) {
    ok(markdownLineEnding(code5), "expected eol");
    return effects.attempt(closeStart, after, contentBefore)(code5);
  }
  function contentBefore(code5) {
    ok(markdownLineEnding(code5), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code5);
    effects.exit(types.lineEnding);
    return contentStart;
  }
  function contentStart(code5) {
    return initialPrefix > 0 && markdownSpace(code5) ? factorySpace(
      effects,
      beforeContentChunk,
      types.linePrefix,
      initialPrefix + 1
    )(code5) : beforeContentChunk(code5);
  }
  function beforeContentChunk(code5) {
    if (code5 === codes.eof || markdownLineEnding(code5)) {
      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code5);
    }
    effects.enter(types.codeFlowValue);
    return contentChunk(code5);
  }
  function contentChunk(code5) {
    if (code5 === codes.eof || markdownLineEnding(code5)) {
      effects.exit(types.codeFlowValue);
      return beforeContentChunk(code5);
    }
    effects.consume(code5);
    return contentChunk;
  }
  function after(code5) {
    effects.exit(types.codeFenced);
    return ok3(code5);
  }
  function tokenizeCloseStart(effects2, ok4, nok2) {
    let size5 = 0;
    return startBefore;
    function startBefore(code5) {
      ok(markdownLineEnding(code5), "expected eol");
      effects2.enter(types.lineEnding);
      effects2.consume(code5);
      effects2.exit(types.lineEnding);
      return start2;
    }
    function start2(code5) {
      ok(
        self2.parser.constructs.disable.null,
        "expected `disable.null` to be populated"
      );
      effects2.enter(types.codeFencedFence);
      return markdownSpace(code5) ? factorySpace(
        effects2,
        beforeSequenceClose,
        types.linePrefix,
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
      )(code5) : beforeSequenceClose(code5);
    }
    function beforeSequenceClose(code5) {
      if (code5 === marker) {
        effects2.enter(types.codeFencedFenceSequence);
        return sequenceClose(code5);
      }
      return nok2(code5);
    }
    function sequenceClose(code5) {
      if (code5 === marker) {
        size5++;
        effects2.consume(code5);
        return sequenceClose;
      }
      if (size5 >= sizeOpen) {
        effects2.exit(types.codeFencedFenceSequence);
        return markdownSpace(code5) ? factorySpace(effects2, sequenceCloseAfter, types.whitespace)(code5) : sequenceCloseAfter(code5);
      }
      return nok2(code5);
    }
    function sequenceCloseAfter(code5) {
      if (code5 === codes.eof || markdownLineEnding(code5)) {
        effects2.exit(types.codeFencedFence);
        return ok4(code5);
      }
      return nok2(code5);
    }
  }
}
function tokenizeNonLazyContinuation(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code5) {
    if (code5 === codes.eof) {
      return nok(code5);
    }
    ok(markdownLineEnding(code5), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code5);
    effects.exit(types.lineEnding);
    return lineStart;
  }
  function lineStart(code5) {
    return self2.parser.lazy[self2.now().line] ? nok(code5) : ok3(code5);
  }
}

// ../node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/dev/lib/code-indented.js
var codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
var furtherStart = { partial: true, tokenize: tokenizeFurtherStart };
function tokenizeCodeIndented(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code5) {
    ok(markdownSpace(code5));
    effects.enter(types.codeIndented);
    return factorySpace(
      effects,
      afterPrefix,
      types.linePrefix,
      constants.tabSize + 1
    )(code5);
  }
  function afterPrefix(code5) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize ? atBreak(code5) : nok(code5);
  }
  function atBreak(code5) {
    if (code5 === codes.eof) {
      return after(code5);
    }
    if (markdownLineEnding(code5)) {
      return effects.attempt(furtherStart, atBreak, after)(code5);
    }
    effects.enter(types.codeFlowValue);
    return inside(code5);
  }
  function inside(code5) {
    if (code5 === codes.eof || markdownLineEnding(code5)) {
      effects.exit(types.codeFlowValue);
      return atBreak(code5);
    }
    effects.consume(code5);
    return inside;
  }
  function after(code5) {
    effects.exit(types.codeIndented);
    return ok3(code5);
  }
}
function tokenizeFurtherStart(effects, ok3, nok) {
  const self2 = this;
  return furtherStart2;
  function furtherStart2(code5) {
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code5);
    }
    if (markdownLineEnding(code5)) {
      effects.enter(types.lineEnding);
      effects.consume(code5);
      effects.exit(types.lineEnding);
      return furtherStart2;
    }
    return factorySpace(
      effects,
      afterPrefix,
      types.linePrefix,
      constants.tabSize + 1
    )(code5);
  }
  function afterPrefix(code5) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize ? ok3(code5) : markdownLineEnding(code5) ? furtherStart2(code5) : nok(code5);
  }
}

// ../node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/dev/lib/code-text.js
var codeText = {
  name: "codeText",
  previous: previous2,
  resolve: resolveCodeText,
  tokenize: tokenizeCodeText
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index4;
  let enter2;
  if ((events[headEnterIndex][1].type === types.lineEnding || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === types.lineEnding || events[tailExitIndex][1].type === "space")) {
    index4 = headEnterIndex;
    while (++index4 < tailExitIndex) {
      if (events[index4][1].type === types.codeTextData) {
        events[headEnterIndex][1].type = types.codeTextPadding;
        events[tailExitIndex][1].type = types.codeTextPadding;
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index4 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index4 <= tailExitIndex) {
    if (enter2 === void 0) {
      if (index4 !== tailExitIndex && events[index4][1].type !== types.lineEnding) {
        enter2 = index4;
      }
    } else if (index4 === tailExitIndex || events[index4][1].type === types.lineEnding) {
      events[enter2][1].type = types.codeTextData;
      if (index4 !== enter2 + 2) {
        events[enter2][1].end = events[index4 - 1][1].end;
        events.splice(enter2 + 2, index4 - enter2 - 2);
        tailExitIndex -= index4 - enter2 - 2;
        index4 = enter2 + 2;
      }
      enter2 = void 0;
    }
  }
  return events;
}
function previous2(code5) {
  return code5 !== codes.graveAccent || this.events[this.events.length - 1][1].type === types.characterEscape;
}
function tokenizeCodeText(effects, ok3, nok) {
  const self2 = this;
  let sizeOpen = 0;
  let size5;
  let token;
  return start;
  function start(code5) {
    ok(code5 === codes.graveAccent, "expected `` ` ``");
    ok(previous2.call(self2, self2.previous), "expected correct previous");
    effects.enter(types.codeText);
    effects.enter(types.codeTextSequence);
    return sequenceOpen(code5);
  }
  function sequenceOpen(code5) {
    if (code5 === codes.graveAccent) {
      effects.consume(code5);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit(types.codeTextSequence);
    return between2(code5);
  }
  function between2(code5) {
    if (code5 === codes.eof) {
      return nok(code5);
    }
    if (code5 === codes.space) {
      effects.enter("space");
      effects.consume(code5);
      effects.exit("space");
      return between2;
    }
    if (code5 === codes.graveAccent) {
      token = effects.enter(types.codeTextSequence);
      size5 = 0;
      return sequenceClose(code5);
    }
    if (markdownLineEnding(code5)) {
      effects.enter(types.lineEnding);
      effects.consume(code5);
      effects.exit(types.lineEnding);
      return between2;
    }
    effects.enter(types.codeTextData);
    return data(code5);
  }
  function data(code5) {
    if (code5 === codes.eof || code5 === codes.space || code5 === codes.graveAccent || markdownLineEnding(code5)) {
      effects.exit(types.codeTextData);
      return between2(code5);
    }
    effects.consume(code5);
    return data;
  }
  function sequenceClose(code5) {
    if (code5 === codes.graveAccent) {
      effects.consume(code5);
      size5++;
      return sequenceClose;
    }
    if (size5 === sizeOpen) {
      effects.exit(types.codeTextSequence);
      effects.exit(types.codeText);
      return ok3(code5);
    }
    token.type = types.codeTextData;
    return data(code5);
  }
}

// ../node_modules/.pnpm/micromark-util-subtokenize@2.1.0/node_modules/micromark-util-subtokenize/dev/lib/splice-buffer.js
var SpliceBuffer = class {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(initial) {
    this.left = initial ? [...initial] : [];
    this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(index4) {
    if (index4 < 0 || index4 >= this.left.length + this.right.length) {
      throw new RangeError(
        "Cannot access index `" + index4 + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`"
      );
    }
    if (index4 < this.left.length) return this.left[index4];
    return this.right[this.right.length - index4 + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    this.setCursor(0);
    return this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(start, end) {
    const stop = end === null || end === void 0 ? Number.POSITIVE_INFINITY : end;
    if (stop < this.left.length) {
      return this.left.slice(start, stop);
    }
    if (start > this.left.length) {
      return this.right.slice(
        this.right.length - stop + this.left.length,
        this.right.length - start + this.left.length
      ).reverse();
    }
    return this.left.slice(start).concat(
      this.right.slice(this.right.length - stop + this.left.length).reverse()
    );
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(start, deleteCount, items) {
    const count2 = deleteCount || 0;
    this.setCursor(Math.trunc(start));
    const removed = this.right.splice(
      this.right.length - count2,
      Number.POSITIVE_INFINITY
    );
    if (items) chunkedPush(this.left, items);
    return removed.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    this.setCursor(Number.POSITIVE_INFINITY);
    return this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(item) {
    this.setCursor(Number.POSITIVE_INFINITY);
    this.left.push(item);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(items) {
    this.setCursor(Number.POSITIVE_INFINITY);
    chunkedPush(this.left, items);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(item) {
    this.setCursor(0);
    this.right.push(item);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(items) {
    this.setCursor(0);
    chunkedPush(this.right, items.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(n) {
    if (n === this.left.length || n > this.left.length && this.right.length === 0 || n < 0 && this.left.length === 0)
      return;
    if (n < this.left.length) {
      const removed = this.left.splice(n, Number.POSITIVE_INFINITY);
      chunkedPush(this.right, removed.reverse());
    } else {
      const removed = this.right.splice(
        this.left.length + this.right.length - n,
        Number.POSITIVE_INFINITY
      );
      chunkedPush(this.left, removed.reverse());
    }
  }
};
function chunkedPush(list7, right) {
  let chunkStart = 0;
  if (right.length < constants.v8MaxSafeChunkSize) {
    list7.push(...right);
  } else {
    while (chunkStart < right.length) {
      list7.push(
        ...right.slice(chunkStart, chunkStart + constants.v8MaxSafeChunkSize)
      );
      chunkStart += constants.v8MaxSafeChunkSize;
    }
  }
}

// ../node_modules/.pnpm/micromark-util-subtokenize@2.1.0/node_modules/micromark-util-subtokenize/dev/index.js
function subtokenize(eventsArray) {
  const jumps = {};
  let index4 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  const events = new SpliceBuffer(eventsArray);
  while (++index4 < events.length) {
    while (index4 in jumps) {
      index4 = jumps[index4];
    }
    event = events.get(index4);
    if (index4 && event[1].type === types.chunkFlow && events.get(index4 - 1)[1].type === types.listItemPrefix) {
      ok(event[1]._tokenizer, "expected `_tokenizer` on subtokens");
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === types.lineEndingBlank) {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === types.content) {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === types.content) {
            break;
          }
          if (subevents[otherIndex][1].type === types.chunkText) {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index4));
        index4 = jumps[index4];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index4;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events.get(otherIndex);
        if (otherEvent[1].type === types.lineEnding || otherEvent[1].type === types.lineEndingBlank) {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events.get(lineIndex)[1].type = types.lineEndingBlank;
            }
            otherEvent[1].type = types.lineEnding;
            lineIndex = otherIndex;
          }
        } else if (otherEvent[1].type === types.linePrefix || otherEvent[1].type === types.listItemIndent) {
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = { ...events.get(lineIndex)[1].start };
        parameters = events.slice(lineIndex, index4);
        parameters.unshift(event);
        events.splice(lineIndex, index4 - lineIndex + 1, parameters);
      }
    }
  }
  splice(eventsArray, 0, Number.POSITIVE_INFINITY, events.slice(0));
  return !more;
}
function subcontent(events, eventIndex) {
  const token = events.get(eventIndex)[1];
  const context = events.get(eventIndex)[2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  ok(token.contentType, "expected `contentType` on subtokens");
  let tokenizer = token._tokenizer;
  if (!tokenizer) {
    tokenizer = context.parser[token.contentType](token.start);
    if (token._contentTypeTextTrailing) {
      tokenizer._contentTypeTextTrailing = true;
    }
  }
  const childEvents = tokenizer.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous3;
  let index4 = -1;
  let current = token;
  let adjust = 0;
  let start = 0;
  const breaks = [start];
  while (current) {
    while (events.get(++startPosition)[1] !== current) {
    }
    ok(
      !previous3 || current.previous === previous3,
      "expected previous to match"
    );
    ok(!previous3 || previous3.next === current, "expected next to match");
    startPositions.push(startPosition);
    if (!current._tokenizer) {
      stream = context.sliceStream(current);
      if (!current.next) {
        stream.push(codes.eof);
      }
      if (previous3) {
        tokenizer.defineSkip(current.start);
      }
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer.write(stream);
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous3 = current;
    current = current.next;
  }
  current = token;
  while (++index4 < childEvents.length) {
    if (
      // Find a void token that includes a break.
      childEvents[index4][0] === "exit" && childEvents[index4 - 1][0] === "enter" && childEvents[index4][1].type === childEvents[index4 - 1][1].type && childEvents[index4][1].start.line !== childEvents[index4][1].end.line
    ) {
      ok(current, "expected a current token");
      start = index4 + 1;
      breaks.push(start);
      current._tokenizer = void 0;
      current.previous = void 0;
      current = current.next;
    }
  }
  tokenizer.events = [];
  if (current) {
    current._tokenizer = void 0;
    current.previous = void 0;
    ok(!current.next, "expected no next token");
  } else {
    breaks.pop();
  }
  index4 = breaks.length;
  while (index4--) {
    const slice = childEvents.slice(breaks[index4], breaks[index4 + 1]);
    const start2 = startPositions.pop();
    ok(start2 !== void 0, "expected a start position when splicing");
    jumps.push([start2, start2 + slice.length - 1]);
    events.splice(start2, 2, slice);
  }
  jumps.reverse();
  index4 = -1;
  while (++index4 < jumps.length) {
    gaps[adjust + jumps[index4][0]] = adjust + jumps[index4][1];
    adjust += jumps[index4][1] - jumps[index4][0] - 1;
  }
  return gaps;
}

// ../node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/dev/lib/content.js
var content3 = { resolve: resolveContent, tokenize: tokenizeContent };
var continuationConstruct = { partial: true, tokenize: tokenizeContinuation };
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok3) {
  let previous3;
  return chunkStart;
  function chunkStart(code5) {
    ok(
      code5 !== codes.eof && !markdownLineEnding(code5),
      "expected no eof or eol"
    );
    effects.enter(types.content);
    previous3 = effects.enter(types.chunkContent, {
      contentType: constants.contentTypeContent
    });
    return chunkInside(code5);
  }
  function chunkInside(code5) {
    if (code5 === codes.eof) {
      return contentEnd(code5);
    }
    if (markdownLineEnding(code5)) {
      return effects.check(
        continuationConstruct,
        contentContinue,
        contentEnd
      )(code5);
    }
    effects.consume(code5);
    return chunkInside;
  }
  function contentEnd(code5) {
    effects.exit(types.chunkContent);
    effects.exit(types.content);
    return ok3(code5);
  }
  function contentContinue(code5) {
    ok(markdownLineEnding(code5), "expected eol");
    effects.consume(code5);
    effects.exit(types.chunkContent);
    ok(previous3, "expected previous token");
    previous3.next = effects.enter(types.chunkContent, {
      contentType: constants.contentTypeContent,
      previous: previous3
    });
    previous3 = previous3.next;
    return chunkInside;
  }
}
function tokenizeContinuation(effects, ok3, nok) {
  const self2 = this;
  return startLookahead;
  function startLookahead(code5) {
    ok(markdownLineEnding(code5), "expected a line ending");
    effects.exit(types.chunkContent);
    effects.enter(types.lineEnding);
    effects.consume(code5);
    effects.exit(types.lineEnding);
    return factorySpace(effects, prefixed, types.linePrefix);
  }
  function prefixed(code5) {
    if (code5 === codes.eof || markdownLineEnding(code5)) {
      return nok(code5);
    }
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    const tail = self2.events[self2.events.length - 1];
    if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize) {
      return ok3(code5);
    }
    return effects.interrupt(self2.parser.constructs.flow, nok, ok3)(code5);
  }
}

// ../node_modules/.pnpm/micromark-factory-destination@2.0.1/node_modules/micromark-factory-destination/dev/index.js
function factoryDestination(effects, ok3, nok, type, literalType, literalMarkerType, rawType, stringType, max3) {
  const limit = max3 || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start;
  function start(code5) {
    if (code5 === codes.lessThan) {
      effects.enter(type);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code5);
      effects.exit(literalMarkerType);
      return enclosedBefore;
    }
    if (code5 === codes.eof || code5 === codes.space || code5 === codes.rightParenthesis || asciiControl(code5)) {
      return nok(code5);
    }
    effects.enter(type);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return raw2(code5);
  }
  function enclosedBefore(code5) {
    if (code5 === codes.greaterThan) {
      effects.enter(literalMarkerType);
      effects.consume(code5);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type);
      return ok3;
    }
    effects.enter(stringType);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return enclosed(code5);
  }
  function enclosed(code5) {
    if (code5 === codes.greaterThan) {
      effects.exit(types.chunkString);
      effects.exit(stringType);
      return enclosedBefore(code5);
    }
    if (code5 === codes.eof || code5 === codes.lessThan || markdownLineEnding(code5)) {
      return nok(code5);
    }
    effects.consume(code5);
    return code5 === codes.backslash ? enclosedEscape : enclosed;
  }
  function enclosedEscape(code5) {
    if (code5 === codes.lessThan || code5 === codes.greaterThan || code5 === codes.backslash) {
      effects.consume(code5);
      return enclosed;
    }
    return enclosed(code5);
  }
  function raw2(code5) {
    if (!balance && (code5 === codes.eof || code5 === codes.rightParenthesis || markdownLineEndingOrSpace(code5))) {
      effects.exit(types.chunkString);
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type);
      return ok3(code5);
    }
    if (balance < limit && code5 === codes.leftParenthesis) {
      effects.consume(code5);
      balance++;
      return raw2;
    }
    if (code5 === codes.rightParenthesis) {
      effects.consume(code5);
      balance--;
      return raw2;
    }
    if (code5 === codes.eof || code5 === codes.space || code5 === codes.leftParenthesis || asciiControl(code5)) {
      return nok(code5);
    }
    effects.consume(code5);
    return code5 === codes.backslash ? rawEscape : raw2;
  }
  function rawEscape(code5) {
    if (code5 === codes.leftParenthesis || code5 === codes.rightParenthesis || code5 === codes.backslash) {
      effects.consume(code5);
      return raw2;
    }
    return raw2(code5);
  }
}

// ../node_modules/.pnpm/micromark-factory-label@2.0.1/node_modules/micromark-factory-label/dev/index.js
function factoryLabel(effects, ok3, nok, type, markerType, stringType) {
  const self2 = this;
  let size5 = 0;
  let seen;
  return start;
  function start(code5) {
    ok(code5 === codes.leftSquareBracket, "expected `[`");
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code5);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code5) {
    if (size5 > constants.linkReferenceSizeMax || code5 === codes.eof || code5 === codes.leftSquareBracket || code5 === codes.rightSquareBracket && !seen || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    code5 === codes.caret && !size5 && "_hiddenFootnoteSupport" in self2.parser.constructs) {
      return nok(code5);
    }
    if (code5 === codes.rightSquareBracket) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code5);
      effects.exit(markerType);
      effects.exit(type);
      return ok3;
    }
    if (markdownLineEnding(code5)) {
      effects.enter(types.lineEnding);
      effects.consume(code5);
      effects.exit(types.lineEnding);
      return atBreak;
    }
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return labelInside(code5);
  }
  function labelInside(code5) {
    if (code5 === codes.eof || code5 === codes.leftSquareBracket || code5 === codes.rightSquareBracket || markdownLineEnding(code5) || size5++ > constants.linkReferenceSizeMax) {
      effects.exit(types.chunkString);
      return atBreak(code5);
    }
    effects.consume(code5);
    if (!seen) seen = !markdownSpace(code5);
    return code5 === codes.backslash ? labelEscape : labelInside;
  }
  function labelEscape(code5) {
    if (code5 === codes.leftSquareBracket || code5 === codes.backslash || code5 === codes.rightSquareBracket) {
      effects.consume(code5);
      size5++;
      return labelInside;
    }
    return labelInside(code5);
  }
}

// ../node_modules/.pnpm/micromark-factory-title@2.0.1/node_modules/micromark-factory-title/dev/index.js
function factoryTitle(effects, ok3, nok, type, markerType, stringType) {
  let marker;
  return start;
  function start(code5) {
    if (code5 === codes.quotationMark || code5 === codes.apostrophe || code5 === codes.leftParenthesis) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code5);
      effects.exit(markerType);
      marker = code5 === codes.leftParenthesis ? codes.rightParenthesis : code5;
      return begin;
    }
    return nok(code5);
  }
  function begin(code5) {
    if (code5 === marker) {
      effects.enter(markerType);
      effects.consume(code5);
      effects.exit(markerType);
      effects.exit(type);
      return ok3;
    }
    effects.enter(stringType);
    return atBreak(code5);
  }
  function atBreak(code5) {
    if (code5 === marker) {
      effects.exit(stringType);
      return begin(marker);
    }
    if (code5 === codes.eof) {
      return nok(code5);
    }
    if (markdownLineEnding(code5)) {
      effects.enter(types.lineEnding);
      effects.consume(code5);
      effects.exit(types.lineEnding);
      return factorySpace(effects, atBreak, types.linePrefix);
    }
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return inside(code5);
  }
  function inside(code5) {
    if (code5 === marker || code5 === codes.eof || markdownLineEnding(code5)) {
      effects.exit(types.chunkString);
      return atBreak(code5);
    }
    effects.consume(code5);
    return code5 === codes.backslash ? escape2 : inside;
  }
  function escape2(code5) {
    if (code5 === marker || code5 === codes.backslash) {
      effects.consume(code5);
      return inside;
    }
    return inside(code5);
  }
}

// ../node_modules/.pnpm/micromark-factory-whitespace@2.0.1/node_modules/micromark-factory-whitespace/dev/index.js
function factoryWhitespace(effects, ok3) {
  let seen;
  return start;
  function start(code5) {
    if (markdownLineEnding(code5)) {
      effects.enter(types.lineEnding);
      effects.consume(code5);
      effects.exit(types.lineEnding);
      seen = true;
      return start;
    }
    if (markdownSpace(code5)) {
      return factorySpace(
        effects,
        start,
        seen ? types.linePrefix : types.lineSuffix
      )(code5);
    }
    return ok3(code5);
  }
}

// ../node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/dev/lib/definition.js
var definition2 = { name: "definition", tokenize: tokenizeDefinition };
var titleBefore = { partial: true, tokenize: tokenizeTitleBefore };
function tokenizeDefinition(effects, ok3, nok) {
  const self2 = this;
  let identifier;
  return start;
  function start(code5) {
    effects.enter(types.definition);
    return before(code5);
  }
  function before(code5) {
    ok(code5 === codes.leftSquareBracket, "expected `[`");
    return factoryLabel.call(
      self2,
      effects,
      labelAfter,
      // Note: we dont need to reset the way `markdown-rs` does.
      nok,
      types.definitionLabel,
      types.definitionLabelMarker,
      types.definitionLabelString
    )(code5);
  }
  function labelAfter(code5) {
    identifier = normalizeIdentifier(
      self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
    );
    if (code5 === codes.colon) {
      effects.enter(types.definitionMarker);
      effects.consume(code5);
      effects.exit(types.definitionMarker);
      return markerAfter;
    }
    return nok(code5);
  }
  function markerAfter(code5) {
    return markdownLineEndingOrSpace(code5) ? factoryWhitespace(effects, destinationBefore)(code5) : destinationBefore(code5);
  }
  function destinationBefore(code5) {
    return factoryDestination(
      effects,
      destinationAfter,
      // Note: we dont need to reset the way `markdown-rs` does.
      nok,
      types.definitionDestination,
      types.definitionDestinationLiteral,
      types.definitionDestinationLiteralMarker,
      types.definitionDestinationRaw,
      types.definitionDestinationString
    )(code5);
  }
  function destinationAfter(code5) {
    return effects.attempt(titleBefore, after, after)(code5);
  }
  function after(code5) {
    return markdownSpace(code5) ? factorySpace(effects, afterWhitespace, types.whitespace)(code5) : afterWhitespace(code5);
  }
  function afterWhitespace(code5) {
    if (code5 === codes.eof || markdownLineEnding(code5)) {
      effects.exit(types.definition);
      self2.parser.defined.push(identifier);
      return ok3(code5);
    }
    return nok(code5);
  }
}
function tokenizeTitleBefore(effects, ok3, nok) {
  return titleBefore2;
  function titleBefore2(code5) {
    return markdownLineEndingOrSpace(code5) ? factoryWhitespace(effects, beforeMarker)(code5) : nok(code5);
  }
  function beforeMarker(code5) {
    return factoryTitle(
      effects,
      titleAfter,
      nok,
      types.definitionTitle,
      types.definitionTitleMarker,
      types.definitionTitleString
    )(code5);
  }
  function titleAfter(code5) {
    return markdownSpace(code5) ? factorySpace(
      effects,
      titleAfterOptionalWhitespace,
      types.whitespace
    )(code5) : titleAfterOptionalWhitespace(code5);
  }
  function titleAfterOptionalWhitespace(code5) {
    return code5 === codes.eof || markdownLineEnding(code5) ? ok3(code5) : nok(code5);
  }
}

// ../node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/dev/lib/hard-break-escape.js
var hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok3, nok) {
  return start;
  function start(code5) {
    ok(code5 === codes.backslash, "expected `\\`");
    effects.enter(types.hardBreakEscape);
    effects.consume(code5);
    return after;
  }
  function after(code5) {
    if (markdownLineEnding(code5)) {
      effects.exit(types.hardBreakEscape);
      return ok3(code5);
    }
    return nok(code5);
  }
}

// ../node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/dev/lib/heading-atx.js
var headingAtx = {
  name: "headingAtx",
  resolve: resolveHeadingAtx,
  tokenize: tokenizeHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content5;
  let text10;
  if (events[contentStart][1].type === types.whitespace) {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === types.whitespace) {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === types.atxHeadingSequence && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === types.whitespace)) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content5 = {
      type: types.atxHeadingText,
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text10 = {
      type: types.chunkText,
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: constants.contentTypeText
    };
    splice(events, contentStart, contentEnd - contentStart + 1, [
      ["enter", content5, context],
      ["enter", text10, context],
      ["exit", text10, context],
      ["exit", content5, context]
    ]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok3, nok) {
  let size5 = 0;
  return start;
  function start(code5) {
    effects.enter(types.atxHeading);
    return before(code5);
  }
  function before(code5) {
    ok(code5 === codes.numberSign, "expected `#`");
    effects.enter(types.atxHeadingSequence);
    return sequenceOpen(code5);
  }
  function sequenceOpen(code5) {
    if (code5 === codes.numberSign && size5++ < constants.atxHeadingOpeningFenceSizeMax) {
      effects.consume(code5);
      return sequenceOpen;
    }
    if (code5 === codes.eof || markdownLineEndingOrSpace(code5)) {
      effects.exit(types.atxHeadingSequence);
      return atBreak(code5);
    }
    return nok(code5);
  }
  function atBreak(code5) {
    if (code5 === codes.numberSign) {
      effects.enter(types.atxHeadingSequence);
      return sequenceFurther(code5);
    }
    if (code5 === codes.eof || markdownLineEnding(code5)) {
      effects.exit(types.atxHeading);
      return ok3(code5);
    }
    if (markdownSpace(code5)) {
      return factorySpace(effects, atBreak, types.whitespace)(code5);
    }
    effects.enter(types.atxHeadingText);
    return data(code5);
  }
  function sequenceFurther(code5) {
    if (code5 === codes.numberSign) {
      effects.consume(code5);
      return sequenceFurther;
    }
    effects.exit(types.atxHeadingSequence);
    return atBreak(code5);
  }
  function data(code5) {
    if (code5 === codes.eof || code5 === codes.numberSign || markdownLineEndingOrSpace(code5)) {
      effects.exit(types.atxHeadingText);
      return atBreak(code5);
    }
    effects.consume(code5);
    return data;
  }
}

// ../node_modules/.pnpm/micromark-util-html-tag-name@2.0.1/node_modules/micromark-util-html-tag-name/index.js
var htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var htmlRawNames = ["pre", "script", "style", "textarea"];

// ../node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/dev/lib/html-flow.js
var htmlFlow = {
  concrete: true,
  name: "htmlFlow",
  resolveTo: resolveToHtmlFlow,
  tokenize: tokenizeHtmlFlow
};
var blankLineBefore = { partial: true, tokenize: tokenizeBlankLineBefore };
var nonLazyContinuationStart = {
  partial: true,
  tokenize: tokenizeNonLazyContinuationStart
};
function resolveToHtmlFlow(events) {
  let index4 = events.length;
  while (index4--) {
    if (events[index4][0] === "enter" && events[index4][1].type === types.htmlFlow) {
      break;
    }
  }
  if (index4 > 1 && events[index4 - 2][1].type === types.linePrefix) {
    events[index4][1].start = events[index4 - 2][1].start;
    events[index4 + 1][1].start = events[index4 - 2][1].start;
    events.splice(index4 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok3, nok) {
  const self2 = this;
  let marker;
  let closingTag;
  let buffer;
  let index4;
  let markerB;
  return start;
  function start(code5) {
    return before(code5);
  }
  function before(code5) {
    ok(code5 === codes.lessThan, "expected `<`");
    effects.enter(types.htmlFlow);
    effects.enter(types.htmlFlowData);
    effects.consume(code5);
    return open;
  }
  function open(code5) {
    if (code5 === codes.exclamationMark) {
      effects.consume(code5);
      return declarationOpen;
    }
    if (code5 === codes.slash) {
      effects.consume(code5);
      closingTag = true;
      return tagCloseStart;
    }
    if (code5 === codes.questionMark) {
      effects.consume(code5);
      marker = constants.htmlInstruction;
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    if (asciiAlpha(code5)) {
      ok(code5 !== null);
      effects.consume(code5);
      buffer = String.fromCharCode(code5);
      return tagName;
    }
    return nok(code5);
  }
  function declarationOpen(code5) {
    if (code5 === codes.dash) {
      effects.consume(code5);
      marker = constants.htmlComment;
      return commentOpenInside;
    }
    if (code5 === codes.leftSquareBracket) {
      effects.consume(code5);
      marker = constants.htmlCdata;
      index4 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code5)) {
      effects.consume(code5);
      marker = constants.htmlDeclaration;
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code5);
  }
  function commentOpenInside(code5) {
    if (code5 === codes.dash) {
      effects.consume(code5);
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code5);
  }
  function cdataOpenInside(code5) {
    const value = constants.cdataOpeningString;
    if (code5 === value.charCodeAt(index4++)) {
      effects.consume(code5);
      if (index4 === value.length) {
        return self2.interrupt ? ok3 : continuation;
      }
      return cdataOpenInside;
    }
    return nok(code5);
  }
  function tagCloseStart(code5) {
    if (asciiAlpha(code5)) {
      ok(code5 !== null);
      effects.consume(code5);
      buffer = String.fromCharCode(code5);
      return tagName;
    }
    return nok(code5);
  }
  function tagName(code5) {
    if (code5 === codes.eof || code5 === codes.slash || code5 === codes.greaterThan || markdownLineEndingOrSpace(code5)) {
      const slash = code5 === codes.slash;
      const name = buffer.toLowerCase();
      if (!slash && !closingTag && htmlRawNames.includes(name)) {
        marker = constants.htmlRaw;
        return self2.interrupt ? ok3(code5) : continuation(code5);
      }
      if (htmlBlockNames.includes(buffer.toLowerCase())) {
        marker = constants.htmlBasic;
        if (slash) {
          effects.consume(code5);
          return basicSelfClosing;
        }
        return self2.interrupt ? ok3(code5) : continuation(code5);
      }
      marker = constants.htmlComplete;
      return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code5) : closingTag ? completeClosingTagAfter(code5) : completeAttributeNameBefore(code5);
    }
    if (code5 === codes.dash || asciiAlphanumeric(code5)) {
      effects.consume(code5);
      buffer += String.fromCharCode(code5);
      return tagName;
    }
    return nok(code5);
  }
  function basicSelfClosing(code5) {
    if (code5 === codes.greaterThan) {
      effects.consume(code5);
      return self2.interrupt ? ok3 : continuation;
    }
    return nok(code5);
  }
  function completeClosingTagAfter(code5) {
    if (markdownSpace(code5)) {
      effects.consume(code5);
      return completeClosingTagAfter;
    }
    return completeEnd(code5);
  }
  function completeAttributeNameBefore(code5) {
    if (code5 === codes.slash) {
      effects.consume(code5);
      return completeEnd;
    }
    if (code5 === codes.colon || code5 === codes.underscore || asciiAlpha(code5)) {
      effects.consume(code5);
      return completeAttributeName;
    }
    if (markdownSpace(code5)) {
      effects.consume(code5);
      return completeAttributeNameBefore;
    }
    return completeEnd(code5);
  }
  function completeAttributeName(code5) {
    if (code5 === codes.dash || code5 === codes.dot || code5 === codes.colon || code5 === codes.underscore || asciiAlphanumeric(code5)) {
      effects.consume(code5);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code5);
  }
  function completeAttributeNameAfter(code5) {
    if (code5 === codes.equalsTo) {
      effects.consume(code5);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code5)) {
      effects.consume(code5);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code5);
  }
  function completeAttributeValueBefore(code5) {
    if (code5 === codes.eof || code5 === codes.lessThan || code5 === codes.equalsTo || code5 === codes.greaterThan || code5 === codes.graveAccent) {
      return nok(code5);
    }
    if (code5 === codes.quotationMark || code5 === codes.apostrophe) {
      effects.consume(code5);
      markerB = code5;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code5)) {
      effects.consume(code5);
      return completeAttributeValueBefore;
    }
    return completeAttributeValueUnquoted(code5);
  }
  function completeAttributeValueQuoted(code5) {
    if (code5 === markerB) {
      effects.consume(code5);
      markerB = null;
      return completeAttributeValueQuotedAfter;
    }
    if (code5 === codes.eof || markdownLineEnding(code5)) {
      return nok(code5);
    }
    effects.consume(code5);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code5) {
    if (code5 === codes.eof || code5 === codes.quotationMark || code5 === codes.apostrophe || code5 === codes.slash || code5 === codes.lessThan || code5 === codes.equalsTo || code5 === codes.greaterThan || code5 === codes.graveAccent || markdownLineEndingOrSpace(code5)) {
      return completeAttributeNameAfter(code5);
    }
    effects.consume(code5);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code5) {
    if (code5 === codes.slash || code5 === codes.greaterThan || markdownSpace(code5)) {
      return completeAttributeNameBefore(code5);
    }
    return nok(code5);
  }
  function completeEnd(code5) {
    if (code5 === codes.greaterThan) {
      effects.consume(code5);
      return completeAfter;
    }
    return nok(code5);
  }
  function completeAfter(code5) {
    if (code5 === codes.eof || markdownLineEnding(code5)) {
      return continuation(code5);
    }
    if (markdownSpace(code5)) {
      effects.consume(code5);
      return completeAfter;
    }
    return nok(code5);
  }
  function continuation(code5) {
    if (code5 === codes.dash && marker === constants.htmlComment) {
      effects.consume(code5);
      return continuationCommentInside;
    }
    if (code5 === codes.lessThan && marker === constants.htmlRaw) {
      effects.consume(code5);
      return continuationRawTagOpen;
    }
    if (code5 === codes.greaterThan && marker === constants.htmlDeclaration) {
      effects.consume(code5);
      return continuationClose;
    }
    if (code5 === codes.questionMark && marker === constants.htmlInstruction) {
      effects.consume(code5);
      return continuationDeclarationInside;
    }
    if (code5 === codes.rightSquareBracket && marker === constants.htmlCdata) {
      effects.consume(code5);
      return continuationCdataInside;
    }
    if (markdownLineEnding(code5) && (marker === constants.htmlBasic || marker === constants.htmlComplete)) {
      effects.exit(types.htmlFlowData);
      return effects.check(
        blankLineBefore,
        continuationAfter,
        continuationStart
      )(code5);
    }
    if (code5 === codes.eof || markdownLineEnding(code5)) {
      effects.exit(types.htmlFlowData);
      return continuationStart(code5);
    }
    effects.consume(code5);
    return continuation;
  }
  function continuationStart(code5) {
    return effects.check(
      nonLazyContinuationStart,
      continuationStartNonLazy,
      continuationAfter
    )(code5);
  }
  function continuationStartNonLazy(code5) {
    ok(markdownLineEnding(code5));
    effects.enter(types.lineEnding);
    effects.consume(code5);
    effects.exit(types.lineEnding);
    return continuationBefore;
  }
  function continuationBefore(code5) {
    if (code5 === codes.eof || markdownLineEnding(code5)) {
      return continuationStart(code5);
    }
    effects.enter(types.htmlFlowData);
    return continuation(code5);
  }
  function continuationCommentInside(code5) {
    if (code5 === codes.dash) {
      effects.consume(code5);
      return continuationDeclarationInside;
    }
    return continuation(code5);
  }
  function continuationRawTagOpen(code5) {
    if (code5 === codes.slash) {
      effects.consume(code5);
      buffer = "";
      return continuationRawEndTag;
    }
    return continuation(code5);
  }
  function continuationRawEndTag(code5) {
    if (code5 === codes.greaterThan) {
      const name = buffer.toLowerCase();
      if (htmlRawNames.includes(name)) {
        effects.consume(code5);
        return continuationClose;
      }
      return continuation(code5);
    }
    if (asciiAlpha(code5) && buffer.length < constants.htmlRawSizeMax) {
      ok(code5 !== null);
      effects.consume(code5);
      buffer += String.fromCharCode(code5);
      return continuationRawEndTag;
    }
    return continuation(code5);
  }
  function continuationCdataInside(code5) {
    if (code5 === codes.rightSquareBracket) {
      effects.consume(code5);
      return continuationDeclarationInside;
    }
    return continuation(code5);
  }
  function continuationDeclarationInside(code5) {
    if (code5 === codes.greaterThan) {
      effects.consume(code5);
      return continuationClose;
    }
    if (code5 === codes.dash && marker === constants.htmlComment) {
      effects.consume(code5);
      return continuationDeclarationInside;
    }
    return continuation(code5);
  }
  function continuationClose(code5) {
    if (code5 === codes.eof || markdownLineEnding(code5)) {
      effects.exit(types.htmlFlowData);
      return continuationAfter(code5);
    }
    effects.consume(code5);
    return continuationClose;
  }
  function continuationAfter(code5) {
    effects.exit(types.htmlFlow);
    return ok3(code5);
  }
}
function tokenizeNonLazyContinuationStart(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code5) {
    if (markdownLineEnding(code5)) {
      effects.enter(types.lineEnding);
      effects.consume(code5);
      effects.exit(types.lineEnding);
      return after;
    }
    return nok(code5);
  }
  function after(code5) {
    return self2.parser.lazy[self2.now().line] ? nok(code5) : ok3(code5);
  }
}
function tokenizeBlankLineBefore(effects, ok3, nok) {
  return start;
  function start(code5) {
    ok(markdownLineEnding(code5), "expected a line ending");
    effects.enter(types.lineEnding);
    effects.consume(code5);
    effects.exit(types.lineEnding);
    return effects.attempt(blankLine, ok3, nok);
  }
}

// ../node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/dev/lib/html-text.js
var htmlText = { name: "htmlText", tokenize: tokenizeHtmlText };
function tokenizeHtmlText(effects, ok3, nok) {
  const self2 = this;
  let marker;
  let index4;
  let returnState;
  return start;
  function start(code5) {
    ok(code5 === codes.lessThan, "expected `<`");
    effects.enter(types.htmlText);
    effects.enter(types.htmlTextData);
    effects.consume(code5);
    return open;
  }
  function open(code5) {
    if (code5 === codes.exclamationMark) {
      effects.consume(code5);
      return declarationOpen;
    }
    if (code5 === codes.slash) {
      effects.consume(code5);
      return tagCloseStart;
    }
    if (code5 === codes.questionMark) {
      effects.consume(code5);
      return instruction;
    }
    if (asciiAlpha(code5)) {
      effects.consume(code5);
      return tagOpen;
    }
    return nok(code5);
  }
  function declarationOpen(code5) {
    if (code5 === codes.dash) {
      effects.consume(code5);
      return commentOpenInside;
    }
    if (code5 === codes.leftSquareBracket) {
      effects.consume(code5);
      index4 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code5)) {
      effects.consume(code5);
      return declaration;
    }
    return nok(code5);
  }
  function commentOpenInside(code5) {
    if (code5 === codes.dash) {
      effects.consume(code5);
      return commentEnd;
    }
    return nok(code5);
  }
  function comment4(code5) {
    if (code5 === codes.eof) {
      return nok(code5);
    }
    if (code5 === codes.dash) {
      effects.consume(code5);
      return commentClose;
    }
    if (markdownLineEnding(code5)) {
      returnState = comment4;
      return lineEndingBefore(code5);
    }
    effects.consume(code5);
    return comment4;
  }
  function commentClose(code5) {
    if (code5 === codes.dash) {
      effects.consume(code5);
      return commentEnd;
    }
    return comment4(code5);
  }
  function commentEnd(code5) {
    return code5 === codes.greaterThan ? end(code5) : code5 === codes.dash ? commentClose(code5) : comment4(code5);
  }
  function cdataOpenInside(code5) {
    const value = constants.cdataOpeningString;
    if (code5 === value.charCodeAt(index4++)) {
      effects.consume(code5);
      return index4 === value.length ? cdata : cdataOpenInside;
    }
    return nok(code5);
  }
  function cdata(code5) {
    if (code5 === codes.eof) {
      return nok(code5);
    }
    if (code5 === codes.rightSquareBracket) {
      effects.consume(code5);
      return cdataClose;
    }
    if (markdownLineEnding(code5)) {
      returnState = cdata;
      return lineEndingBefore(code5);
    }
    effects.consume(code5);
    return cdata;
  }
  function cdataClose(code5) {
    if (code5 === codes.rightSquareBracket) {
      effects.consume(code5);
      return cdataEnd;
    }
    return cdata(code5);
  }
  function cdataEnd(code5) {
    if (code5 === codes.greaterThan) {
      return end(code5);
    }
    if (code5 === codes.rightSquareBracket) {
      effects.consume(code5);
      return cdataEnd;
    }
    return cdata(code5);
  }
  function declaration(code5) {
    if (code5 === codes.eof || code5 === codes.greaterThan) {
      return end(code5);
    }
    if (markdownLineEnding(code5)) {
      returnState = declaration;
      return lineEndingBefore(code5);
    }
    effects.consume(code5);
    return declaration;
  }
  function instruction(code5) {
    if (code5 === codes.eof) {
      return nok(code5);
    }
    if (code5 === codes.questionMark) {
      effects.consume(code5);
      return instructionClose;
    }
    if (markdownLineEnding(code5)) {
      returnState = instruction;
      return lineEndingBefore(code5);
    }
    effects.consume(code5);
    return instruction;
  }
  function instructionClose(code5) {
    return code5 === codes.greaterThan ? end(code5) : instruction(code5);
  }
  function tagCloseStart(code5) {
    if (asciiAlpha(code5)) {
      effects.consume(code5);
      return tagClose;
    }
    return nok(code5);
  }
  function tagClose(code5) {
    if (code5 === codes.dash || asciiAlphanumeric(code5)) {
      effects.consume(code5);
      return tagClose;
    }
    return tagCloseBetween(code5);
  }
  function tagCloseBetween(code5) {
    if (markdownLineEnding(code5)) {
      returnState = tagCloseBetween;
      return lineEndingBefore(code5);
    }
    if (markdownSpace(code5)) {
      effects.consume(code5);
      return tagCloseBetween;
    }
    return end(code5);
  }
  function tagOpen(code5) {
    if (code5 === codes.dash || asciiAlphanumeric(code5)) {
      effects.consume(code5);
      return tagOpen;
    }
    if (code5 === codes.slash || code5 === codes.greaterThan || markdownLineEndingOrSpace(code5)) {
      return tagOpenBetween(code5);
    }
    return nok(code5);
  }
  function tagOpenBetween(code5) {
    if (code5 === codes.slash) {
      effects.consume(code5);
      return end;
    }
    if (code5 === codes.colon || code5 === codes.underscore || asciiAlpha(code5)) {
      effects.consume(code5);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code5)) {
      returnState = tagOpenBetween;
      return lineEndingBefore(code5);
    }
    if (markdownSpace(code5)) {
      effects.consume(code5);
      return tagOpenBetween;
    }
    return end(code5);
  }
  function tagOpenAttributeName(code5) {
    if (code5 === codes.dash || code5 === codes.dot || code5 === codes.colon || code5 === codes.underscore || asciiAlphanumeric(code5)) {
      effects.consume(code5);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code5);
  }
  function tagOpenAttributeNameAfter(code5) {
    if (code5 === codes.equalsTo) {
      effects.consume(code5);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code5)) {
      returnState = tagOpenAttributeNameAfter;
      return lineEndingBefore(code5);
    }
    if (markdownSpace(code5)) {
      effects.consume(code5);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code5);
  }
  function tagOpenAttributeValueBefore(code5) {
    if (code5 === codes.eof || code5 === codes.lessThan || code5 === codes.equalsTo || code5 === codes.greaterThan || code5 === codes.graveAccent) {
      return nok(code5);
    }
    if (code5 === codes.quotationMark || code5 === codes.apostrophe) {
      effects.consume(code5);
      marker = code5;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code5)) {
      returnState = tagOpenAttributeValueBefore;
      return lineEndingBefore(code5);
    }
    if (markdownSpace(code5)) {
      effects.consume(code5);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code5);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code5) {
    if (code5 === marker) {
      effects.consume(code5);
      marker = void 0;
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code5 === codes.eof) {
      return nok(code5);
    }
    if (markdownLineEnding(code5)) {
      returnState = tagOpenAttributeValueQuoted;
      return lineEndingBefore(code5);
    }
    effects.consume(code5);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueUnquoted(code5) {
    if (code5 === codes.eof || code5 === codes.quotationMark || code5 === codes.apostrophe || code5 === codes.lessThan || code5 === codes.equalsTo || code5 === codes.graveAccent) {
      return nok(code5);
    }
    if (code5 === codes.slash || code5 === codes.greaterThan || markdownLineEndingOrSpace(code5)) {
      return tagOpenBetween(code5);
    }
    effects.consume(code5);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuotedAfter(code5) {
    if (code5 === codes.slash || code5 === codes.greaterThan || markdownLineEndingOrSpace(code5)) {
      return tagOpenBetween(code5);
    }
    return nok(code5);
  }
  function end(code5) {
    if (code5 === codes.greaterThan) {
      effects.consume(code5);
      effects.exit(types.htmlTextData);
      effects.exit(types.htmlText);
      return ok3;
    }
    return nok(code5);
  }
  function lineEndingBefore(code5) {
    ok(returnState, "expected return state");
    ok(markdownLineEnding(code5), "expected eol");
    effects.exit(types.htmlTextData);
    effects.enter(types.lineEnding);
    effects.consume(code5);
    effects.exit(types.lineEnding);
    return lineEndingAfter;
  }
  function lineEndingAfter(code5) {
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    return markdownSpace(code5) ? factorySpace(
      effects,
      lineEndingAfterPrefix,
      types.linePrefix,
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
    )(code5) : lineEndingAfterPrefix(code5);
  }
  function lineEndingAfterPrefix(code5) {
    effects.enter(types.htmlTextData);
    return returnState(code5);
  }
}

// ../node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/dev/lib/label-end.js
var labelEnd = {
  name: "labelEnd",
  resolveAll: resolveAllLabelEnd,
  resolveTo: resolveToLabelEnd,
  tokenize: tokenizeLabelEnd
};
var resourceConstruct = { tokenize: tokenizeResource };
var referenceFullConstruct = { tokenize: tokenizeReferenceFull };
var referenceCollapsedConstruct = { tokenize: tokenizeReferenceCollapsed };
function resolveAllLabelEnd(events) {
  let index4 = -1;
  const newEvents = [];
  while (++index4 < events.length) {
    const token = events[index4][1];
    newEvents.push(events[index4]);
    if (token.type === types.labelImage || token.type === types.labelLink || token.type === types.labelEnd) {
      const offset4 = token.type === types.labelImage ? 4 : 2;
      token.type = types.data;
      index4 += offset4;
    }
  }
  if (events.length !== newEvents.length) {
    splice(events, 0, events.length, newEvents);
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index4 = events.length;
  let offset4 = 0;
  let token;
  let open;
  let close;
  let media2;
  while (index4--) {
    token = events[index4][1];
    if (open) {
      if (token.type === types.link || token.type === types.labelLink && token._inactive) {
        break;
      }
      if (events[index4][0] === "enter" && token.type === types.labelLink) {
        token._inactive = true;
      }
    } else if (close) {
      if (events[index4][0] === "enter" && (token.type === types.labelImage || token.type === types.labelLink) && !token._balanced) {
        open = index4;
        if (token.type !== types.labelLink) {
          offset4 = 2;
          break;
        }
      }
    } else if (token.type === types.labelEnd) {
      close = index4;
    }
  }
  ok(open !== void 0, "`open` is supposed to be found");
  ok(close !== void 0, "`close` is supposed to be found");
  const group = {
    type: events[open][1].type === types.labelLink ? types.link : types.image,
    start: { ...events[open][1].start },
    end: { ...events[events.length - 1][1].end }
  };
  const label = {
    type: types.label,
    start: { ...events[open][1].start },
    end: { ...events[close][1].end }
  };
  const text10 = {
    type: types.labelText,
    start: { ...events[open + offset4 + 2][1].end },
    end: { ...events[close - 2][1].start }
  };
  media2 = [
    ["enter", group, context],
    ["enter", label, context]
  ];
  media2 = push(media2, events.slice(open + 1, open + offset4 + 3));
  media2 = push(media2, [["enter", text10, context]]);
  ok(
    context.parser.constructs.insideSpan.null,
    "expected `insideSpan.null` to be populated"
  );
  media2 = push(
    media2,
    resolveAll(
      context.parser.constructs.insideSpan.null,
      events.slice(open + offset4 + 4, close - 3),
      context
    )
  );
  media2 = push(media2, [
    ["exit", text10, context],
    events[close - 2],
    events[close - 1],
    ["exit", label, context]
  ]);
  media2 = push(media2, events.slice(close + 1));
  media2 = push(media2, [["exit", group, context]]);
  splice(events, open, events.length, media2);
  return events;
}
function tokenizeLabelEnd(effects, ok3, nok) {
  const self2 = this;
  let index4 = self2.events.length;
  let labelStart;
  let defined;
  while (index4--) {
    if ((self2.events[index4][1].type === types.labelImage || self2.events[index4][1].type === types.labelLink) && !self2.events[index4][1]._balanced) {
      labelStart = self2.events[index4][1];
      break;
    }
  }
  return start;
  function start(code5) {
    ok(code5 === codes.rightSquareBracket, "expected `]`");
    if (!labelStart) {
      return nok(code5);
    }
    if (labelStart._inactive) {
      return labelEndNok(code5);
    }
    defined = self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize({ start: labelStart.end, end: self2.now() })
      )
    );
    effects.enter(types.labelEnd);
    effects.enter(types.labelMarker);
    effects.consume(code5);
    effects.exit(types.labelMarker);
    effects.exit(types.labelEnd);
    return after;
  }
  function after(code5) {
    if (code5 === codes.leftParenthesis) {
      return effects.attempt(
        resourceConstruct,
        labelEndOk,
        defined ? labelEndOk : labelEndNok
      )(code5);
    }
    if (code5 === codes.leftSquareBracket) {
      return effects.attempt(
        referenceFullConstruct,
        labelEndOk,
        defined ? referenceNotFull : labelEndNok
      )(code5);
    }
    return defined ? labelEndOk(code5) : labelEndNok(code5);
  }
  function referenceNotFull(code5) {
    return effects.attempt(
      referenceCollapsedConstruct,
      labelEndOk,
      labelEndNok
    )(code5);
  }
  function labelEndOk(code5) {
    return ok3(code5);
  }
  function labelEndNok(code5) {
    labelStart._balanced = true;
    return nok(code5);
  }
}
function tokenizeResource(effects, ok3, nok) {
  return resourceStart;
  function resourceStart(code5) {
    ok(code5 === codes.leftParenthesis, "expected left paren");
    effects.enter(types.resource);
    effects.enter(types.resourceMarker);
    effects.consume(code5);
    effects.exit(types.resourceMarker);
    return resourceBefore;
  }
  function resourceBefore(code5) {
    return markdownLineEndingOrSpace(code5) ? factoryWhitespace(effects, resourceOpen)(code5) : resourceOpen(code5);
  }
  function resourceOpen(code5) {
    if (code5 === codes.rightParenthesis) {
      return resourceEnd(code5);
    }
    return factoryDestination(
      effects,
      resourceDestinationAfter,
      resourceDestinationMissing,
      types.resourceDestination,
      types.resourceDestinationLiteral,
      types.resourceDestinationLiteralMarker,
      types.resourceDestinationRaw,
      types.resourceDestinationString,
      constants.linkResourceDestinationBalanceMax
    )(code5);
  }
  function resourceDestinationAfter(code5) {
    return markdownLineEndingOrSpace(code5) ? factoryWhitespace(effects, resourceBetween)(code5) : resourceEnd(code5);
  }
  function resourceDestinationMissing(code5) {
    return nok(code5);
  }
  function resourceBetween(code5) {
    if (code5 === codes.quotationMark || code5 === codes.apostrophe || code5 === codes.leftParenthesis) {
      return factoryTitle(
        effects,
        resourceTitleAfter,
        nok,
        types.resourceTitle,
        types.resourceTitleMarker,
        types.resourceTitleString
      )(code5);
    }
    return resourceEnd(code5);
  }
  function resourceTitleAfter(code5) {
    return markdownLineEndingOrSpace(code5) ? factoryWhitespace(effects, resourceEnd)(code5) : resourceEnd(code5);
  }
  function resourceEnd(code5) {
    if (code5 === codes.rightParenthesis) {
      effects.enter(types.resourceMarker);
      effects.consume(code5);
      effects.exit(types.resourceMarker);
      effects.exit(types.resource);
      return ok3;
    }
    return nok(code5);
  }
}
function tokenizeReferenceFull(effects, ok3, nok) {
  const self2 = this;
  return referenceFull;
  function referenceFull(code5) {
    ok(code5 === codes.leftSquareBracket, "expected left bracket");
    return factoryLabel.call(
      self2,
      effects,
      referenceFullAfter,
      referenceFullMissing,
      types.reference,
      types.referenceMarker,
      types.referenceString
    )(code5);
  }
  function referenceFullAfter(code5) {
    return self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
      )
    ) ? ok3(code5) : nok(code5);
  }
  function referenceFullMissing(code5) {
    return nok(code5);
  }
}
function tokenizeReferenceCollapsed(effects, ok3, nok) {
  return referenceCollapsedStart;
  function referenceCollapsedStart(code5) {
    ok(code5 === codes.leftSquareBracket, "expected left bracket");
    effects.enter(types.reference);
    effects.enter(types.referenceMarker);
    effects.consume(code5);
    effects.exit(types.referenceMarker);
    return referenceCollapsedOpen;
  }
  function referenceCollapsedOpen(code5) {
    if (code5 === codes.rightSquareBracket) {
      effects.enter(types.referenceMarker);
      effects.consume(code5);
      effects.exit(types.referenceMarker);
      effects.exit(types.reference);
      return ok3;
    }
    return nok(code5);
  }
}

// ../node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/dev/lib/label-start-image.js
var labelStartImage = {
  name: "labelStartImage",
  resolveAll: labelEnd.resolveAll,
  tokenize: tokenizeLabelStartImage
};
function tokenizeLabelStartImage(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code5) {
    ok(code5 === codes.exclamationMark, "expected `!`");
    effects.enter(types.labelImage);
    effects.enter(types.labelImageMarker);
    effects.consume(code5);
    effects.exit(types.labelImageMarker);
    return open;
  }
  function open(code5) {
    if (code5 === codes.leftSquareBracket) {
      effects.enter(types.labelMarker);
      effects.consume(code5);
      effects.exit(types.labelMarker);
      effects.exit(types.labelImage);
      return after;
    }
    return nok(code5);
  }
  function after(code5) {
    return code5 === codes.caret && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code5) : ok3(code5);
  }
}

// ../node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/dev/lib/label-start-link.js
var labelStartLink = {
  name: "labelStartLink",
  resolveAll: labelEnd.resolveAll,
  tokenize: tokenizeLabelStartLink
};
function tokenizeLabelStartLink(effects, ok3, nok) {
  const self2 = this;
  return start;
  function start(code5) {
    ok(code5 === codes.leftSquareBracket, "expected `[`");
    effects.enter(types.labelLink);
    effects.enter(types.labelMarker);
    effects.consume(code5);
    effects.exit(types.labelMarker);
    effects.exit(types.labelLink);
    return after;
  }
  function after(code5) {
    return code5 === codes.caret && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code5) : ok3(code5);
  }
}

// ../node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/dev/lib/line-ending.js
var lineEnding = { name: "lineEnding", tokenize: tokenizeLineEnding };
function tokenizeLineEnding(effects, ok3) {
  return start;
  function start(code5) {
    ok(markdownLineEnding(code5), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code5);
    effects.exit(types.lineEnding);
    return factorySpace(effects, ok3, types.linePrefix);
  }
}

// ../node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/dev/lib/thematic-break.js
var thematicBreak2 = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok3, nok) {
  let size5 = 0;
  let marker;
  return start;
  function start(code5) {
    effects.enter(types.thematicBreak);
    return before(code5);
  }
  function before(code5) {
    ok(
      code5 === codes.asterisk || code5 === codes.dash || code5 === codes.underscore,
      "expected `*`, `-`, or `_`"
    );
    marker = code5;
    return atBreak(code5);
  }
  function atBreak(code5) {
    if (code5 === marker) {
      effects.enter(types.thematicBreakSequence);
      return sequence(code5);
    }
    if (size5 >= constants.thematicBreakMarkerCountMin && (code5 === codes.eof || markdownLineEnding(code5))) {
      effects.exit(types.thematicBreak);
      return ok3(code5);
    }
    return nok(code5);
  }
  function sequence(code5) {
    if (code5 === marker) {
      effects.consume(code5);
      size5++;
      return sequence;
    }
    effects.exit(types.thematicBreakSequence);
    return markdownSpace(code5) ? factorySpace(effects, atBreak, types.whitespace)(code5) : atBreak(code5);
  }
}

// ../node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/dev/lib/list.js
var list5 = {
  continuation: { tokenize: tokenizeListContinuation },
  exit: tokenizeListEnd,
  name: "list",
  tokenize: tokenizeListStart
};
var listItemPrefixWhitespaceConstruct = {
  partial: true,
  tokenize: tokenizeListItemPrefixWhitespace
};
var indentConstruct = { partial: true, tokenize: tokenizeIndent };
function tokenizeListStart(effects, ok3, nok) {
  const self2 = this;
  const tail = self2.events[self2.events.length - 1];
  let initialSize = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size5 = 0;
  return start;
  function start(code5) {
    ok(self2.containerState, "expected state");
    const kind = self2.containerState.type || (code5 === codes.asterisk || code5 === codes.plusSign || code5 === codes.dash ? types.listUnordered : types.listOrdered);
    if (kind === types.listUnordered ? !self2.containerState.marker || code5 === self2.containerState.marker : asciiDigit(code5)) {
      if (!self2.containerState.type) {
        self2.containerState.type = kind;
        effects.enter(kind, { _container: true });
      }
      if (kind === types.listUnordered) {
        effects.enter(types.listItemPrefix);
        return code5 === codes.asterisk || code5 === codes.dash ? effects.check(thematicBreak2, nok, atMarker)(code5) : atMarker(code5);
      }
      if (!self2.interrupt || code5 === codes.digit1) {
        effects.enter(types.listItemPrefix);
        effects.enter(types.listItemValue);
        return inside(code5);
      }
    }
    return nok(code5);
  }
  function inside(code5) {
    ok(self2.containerState, "expected state");
    if (asciiDigit(code5) && ++size5 < constants.listItemValueSizeMax) {
      effects.consume(code5);
      return inside;
    }
    if ((!self2.interrupt || size5 < 2) && (self2.containerState.marker ? code5 === self2.containerState.marker : code5 === codes.rightParenthesis || code5 === codes.dot)) {
      effects.exit(types.listItemValue);
      return atMarker(code5);
    }
    return nok(code5);
  }
  function atMarker(code5) {
    ok(self2.containerState, "expected state");
    ok(code5 !== codes.eof, "eof (`null`) is not a marker");
    effects.enter(types.listItemMarker);
    effects.consume(code5);
    effects.exit(types.listItemMarker);
    self2.containerState.marker = self2.containerState.marker || code5;
    return effects.check(
      blankLine,
      // Cant be empty when interrupting.
      self2.interrupt ? nok : onBlank,
      effects.attempt(
        listItemPrefixWhitespaceConstruct,
        endOfPrefix,
        otherPrefix
      )
    );
  }
  function onBlank(code5) {
    ok(self2.containerState, "expected state");
    self2.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code5);
  }
  function otherPrefix(code5) {
    if (markdownSpace(code5)) {
      effects.enter(types.listItemPrefixWhitespace);
      effects.consume(code5);
      effects.exit(types.listItemPrefixWhitespace);
      return endOfPrefix;
    }
    return nok(code5);
  }
  function endOfPrefix(code5) {
    ok(self2.containerState, "expected state");
    self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit(types.listItemPrefix), true).length;
    return ok3(code5);
  }
}
function tokenizeListContinuation(effects, ok3, nok) {
  const self2 = this;
  ok(self2.containerState, "expected state");
  self2.containerState._closeFlow = void 0;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code5) {
    ok(self2.containerState, "expected state");
    ok(typeof self2.containerState.size === "number", "expected size");
    self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
    return factorySpace(
      effects,
      ok3,
      types.listItemIndent,
      self2.containerState.size + 1
    )(code5);
  }
  function notBlank(code5) {
    ok(self2.containerState, "expected state");
    if (self2.containerState.furtherBlankLines || !markdownSpace(code5)) {
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code5);
    }
    self2.containerState.furtherBlankLines = void 0;
    self2.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok3, notInCurrentItem)(code5);
  }
  function notInCurrentItem(code5) {
    ok(self2.containerState, "expected state");
    self2.containerState._closeFlow = true;
    self2.interrupt = void 0;
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    return factorySpace(
      effects,
      effects.attempt(list5, ok3, nok),
      types.linePrefix,
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
    )(code5);
  }
}
function tokenizeIndent(effects, ok3, nok) {
  const self2 = this;
  ok(self2.containerState, "expected state");
  ok(typeof self2.containerState.size === "number", "expected size");
  return factorySpace(
    effects,
    afterPrefix,
    types.listItemIndent,
    self2.containerState.size + 1
  );
  function afterPrefix(code5) {
    ok(self2.containerState, "expected state");
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types.listItemIndent && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok3(code5) : nok(code5);
  }
}
function tokenizeListEnd(effects) {
  ok(this.containerState, "expected state");
  ok(typeof this.containerState.type === "string", "expected type");
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok3, nok) {
  const self2 = this;
  ok(
    self2.parser.constructs.disable.null,
    "expected `disable.null` to be populated"
  );
  return factorySpace(
    effects,
    afterPrefix,
    types.listItemPrefixWhitespace,
    self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize + 1
  );
  function afterPrefix(code5) {
    const tail = self2.events[self2.events.length - 1];
    return !markdownSpace(code5) && tail && tail[1].type === types.listItemPrefixWhitespace ? ok3(code5) : nok(code5);
  }
}

// ../node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/dev/lib/setext-underline.js
var setextUnderline = {
  name: "setextUnderline",
  resolveTo: resolveToSetextUnderline,
  tokenize: tokenizeSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index4 = events.length;
  let content5;
  let text10;
  let definition3;
  while (index4--) {
    if (events[index4][0] === "enter") {
      if (events[index4][1].type === types.content) {
        content5 = index4;
        break;
      }
      if (events[index4][1].type === types.paragraph) {
        text10 = index4;
      }
    } else {
      if (events[index4][1].type === types.content) {
        events.splice(index4, 1);
      }
      if (!definition3 && events[index4][1].type === types.definition) {
        definition3 = index4;
      }
    }
  }
  ok(text10 !== void 0, "expected a `text` index to be found");
  ok(content5 !== void 0, "expected a `text` index to be found");
  ok(events[content5][2] === context, "enter context should be same");
  ok(
    events[events.length - 1][2] === context,
    "enter context should be same"
  );
  const heading4 = {
    type: types.setextHeading,
    start: { ...events[content5][1].start },
    end: { ...events[events.length - 1][1].end }
  };
  events[text10][1].type = types.setextHeadingText;
  if (definition3) {
    events.splice(text10, 0, ["enter", heading4, context]);
    events.splice(definition3 + 1, 0, ["exit", events[content5][1], context]);
    events[content5][1].end = { ...events[definition3][1].end };
  } else {
    events[content5][1] = heading4;
  }
  events.push(["exit", heading4, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok3, nok) {
  const self2 = this;
  let marker;
  return start;
  function start(code5) {
    let index4 = self2.events.length;
    let paragraph3;
    ok(
      code5 === codes.dash || code5 === codes.equalsTo,
      "expected `=` or `-`"
    );
    while (index4--) {
      if (self2.events[index4][1].type !== types.lineEnding && self2.events[index4][1].type !== types.linePrefix && self2.events[index4][1].type !== types.content) {
        paragraph3 = self2.events[index4][1].type === types.paragraph;
        break;
      }
    }
    if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph3)) {
      effects.enter(types.setextHeadingLine);
      marker = code5;
      return before(code5);
    }
    return nok(code5);
  }
  function before(code5) {
    effects.enter(types.setextHeadingLineSequence);
    return inside(code5);
  }
  function inside(code5) {
    if (code5 === marker) {
      effects.consume(code5);
      return inside;
    }
    effects.exit(types.setextHeadingLineSequence);
    return markdownSpace(code5) ? factorySpace(effects, after, types.lineSuffix)(code5) : after(code5);
  }
  function after(code5) {
    if (code5 === codes.eof || markdownLineEnding(code5)) {
      effects.exit(types.setextHeadingLine);
      return ok3(code5);
    }
    return nok(code5);
  }
}

// ../node_modules/.pnpm/micromark-extension-gfm-footnote@2.1.0/node_modules/micromark-extension-gfm-footnote/dev/lib/syntax.js
var indent = { tokenize: tokenizeIndent2, partial: true };
function gfmFootnote() {
  return {
    document: {
      [codes.leftSquareBracket]: {
        name: "gfmFootnoteDefinition",
        tokenize: tokenizeDefinitionStart,
        continuation: { tokenize: tokenizeDefinitionContinuation },
        exit: gfmFootnoteDefinitionEnd
      }
    },
    text: {
      [codes.leftSquareBracket]: {
        name: "gfmFootnoteCall",
        tokenize: tokenizeGfmFootnoteCall
      },
      [codes.rightSquareBracket]: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: tokenizePotentialGfmFootnoteCall,
        resolveTo: resolveToPotentialGfmFootnoteCall
      }
    }
  };
}
function tokenizePotentialGfmFootnoteCall(effects, ok3, nok) {
  const self2 = this;
  let index4 = self2.events.length;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let labelStart;
  while (index4--) {
    const token = self2.events[index4][1];
    if (token.type === types.labelImage) {
      labelStart = token;
      break;
    }
    if (token.type === "gfmFootnoteCall" || token.type === types.labelLink || token.type === types.label || token.type === types.image || token.type === types.link) {
      break;
    }
  }
  return start;
  function start(code5) {
    ok(code5 === codes.rightSquareBracket, "expected `]`");
    if (!labelStart || !labelStart._balanced) {
      return nok(code5);
    }
    const id2 = normalizeIdentifier(
      self2.sliceSerialize({ start: labelStart.end, end: self2.now() })
    );
    if (id2.codePointAt(0) !== codes.caret || !defined.includes(id2.slice(1))) {
      return nok(code5);
    }
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code5);
    effects.exit("gfmFootnoteCallLabelMarker");
    return ok3(code5);
  }
}
function resolveToPotentialGfmFootnoteCall(events, context) {
  let index4 = events.length;
  let labelStart;
  while (index4--) {
    if (events[index4][1].type === types.labelImage && events[index4][0] === "enter") {
      labelStart = events[index4][1];
      break;
    }
  }
  ok(labelStart, "expected `labelStart` to resolve");
  events[index4 + 1][1].type = types.data;
  events[index4 + 3][1].type = "gfmFootnoteCallLabelMarker";
  const call = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, events[index4 + 3][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const marker = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, events[index4 + 3][1].end),
    end: Object.assign({}, events[index4 + 3][1].end)
  };
  marker.end.column++;
  marker.end.offset++;
  marker.end._bufferIndex++;
  const string3 = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, marker.end),
    end: Object.assign({}, events[events.length - 1][1].start)
  };
  const chunk = {
    type: types.chunkString,
    contentType: "string",
    start: Object.assign({}, string3.start),
    end: Object.assign({}, string3.end)
  };
  const replacement = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    events[index4 + 1],
    events[index4 + 2],
    ["enter", call, context],
    // The `[`
    events[index4 + 3],
    events[index4 + 4],
    // The `^`.
    ["enter", marker, context],
    ["exit", marker, context],
    // Everything in between.
    ["enter", string3, context],
    ["enter", chunk, context],
    ["exit", chunk, context],
    ["exit", string3, context],
    // The ending (`]`, properly parsed and labelled).
    events[events.length - 2],
    events[events.length - 1],
    ["exit", call, context]
  ];
  events.splice(index4, events.length - index4 + 1, ...replacement);
  return events;
}
function tokenizeGfmFootnoteCall(effects, ok3, nok) {
  const self2 = this;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let size5 = 0;
  let data;
  return start;
  function start(code5) {
    ok(code5 === codes.leftSquareBracket, "expected `[`");
    effects.enter("gfmFootnoteCall");
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code5);
    effects.exit("gfmFootnoteCallLabelMarker");
    return callStart;
  }
  function callStart(code5) {
    if (code5 !== codes.caret) return nok(code5);
    effects.enter("gfmFootnoteCallMarker");
    effects.consume(code5);
    effects.exit("gfmFootnoteCallMarker");
    effects.enter("gfmFootnoteCallString");
    effects.enter("chunkString").contentType = "string";
    return callData;
  }
  function callData(code5) {
    if (
      // Too long.
      size5 > constants.linkReferenceSizeMax || // Closing brace with nothing.
      code5 === codes.rightSquareBracket && !data || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      code5 === codes.eof || code5 === codes.leftSquareBracket || markdownLineEndingOrSpace(code5)
    ) {
      return nok(code5);
    }
    if (code5 === codes.rightSquareBracket) {
      effects.exit("chunkString");
      const token = effects.exit("gfmFootnoteCallString");
      if (!defined.includes(normalizeIdentifier(self2.sliceSerialize(token)))) {
        return nok(code5);
      }
      effects.enter("gfmFootnoteCallLabelMarker");
      effects.consume(code5);
      effects.exit("gfmFootnoteCallLabelMarker");
      effects.exit("gfmFootnoteCall");
      return ok3;
    }
    if (!markdownLineEndingOrSpace(code5)) {
      data = true;
    }
    size5++;
    effects.consume(code5);
    return code5 === codes.backslash ? callEscape : callData;
  }
  function callEscape(code5) {
    if (code5 === codes.leftSquareBracket || code5 === codes.backslash || code5 === codes.rightSquareBracket) {
      effects.consume(code5);
      size5++;
      return callData;
    }
    return callData(code5);
  }
}
function tokenizeDefinitionStart(effects, ok3, nok) {
  const self2 = this;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let identifier;
  let size5 = 0;
  let data;
  return start;
  function start(code5) {
    ok(code5 === codes.leftSquareBracket, "expected `[`");
    effects.enter("gfmFootnoteDefinition")._container = true;
    effects.enter("gfmFootnoteDefinitionLabel");
    effects.enter("gfmFootnoteDefinitionLabelMarker");
    effects.consume(code5);
    effects.exit("gfmFootnoteDefinitionLabelMarker");
    return labelAtMarker;
  }
  function labelAtMarker(code5) {
    if (code5 === codes.caret) {
      effects.enter("gfmFootnoteDefinitionMarker");
      effects.consume(code5);
      effects.exit("gfmFootnoteDefinitionMarker");
      effects.enter("gfmFootnoteDefinitionLabelString");
      effects.enter("chunkString").contentType = "string";
      return labelInside;
    }
    return nok(code5);
  }
  function labelInside(code5) {
    if (
      // Too long.
      size5 > constants.linkReferenceSizeMax || // Closing brace with nothing.
      code5 === codes.rightSquareBracket && !data || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      code5 === codes.eof || code5 === codes.leftSquareBracket || markdownLineEndingOrSpace(code5)
    ) {
      return nok(code5);
    }
    if (code5 === codes.rightSquareBracket) {
      effects.exit("chunkString");
      const token = effects.exit("gfmFootnoteDefinitionLabelString");
      identifier = normalizeIdentifier(self2.sliceSerialize(token));
      effects.enter("gfmFootnoteDefinitionLabelMarker");
      effects.consume(code5);
      effects.exit("gfmFootnoteDefinitionLabelMarker");
      effects.exit("gfmFootnoteDefinitionLabel");
      return labelAfter;
    }
    if (!markdownLineEndingOrSpace(code5)) {
      data = true;
    }
    size5++;
    effects.consume(code5);
    return code5 === codes.backslash ? labelEscape : labelInside;
  }
  function labelEscape(code5) {
    if (code5 === codes.leftSquareBracket || code5 === codes.backslash || code5 === codes.rightSquareBracket) {
      effects.consume(code5);
      size5++;
      return labelInside;
    }
    return labelInside(code5);
  }
  function labelAfter(code5) {
    if (code5 === codes.colon) {
      effects.enter("definitionMarker");
      effects.consume(code5);
      effects.exit("definitionMarker");
      if (!defined.includes(identifier)) {
        defined.push(identifier);
      }
      return factorySpace(
        effects,
        whitespaceAfter,
        "gfmFootnoteDefinitionWhitespace"
      );
    }
    return nok(code5);
  }
  function whitespaceAfter(code5) {
    return ok3(code5);
  }
}
function tokenizeDefinitionContinuation(effects, ok3, nok) {
  return effects.check(blankLine, ok3, effects.attempt(indent, ok3, nok));
}
function gfmFootnoteDefinitionEnd(effects) {
  effects.exit("gfmFootnoteDefinition");
}
function tokenizeIndent2(effects, ok3, nok) {
  const self2 = this;
  return factorySpace(
    effects,
    afterPrefix,
    "gfmFootnoteDefinitionIndent",
    constants.tabSize + 1
  );
  function afterPrefix(code5) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "gfmFootnoteDefinitionIndent" && tail[2].sliceSerialize(tail[1], true).length === constants.tabSize ? ok3(code5) : nok(code5);
  }
}

// ../node_modules/.pnpm/micromark-extension-gfm-footnote@2.1.0/node_modules/micromark-extension-gfm-footnote/dev/lib/html.js
var own6 = {}.hasOwnProperty;

// ../node_modules/.pnpm/micromark-extension-gfm-strikethrough@2.1.0/node_modules/micromark-extension-gfm-strikethrough/dev/lib/syntax.js
function gfmStrikethrough(options) {
  const options_ = options || {};
  let single = options_.singleTilde;
  const tokenizer = {
    name: "strikethrough",
    tokenize: tokenizeStrikethrough,
    resolveAll: resolveAllStrikethrough
  };
  if (single === null || single === void 0) {
    single = true;
  }
  return {
    text: { [codes.tilde]: tokenizer },
    insideSpan: { null: [tokenizer] },
    attentionMarkers: { null: [codes.tilde] }
  };
  function resolveAllStrikethrough(events, context) {
    let index4 = -1;
    while (++index4 < events.length) {
      if (events[index4][0] === "enter" && events[index4][1].type === "strikethroughSequenceTemporary" && events[index4][1]._close) {
        let open = index4;
        while (open--) {
          if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && // If the sizes are the same:
          events[index4][1].end.offset - events[index4][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
            events[index4][1].type = "strikethroughSequence";
            events[open][1].type = "strikethroughSequence";
            const strikethrough2 = {
              type: "strikethrough",
              start: Object.assign({}, events[open][1].start),
              end: Object.assign({}, events[index4][1].end)
            };
            const text10 = {
              type: "strikethroughText",
              start: Object.assign({}, events[open][1].end),
              end: Object.assign({}, events[index4][1].start)
            };
            const nextEvents = [
              ["enter", strikethrough2, context],
              ["enter", events[open][1], context],
              ["exit", events[open][1], context],
              ["enter", text10, context]
            ];
            const insideSpan2 = context.parser.constructs.insideSpan.null;
            if (insideSpan2) {
              splice(
                nextEvents,
                nextEvents.length,
                0,
                resolveAll(insideSpan2, events.slice(open + 1, index4), context)
              );
            }
            splice(nextEvents, nextEvents.length, 0, [
              ["exit", text10, context],
              ["enter", events[index4][1], context],
              ["exit", events[index4][1], context],
              ["exit", strikethrough2, context]
            ]);
            splice(events, open - 1, index4 - open + 3, nextEvents);
            index4 = open + nextEvents.length - 2;
            break;
          }
        }
      }
    }
    index4 = -1;
    while (++index4 < events.length) {
      if (events[index4][1].type === "strikethroughSequenceTemporary") {
        events[index4][1].type = types.data;
      }
    }
    return events;
  }
  function tokenizeStrikethrough(effects, ok3, nok) {
    const previous3 = this.previous;
    const events = this.events;
    let size5 = 0;
    return start;
    function start(code5) {
      ok(code5 === codes.tilde, "expected `~`");
      if (previous3 === codes.tilde && events[events.length - 1][1].type !== types.characterEscape) {
        return nok(code5);
      }
      effects.enter("strikethroughSequenceTemporary");
      return more(code5);
    }
    function more(code5) {
      const before = classifyCharacter(previous3);
      if (code5 === codes.tilde) {
        if (size5 > 1) return nok(code5);
        effects.consume(code5);
        size5++;
        return more;
      }
      if (size5 < 2 && !single) return nok(code5);
      const token = effects.exit("strikethroughSequenceTemporary");
      const after = classifyCharacter(code5);
      token._open = !after || after === constants.attentionSideAfter && Boolean(before);
      token._close = !before || before === constants.attentionSideAfter && Boolean(after);
      return ok3(code5);
    }
  }
}

// ../node_modules/.pnpm/micromark-extension-gfm-table@2.1.1/node_modules/micromark-extension-gfm-table/dev/lib/edit-map.js
var EditMap = class {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(index4, remove, add) {
    addImplementation(this, index4, remove, add);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(events) {
    this.map.sort(function(a2, b2) {
      return a2[0] - b2[0];
    });
    if (this.map.length === 0) {
      return;
    }
    let index4 = this.map.length;
    const vecs = [];
    while (index4 > 0) {
      index4 -= 1;
      vecs.push(
        events.slice(this.map[index4][0] + this.map[index4][1]),
        this.map[index4][2]
      );
      events.length = this.map[index4][0];
    }
    vecs.push(events.slice());
    events.length = 0;
    let slice = vecs.pop();
    while (slice) {
      for (const element7 of slice) {
        events.push(element7);
      }
      slice = vecs.pop();
    }
    this.map.length = 0;
  }
};
function addImplementation(editMap, at4, remove, add) {
  let index4 = 0;
  if (remove === 0 && add.length === 0) {
    return;
  }
  while (index4 < editMap.map.length) {
    if (editMap.map[index4][0] === at4) {
      editMap.map[index4][1] += remove;
      editMap.map[index4][2].push(...add);
      return;
    }
    index4 += 1;
  }
  editMap.map.push([at4, remove, add]);
}

// ../node_modules/.pnpm/micromark-extension-gfm-table@2.1.1/node_modules/micromark-extension-gfm-table/dev/lib/infer.js
function gfmTableAlign(events, index4) {
  ok(events[index4][1].type === "table", "expected table");
  let inDelimiterRow = false;
  const align = [];
  while (index4 < events.length) {
    const event = events[index4];
    if (inDelimiterRow) {
      if (event[0] === "enter") {
        if (event[1].type === "tableContent") {
          align.push(
            events[index4 + 1][1].type === "tableDelimiterMarker" ? "left" : "none"
          );
        }
      } else if (event[1].type === "tableContent") {
        if (events[index4 - 1][1].type === "tableDelimiterMarker") {
          const alignIndex = align.length - 1;
          align[alignIndex] = align[alignIndex] === "left" ? "center" : "right";
        }
      } else if (event[1].type === "tableDelimiterRow") {
        break;
      }
    } else if (event[0] === "enter" && event[1].type === "tableDelimiterRow") {
      inDelimiterRow = true;
    }
    index4 += 1;
  }
  return align;
}

// ../node_modules/.pnpm/micromark-extension-gfm-table@2.1.1/node_modules/micromark-extension-gfm-table/dev/lib/syntax.js
function gfmTable() {
  return {
    flow: {
      null: { name: "table", tokenize: tokenizeTable, resolveAll: resolveTable }
    }
  };
}
function tokenizeTable(effects, ok3, nok) {
  const self2 = this;
  let size5 = 0;
  let sizeB = 0;
  let seen;
  return start;
  function start(code5) {
    let index4 = self2.events.length - 1;
    while (index4 > -1) {
      const type = self2.events[index4][1].type;
      if (type === types.lineEnding || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      type === types.linePrefix)
        index4--;
      else break;
    }
    const tail = index4 > -1 ? self2.events[index4][1].type : null;
    const next2 = tail === "tableHead" || tail === "tableRow" ? bodyRowStart : headRowBefore;
    if (next2 === bodyRowStart && self2.parser.lazy[self2.now().line]) {
      return nok(code5);
    }
    return next2(code5);
  }
  function headRowBefore(code5) {
    effects.enter("tableHead");
    effects.enter("tableRow");
    return headRowStart(code5);
  }
  function headRowStart(code5) {
    if (code5 === codes.verticalBar) {
      return headRowBreak(code5);
    }
    seen = true;
    sizeB += 1;
    return headRowBreak(code5);
  }
  function headRowBreak(code5) {
    if (code5 === codes.eof) {
      return nok(code5);
    }
    if (markdownLineEnding(code5)) {
      if (sizeB > 1) {
        sizeB = 0;
        self2.interrupt = true;
        effects.exit("tableRow");
        effects.enter(types.lineEnding);
        effects.consume(code5);
        effects.exit(types.lineEnding);
        return headDelimiterStart;
      }
      return nok(code5);
    }
    if (markdownSpace(code5)) {
      return factorySpace(effects, headRowBreak, types.whitespace)(code5);
    }
    sizeB += 1;
    if (seen) {
      seen = false;
      size5 += 1;
    }
    if (code5 === codes.verticalBar) {
      effects.enter("tableCellDivider");
      effects.consume(code5);
      effects.exit("tableCellDivider");
      seen = true;
      return headRowBreak;
    }
    effects.enter(types.data);
    return headRowData(code5);
  }
  function headRowData(code5) {
    if (code5 === codes.eof || code5 === codes.verticalBar || markdownLineEndingOrSpace(code5)) {
      effects.exit(types.data);
      return headRowBreak(code5);
    }
    effects.consume(code5);
    return code5 === codes.backslash ? headRowEscape : headRowData;
  }
  function headRowEscape(code5) {
    if (code5 === codes.backslash || code5 === codes.verticalBar) {
      effects.consume(code5);
      return headRowData;
    }
    return headRowData(code5);
  }
  function headDelimiterStart(code5) {
    self2.interrupt = false;
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code5);
    }
    effects.enter("tableDelimiterRow");
    seen = false;
    if (markdownSpace(code5)) {
      ok(self2.parser.constructs.disable.null, "expected `disabled.null`");
      return factorySpace(
        effects,
        headDelimiterBefore,
        types.linePrefix,
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
      )(code5);
    }
    return headDelimiterBefore(code5);
  }
  function headDelimiterBefore(code5) {
    if (code5 === codes.dash || code5 === codes.colon) {
      return headDelimiterValueBefore(code5);
    }
    if (code5 === codes.verticalBar) {
      seen = true;
      effects.enter("tableCellDivider");
      effects.consume(code5);
      effects.exit("tableCellDivider");
      return headDelimiterCellBefore;
    }
    return headDelimiterNok(code5);
  }
  function headDelimiterCellBefore(code5) {
    if (markdownSpace(code5)) {
      return factorySpace(
        effects,
        headDelimiterValueBefore,
        types.whitespace
      )(code5);
    }
    return headDelimiterValueBefore(code5);
  }
  function headDelimiterValueBefore(code5) {
    if (code5 === codes.colon) {
      sizeB += 1;
      seen = true;
      effects.enter("tableDelimiterMarker");
      effects.consume(code5);
      effects.exit("tableDelimiterMarker");
      return headDelimiterLeftAlignmentAfter;
    }
    if (code5 === codes.dash) {
      sizeB += 1;
      return headDelimiterLeftAlignmentAfter(code5);
    }
    if (code5 === codes.eof || markdownLineEnding(code5)) {
      return headDelimiterCellAfter(code5);
    }
    return headDelimiterNok(code5);
  }
  function headDelimiterLeftAlignmentAfter(code5) {
    if (code5 === codes.dash) {
      effects.enter("tableDelimiterFiller");
      return headDelimiterFiller(code5);
    }
    return headDelimiterNok(code5);
  }
  function headDelimiterFiller(code5) {
    if (code5 === codes.dash) {
      effects.consume(code5);
      return headDelimiterFiller;
    }
    if (code5 === codes.colon) {
      seen = true;
      effects.exit("tableDelimiterFiller");
      effects.enter("tableDelimiterMarker");
      effects.consume(code5);
      effects.exit("tableDelimiterMarker");
      return headDelimiterRightAlignmentAfter;
    }
    effects.exit("tableDelimiterFiller");
    return headDelimiterRightAlignmentAfter(code5);
  }
  function headDelimiterRightAlignmentAfter(code5) {
    if (markdownSpace(code5)) {
      return factorySpace(
        effects,
        headDelimiterCellAfter,
        types.whitespace
      )(code5);
    }
    return headDelimiterCellAfter(code5);
  }
  function headDelimiterCellAfter(code5) {
    if (code5 === codes.verticalBar) {
      return headDelimiterBefore(code5);
    }
    if (code5 === codes.eof || markdownLineEnding(code5)) {
      if (!seen || size5 !== sizeB) {
        return headDelimiterNok(code5);
      }
      effects.exit("tableDelimiterRow");
      effects.exit("tableHead");
      return ok3(code5);
    }
    return headDelimiterNok(code5);
  }
  function headDelimiterNok(code5) {
    return nok(code5);
  }
  function bodyRowStart(code5) {
    effects.enter("tableRow");
    return bodyRowBreak(code5);
  }
  function bodyRowBreak(code5) {
    if (code5 === codes.verticalBar) {
      effects.enter("tableCellDivider");
      effects.consume(code5);
      effects.exit("tableCellDivider");
      return bodyRowBreak;
    }
    if (code5 === codes.eof || markdownLineEnding(code5)) {
      effects.exit("tableRow");
      return ok3(code5);
    }
    if (markdownSpace(code5)) {
      return factorySpace(effects, bodyRowBreak, types.whitespace)(code5);
    }
    effects.enter(types.data);
    return bodyRowData(code5);
  }
  function bodyRowData(code5) {
    if (code5 === codes.eof || code5 === codes.verticalBar || markdownLineEndingOrSpace(code5)) {
      effects.exit(types.data);
      return bodyRowBreak(code5);
    }
    effects.consume(code5);
    return code5 === codes.backslash ? bodyRowEscape : bodyRowData;
  }
  function bodyRowEscape(code5) {
    if (code5 === codes.backslash || code5 === codes.verticalBar) {
      effects.consume(code5);
      return bodyRowData;
    }
    return bodyRowData(code5);
  }
}
function resolveTable(events, context) {
  let index4 = -1;
  let inFirstCellAwaitingPipe = true;
  let rowKind = 0;
  let lastCell = [0, 0, 0, 0];
  let cell2 = [0, 0, 0, 0];
  let afterHeadAwaitingFirstBodyRow = false;
  let lastTableEnd = 0;
  let currentTable;
  let currentBody;
  let currentCell;
  const map6 = new EditMap();
  while (++index4 < events.length) {
    const event = events[index4];
    const token = event[1];
    if (event[0] === "enter") {
      if (token.type === "tableHead") {
        afterHeadAwaitingFirstBodyRow = false;
        if (lastTableEnd !== 0) {
          ok(currentTable, "there should be a table opening");
          flushTableEnd(map6, context, lastTableEnd, currentTable, currentBody);
          currentBody = void 0;
          lastTableEnd = 0;
        }
        currentTable = {
          type: "table",
          start: Object.assign({}, token.start),
          // Note: correct end is set later.
          end: Object.assign({}, token.end)
        };
        map6.add(index4, 0, [["enter", currentTable, context]]);
      } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
        inFirstCellAwaitingPipe = true;
        currentCell = void 0;
        lastCell = [0, 0, 0, 0];
        cell2 = [0, index4 + 1, 0, 0];
        if (afterHeadAwaitingFirstBodyRow) {
          afterHeadAwaitingFirstBodyRow = false;
          currentBody = {
            type: "tableBody",
            start: Object.assign({}, token.start),
            // Note: correct end is set later.
            end: Object.assign({}, token.end)
          };
          map6.add(index4, 0, [["enter", currentBody, context]]);
        }
        rowKind = token.type === "tableDelimiterRow" ? 2 : currentBody ? 3 : 1;
      } else if (rowKind && (token.type === types.data || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
        inFirstCellAwaitingPipe = false;
        if (cell2[2] === 0) {
          if (lastCell[1] !== 0) {
            cell2[0] = cell2[1];
            currentCell = flushCell(
              map6,
              context,
              lastCell,
              rowKind,
              void 0,
              currentCell
            );
            lastCell = [0, 0, 0, 0];
          }
          cell2[2] = index4;
        }
      } else if (token.type === "tableCellDivider") {
        if (inFirstCellAwaitingPipe) {
          inFirstCellAwaitingPipe = false;
        } else {
          if (lastCell[1] !== 0) {
            cell2[0] = cell2[1];
            currentCell = flushCell(
              map6,
              context,
              lastCell,
              rowKind,
              void 0,
              currentCell
            );
          }
          lastCell = cell2;
          cell2 = [lastCell[1], index4, 0, 0];
        }
      }
    } else if (token.type === "tableHead") {
      afterHeadAwaitingFirstBodyRow = true;
      lastTableEnd = index4;
    } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
      lastTableEnd = index4;
      if (lastCell[1] !== 0) {
        cell2[0] = cell2[1];
        currentCell = flushCell(
          map6,
          context,
          lastCell,
          rowKind,
          index4,
          currentCell
        );
      } else if (cell2[1] !== 0) {
        currentCell = flushCell(map6, context, cell2, rowKind, index4, currentCell);
      }
      rowKind = 0;
    } else if (rowKind && (token.type === types.data || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
      cell2[3] = index4;
    }
  }
  if (lastTableEnd !== 0) {
    ok(currentTable, "expected table opening");
    flushTableEnd(map6, context, lastTableEnd, currentTable, currentBody);
  }
  map6.consume(context.events);
  index4 = -1;
  while (++index4 < context.events.length) {
    const event = context.events[index4];
    if (event[0] === "enter" && event[1].type === "table") {
      event[1]._align = gfmTableAlign(context.events, index4);
    }
  }
  return events;
}
function flushCell(map6, context, range, rowKind, rowEnd, previousCell) {
  const groupName = rowKind === 1 ? "tableHeader" : rowKind === 2 ? "tableDelimiter" : "tableData";
  const valueName = "tableContent";
  if (range[0] !== 0) {
    ok(previousCell, "expected previous cell enter");
    previousCell.end = Object.assign({}, getPoint(context.events, range[0]));
    map6.add(range[0], 0, [["exit", previousCell, context]]);
  }
  const now = getPoint(context.events, range[1]);
  previousCell = {
    type: groupName,
    start: Object.assign({}, now),
    // Note: correct end is set later.
    end: Object.assign({}, now)
  };
  map6.add(range[1], 0, [["enter", previousCell, context]]);
  if (range[2] !== 0) {
    const relatedStart = getPoint(context.events, range[2]);
    const relatedEnd = getPoint(context.events, range[3]);
    const valueToken = {
      type: valueName,
      start: Object.assign({}, relatedStart),
      end: Object.assign({}, relatedEnd)
    };
    map6.add(range[2], 0, [["enter", valueToken, context]]);
    ok(range[3] !== 0);
    if (rowKind !== 2) {
      const start = context.events[range[2]];
      const end = context.events[range[3]];
      start[1].end = Object.assign({}, end[1].end);
      start[1].type = types.chunkText;
      start[1].contentType = constants.contentTypeText;
      if (range[3] > range[2] + 1) {
        const a2 = range[2] + 1;
        const b2 = range[3] - range[2] - 1;
        map6.add(a2, b2, []);
      }
    }
    map6.add(range[3] + 1, 0, [["exit", valueToken, context]]);
  }
  if (rowEnd !== void 0) {
    previousCell.end = Object.assign({}, getPoint(context.events, rowEnd));
    map6.add(rowEnd, 0, [["exit", previousCell, context]]);
    previousCell = void 0;
  }
  return previousCell;
}
function flushTableEnd(map6, context, index4, table3, tableBody) {
  const exits = [];
  const related = getPoint(context.events, index4);
  if (tableBody) {
    tableBody.end = Object.assign({}, related);
    exits.push(["exit", tableBody, context]);
  }
  table3.end = Object.assign({}, related);
  exits.push(["exit", table3, context]);
  map6.add(index4 + 1, 0, exits);
}
function getPoint(events, index4) {
  const event = events[index4];
  const side = event[0] === "enter" ? "start" : "end";
  return event[1][side];
}

// ../node_modules/.pnpm/micromark-extension-gfm-tagfilter@2.0.0/node_modules/micromark-extension-gfm-tagfilter/lib/index.js
var reFlow = /<(\/?)(iframe|noembed|noframes|plaintext|script|style|title|textarea|xmp)(?=[\t\n\f\r />])/gi;
var reText = new RegExp("^" + reFlow.source, "i");

// ../node_modules/.pnpm/micromark-extension-gfm-task-list-item@2.1.0/node_modules/micromark-extension-gfm-task-list-item/dev/lib/syntax.js
var tasklistCheck = { name: "tasklistCheck", tokenize: tokenizeTasklistCheck };
function gfmTaskListItem() {
  return {
    text: { [codes.leftSquareBracket]: tasklistCheck }
  };
}
function tokenizeTasklistCheck(effects, ok3, nok) {
  const self2 = this;
  return open;
  function open(code5) {
    ok(code5 === codes.leftSquareBracket, "expected `[`");
    if (
      // Exit if theres stuff before.
      self2.previous !== codes.eof || // Exit if not in the first content that is the first child of a list
      // item.
      !self2._gfmTasklistFirstContentOfListItem
    ) {
      return nok(code5);
    }
    effects.enter("taskListCheck");
    effects.enter("taskListCheckMarker");
    effects.consume(code5);
    effects.exit("taskListCheckMarker");
    return inside;
  }
  function inside(code5) {
    if (markdownLineEndingOrSpace(code5)) {
      effects.enter("taskListCheckValueUnchecked");
      effects.consume(code5);
      effects.exit("taskListCheckValueUnchecked");
      return close;
    }
    if (code5 === codes.uppercaseX || code5 === codes.lowercaseX) {
      effects.enter("taskListCheckValueChecked");
      effects.consume(code5);
      effects.exit("taskListCheckValueChecked");
      return close;
    }
    return nok(code5);
  }
  function close(code5) {
    if (code5 === codes.rightSquareBracket) {
      effects.enter("taskListCheckMarker");
      effects.consume(code5);
      effects.exit("taskListCheckMarker");
      effects.exit("taskListCheck");
      return after;
    }
    return nok(code5);
  }
  function after(code5) {
    if (markdownLineEnding(code5)) {
      return ok3(code5);
    }
    if (markdownSpace(code5)) {
      return effects.check({ tokenize: spaceThenNonSpace }, ok3, nok)(code5);
    }
    return nok(code5);
  }
}
function spaceThenNonSpace(effects, ok3, nok) {
  return factorySpace(effects, after, types.whitespace);
  function after(code5) {
    return code5 === codes.eof ? nok(code5) : ok3(code5);
  }
}

// ../node_modules/.pnpm/micromark-extension-gfm@3.0.0/node_modules/micromark-extension-gfm/index.js
function gfm(options) {
  return combineExtensions([
    gfmAutolinkLiteral(),
    gfmFootnote(),
    gfmStrikethrough(options),
    gfmTable(),
    gfmTaskListItem()
  ]);
}

// ../node_modules/.pnpm/remark-gfm@4.0.1/node_modules/remark-gfm/lib/index.js
var emptyOptions5 = {};
function remarkGfm(options) {
  const self2 = (
    /** @type {Processor<Root>} */
    this
  );
  const settings = options || emptyOptions5;
  const data = self2.data();
  const micromarkExtensions = data.micromarkExtensions || (data.micromarkExtensions = []);
  const fromMarkdownExtensions = data.fromMarkdownExtensions || (data.fromMarkdownExtensions = []);
  const toMarkdownExtensions = data.toMarkdownExtensions || (data.toMarkdownExtensions = []);
  micromarkExtensions.push(gfm(settings));
  fromMarkdownExtensions.push(gfmFromMarkdown());
  toMarkdownExtensions.push(gfmToMarkdown(settings));
}

// ../node_modules/.pnpm/remark-stringify@11.0.0/node_modules/remark-stringify/lib/index.js
function remarkStringify(options) {
  const self2 = this;
  self2.compiler = compiler2;
  function compiler2(tree) {
    return toMarkdown(tree, {
      ...self2.data("settings"),
      ...options,
      // Note: this option is not in the readme.
      // The goal is for it to be set by plugins on `data` instead of being
      // passed by users.
      extensions: self2.data("toMarkdownExtensions") || []
    });
  }
}

// ../node_modules/.pnpm/bail@2.0.2/node_modules/bail/index.js
function bail(error2) {
  if (error2) {
    throw error2;
  }
}

// ../node_modules/.pnpm/unified@11.0.5/node_modules/unified/lib/index.js
var import_extend = __toESM(require_extend(), 1);

// ../node_modules/.pnpm/is-plain-obj@4.1.0/node_modules/is-plain-obj/index.js
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

// ../node_modules/.pnpm/trough@2.2.0/node_modules/trough/lib/index.js
function trough() {
  const fns = [];
  const pipeline = { run: run3, use };
  return pipeline;
  function run3(...values2) {
    let middlewareIndex = -1;
    const callback = values2.pop();
    if (typeof callback !== "function") {
      throw new TypeError("Expected function as last argument, not " + callback);
    }
    next2(null, ...values2);
    function next2(error2, ...output) {
      const fn3 = fns[++middlewareIndex];
      let index4 = -1;
      if (error2) {
        callback(error2);
        return;
      }
      while (++index4 < values2.length) {
        if (output[index4] === null || output[index4] === void 0) {
          output[index4] = values2[index4];
        }
      }
      values2 = output;
      if (fn3) {
        wrap2(fn3, next2)(...output);
      } else {
        callback(null, ...output);
      }
    }
  }
  function use(middelware) {
    if (typeof middelware !== "function") {
      throw new TypeError(
        "Expected `middelware` to be a function, not " + middelware
      );
    }
    fns.push(middelware);
    return pipeline;
  }
}
function wrap2(middleware, callback) {
  let called;
  return wrapped;
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware.length > parameters.length;
    let result;
    if (fnExpectsCallback) {
      parameters.push(done);
    }
    try {
      result = middleware.apply(this, parameters);
    } catch (error2) {
      const exception = (
        /** @type {Error} */
        error2
      );
      if (fnExpectsCallback && called) {
        throw exception;
      }
      return done(exception);
    }
    if (!fnExpectsCallback) {
      if (result && result.then && typeof result.then === "function") {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done(error2, ...output) {
    if (!called) {
      called = true;
      callback(error2, ...output);
    }
  }
  function then(value) {
    done(null, value);
  }
}

// ../node_modules/.pnpm/unified@11.0.5/node_modules/unified/lib/callable-instance.js
var CallableInstance = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  (function(property) {
    const self2 = this;
    const constr = self2.constructor;
    const proto2 = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      constr.prototype
    );
    const value = proto2[property];
    const apply = function() {
      return value.apply(apply, arguments);
    };
    Object.setPrototypeOf(apply, proto2);
    return apply;
  })
);

// ../node_modules/.pnpm/unified@11.0.5/node_modules/unified/lib/index.js
var own7 = {}.hasOwnProperty;
var Processor = class _Processor extends CallableInstance {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy");
    this.Compiler = void 0;
    this.Parser = void 0;
    this.attachers = [];
    this.compiler = void 0;
    this.freezeIndex = -1;
    this.frozen = void 0;
    this.namespace = {};
    this.parser = void 0;
    this.transformers = trough();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const destination = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new _Processor()
    );
    let index4 = -1;
    while (++index4 < this.attachers.length) {
      const attacher = this.attachers[index4];
      destination.use(...attacher);
    }
    destination.data((0, import_extend.default)(true, {}, this.namespace));
    return destination;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(key2, value) {
    if (typeof key2 === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", this.frozen);
        this.namespace[key2] = value;
        return this;
      }
      return own7.call(this.namespace, key2) && this.namespace[key2] || void 0;
    }
    if (key2) {
      assertUnfrozen("data", this.frozen);
      this.namespace = key2;
      return this;
    }
    return this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen) {
      return this;
    }
    const self2 = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    while (++this.freezeIndex < this.attachers.length) {
      const [attacher, ...options] = this.attachers[this.freezeIndex];
      if (options[0] === false) {
        continue;
      }
      if (options[0] === true) {
        options[0] = void 0;
      }
      const transformer = attacher.call(self2, ...options);
      if (typeof transformer === "function") {
        this.transformers.use(transformer);
      }
    }
    this.frozen = true;
    this.freezeIndex = Number.POSITIVE_INFINITY;
    return this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(file) {
    this.freeze();
    const realFile = vfile(file);
    const parser = this.parser || this.Parser;
    assertParser("parse", parser);
    return parser(String(realFile), realFile);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(file, done) {
    const self2 = this;
    this.freeze();
    assertParser("process", this.parser || this.Parser);
    assertCompiler("process", this.compiler || this.Compiler);
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve2, reject) {
      const realFile = vfile(file);
      const parseTree = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        self2.parse(realFile)
      );
      self2.run(parseTree, realFile, function(error2, tree, file2) {
        if (error2 || !tree || !file2) {
          return realDone(error2);
        }
        const compileTree = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          tree
        );
        const compileResult = self2.stringify(compileTree, file2);
        if (looksLikeAValue(compileResult)) {
          file2.value = compileResult;
        } else {
          file2.result = compileResult;
        }
        realDone(
          error2,
          /** @type {VFileWithOutput<CompileResult>} */
          file2
        );
      });
      function realDone(error2, file2) {
        if (error2 || !file2) {
          reject(error2);
        } else if (resolve2) {
          resolve2(file2);
        } else {
          ok(done, "`done` is defined if `resolve` is not");
          done(void 0, file2);
        }
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(file) {
    let complete = false;
    let result;
    this.freeze();
    assertParser("processSync", this.parser || this.Parser);
    assertCompiler("processSync", this.compiler || this.Compiler);
    this.process(file, realDone);
    assertDone("processSync", "process", complete);
    ok(result, "we either bailed on an error or have a tree");
    return result;
    function realDone(error2, file2) {
      complete = true;
      bail(error2);
      result = file2;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(tree, file, done) {
    assertNode(tree);
    this.freeze();
    const transformers = this.transformers;
    if (!done && typeof file === "function") {
      done = file;
      file = void 0;
    }
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve2, reject) {
      ok(
        typeof file !== "function",
        "`file` cant be a `done` anymore, we checked"
      );
      const realFile = vfile(file);
      transformers.run(tree, realFile, realDone);
      function realDone(error2, outputTree, file2) {
        const resultingTree = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          outputTree || tree
        );
        if (error2) {
          reject(error2);
        } else if (resolve2) {
          resolve2(resultingTree);
        } else {
          ok(done, "`done` is defined if `resolve` is not");
          done(void 0, resultingTree, file2);
        }
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(tree, file) {
    let complete = false;
    let result;
    this.run(tree, file, realDone);
    assertDone("runSync", "run", complete);
    ok(result, "we either bailed on an error or have a tree");
    return result;
    function realDone(error2, tree2) {
      bail(error2);
      result = tree2;
      complete = true;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(tree, file) {
    this.freeze();
    const realFile = vfile(file);
    const compiler2 = this.compiler || this.Compiler;
    assertCompiler("stringify", compiler2);
    assertNode(tree);
    return compiler2(tree, realFile);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(value, ...parameters) {
    const attachers = this.attachers;
    const namespace = this.namespace;
    assertUnfrozen("use", this.frozen);
    if (value === null || value === void 0) {
    } else if (typeof value === "function") {
      addPlugin(value, parameters);
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value + "`");
    }
    return this;
    function add(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2, []);
      } else if (typeof value2 === "object") {
        if (Array.isArray(value2)) {
          const [plugin, ...parameters2] = (
            /** @type {PluginTuple<Array<unknown>>} */
            value2
          );
          addPlugin(plugin, parameters2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value2 + "`");
      }
    }
    function addPreset(result) {
      if (!("plugins" in result) && !("settings" in result)) {
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      }
      addList(result.plugins);
      if (result.settings) {
        namespace.settings = (0, import_extend.default)(true, namespace.settings, result.settings);
      }
    }
    function addList(plugins) {
      let index4 = -1;
      if (plugins === null || plugins === void 0) {
      } else if (Array.isArray(plugins)) {
        while (++index4 < plugins.length) {
          const thing = plugins[index4];
          add(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, parameters2) {
      let index4 = -1;
      let entryIndex = -1;
      while (++index4 < attachers.length) {
        if (attachers[index4][0] === plugin) {
          entryIndex = index4;
          break;
        }
      }
      if (entryIndex === -1) {
        attachers.push([plugin, ...parameters2]);
      } else if (parameters2.length > 0) {
        let [primary, ...rest] = parameters2;
        const currentPrimary = attachers[entryIndex][1];
        if (isPlainObject2(currentPrimary) && isPlainObject2(primary)) {
          primary = (0, import_extend.default)(true, currentPrimary, primary);
        }
        attachers[entryIndex] = [plugin, primary, ...rest];
      }
    }
  }
};
var unified = new Processor().freeze();
function assertParser(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `parser`");
  }
}
function assertCompiler(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `compiler`");
  }
}
function assertUnfrozen(name, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot call `" + name + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode(node2) {
  if (!isPlainObject2(node2) || typeof node2.type !== "string") {
    throw new TypeError("Expected node, got `" + node2 + "`");
  }
}
function assertDone(name, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
function vfile(value) {
  return looksLikeAVFile(value) ? value : new VFile(value);
}
function looksLikeAVFile(value) {
  return Boolean(
    value && typeof value === "object" && "message" in value && "messages" in value
  );
}
function looksLikeAValue(value) {
  return typeof value === "string" || isUint8Array2(value);
}
function isUint8Array2(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}

// ../node_modules/.pnpm/hast-util-from-dom@5.0.1/node_modules/hast-util-from-dom/lib/index.js
function fromDom(tree, options) {
  return transform(tree, options || {}) || { type: "root", children: [] };
}
function transform(node2, options) {
  const transformed = one4(node2, options);
  if (transformed && options.afterTransform)
    options.afterTransform(node2, transformed);
  return transformed;
}
function one4(node2, options) {
  switch (node2.nodeType) {
    case 1: {
      const domNode = (
        /** @type {Element} */
        node2
      );
      return element5(domNode, options);
    }
    // Ignore: Attr (2).
    case 3: {
      const domNode = (
        /** @type {Text} */
        node2
      );
      return text5(domNode);
    }
    // Ignore: CDATA (4).
    // Removed: Entity reference (5)
    // Removed: Entity (6)
    // Ignore: Processing instruction (7).
    case 8: {
      const domNode = (
        /** @type {Comment} */
        node2
      );
      return comment2(domNode);
    }
    case 9: {
      const domNode = (
        /** @type {Document} */
        node2
      );
      return root3(domNode, options);
    }
    case 10: {
      return doctype();
    }
    case 11: {
      const domNode = (
        /** @type {DocumentFragment} */
        node2
      );
      return root3(domNode, options);
    }
    default: {
      return void 0;
    }
  }
}
function root3(node2, options) {
  return { type: "root", children: all7(node2, options) };
}
function doctype() {
  return { type: "doctype" };
}
function text5(node2) {
  return { type: "text", value: node2.nodeValue || "" };
}
function comment2(node2) {
  return { type: "comment", value: node2.nodeValue || "" };
}
function element5(node2, options) {
  const space2 = node2.namespaceURI;
  const x4 = space2 === webNamespaces.svg ? s : h2;
  const tagName = space2 === webNamespaces.html ? node2.tagName.toLowerCase() : node2.tagName;
  const content5 = (
    // @ts-expect-error: DOM types are wrong, content can exist.
    space2 === webNamespaces.html && tagName === "template" ? node2.content : node2
  );
  const attributes = node2.getAttributeNames();
  const properties = {};
  let index4 = -1;
  while (++index4 < attributes.length) {
    properties[attributes[index4]] = node2.getAttribute(attributes[index4]) || "";
  }
  return x4(tagName, properties, all7(content5, options));
}
function all7(node2, options) {
  const nodes = node2.childNodes;
  const children = [];
  let index4 = -1;
  while (++index4 < nodes.length) {
    const child = transform(nodes[index4], options);
    if (child !== void 0) {
      children.push(child);
    }
  }
  return children;
}

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/mutex.js
var createMutex = () => {
  let token = true;
  return (f2, g) => {
    if (token) {
      token = false;
      try {
        f2();
      } finally {
        token = true;
      }
    } else if (g !== void 0) {
      g();
    }
  };
};

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/diff.js
var highSurrogateRegex = /[\uD800-\uDBFF]/;
var lowSurrogateRegex = /[\uDC00-\uDFFF]/;
var simpleDiffString = (a2, b2) => {
  let left = 0;
  let right = 0;
  while (left < a2.length && left < b2.length && a2[left] === b2[left]) {
    left++;
  }
  if (left > 0 && highSurrogateRegex.test(a2[left - 1])) left--;
  while (right + left < a2.length && right + left < b2.length && a2[a2.length - right - 1] === b2[b2.length - right - 1]) {
    right++;
  }
  if (right > 0 && lowSurrogateRegex.test(a2[a2.length - right])) right--;
  return {
    index: left,
    remove: a2.length - left - right,
    insert: b2.slice(left, b2.length - right)
  };
};
var simpleDiff = simpleDiffString;

// ../node_modules/.pnpm/y-prosemirror@1.3.7_prosemi_a3ecbc8ef8fd72690320bad9def4d609/node_modules/y-prosemirror/src/plugins/keys.js
var ySyncPluginKey = new PluginKey("y-sync");
var yUndoPluginKey = new PluginKey("y-undo");
var yCursorPluginKey = new PluginKey("yjs-cursor");

// ../node_modules/.pnpm/lib0@0.2.114/node_modules/lib0/hash/sha256.js
var rotr = (w3, shift4) => w3 >>> shift4 | w3 << 32 - shift4;
var sum0to256 = (x4) => rotr(x4, 2) ^ rotr(x4, 13) ^ rotr(x4, 22);
var sum1to256 = (x4) => rotr(x4, 6) ^ rotr(x4, 11) ^ rotr(x4, 25);
var sigma0to256 = (x4) => rotr(x4, 7) ^ rotr(x4, 18) ^ x4 >>> 3;
var sigma1to256 = (x4) => rotr(x4, 17) ^ rotr(x4, 19) ^ x4 >>> 10;
var K2 = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var HINIT = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var Hasher = class {
  constructor() {
    const buf = new ArrayBuffer(64 + 64 * 4);
    this._H = new Uint32Array(buf, 0, 8);
    this._H.set(HINIT);
    this._W = new Uint32Array(buf, 64, 64);
  }
  _updateHash() {
    const H2 = this._H;
    const W = this._W;
    for (let t = 16; t < 64; t++) {
      W[t] = sigma1to256(W[t - 2]) + W[t - 7] + sigma0to256(W[t - 15]) + W[t - 16];
    }
    let a2 = H2[0];
    let b2 = H2[1];
    let c = H2[2];
    let d = H2[3];
    let e = H2[4];
    let f2 = H2[5];
    let g = H2[6];
    let h4 = H2[7];
    for (let tt3 = 0, T1, T22; tt3 < 64; tt3++) {
      T1 = h4 + sum1to256(e) + (e & f2 ^ ~e & g) + K2[tt3] + W[tt3] >>> 0;
      T22 = sum0to256(a2) + (a2 & b2 ^ a2 & c ^ b2 & c) >>> 0;
      h4 = g;
      g = f2;
      f2 = e;
      e = d + T1 >>> 0;
      d = c;
      c = b2;
      b2 = a2;
      a2 = T1 + T22 >>> 0;
    }
    H2[0] += a2;
    H2[1] += b2;
    H2[2] += c;
    H2[3] += d;
    H2[4] += e;
    H2[5] += f2;
    H2[6] += g;
    H2[7] += h4;
  }
  /**
   * Returns a 32-byte hash.
   *
   * @param {Uint8Array} data
   */
  digest(data) {
    let i2 = 0;
    for (; i2 + 56 <= data.length; ) {
      let j6 = 0;
      for (; j6 < 16 && i2 + 3 < data.length; j6++) {
        this._W[j6] = data[i2++] << 24 | data[i2++] << 16 | data[i2++] << 8 | data[i2++];
      }
      if (i2 % 64 !== 0) {
        this._W.fill(0, j6, 16);
        while (i2 < data.length) {
          this._W[j6] |= data[i2] << (3 - i2 % 4) * 8;
          i2++;
        }
        this._W[j6] |= BIT8 << (3 - i2 % 4) * 8;
      }
      this._updateHash();
    }
    const isPaddedWith1 = i2 % 64 !== 0;
    this._W.fill(0, 0, 16);
    let j5 = 0;
    for (; i2 < data.length; j5++) {
      for (let ci = 3; ci >= 0 && i2 < data.length; ci--) {
        this._W[j5] |= data[i2++] << ci * 8;
      }
    }
    if (!isPaddedWith1) {
      this._W[j5 - (i2 % 4 === 0 ? 0 : 1)] |= BIT8 << (3 - i2 % 4) * 8;
    }
    this._W[14] = data.byteLength / BIT30;
    this._W[15] = data.byteLength * 8;
    this._updateHash();
    const dv = new Uint8Array(32);
    for (let i3 = 0; i3 < this._H.length; i3++) {
      for (let ci = 0; ci < 4; ci++) {
        dv[i3 * 4 + ci] = this._H[i3] >>> (3 - ci) * 8;
      }
    }
    return dv;
  }
};
var digest = (data) => new Hasher().digest(data);

// ../node_modules/.pnpm/y-prosemirror@1.3.7_prosemi_a3ecbc8ef8fd72690320bad9def4d609/node_modules/y-prosemirror/src/utils.js
var _convolute = (digest2) => {
  const N4 = 6;
  for (let i2 = N4; i2 < digest2.length; i2++) {
    digest2[i2 % N4] = digest2[i2 % N4] ^ digest2[i2];
  }
  return digest2.slice(0, N4);
};
var hashOfJSON = (json) => toBase64(_convolute(digest(encodeAny(json))));

// ../node_modules/.pnpm/y-prosemirror@1.3.7_prosemi_a3ecbc8ef8fd72690320bad9def4d609/node_modules/y-prosemirror/src/plugins/sync-plugin.js
var isVisible2 = (item, snapshot2) => snapshot2 === void 0 ? !item.deleted : snapshot2.sv.has(item.id.client) && /** @type {number} */
snapshot2.sv.get(item.id.client) > item.id.clock && !isDeleted(snapshot2.ds, item.id);
var defaultColors = [{ light: "#ecd44433", dark: "#ecd444" }];
var getUserColor = (colorMapping, colors, user) => {
  if (!colorMapping.has(user)) {
    if (colorMapping.size < colors.length) {
      const usedColors = create2();
      colorMapping.forEach((color2) => usedColors.add(color2));
      colors = colors.filter((color2) => !usedColors.has(color2));
    }
    colorMapping.set(user, oneOf(colors));
  }
  return (
    /** @type {ColorDef} */
    colorMapping.get(user)
  );
};
var ySyncPlugin = (yXmlFragment, {
  colors = defaultColors,
  colorMapping = /* @__PURE__ */ new Map(),
  permanentUserData = null,
  onFirstRender = () => {
  },
  mapping
} = {}) => {
  let initialContentChanged = false;
  const binding = new ProsemirrorBinding(yXmlFragment, mapping);
  const plugin = new Plugin({
    props: {
      editable: (state) => {
        const syncState = ySyncPluginKey.getState(state);
        return syncState.snapshot == null && syncState.prevSnapshot == null;
      }
    },
    key: ySyncPluginKey,
    state: {
      /**
       * @returns {any}
       */
      init: (_initargs, _state) => {
        return {
          type: yXmlFragment,
          doc: yXmlFragment.doc,
          binding,
          snapshot: null,
          prevSnapshot: null,
          isChangeOrigin: false,
          isUndoRedoOperation: false,
          addToHistory: true,
          colors,
          colorMapping,
          permanentUserData
        };
      },
      apply: (tr5, pluginState) => {
        const change = tr5.getMeta(ySyncPluginKey);
        if (change !== void 0) {
          pluginState = Object.assign({}, pluginState);
          for (const key2 in change) {
            pluginState[key2] = change[key2];
          }
        }
        pluginState.addToHistory = tr5.getMeta("addToHistory") !== false;
        pluginState.isChangeOrigin = change !== void 0 && !!change.isChangeOrigin;
        pluginState.isUndoRedoOperation = change !== void 0 && !!change.isChangeOrigin && !!change.isUndoRedoOperation;
        if (binding.prosemirrorView !== null) {
          if (change !== void 0 && (change.snapshot != null || change.prevSnapshot != null)) {
            timeout(0, () => {
              if (binding.prosemirrorView == null) {
                return;
              }
              if (change.restore == null) {
                binding._renderSnapshot(
                  change.snapshot,
                  change.prevSnapshot,
                  pluginState
                );
              } else {
                binding._renderSnapshot(
                  change.snapshot,
                  change.snapshot,
                  pluginState
                );
                delete pluginState.restore;
                delete pluginState.snapshot;
                delete pluginState.prevSnapshot;
                binding.mux(() => {
                  binding._prosemirrorChanged(
                    binding.prosemirrorView.state.doc
                  );
                });
              }
            });
          }
        }
        return pluginState;
      }
    },
    view: (view) => {
      binding.initView(view);
      if (mapping == null) {
        binding._forceRerender();
      }
      onFirstRender();
      return {
        update: () => {
          const pluginState = plugin.getState(view.state);
          if (pluginState.snapshot == null && pluginState.prevSnapshot == null) {
            if (
              // If the content doesn't change initially, we don't render anything to Yjs
              // If the content was cleared by a user action, we want to catch the change and
              // represent it in Yjs
              initialContentChanged || view.state.doc.content.findDiffStart(
                view.state.doc.type.createAndFill().content
              ) !== null
            ) {
              initialContentChanged = true;
              if (pluginState.addToHistory === false && !pluginState.isChangeOrigin) {
                const yUndoPluginState = yUndoPluginKey.getState(view.state);
                const um = yUndoPluginState && yUndoPluginState.undoManager;
                if (um) {
                  um.stopCapturing();
                }
              }
              binding.mux(() => {
                pluginState.doc.transact((tr5) => {
                  tr5.meta.set("addToHistory", pluginState.addToHistory);
                  binding._prosemirrorChanged(view.state.doc);
                }, ySyncPluginKey);
              });
            }
          }
        },
        destroy: () => {
          binding.destroy();
        }
      };
    }
  });
  return plugin;
};
var restoreRelativeSelection = (tr5, relSel, binding) => {
  if (relSel !== null && relSel.anchor !== null && relSel.head !== null) {
    if (relSel.type === "all") {
      tr5.setSelection(new AllSelection(tr5.doc));
    } else if (relSel.type === "node") {
      const anchor = relativePositionToAbsolutePosition(
        binding.doc,
        binding.type,
        relSel.anchor,
        binding.mapping
      );
      tr5.setSelection(NodeSelection.create(tr5.doc, anchor));
    } else {
      const anchor = relativePositionToAbsolutePosition(
        binding.doc,
        binding.type,
        relSel.anchor,
        binding.mapping
      );
      const head2 = relativePositionToAbsolutePosition(
        binding.doc,
        binding.type,
        relSel.head,
        binding.mapping
      );
      if (anchor !== null && head2 !== null) {
        const sel = TextSelection.between(tr5.doc.resolve(anchor), tr5.doc.resolve(head2));
        tr5.setSelection(sel);
      }
    }
  }
};
var getRelativeSelection = (pmbinding, state) => ({
  type: (
    /** @type {any} */
    state.selection.jsonID
  ),
  anchor: absolutePositionToRelativePosition(
    state.selection.anchor,
    pmbinding.type,
    pmbinding.mapping
  ),
  head: absolutePositionToRelativePosition(
    state.selection.head,
    pmbinding.type,
    pmbinding.mapping
  )
});
var ProsemirrorBinding = class {
  /**
   * @param {Y.XmlFragment} yXmlFragment The bind source
   * @param {ProsemirrorMapping} mapping
   */
  constructor(yXmlFragment, mapping = /* @__PURE__ */ new Map()) {
    this.type = yXmlFragment;
    this.prosemirrorView = null;
    this.mux = createMutex();
    this.mapping = mapping;
    this.isOMark = /* @__PURE__ */ new Map();
    this._observeFunction = this._typeChanged.bind(this);
    this.doc = yXmlFragment.doc;
    this.beforeTransactionSelection = null;
    this.beforeAllTransactions = () => {
      if (this.beforeTransactionSelection === null && this.prosemirrorView != null) {
        this.beforeTransactionSelection = getRelativeSelection(
          this,
          this.prosemirrorView.state
        );
      }
    };
    this.afterAllTransactions = () => {
      this.beforeTransactionSelection = null;
    };
    this._domSelectionInView = null;
  }
  /**
   * Create a transaction for changing the prosemirror state.
   *
   * @returns
   */
  get _tr() {
    return this.prosemirrorView.state.tr.setMeta("addToHistory", false);
  }
  _isLocalCursorInView() {
    if (!this.prosemirrorView.hasFocus()) return false;
    if (isBrowser && this._domSelectionInView === null) {
      timeout(0, () => {
        this._domSelectionInView = null;
      });
      this._domSelectionInView = this._isDomSelectionInView();
    }
    return this._domSelectionInView;
  }
  _isDomSelectionInView() {
    const selection = this.prosemirrorView._root.getSelection();
    if (selection == null || selection.anchorNode == null) return false;
    const range = this.prosemirrorView._root.createRange();
    range.setStart(selection.anchorNode, selection.anchorOffset);
    range.setEnd(selection.focusNode, selection.focusOffset);
    const rects = range.getClientRects();
    if (rects.length === 0) {
      if (range.startContainer && range.collapsed) {
        range.selectNodeContents(range.startContainer);
      }
    }
    const bounding = range.getBoundingClientRect();
    const documentElement = doc.documentElement;
    return bounding.bottom >= 0 && bounding.right >= 0 && bounding.left <= (window.innerWidth || documentElement.clientWidth || 0) && bounding.top <= (window.innerHeight || documentElement.clientHeight || 0);
  }
  /**
   * @param {Y.Snapshot} snapshot
   * @param {Y.Snapshot} prevSnapshot
   */
  renderSnapshot(snapshot2, prevSnapshot) {
    if (!prevSnapshot) {
      prevSnapshot = createSnapshot(createDeleteSet(), /* @__PURE__ */ new Map());
    }
    this.prosemirrorView.dispatch(
      this._tr.setMeta(ySyncPluginKey, { snapshot: snapshot2, prevSnapshot })
    );
  }
  unrenderSnapshot() {
    this.mapping.clear();
    this.mux(() => {
      const fragmentContent = this.type.toArray().map(
        (t) => createNodeFromYElement(
          /** @type {Y.XmlElement} */
          t,
          this.prosemirrorView.state.schema,
          this
        )
      ).filter((n) => n !== null);
      const tr5 = this._tr.replace(
        0,
        this.prosemirrorView.state.doc.content.size,
        new Slice(Fragment.from(fragmentContent), 0, 0)
      );
      tr5.setMeta(ySyncPluginKey, { snapshot: null, prevSnapshot: null });
      this.prosemirrorView.dispatch(tr5);
    });
  }
  _forceRerender() {
    this.mapping.clear();
    this.mux(() => {
      const sel = this.beforeTransactionSelection !== null ? null : this.prosemirrorView.state.selection;
      const fragmentContent = this.type.toArray().map(
        (t) => createNodeFromYElement(
          /** @type {Y.XmlElement} */
          t,
          this.prosemirrorView.state.schema,
          this
        )
      ).filter((n) => n !== null);
      const tr5 = this._tr.replace(
        0,
        this.prosemirrorView.state.doc.content.size,
        new Slice(Fragment.from(fragmentContent), 0, 0)
      );
      if (sel) {
        const clampedAnchor = min2(max2(sel.anchor, 0), tr5.doc.content.size);
        const clampedHead = min2(max2(sel.head, 0), tr5.doc.content.size);
        tr5.setSelection(TextSelection.create(tr5.doc, clampedAnchor, clampedHead));
      }
      this.prosemirrorView.dispatch(
        tr5.setMeta(ySyncPluginKey, { isChangeOrigin: true, binding: this })
      );
    });
  }
  /**
   * @param {Y.Snapshot|Uint8Array} snapshot
   * @param {Y.Snapshot|Uint8Array} prevSnapshot
   * @param {Object} pluginState
   */
  _renderSnapshot(snapshot2, prevSnapshot, pluginState) {
    let historyDoc = this.doc;
    let historyType = this.type;
    if (!snapshot2) {
      snapshot2 = snapshot(this.doc);
    }
    if (snapshot2 instanceof Uint8Array || prevSnapshot instanceof Uint8Array) {
      if (!(snapshot2 instanceof Uint8Array) || !(prevSnapshot instanceof Uint8Array)) {
        unexpectedCase();
      }
      historyDoc = new Doc({ gc: false });
      applyUpdateV2(historyDoc, prevSnapshot);
      prevSnapshot = snapshot(historyDoc);
      applyUpdateV2(historyDoc, snapshot2);
      snapshot2 = snapshot(historyDoc);
      if (historyType._item === null) {
        const rootKey = Array.from(this.doc.share.keys()).find(
          (key2) => this.doc.share.get(key2) === this.type
        );
        historyType = historyDoc.getXmlFragment(rootKey);
      } else {
        const historyStructs = historyDoc.store.clients.get(historyType._item.id.client) ?? [];
        const itemIndex = findIndexSS(
          historyStructs,
          historyType._item.id.clock
        );
        const item = (
          /** @type {Y.Item} */
          historyStructs[itemIndex]
        );
        const content5 = (
          /** @type {Y.ContentType} */
          item.content
        );
        historyType = /** @type {Y.XmlFragment} */
        content5.type;
      }
    }
    this.mapping.clear();
    this.mux(() => {
      historyDoc.transact((transaction) => {
        const pud = pluginState.permanentUserData;
        if (pud) {
          pud.dss.forEach((ds2) => {
            iterateDeletedStructs(transaction, ds2, (_item) => {
            });
          });
        }
        const computeYChange = (type, id2) => {
          const user = type === "added" ? pud.getUserByClientId(id2.client) : pud.getUserByDeletedId(id2);
          return {
            user,
            type,
            color: getUserColor(
              pluginState.colorMapping,
              pluginState.colors,
              user
            )
          };
        };
        const fragmentContent = typeListToArraySnapshot(
          historyType,
          new Snapshot(prevSnapshot.ds, snapshot2.sv)
        ).map((t) => {
          if (!t._item.deleted || isVisible2(t._item, snapshot2) || isVisible2(t._item, prevSnapshot)) {
            return createNodeFromYElement(
              t,
              this.prosemirrorView.state.schema,
              { mapping: /* @__PURE__ */ new Map(), isOMark: /* @__PURE__ */ new Map() },
              snapshot2,
              prevSnapshot,
              computeYChange
            );
          } else {
            return null;
          }
        }).filter((n) => n !== null);
        const tr5 = this._tr.replace(
          0,
          this.prosemirrorView.state.doc.content.size,
          new Slice(Fragment.from(fragmentContent), 0, 0)
        );
        this.prosemirrorView.dispatch(
          tr5.setMeta(ySyncPluginKey, { isChangeOrigin: true })
        );
      }, ySyncPluginKey);
    });
  }
  /**
   * @param {Array<Y.YEvent<any>>} events
   * @param {Y.Transaction} transaction
   */
  _typeChanged(events, transaction) {
    if (this.prosemirrorView == null) return;
    const syncState = ySyncPluginKey.getState(this.prosemirrorView.state);
    if (events.length === 0 || syncState.snapshot != null || syncState.prevSnapshot != null) {
      this.renderSnapshot(syncState.snapshot, syncState.prevSnapshot);
      return;
    }
    this.mux(() => {
      const delType = (_, type) => this.mapping.delete(type);
      iterateDeletedStructs(
        transaction,
        transaction.deleteSet,
        (struct) => {
          if (struct.constructor === Item) {
            const type = (
              /** @type {Y.ContentType} */
              /** @type {Y.Item} */
              struct.content.type
            );
            type && this.mapping.delete(type);
          }
        }
      );
      transaction.changed.forEach(delType);
      transaction.changedParentTypes.forEach(delType);
      const fragmentContent = this.type.toArray().map(
        (t) => createNodeIfNotExists(
          /** @type {Y.XmlElement | Y.XmlHook} */
          t,
          this.prosemirrorView.state.schema,
          this
        )
      ).filter((n) => n !== null);
      let tr5 = this._tr.replace(
        0,
        this.prosemirrorView.state.doc.content.size,
        new Slice(Fragment.from(fragmentContent), 0, 0)
      );
      restoreRelativeSelection(tr5, this.beforeTransactionSelection, this);
      tr5 = tr5.setMeta(ySyncPluginKey, { isChangeOrigin: true, isUndoRedoOperation: transaction.origin instanceof UndoManager });
      if (this.beforeTransactionSelection !== null && this._isLocalCursorInView()) {
        tr5.scrollIntoView();
      }
      this.prosemirrorView.dispatch(tr5);
    });
  }
  /**
   * @param {import('prosemirror-model').Node} doc
   */
  _prosemirrorChanged(doc2) {
    this.doc.transact(() => {
      updateYFragment(this.doc, this.type, doc2, this);
      this.beforeTransactionSelection = getRelativeSelection(
        this,
        this.prosemirrorView.state
      );
    }, ySyncPluginKey);
  }
  /**
   * View is ready to listen to changes. Register observers.
   * @param {any} prosemirrorView
   */
  initView(prosemirrorView) {
    if (this.prosemirrorView != null) this.destroy();
    this.prosemirrorView = prosemirrorView;
    this.doc.on("beforeAllTransactions", this.beforeAllTransactions);
    this.doc.on("afterAllTransactions", this.afterAllTransactions);
    this.type.observeDeep(this._observeFunction);
  }
  destroy() {
    if (this.prosemirrorView == null) return;
    this.prosemirrorView = null;
    this.type.unobserveDeep(this._observeFunction);
    this.doc.off("beforeAllTransactions", this.beforeAllTransactions);
    this.doc.off("afterAllTransactions", this.afterAllTransactions);
  }
};
var createNodeIfNotExists = (el2, schema, meta2, snapshot2, prevSnapshot, computeYChange) => {
  const node2 = (
    /** @type {PModel.Node} */
    meta2.mapping.get(el2)
  );
  if (node2 === void 0) {
    if (el2 instanceof YXmlElement) {
      return createNodeFromYElement(
        el2,
        schema,
        meta2,
        snapshot2,
        prevSnapshot,
        computeYChange
      );
    } else {
      throw methodUnimplemented();
    }
  }
  return node2;
};
var createNodeFromYElement = (el2, schema, meta2, snapshot2, prevSnapshot, computeYChange) => {
  const children = [];
  const createChildren = (type) => {
    if (type instanceof YXmlElement) {
      const n = createNodeIfNotExists(
        type,
        schema,
        meta2,
        snapshot2,
        prevSnapshot,
        computeYChange
      );
      if (n !== null) {
        children.push(n);
      }
    } else {
      const nextytext = (
        /** @type {Y.ContentType} */
        type._item.right?.content?.type
      );
      if (nextytext instanceof YText && !nextytext._item.deleted && nextytext._item.id.client === nextytext.doc.clientID) {
        type.applyDelta([
          { retain: type.length },
          ...nextytext.toDelta()
        ]);
        nextytext.doc.transact((tr5) => {
          nextytext._item.delete(tr5);
        });
      }
      const ns2 = createTextNodesFromYText(
        type,
        schema,
        meta2,
        snapshot2,
        prevSnapshot,
        computeYChange
      );
      if (ns2 !== null) {
        ns2.forEach((textchild) => {
          if (textchild !== null) {
            children.push(textchild);
          }
        });
      }
    }
  };
  if (snapshot2 === void 0 || prevSnapshot === void 0) {
    el2.toArray().forEach(createChildren);
  } else {
    typeListToArraySnapshot(el2, new Snapshot(prevSnapshot.ds, snapshot2.sv)).forEach(createChildren);
  }
  try {
    const attrs = el2.getAttributes(snapshot2);
    if (snapshot2 !== void 0) {
      if (!isVisible2(
        /** @type {Y.Item} */
        el2._item,
        snapshot2
      )) {
        attrs.ychange = computeYChange ? computeYChange(
          "removed",
          /** @type {Y.Item} */
          el2._item.id
        ) : { type: "removed" };
      } else if (!isVisible2(
        /** @type {Y.Item} */
        el2._item,
        prevSnapshot
      )) {
        attrs.ychange = computeYChange ? computeYChange(
          "added",
          /** @type {Y.Item} */
          el2._item.id
        ) : { type: "added" };
      }
    }
    const node2 = schema.node(el2.nodeName, attrs, children);
    meta2.mapping.set(el2, node2);
    return node2;
  } catch (e) {
    el2.doc.transact((transaction) => {
      el2._item.delete(transaction);
    }, ySyncPluginKey);
    meta2.mapping.delete(el2);
    return null;
  }
};
var createTextNodesFromYText = (text10, schema, _meta, snapshot2, prevSnapshot, computeYChange) => {
  const nodes = [];
  const deltas = text10.toDelta(snapshot2, prevSnapshot, computeYChange);
  try {
    for (let i2 = 0; i2 < deltas.length; i2++) {
      const delta = deltas[i2];
      nodes.push(schema.text(delta.insert, attributesToMarks(delta.attributes, schema)));
    }
  } catch (e) {
    text10.doc.transact((transaction) => {
      text10._item.delete(transaction);
    }, ySyncPluginKey);
    return null;
  }
  return nodes;
};
var createTypeFromTextNodes = (nodes, meta2) => {
  const type = new YXmlText();
  const delta = nodes.map((node2) => ({
    // @ts-ignore
    insert: node2.text,
    attributes: marksToAttributes(node2.marks, meta2)
  }));
  type.applyDelta(delta);
  meta2.mapping.set(type, nodes);
  return type;
};
var createTypeFromElementNode = (node2, meta2) => {
  const type = new YXmlElement(node2.type.name);
  for (const key2 in node2.attrs) {
    const val = node2.attrs[key2];
    if (val !== null && key2 !== "ychange") {
      type.setAttribute(key2, val);
    }
  }
  type.insert(
    0,
    normalizePNodeContent(node2).map(
      (n) => createTypeFromTextOrElementNode(n, meta2)
    )
  );
  meta2.mapping.set(type, node2);
  return type;
};
var createTypeFromTextOrElementNode = (node2, meta2) => node2 instanceof Array ? createTypeFromTextNodes(node2, meta2) : createTypeFromElementNode(node2, meta2);
var isObject = (val) => typeof val === "object" && val !== null;
var equalAttrs2 = (pattrs, yattrs) => {
  const keys3 = Object.keys(pattrs).filter((key2) => pattrs[key2] !== null);
  let eq = keys3.length === (yattrs == null ? 0 : Object.keys(yattrs).filter((key2) => yattrs[key2] !== null).length);
  for (let i2 = 0; i2 < keys3.length && eq; i2++) {
    const key2 = keys3[i2];
    const l2 = pattrs[key2];
    const r = yattrs[key2];
    eq = key2 === "ychange" || l2 === r || isObject(l2) && isObject(r) && equalAttrs2(l2, r);
  }
  return eq;
};
var normalizePNodeContent = (pnode) => {
  const c = pnode.content.content;
  const res = [];
  for (let i2 = 0; i2 < c.length; i2++) {
    const n = c[i2];
    if (n.isText) {
      const textNodes = [];
      for (let tnode = c[i2]; i2 < c.length && tnode.isText; tnode = c[++i2]) {
        textNodes.push(tnode);
      }
      i2--;
      res.push(textNodes);
    } else {
      res.push(n);
    }
  }
  return res;
};
var equalYTextPText = (ytext, ptexts) => {
  const delta = ytext.toDelta();
  return delta.length === ptexts.length && delta.every(
    /** @type {(d:any,i:number) => boolean} */
    (d, i2) => d.insert === /** @type {any} */
    ptexts[i2].text && keys(d.attributes || {}).length === ptexts[i2].marks.length && every(d.attributes, (attr2, yattrname) => {
      const markname = yattr2markname(yattrname);
      const pmarks = ptexts[i2].marks;
      return equalAttrs2(attr2, pmarks.find(
        /** @param {any} mark */
        (mark2) => mark2.type.name === markname
      )?.attrs);
    })
  );
};
var equalYTypePNode = (ytype, pnode) => {
  if (ytype instanceof YXmlElement && !(pnode instanceof Array) && matchNodeName(ytype, pnode)) {
    const normalizedContent = normalizePNodeContent(pnode);
    return ytype._length === normalizedContent.length && equalAttrs2(ytype.getAttributes(), pnode.attrs) && ytype.toArray().every(
      (ychild, i2) => equalYTypePNode(ychild, normalizedContent[i2])
    );
  }
  return ytype instanceof YXmlText && pnode instanceof Array && equalYTextPText(ytype, pnode);
};
var mappedIdentity = (mapped, pcontent) => mapped === pcontent || mapped instanceof Array && pcontent instanceof Array && mapped.length === pcontent.length && mapped.every(
  (a2, i2) => pcontent[i2] === a2
);
var computeChildEqualityFactor = (ytype, pnode, meta2) => {
  const yChildren = ytype.toArray();
  const pChildren = normalizePNodeContent(pnode);
  const pChildCnt = pChildren.length;
  const yChildCnt = yChildren.length;
  const minCnt = min2(yChildCnt, pChildCnt);
  let left = 0;
  let right = 0;
  let foundMappedChild = false;
  for (; left < minCnt; left++) {
    const leftY = yChildren[left];
    const leftP = pChildren[left];
    if (mappedIdentity(meta2.mapping.get(leftY), leftP)) {
      foundMappedChild = true;
    } else if (!equalYTypePNode(leftY, leftP)) {
      break;
    }
  }
  for (; left + right < minCnt; right++) {
    const rightY = yChildren[yChildCnt - right - 1];
    const rightP = pChildren[pChildCnt - right - 1];
    if (mappedIdentity(meta2.mapping.get(rightY), rightP)) {
      foundMappedChild = true;
    } else if (!equalYTypePNode(rightY, rightP)) {
      break;
    }
  }
  return {
    equalityFactor: left + right,
    foundMappedChild
  };
};
var ytextTrans = (ytext) => {
  let str = "";
  let n = ytext._start;
  const nAttrs = {};
  while (n !== null) {
    if (!n.deleted) {
      if (n.countable && n.content instanceof ContentString) {
        str += n.content.str;
      } else if (n.content instanceof ContentFormat) {
        nAttrs[n.content.key] = null;
      }
    }
    n = n.right;
  }
  return {
    str,
    nAttrs
  };
};
var updateYText = (ytext, ptexts, meta2) => {
  meta2.mapping.set(ytext, ptexts);
  const { nAttrs, str } = ytextTrans(ytext);
  const content5 = ptexts.map((p5) => ({
    insert: (
      /** @type {any} */
      p5.text
    ),
    attributes: Object.assign({}, nAttrs, marksToAttributes(p5.marks, meta2))
  }));
  const { insert, remove, index: index4 } = simpleDiff(
    str,
    content5.map((c) => c.insert).join("")
  );
  ytext.delete(index4, remove);
  ytext.insert(index4, insert);
  ytext.applyDelta(
    content5.map((c) => ({ retain: c.insert.length, attributes: c.attributes }))
  );
};
var hashedMarkNameRegex = /(.*)(--[a-zA-Z0-9+/=]{8})$/;
var yattr2markname = (attrName) => hashedMarkNameRegex.exec(attrName)?.[1] ?? attrName;
var attributesToMarks = (attrs, schema) => {
  const marks = [];
  for (const markName in attrs) {
    marks.push(schema.mark(yattr2markname(markName), attrs[markName]));
  }
  return marks;
};
var marksToAttributes = (marks, meta2) => {
  const pattrs = {};
  marks.forEach((mark2) => {
    if (mark2.type.name !== "ychange") {
      const isOverlapping = setIfUndefined(meta2.isOMark, mark2.type, () => !mark2.type.excludes(mark2.type));
      pattrs[isOverlapping ? `${mark2.type.name}--${hashOfJSON(mark2.toJSON())}` : mark2.type.name] = mark2.attrs;
    }
  });
  return pattrs;
};
var updateYFragment = (y2, yDomFragment, pNode, meta2) => {
  if (yDomFragment instanceof YXmlElement && yDomFragment.nodeName !== pNode.type.name) {
    throw new Error("node name mismatch!");
  }
  meta2.mapping.set(yDomFragment, pNode);
  if (yDomFragment instanceof YXmlElement) {
    const yDomAttrs = yDomFragment.getAttributes();
    const pAttrs = pNode.attrs;
    for (const key2 in pAttrs) {
      if (pAttrs[key2] !== null) {
        if (yDomAttrs[key2] !== pAttrs[key2] && key2 !== "ychange") {
          yDomFragment.setAttribute(key2, pAttrs[key2]);
        }
      } else {
        yDomFragment.removeAttribute(key2);
      }
    }
    for (const key2 in yDomAttrs) {
      if (pAttrs[key2] === void 0) {
        yDomFragment.removeAttribute(key2);
      }
    }
  }
  const pChildren = normalizePNodeContent(pNode);
  const pChildCnt = pChildren.length;
  const yChildren = yDomFragment.toArray();
  const yChildCnt = yChildren.length;
  const minCnt = min2(pChildCnt, yChildCnt);
  let left = 0;
  let right = 0;
  for (; left < minCnt; left++) {
    const leftY = yChildren[left];
    const leftP = pChildren[left];
    if (!mappedIdentity(meta2.mapping.get(leftY), leftP)) {
      if (equalYTypePNode(leftY, leftP)) {
        meta2.mapping.set(leftY, leftP);
      } else {
        break;
      }
    }
  }
  for (; right + left < minCnt; right++) {
    const rightY = yChildren[yChildCnt - right - 1];
    const rightP = pChildren[pChildCnt - right - 1];
    if (!mappedIdentity(meta2.mapping.get(rightY), rightP)) {
      if (equalYTypePNode(rightY, rightP)) {
        meta2.mapping.set(rightY, rightP);
      } else {
        break;
      }
    }
  }
  y2.transact(() => {
    while (yChildCnt - left - right > 0 && pChildCnt - left - right > 0) {
      const leftY = yChildren[left];
      const leftP = pChildren[left];
      const rightY = yChildren[yChildCnt - right - 1];
      const rightP = pChildren[pChildCnt - right - 1];
      if (leftY instanceof YXmlText && leftP instanceof Array) {
        if (!equalYTextPText(leftY, leftP)) {
          updateYText(leftY, leftP, meta2);
        }
        left += 1;
      } else {
        let updateLeft = leftY instanceof YXmlElement && matchNodeName(leftY, leftP);
        let updateRight = rightY instanceof YXmlElement && matchNodeName(rightY, rightP);
        if (updateLeft && updateRight) {
          const equalityLeft = computeChildEqualityFactor(
            /** @type {Y.XmlElement} */
            leftY,
            /** @type {PModel.Node} */
            leftP,
            meta2
          );
          const equalityRight = computeChildEqualityFactor(
            /** @type {Y.XmlElement} */
            rightY,
            /** @type {PModel.Node} */
            rightP,
            meta2
          );
          if (equalityLeft.foundMappedChild && !equalityRight.foundMappedChild) {
            updateRight = false;
          } else if (!equalityLeft.foundMappedChild && equalityRight.foundMappedChild) {
            updateLeft = false;
          } else if (equalityLeft.equalityFactor < equalityRight.equalityFactor) {
            updateLeft = false;
          } else {
            updateRight = false;
          }
        }
        if (updateLeft) {
          updateYFragment(
            y2,
            /** @type {Y.XmlFragment} */
            leftY,
            /** @type {PModel.Node} */
            leftP,
            meta2
          );
          left += 1;
        } else if (updateRight) {
          updateYFragment(
            y2,
            /** @type {Y.XmlFragment} */
            rightY,
            /** @type {PModel.Node} */
            rightP,
            meta2
          );
          right += 1;
        } else {
          meta2.mapping.delete(yDomFragment.get(left));
          yDomFragment.delete(left, 1);
          yDomFragment.insert(left, [
            createTypeFromTextOrElementNode(leftP, meta2)
          ]);
          left += 1;
        }
      }
    }
    const yDelLen = yChildCnt - left - right;
    if (yChildCnt === 1 && pChildCnt === 0 && yChildren[0] instanceof YXmlText) {
      meta2.mapping.delete(yChildren[0]);
      yChildren[0].delete(0, yChildren[0].length);
    } else if (yDelLen > 0) {
      yDomFragment.slice(left, left + yDelLen).forEach((type) => meta2.mapping.delete(type));
      yDomFragment.delete(left, yDelLen);
    }
    if (left + right < pChildCnt) {
      const ins = [];
      for (let i2 = left; i2 < pChildCnt - right; i2++) {
        ins.push(createTypeFromTextOrElementNode(pChildren[i2], meta2));
      }
      yDomFragment.insert(left, ins);
    }
  }, ySyncPluginKey);
};
var matchNodeName = (yElement, pNode) => !(pNode instanceof Array) && yElement.nodeName === pNode.type.name;

// ../node_modules/.pnpm/y-prosemirror@1.3.7_prosemi_a3ecbc8ef8fd72690320bad9def4d609/node_modules/y-prosemirror/src/lib.js
var viewsToUpdate = null;
var updateMetas = () => {
  const ups = (
    /** @type {Map<EditorView, Map<any, any>>} */
    viewsToUpdate
  );
  viewsToUpdate = null;
  ups.forEach((metas, view) => {
    const tr5 = view.state.tr;
    const syncState = ySyncPluginKey.getState(view.state);
    if (syncState && syncState.binding && !syncState.binding.isDestroyed) {
      metas.forEach((val, key2) => {
        tr5.setMeta(key2, val);
      });
      view.dispatch(tr5);
    }
  });
};
var setMeta2 = (view, key2, value) => {
  if (!viewsToUpdate) {
    viewsToUpdate = /* @__PURE__ */ new Map();
    timeout(0, updateMetas);
  }
  setIfUndefined(viewsToUpdate, view, create).set(key2, value);
};
var absolutePositionToRelativePosition = (pos, type, mapping) => {
  if (pos === 0) {
    return createRelativePositionFromTypeIndex(type, 0, type.length === 0 ? -1 : 0);
  }
  let n = type._first === null ? null : (
    /** @type {Y.ContentType} */
    type._first.content.type
  );
  while (n !== null && type !== n) {
    if (n instanceof YXmlText) {
      if (n._length >= pos) {
        return createRelativePositionFromTypeIndex(n, pos, type.length === 0 ? -1 : 0);
      } else {
        pos -= n._length;
      }
      if (n._item !== null && n._item.next !== null) {
        n = /** @type {Y.ContentType} */
        n._item.next.content.type;
      } else {
        do {
          n = n._item === null ? null : n._item.parent;
          pos--;
        } while (n !== type && n !== null && n._item !== null && n._item.next === null);
        if (n !== null && n !== type) {
          n = n._item === null ? null : (
            /** @type {Y.ContentType} */
            /** @type Y.Item */
            n._item.next.content.type
          );
        }
      }
    } else {
      const pNodeSize = (
        /** @type {any} */
        (mapping.get(n) || { nodeSize: 0 }).nodeSize
      );
      if (n._first !== null && pos < pNodeSize) {
        n = /** @type {Y.ContentType} */
        n._first.content.type;
        pos--;
      } else {
        if (pos === 1 && n._length === 0 && pNodeSize > 1) {
          return new RelativePosition(n._item === null ? null : n._item.id, n._item === null ? findRootTypeKey(n) : null, null);
        }
        pos -= pNodeSize;
        if (n._item !== null && n._item.next !== null) {
          n = /** @type {Y.ContentType} */
          n._item.next.content.type;
        } else {
          if (pos === 0) {
            n = n._item === null ? n : n._item.parent;
            return new RelativePosition(n._item === null ? null : n._item.id, n._item === null ? findRootTypeKey(n) : null, null);
          }
          do {
            n = /** @type {Y.Item} */
            n._item.parent;
            pos--;
          } while (n !== type && /** @type {Y.Item} */
          n._item.next === null);
          if (n !== type) {
            n = /** @type {Y.ContentType} */
            /** @type {Y.Item} */
            /** @type {Y.Item} */
            n._item.next.content.type;
          }
        }
      }
    }
    if (n === null) {
      throw unexpectedCase();
    }
    if (pos === 0 && n.constructor !== YXmlText && n !== type) {
      return createRelativePosition2(n._item.parent, n._item);
    }
  }
  return createRelativePositionFromTypeIndex(type, type._length, type.length === 0 ? -1 : 0);
};
var createRelativePosition2 = (type, item) => {
  let typeid = null;
  let tname = null;
  if (type._item === null) {
    tname = findRootTypeKey(type);
  } else {
    typeid = createID(type._item.id.client, type._item.id.clock);
  }
  return new RelativePosition(typeid, tname, item.id);
};
var relativePositionToAbsolutePosition = (y2, documentType, relPos, mapping) => {
  const decodedPos = createAbsolutePositionFromRelativePosition(relPos, y2);
  if (decodedPos === null || decodedPos.type !== documentType && !isParentOf(documentType, decodedPos.type._item)) {
    return null;
  }
  let type = decodedPos.type;
  let pos = 0;
  if (type.constructor === YXmlText) {
    pos = decodedPos.index;
  } else if (type._item === null || !type._item.deleted) {
    let n = type._first;
    let i2 = 0;
    while (i2 < type._length && i2 < decodedPos.index && n !== null) {
      if (!n.deleted) {
        const t = (
          /** @type {Y.ContentType} */
          n.content.type
        );
        i2++;
        if (t instanceof YXmlText) {
          pos += t._length;
        } else {
          pos += /** @type {any} */
          mapping.get(t).nodeSize;
        }
      }
      n = /** @type {Y.Item} */
      n.right;
    }
    pos += 1;
  }
  while (type !== documentType && type._item !== null) {
    const parent = type._item.parent;
    if (parent._item === null || !parent._item.deleted) {
      pos += 1;
      let n = (
        /** @type {Y.AbstractType} */
        parent._first
      );
      while (n !== null) {
        const contentType = (
          /** @type {Y.ContentType} */
          n.content.type
        );
        if (contentType === type) {
          break;
        }
        if (!n.deleted) {
          if (contentType instanceof YXmlText) {
            pos += contentType._length;
          } else {
            pos += /** @type {any} */
            mapping.get(contentType).nodeSize;
          }
        }
        n = n.right;
      }
    }
    type = /** @type {Y.AbstractType} */
    parent;
  }
  return pos - 1;
};

// ../node_modules/.pnpm/y-prosemirror@1.3.7_prosemi_a3ecbc8ef8fd72690320bad9def4d609/node_modules/y-prosemirror/src/plugins/cursor-plugin.js
var defaultAwarenessStateFilter = (currentClientId, userClientId, _user) => currentClientId !== userClientId;
var defaultCursorBuilder = (user) => {
  const cursor = document.createElement("span");
  cursor.classList.add("ProseMirror-yjs-cursor");
  cursor.setAttribute("style", `border-color: ${user.color}`);
  const userDiv = document.createElement("div");
  userDiv.setAttribute("style", `background-color: ${user.color}`);
  userDiv.insertBefore(document.createTextNode(user.name), null);
  const nonbreakingSpace1 = document.createTextNode("");
  const nonbreakingSpace2 = document.createTextNode("");
  cursor.insertBefore(nonbreakingSpace1, null);
  cursor.insertBefore(userDiv, null);
  cursor.insertBefore(nonbreakingSpace2, null);
  return cursor;
};
var defaultSelectionBuilder = (user) => {
  return {
    style: `background-color: ${user.color}70`,
    class: "ProseMirror-yjs-selection"
  };
};
var rxValidColor = /^#[0-9a-fA-F]{6}$/;
var createDecorations = (state, awareness, awarenessFilter, createCursor, createSelection) => {
  const ystate = ySyncPluginKey.getState(state);
  const y2 = ystate.doc;
  const decorations = [];
  if (ystate.snapshot != null || ystate.prevSnapshot != null || ystate.binding.mapping.size === 0) {
    return DecorationSet.create(state.doc, []);
  }
  awareness.getStates().forEach((aw, clientId) => {
    if (!awarenessFilter(y2.clientID, clientId, aw)) {
      return;
    }
    if (aw.cursor != null) {
      const user = aw.user || {};
      if (user.color == null) {
        user.color = "#ffa500";
      } else if (!rxValidColor.test(user.color)) {
        console.warn("A user uses an unsupported color format", user);
      }
      if (user.name == null) {
        user.name = `User: ${clientId}`;
      }
      let anchor = relativePositionToAbsolutePosition(
        y2,
        ystate.type,
        createRelativePositionFromJSON(aw.cursor.anchor),
        ystate.binding.mapping
      );
      let head2 = relativePositionToAbsolutePosition(
        y2,
        ystate.type,
        createRelativePositionFromJSON(aw.cursor.head),
        ystate.binding.mapping
      );
      if (anchor !== null && head2 !== null) {
        const maxsize = max2(state.doc.content.size - 1, 0);
        anchor = min2(anchor, maxsize);
        head2 = min2(head2, maxsize);
        decorations.push(
          Decoration.widget(head2, () => createCursor(user, clientId), {
            key: clientId + "",
            side: 10
          })
        );
        const from3 = min2(anchor, head2);
        const to3 = max2(anchor, head2);
        decorations.push(
          Decoration.inline(from3, to3, createSelection(user, clientId), {
            inclusiveEnd: true,
            inclusiveStart: false
          })
        );
      }
    }
  });
  return DecorationSet.create(state.doc, decorations);
};
var yCursorPlugin = (awareness, {
  awarenessStateFilter = defaultAwarenessStateFilter,
  cursorBuilder = defaultCursorBuilder,
  selectionBuilder = defaultSelectionBuilder,
  getSelection = (state) => state.selection
} = {}, cursorStateField = "cursor") => new Plugin({
  key: yCursorPluginKey,
  state: {
    init(_, state) {
      return createDecorations(
        state,
        awareness,
        awarenessStateFilter,
        cursorBuilder,
        selectionBuilder
      );
    },
    apply(tr5, prevState, _oldState, newState) {
      const ystate = ySyncPluginKey.getState(newState);
      const yCursorState = tr5.getMeta(yCursorPluginKey);
      if (ystate && ystate.isChangeOrigin || yCursorState && yCursorState.awarenessUpdated) {
        return createDecorations(
          newState,
          awareness,
          awarenessStateFilter,
          cursorBuilder,
          selectionBuilder
        );
      }
      return prevState.map(tr5.mapping, tr5.doc);
    }
  },
  props: {
    decorations: (state) => {
      return yCursorPluginKey.getState(state);
    }
  },
  view: (view) => {
    const awarenessListener = () => {
      if (view.docView) {
        setMeta2(view, yCursorPluginKey, { awarenessUpdated: true });
      }
    };
    const updateCursorInfo = () => {
      const ystate = ySyncPluginKey.getState(view.state);
      const current = awareness.getLocalState() || {};
      if (view.hasFocus()) {
        const selection = getSelection(view.state);
        const anchor = absolutePositionToRelativePosition(
          selection.anchor,
          ystate.type,
          ystate.binding.mapping
        );
        const head2 = absolutePositionToRelativePosition(
          selection.head,
          ystate.type,
          ystate.binding.mapping
        );
        if (current.cursor == null || !compareRelativePositions(
          createRelativePositionFromJSON(current.cursor.anchor),
          anchor
        ) || !compareRelativePositions(
          createRelativePositionFromJSON(current.cursor.head),
          head2
        )) {
          awareness.setLocalStateField(cursorStateField, {
            anchor,
            head: head2
          });
        }
      } else if (current.cursor != null && relativePositionToAbsolutePosition(
        ystate.doc,
        ystate.type,
        createRelativePositionFromJSON(current.cursor.anchor),
        ystate.binding.mapping
      ) !== null) {
        awareness.setLocalStateField(cursorStateField, null);
      }
    };
    awareness.on("change", awarenessListener);
    view.dom.addEventListener("focusin", updateCursorInfo);
    view.dom.addEventListener("focusout", updateCursorInfo);
    return {
      update: updateCursorInfo,
      destroy: () => {
        view.dom.removeEventListener("focusin", updateCursorInfo);
        view.dom.removeEventListener("focusout", updateCursorInfo);
        awareness.off("change", awarenessListener);
        awareness.setLocalStateField(cursorStateField, null);
      }
    };
  }
});

// ../node_modules/.pnpm/y-prosemirror@1.3.7_prosemi_a3ecbc8ef8fd72690320bad9def4d609/node_modules/y-prosemirror/src/plugins/undo-plugin.js
var undo2 = (state) => yUndoPluginKey.getState(state)?.undoManager?.undo() != null;
var redo2 = (state) => yUndoPluginKey.getState(state)?.undoManager?.redo() != null;
var undoCommand = (state, dispatch) => dispatch == null ? yUndoPluginKey.getState(state)?.undoManager?.canUndo() : undo2(state);
var redoCommand = (state, dispatch) => dispatch == null ? yUndoPluginKey.getState(state)?.undoManager?.canRedo() : redo2(state);
var defaultProtectedNodes = /* @__PURE__ */ new Set(["paragraph"]);
var defaultDeleteFilter = (item, protectedNodes) => !(item instanceof Item) || !(item.content instanceof ContentType) || !(item.content.type instanceof YText || item.content.type instanceof YXmlElement && protectedNodes.has(item.content.type.nodeName)) || item.content.type._length === 0;
var yUndoPlugin = ({ protectedNodes = defaultProtectedNodes, trackedOrigins = [], undoManager = null } = {}) => new Plugin({
  key: yUndoPluginKey,
  state: {
    init: (initargs, state) => {
      const ystate = ySyncPluginKey.getState(state);
      const _undoManager = undoManager || new UndoManager(ystate.type, {
        trackedOrigins: new Set([ySyncPluginKey].concat(trackedOrigins)),
        deleteFilter: (item) => defaultDeleteFilter(item, protectedNodes),
        captureTransaction: (tr5) => tr5.meta.get("addToHistory") !== false
      });
      return {
        undoManager: _undoManager,
        prevSel: null,
        hasUndoOps: _undoManager.undoStack.length > 0,
        hasRedoOps: _undoManager.redoStack.length > 0
      };
    },
    apply: (tr5, val, oldState, state) => {
      const binding = ySyncPluginKey.getState(state).binding;
      const undoManager2 = val.undoManager;
      const hasUndoOps = undoManager2.undoStack.length > 0;
      const hasRedoOps = undoManager2.redoStack.length > 0;
      if (binding) {
        return {
          undoManager: undoManager2,
          prevSel: getRelativeSelection(binding, oldState),
          hasUndoOps,
          hasRedoOps
        };
      } else {
        if (hasUndoOps !== val.hasUndoOps || hasRedoOps !== val.hasRedoOps) {
          return Object.assign({}, val, {
            hasUndoOps: undoManager2.undoStack.length > 0,
            hasRedoOps: undoManager2.redoStack.length > 0
          });
        } else {
          return val;
        }
      }
    }
  },
  view: (view) => {
    const ystate = ySyncPluginKey.getState(view.state);
    const undoManager2 = yUndoPluginKey.getState(view.state).undoManager;
    undoManager2.on("stack-item-added", ({ stackItem }) => {
      const binding = ystate.binding;
      if (binding) {
        stackItem.meta.set(binding, yUndoPluginKey.getState(view.state).prevSel);
      }
    });
    undoManager2.on("stack-item-popped", ({ stackItem }) => {
      const binding = ystate.binding;
      if (binding) {
        binding.beforeTransactionSelection = stackItem.meta.get(binding) || binding.beforeTransactionSelection;
      }
    });
    return {
      destroy: () => {
        undoManager2.destroy();
      }
    };
  }
});

// ../node_modules/.pnpm/@blocknote+core@0.41.1_@tip_88da0e2ca7990b1ebffff41010f54baa/node_modules/@blocknote/core/dist/en-njEqD7AG.js
var i = {
  slash_menu: {
    heading: {
      title: "Heading 1",
      subtext: "Top-level heading",
      aliases: ["h", "heading1", "h1"],
      group: "Headings"
    },
    heading_2: {
      title: "Heading 2",
      subtext: "Key section heading",
      aliases: ["h2", "heading2", "subheading"],
      group: "Headings"
    },
    heading_3: {
      title: "Heading 3",
      subtext: "Subsection and group heading",
      aliases: ["h3", "heading3", "subheading"],
      group: "Headings"
    },
    heading_4: {
      title: "Heading 4",
      subtext: "Minor subsection heading",
      aliases: ["h4", "heading4", "subheading4"],
      group: "Subheadings"
    },
    heading_5: {
      title: "Heading 5",
      subtext: "Small subsection heading",
      aliases: ["h5", "heading5", "subheading5"],
      group: "Subheadings"
    },
    heading_6: {
      title: "Heading 6",
      subtext: "Lowest-level heading",
      aliases: ["h6", "heading6", "subheading6"],
      group: "Subheadings"
    },
    toggle_heading: {
      title: "Toggle Heading 1",
      subtext: "Toggleable top-level heading",
      aliases: ["h", "heading1", "h1", "collapsable"],
      group: "Subheadings"
    },
    toggle_heading_2: {
      title: "Toggle Heading 2",
      subtext: "Toggleable key section heading",
      aliases: ["h2", "heading2", "subheading", "collapsable"],
      group: "Subheadings"
    },
    toggle_heading_3: {
      title: "Toggle Heading 3",
      subtext: "Toggleable subsection and group heading",
      aliases: ["h3", "heading3", "subheading", "collapsable"],
      group: "Subheadings"
    },
    quote: {
      title: "Quote",
      subtext: "Quote or excerpt",
      aliases: ["quotation", "blockquote", "bq"],
      group: "Basic blocks"
    },
    toggle_list: {
      title: "Toggle List",
      subtext: "List with hideable sub-items",
      aliases: ["li", "list", "toggleList", "toggle list", "collapsable list"],
      group: "Basic blocks"
    },
    numbered_list: {
      title: "Numbered List",
      subtext: "List with ordered items",
      aliases: ["ol", "li", "list", "numberedlist", "numbered list"],
      group: "Basic blocks"
    },
    bullet_list: {
      title: "Bullet List",
      subtext: "List with unordered items",
      aliases: ["ul", "li", "list", "bulletlist", "bullet list"],
      group: "Basic blocks"
    },
    check_list: {
      title: "Check List",
      subtext: "List with checkboxes",
      aliases: [
        "ul",
        "li",
        "list",
        "checklist",
        "check list",
        "checked list",
        "checkbox"
      ],
      group: "Basic blocks"
    },
    paragraph: {
      title: "Paragraph",
      subtext: "The body of your document",
      aliases: ["p", "paragraph"],
      group: "Basic blocks"
    },
    code_block: {
      title: "Code Block",
      subtext: "Code block with syntax highlighting",
      aliases: ["code", "pre"],
      group: "Basic blocks"
    },
    page_break: {
      title: "Page Break",
      subtext: "Page separator",
      aliases: ["page", "break", "separator"],
      group: "Basic blocks"
    },
    table: {
      title: "Table",
      subtext: "Table with editable cells",
      aliases: ["table"],
      group: "Advanced"
    },
    image: {
      title: "Image",
      subtext: "Resizable image with caption",
      aliases: [
        "image",
        "imageUpload",
        "upload",
        "img",
        "picture",
        "media",
        "url"
      ],
      group: "Media"
    },
    video: {
      title: "Video",
      subtext: "Resizable video with caption",
      aliases: [
        "video",
        "videoUpload",
        "upload",
        "mp4",
        "film",
        "media",
        "url"
      ],
      group: "Media"
    },
    audio: {
      title: "Audio",
      subtext: "Embedded audio with caption",
      aliases: [
        "audio",
        "audioUpload",
        "upload",
        "mp3",
        "sound",
        "media",
        "url"
      ],
      group: "Media"
    },
    file: {
      title: "File",
      subtext: "Embedded file",
      aliases: ["file", "upload", "embed", "media", "url"],
      group: "Media"
    },
    emoji: {
      title: "Emoji",
      subtext: "Search for and insert an emoji",
      aliases: ["emoji", "emote", "emotion", "face"],
      group: "Others"
    },
    divider: {
      title: "Divider",
      subtext: "Visually divide blocks",
      aliases: ["divider", "hr", "line", "horizontal rule"],
      group: "Basic blocks"
    }
  },
  placeholders: {
    default: "Enter text or type '/' for commands",
    heading: "Heading",
    toggleListItem: "Toggle",
    bulletListItem: "List",
    numberedListItem: "List",
    checkListItem: "List",
    emptyDocument: void 0,
    new_comment: "Write a comment...",
    edit_comment: "Edit comment...",
    comment_reply: "Add comment..."
  },
  file_blocks: {
    add_button_text: {
      image: "Add image",
      video: "Add video",
      audio: "Add audio",
      file: "Add file"
    }
  },
  toggle_blocks: {
    add_block_button: "Empty toggle. Click to add a block."
  },
  // from react package:
  side_menu: {
    add_block_label: "Add block",
    drag_handle_label: "Open block menu"
  },
  drag_handle: {
    delete_menuitem: "Delete",
    colors_menuitem: "Colors",
    header_row_menuitem: "Header row",
    header_column_menuitem: "Header column"
  },
  table_handle: {
    delete_column_menuitem: "Delete column",
    delete_row_menuitem: "Delete row",
    add_left_menuitem: "Add column left",
    add_right_menuitem: "Add column right",
    add_above_menuitem: "Add row above",
    add_below_menuitem: "Add row below",
    split_cell_menuitem: "Split cell",
    merge_cells_menuitem: "Merge cells",
    background_color_menuitem: "Background color"
  },
  suggestion_menu: {
    no_items_title: "No items found"
  },
  color_picker: {
    text_title: "Text",
    background_title: "Background",
    colors: {
      default: "Default",
      gray: "Gray",
      brown: "Brown",
      red: "Red",
      orange: "Orange",
      yellow: "Yellow",
      green: "Green",
      blue: "Blue",
      purple: "Purple",
      pink: "Pink"
    }
  },
  formatting_toolbar: {
    bold: {
      tooltip: "Bold",
      secondary_tooltip: "Mod+B"
    },
    italic: {
      tooltip: "Italic",
      secondary_tooltip: "Mod+I"
    },
    underline: {
      tooltip: "Underline",
      secondary_tooltip: "Mod+U"
    },
    strike: {
      tooltip: "Strike",
      secondary_tooltip: "Mod+Shift+S"
    },
    code: {
      tooltip: "Code",
      secondary_tooltip: ""
    },
    colors: {
      tooltip: "Colors"
    },
    link: {
      tooltip: "Create link",
      secondary_tooltip: "Mod+K"
    },
    file_caption: {
      tooltip: "Edit caption",
      input_placeholder: "Edit caption"
    },
    file_replace: {
      tooltip: {
        image: "Replace image",
        video: "Replace video",
        audio: "Replace audio",
        file: "Replace file"
      }
    },
    file_rename: {
      tooltip: {
        image: "Rename image",
        video: "Rename video",
        audio: "Rename audio",
        file: "Rename file"
      },
      input_placeholder: {
        image: "Rename image",
        video: "Rename video",
        audio: "Rename audio",
        file: "Rename file"
      }
    },
    file_download: {
      tooltip: {
        image: "Download image",
        video: "Download video",
        audio: "Download audio",
        file: "Download file"
      }
    },
    file_delete: {
      tooltip: {
        image: "Delete image",
        video: "Delete video",
        audio: "Delete audio",
        file: "Delete file"
      }
    },
    file_preview_toggle: {
      tooltip: "Toggle preview"
    },
    nest: {
      tooltip: "Nest block",
      secondary_tooltip: "Tab"
    },
    unnest: {
      tooltip: "Unnest block",
      secondary_tooltip: "Shift+Tab"
    },
    align_left: {
      tooltip: "Align text left"
    },
    align_center: {
      tooltip: "Align text center"
    },
    align_right: {
      tooltip: "Align text right"
    },
    align_justify: {
      tooltip: "Justify text"
    },
    table_cell_merge: {
      tooltip: "Merge cells"
    },
    comment: {
      tooltip: "Add comment"
    }
  },
  file_panel: {
    upload: {
      title: "Upload",
      file_placeholder: {
        image: "Upload image",
        video: "Upload video",
        audio: "Upload audio",
        file: "Upload file"
      },
      upload_error: "Error: Upload failed"
    },
    embed: {
      title: "Embed",
      embed_button: {
        image: "Embed image",
        video: "Embed video",
        audio: "Embed audio",
        file: "Embed file"
      },
      url_placeholder: "Enter URL"
    }
  },
  link_toolbar: {
    delete: {
      tooltip: "Remove link"
    },
    edit: {
      text: "Edit link",
      tooltip: "Edit"
    },
    open: {
      tooltip: "Open in new tab"
    },
    form: {
      title_placeholder: "Edit title",
      url_placeholder: "Edit URL"
    }
  },
  comments: {
    edited: "edited",
    save_button_text: "Save",
    cancel_button_text: "Cancel",
    actions: {
      add_reaction: "Add reaction",
      resolve: "Resolve",
      edit_comment: "Edit comment",
      delete_comment: "Delete comment",
      more_actions: "More actions"
    },
    reactions: {
      reacted_by: "Reacted by"
    },
    sidebar: {
      marked_as_resolved: "Marked as resolved",
      more_replies: (e) => `${e} more replies`
    }
  },
  generic: {
    ctrl_shortcut: "Ctrl"
  }
};

// ../node_modules/.pnpm/micromark@4.0.2/node_modules/micromark/dev/lib/compile.js
var hasOwnProperty2 = {}.hasOwnProperty;

// ../node_modules/.pnpm/micromark@4.0.2/node_modules/micromark/dev/lib/initialize/content.js
var content4 = { tokenize: initializeContent };
function initializeContent(effects) {
  const contentStart = effects.attempt(
    this.parser.constructs.contentInitial,
    afterContentStartConstruct,
    paragraphInitial
  );
  let previous3;
  return contentStart;
  function afterContentStartConstruct(code5) {
    ok(
      code5 === codes.eof || markdownLineEnding(code5),
      "expected eol or eof"
    );
    if (code5 === codes.eof) {
      effects.consume(code5);
      return;
    }
    effects.enter(types.lineEnding);
    effects.consume(code5);
    effects.exit(types.lineEnding);
    return factorySpace(effects, contentStart, types.linePrefix);
  }
  function paragraphInitial(code5) {
    ok(
      code5 !== codes.eof && !markdownLineEnding(code5),
      "expected anything other than a line ending or EOF"
    );
    effects.enter(types.paragraph);
    return lineStart(code5);
  }
  function lineStart(code5) {
    const token = effects.enter(types.chunkText, {
      contentType: constants.contentTypeText,
      previous: previous3
    });
    if (previous3) {
      previous3.next = token;
    }
    previous3 = token;
    return data(code5);
  }
  function data(code5) {
    if (code5 === codes.eof) {
      effects.exit(types.chunkText);
      effects.exit(types.paragraph);
      effects.consume(code5);
      return;
    }
    if (markdownLineEnding(code5)) {
      effects.consume(code5);
      effects.exit(types.chunkText);
      return lineStart;
    }
    effects.consume(code5);
    return data;
  }
}

// ../node_modules/.pnpm/micromark@4.0.2/node_modules/micromark/dev/lib/initialize/document.js
var document2 = { tokenize: initializeDocument };
var containerConstruct = { tokenize: tokenizeContainer };
function initializeDocument(effects) {
  const self2 = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start;
  function start(code5) {
    if (continued < stack.length) {
      const item = stack[continued];
      self2.containerState = item[1];
      ok(
        item[0].continuation,
        "expected `continuation` to be defined on container construct"
      );
      return effects.attempt(
        item[0].continuation,
        documentContinue,
        checkNewContainers
      )(code5);
    }
    return checkNewContainers(code5);
  }
  function documentContinue(code5) {
    ok(
      self2.containerState,
      "expected `containerState` to be defined after continuation"
    );
    continued++;
    if (self2.containerState._closeFlow) {
      self2.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point5;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === types.chunkFlow) {
          point5 = self2.events[indexBeforeFlow][1].end;
          break;
        }
      }
      ok(point5, "could not find previous flow chunk");
      exitContainers(continued);
      let index4 = indexBeforeExits;
      while (index4 < self2.events.length) {
        self2.events[index4][1].end = { ...point5 };
        index4++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index4;
      return checkNewContainers(code5);
    }
    return start(code5);
  }
  function checkNewContainers(code5) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code5);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code5);
      }
      self2.interrupt = Boolean(
        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
      );
    }
    self2.containerState = {};
    return effects.check(
      containerConstruct,
      thereIsANewContainer,
      thereIsNoNewContainer
    )(code5);
  }
  function thereIsANewContainer(code5) {
    if (childFlow) closeFlow();
    exitContainers(continued);
    return documentContinued(code5);
  }
  function thereIsNoNewContainer(code5) {
    self2.parser.lazy[self2.now().line] = continued !== stack.length;
    lineStartOffset = self2.now().offset;
    return flowStart(code5);
  }
  function documentContinued(code5) {
    self2.containerState = {};
    return effects.attempt(
      containerConstruct,
      containerContinue,
      flowStart
    )(code5);
  }
  function containerContinue(code5) {
    ok(
      self2.currentConstruct,
      "expected `currentConstruct` to be defined on tokenizer"
    );
    ok(
      self2.containerState,
      "expected `containerState` to be defined on tokenizer"
    );
    continued++;
    stack.push([self2.currentConstruct, self2.containerState]);
    return documentContinued(code5);
  }
  function flowStart(code5) {
    if (code5 === codes.eof) {
      if (childFlow) closeFlow();
      exitContainers(0);
      effects.consume(code5);
      return;
    }
    childFlow = childFlow || self2.parser.flow(self2.now());
    effects.enter(types.chunkFlow, {
      _tokenizer: childFlow,
      contentType: constants.contentTypeFlow,
      previous: childToken
    });
    return flowContinue(code5);
  }
  function flowContinue(code5) {
    if (code5 === codes.eof) {
      writeToChild(effects.exit(types.chunkFlow), true);
      exitContainers(0);
      effects.consume(code5);
      return;
    }
    if (markdownLineEnding(code5)) {
      effects.consume(code5);
      writeToChild(effects.exit(types.chunkFlow));
      continued = 0;
      self2.interrupt = void 0;
      return start;
    }
    effects.consume(code5);
    return flowContinue;
  }
  function writeToChild(token, endOfFile) {
    ok(childFlow, "expected `childFlow` to be defined when continuing");
    const stream = self2.sliceStream(token);
    if (endOfFile) stream.push(null);
    token.previous = childToken;
    if (childToken) childToken.next = token;
    childToken = token;
    childFlow.defineSkip(token.start);
    childFlow.write(stream);
    if (self2.parser.lazy[token.start.line]) {
      let index4 = childFlow.events.length;
      while (index4--) {
        if (
          // The token starts before the line ending
          childFlow.events[index4][1].start.offset < lineStartOffset && // and either is not ended yet
          (!childFlow.events[index4][1].end || // or ends after it.
          childFlow.events[index4][1].end.offset > lineStartOffset)
        ) {
          return;
        }
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen;
      let point5;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === types.chunkFlow) {
          if (seen) {
            point5 = self2.events[indexBeforeFlow][1].end;
            break;
          }
          seen = true;
        }
      }
      ok(point5, "could not find previous flow chunk");
      exitContainers(continued);
      index4 = indexBeforeExits;
      while (index4 < self2.events.length) {
        self2.events[index4][1].end = { ...point5 };
        index4++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index4;
    }
  }
  function exitContainers(size5) {
    let index4 = stack.length;
    while (index4-- > size5) {
      const entry = stack[index4];
      self2.containerState = entry[1];
      ok(
        entry[0].exit,
        "expected `exit` to be defined on container construct"
      );
      entry[0].exit.call(self2, effects);
    }
    stack.length = size5;
  }
  function closeFlow() {
    ok(
      self2.containerState,
      "expected `containerState` to be defined when closing flow"
    );
    ok(childFlow, "expected `childFlow` to be defined when closing it");
    childFlow.write([codes.eof]);
    childToken = void 0;
    childFlow = void 0;
    self2.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok3, nok) {
  ok(
    this.parser.constructs.disable.null,
    "expected `disable.null` to be populated"
  );
  return factorySpace(
    effects,
    effects.attempt(this.parser.constructs.document, ok3, nok),
    types.linePrefix,
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
  );
}

// ../node_modules/.pnpm/micromark@4.0.2/node_modules/micromark/dev/lib/initialize/flow.js
var flow2 = { tokenize: initializeFlow };
function initializeFlow(effects) {
  const self2 = this;
  const initial = effects.attempt(
    // Try to parse a blank line.
    blankLine,
    atBlankEnding,
    // Try to parse initial flow (essentially, only code).
    effects.attempt(
      this.parser.constructs.flowInitial,
      afterConstruct,
      factorySpace(
        effects,
        effects.attempt(
          this.parser.constructs.flow,
          afterConstruct,
          effects.attempt(content3, afterConstruct)
        ),
        types.linePrefix
      )
    )
  );
  return initial;
  function atBlankEnding(code5) {
    ok(
      code5 === codes.eof || markdownLineEnding(code5),
      "expected eol or eof"
    );
    if (code5 === codes.eof) {
      effects.consume(code5);
      return;
    }
    effects.enter(types.lineEndingBlank);
    effects.consume(code5);
    effects.exit(types.lineEndingBlank);
    self2.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code5) {
    ok(
      code5 === codes.eof || markdownLineEnding(code5),
      "expected eol or eof"
    );
    if (code5 === codes.eof) {
      effects.consume(code5);
      return;
    }
    effects.enter(types.lineEnding);
    effects.consume(code5);
    effects.exit(types.lineEnding);
    self2.currentConstruct = void 0;
    return initial;
  }
}

// ../node_modules/.pnpm/micromark@4.0.2/node_modules/micromark/dev/lib/initialize/text.js
var resolver = { resolveAll: createResolver() };
var string = initializeFactory("string");
var text6 = initializeFactory("text");
function initializeFactory(field) {
  return {
    resolveAll: createResolver(
      field === "text" ? resolveAllLineSuffixes : void 0
    ),
    tokenize: initializeText
  };
  function initializeText(effects) {
    const self2 = this;
    const constructs2 = this.parser.constructs[field];
    const text10 = effects.attempt(constructs2, start, notText);
    return start;
    function start(code5) {
      return atBreak(code5) ? text10(code5) : notText(code5);
    }
    function notText(code5) {
      if (code5 === codes.eof) {
        effects.consume(code5);
        return;
      }
      effects.enter(types.data);
      effects.consume(code5);
      return data;
    }
    function data(code5) {
      if (atBreak(code5)) {
        effects.exit(types.data);
        return text10(code5);
      }
      effects.consume(code5);
      return data;
    }
    function atBreak(code5) {
      if (code5 === codes.eof) {
        return true;
      }
      const list7 = constructs2[code5];
      let index4 = -1;
      if (list7) {
        ok(Array.isArray(list7), "expected `disable.null` to be populated");
        while (++index4 < list7.length) {
          const item = list7[index4];
          if (!item.previous || item.previous.call(self2, self2.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index4 = -1;
    let enter2;
    while (++index4 <= events.length) {
      if (enter2 === void 0) {
        if (events[index4] && events[index4][1].type === types.data) {
          enter2 = index4;
          index4++;
        }
      } else if (!events[index4] || events[index4][1].type !== types.data) {
        if (index4 !== enter2 + 2) {
          events[enter2][1].end = events[index4 - 1][1].end;
          events.splice(enter2 + 2, index4 - enter2 - 2);
          index4 = enter2 + 2;
        }
        enter2 = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === types.lineEnding) && events[eventIndex - 1][1].type === types.data) {
      const data = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data);
      let index4 = chunks.length;
      let bufferIndex = -1;
      let size5 = 0;
      let tabs;
      while (index4--) {
        const chunk = chunks[index4];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === codes.space) {
            size5++;
            bufferIndex--;
          }
          if (bufferIndex) break;
          bufferIndex = -1;
        } else if (chunk === codes.horizontalTab) {
          tabs = true;
          size5++;
        } else if (chunk === codes.virtualSpace) {
        } else {
          index4++;
          break;
        }
      }
      if (context._contentTypeTextTrailing && eventIndex === events.length) {
        size5 = 0;
      }
      if (size5) {
        const token = {
          type: eventIndex === events.length || tabs || size5 < constants.hardBreakPrefixSizeMin ? types.lineSuffix : types.hardBreakTrailing,
          start: {
            _bufferIndex: index4 ? bufferIndex : data.start._bufferIndex + bufferIndex,
            _index: data.start._index + index4,
            line: data.end.line,
            column: data.end.column - size5,
            offset: data.end.offset - size5
          },
          end: { ...data.end }
        };
        data.end = { ...token.start };
        if (data.start.offset === data.end.offset) {
          Object.assign(data, token);
        } else {
          events.splice(
            eventIndex,
            0,
            ["enter", token, context],
            ["exit", token, context]
          );
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}

// ../node_modules/.pnpm/micromark@4.0.2/node_modules/micromark/dev/lib/constructs.js
var constructs_exports = {};
__export(constructs_exports, {
  attentionMarkers: () => attentionMarkers,
  contentInitial: () => contentInitial,
  disable: () => disable,
  document: () => document3,
  flow: () => flow3,
  flowInitial: () => flowInitial,
  insideSpan: () => insideSpan,
  string: () => string2,
  text: () => text7
});
var document3 = {
  [codes.asterisk]: list5,
  [codes.plusSign]: list5,
  [codes.dash]: list5,
  [codes.digit0]: list5,
  [codes.digit1]: list5,
  [codes.digit2]: list5,
  [codes.digit3]: list5,
  [codes.digit4]: list5,
  [codes.digit5]: list5,
  [codes.digit6]: list5,
  [codes.digit7]: list5,
  [codes.digit8]: list5,
  [codes.digit9]: list5,
  [codes.greaterThan]: blockQuote
};
var contentInitial = {
  [codes.leftSquareBracket]: definition2
};
var flowInitial = {
  [codes.horizontalTab]: codeIndented,
  [codes.virtualSpace]: codeIndented,
  [codes.space]: codeIndented
};
var flow3 = {
  [codes.numberSign]: headingAtx,
  [codes.asterisk]: thematicBreak2,
  [codes.dash]: [setextUnderline, thematicBreak2],
  [codes.lessThan]: htmlFlow,
  [codes.equalsTo]: setextUnderline,
  [codes.underscore]: thematicBreak2,
  [codes.graveAccent]: codeFenced,
  [codes.tilde]: codeFenced
};
var string2 = {
  [codes.ampersand]: characterReference,
  [codes.backslash]: characterEscape
};
var text7 = {
  [codes.carriageReturn]: lineEnding,
  [codes.lineFeed]: lineEnding,
  [codes.carriageReturnLineFeed]: lineEnding,
  [codes.exclamationMark]: labelStartImage,
  [codes.ampersand]: characterReference,
  [codes.asterisk]: attention,
  [codes.lessThan]: [autolink2, htmlText],
  [codes.leftSquareBracket]: labelStartLink,
  [codes.backslash]: [hardBreakEscape, characterEscape],
  [codes.rightSquareBracket]: labelEnd,
  [codes.underscore]: attention,
  [codes.graveAccent]: codeText
};
var insideSpan = { null: [attention, resolver] };
var attentionMarkers = { null: [codes.asterisk, codes.underscore] };
var disable = { null: [] };

// ../node_modules/.pnpm/micromark@4.0.2/node_modules/micromark/dev/lib/create-tokenizer.js
var import_debug = __toESM(require_browser(), 1);
var debug = (0, import_debug.default)("micromark");
function createTokenizer(parser, initialize, from3) {
  let point5 = {
    _bufferIndex: -1,
    _index: 0,
    line: from3 && from3.line || 1,
    column: from3 && from3.column || 1,
    offset: from3 && from3.offset || 0
  };
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  let consumed = true;
  const effects = {
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    consume,
    enter: enter2,
    exit: exit3,
    interrupt: constructFactory(onsuccessfulcheck, { interrupt: true })
  };
  const context = {
    code: codes.eof,
    containerState: {},
    defineSkip,
    events: [],
    now,
    parser,
    previous: codes.eof,
    sliceSerialize,
    sliceStream,
    write: write2
  };
  let state = initialize.tokenize.call(context, effects);
  let expectedCode;
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write2(slice) {
    chunks = push(chunks, slice);
    main();
    if (chunks[chunks.length - 1] !== codes.eof) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token, expandTabs) {
    return serializeChunks(sliceStream(token), expandTabs);
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token);
  }
  function now() {
    const { _bufferIndex, _index, line, column, offset: offset4 } = point5;
    return { _bufferIndex, _index, line, column, offset: offset4 };
  }
  function defineSkip(value) {
    columnStart[value.line] = value.column;
    accountForPotentialSkip();
    debug("position: define skip: `%j`", point5);
  }
  function main() {
    let chunkIndex;
    while (point5._index < chunks.length) {
      const chunk = chunks[point5._index];
      if (typeof chunk === "string") {
        chunkIndex = point5._index;
        if (point5._bufferIndex < 0) {
          point5._bufferIndex = 0;
        }
        while (point5._index === chunkIndex && point5._bufferIndex < chunk.length) {
          go3(chunk.charCodeAt(point5._bufferIndex));
        }
      } else {
        go3(chunk);
      }
    }
  }
  function go3(code5) {
    ok(consumed === true, "expected character to be consumed");
    consumed = void 0;
    debug("main: passing `%s` to %s", code5, state && state.name);
    expectedCode = code5;
    ok(typeof state === "function", "expected state");
    state = state(code5);
  }
  function consume(code5) {
    ok(code5 === expectedCode, "expected given code to equal expected code");
    debug("consume: `%s`", code5);
    ok(
      consumed === void 0,
      "expected code to not have been consumed: this might be because `return x(code)` instead of `return x` was used"
    );
    ok(
      code5 === null ? context.events.length === 0 || context.events[context.events.length - 1][0] === "exit" : context.events[context.events.length - 1][0] === "enter",
      "expected last token to be open"
    );
    if (markdownLineEnding(code5)) {
      point5.line++;
      point5.column = 1;
      point5.offset += code5 === codes.carriageReturnLineFeed ? 2 : 1;
      accountForPotentialSkip();
      debug("position: after eol: `%j`", point5);
    } else if (code5 !== codes.virtualSpace) {
      point5.column++;
      point5.offset++;
    }
    if (point5._bufferIndex < 0) {
      point5._index++;
    } else {
      point5._bufferIndex++;
      if (point5._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
      // strings.
      /** @type {string} */
      chunks[point5._index].length) {
        point5._bufferIndex = -1;
        point5._index++;
      }
    }
    context.previous = code5;
    consumed = true;
  }
  function enter2(type, fields) {
    const token = fields || {};
    token.type = type;
    token.start = now();
    ok(typeof type === "string", "expected string type");
    ok(type.length > 0, "expected non-empty string");
    debug("enter: `%s`", type);
    context.events.push(["enter", token, context]);
    stack.push(token);
    return token;
  }
  function exit3(type) {
    ok(typeof type === "string", "expected string type");
    ok(type.length > 0, "expected non-empty string");
    const token = stack.pop();
    ok(token, "cannot close w/o open tokens");
    token.end = now();
    ok(type === token.type, "expected exit token to match current token");
    ok(
      !(token.start._index === token.end._index && token.start._bufferIndex === token.end._bufferIndex),
      "expected non-empty token (`" + type + "`)"
    );
    debug("exit: `%s`", token.type);
    context.events.push(["exit", token, context]);
    return token;
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  function onsuccessfulcheck(_, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? (
        /* c8 ignore next 1 */
        handleListOfConstructs(constructs2)
      ) : "tokenize" in constructs2 ? (
        // Looks like a construct.
        handleListOfConstructs([
          /** @type {Construct} */
          constructs2
        ])
      ) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map6) {
        return start;
        function start(code5) {
          const left = code5 !== null && map6[code5];
          const all9 = code5 !== null && map6.null;
          const list7 = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(left) ? left : left ? [left] : [],
            ...Array.isArray(all9) ? all9 : all9 ? [all9] : []
          ];
          return handleListOfConstructs(list7)(code5);
        }
      }
      function handleListOfConstructs(list7) {
        listOfConstructs = list7;
        constructIndex = 0;
        if (list7.length === 0) {
          ok(bogusState, "expected `bogusState` to be given");
          return bogusState;
        }
        return handleConstruct(list7[constructIndex]);
      }
      function handleConstruct(construct) {
        return start;
        function start(code5) {
          info = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          ok(
            context.parser.constructs.disable.null,
            "expected `disable.null` to be populated"
          );
          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
            return nok(code5);
          }
          return construct.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            fields ? Object.assign(Object.create(context), fields) : context,
            effects,
            ok3,
            nok
          )(code5);
        }
      }
      function ok3(code5) {
        ok(code5 === expectedCode, "expected code");
        consumed = true;
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code5) {
        ok(code5 === expectedCode, "expected code");
        consumed = true;
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from4) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice(
        context.events,
        from4,
        context.events.length - from4,
        construct.resolve(context.events.slice(from4), context)
      );
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
    ok(
      construct.partial || context.events.length === 0 || context.events[context.events.length - 1][0] === "exit",
      "expected last token to end"
    );
  }
  function store() {
    const startPoint = now();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return { from: startEventsIndex, restore };
    function restore() {
      point5 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
      debug("position: restore: `%j`", point5);
    }
  }
  function accountForPotentialSkip() {
    if (point5.line in columnStart && point5.column < 2) {
      point5.column = columnStart[point5.line];
      point5.offset += columnStart[point5.line] - 1;
    }
  }
}
function sliceChunks(chunks, token) {
  const startIndex = token.start._index;
  const startBufferIndex = token.start._bufferIndex;
  const endIndex = token.end._index;
  const endBufferIndex = token.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    ok(endBufferIndex > -1, "expected non-negative end buffer index");
    ok(startBufferIndex > -1, "expected non-negative start buffer index");
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      const head2 = view[0];
      if (typeof head2 === "string") {
        view[0] = head2.slice(startBufferIndex);
      } else {
        ok(startBufferIndex === 0, "expected `startBufferIndex` to be `0`");
        view.shift();
      }
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index4 = -1;
  const result = [];
  let atTab;
  while (++index4 < chunks.length) {
    const chunk = chunks[index4];
    let value;
    if (typeof chunk === "string") {
      value = chunk;
    } else
      switch (chunk) {
        case codes.carriageReturn: {
          value = values.cr;
          break;
        }
        case codes.lineFeed: {
          value = values.lf;
          break;
        }
        case codes.carriageReturnLineFeed: {
          value = values.cr + values.lf;
          break;
        }
        case codes.horizontalTab: {
          value = expandTabs ? values.space : values.ht;
          break;
        }
        case codes.virtualSpace: {
          if (!expandTabs && atTab) continue;
          value = values.space;
          break;
        }
        default: {
          ok(typeof chunk === "number", "expected number");
          value = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === codes.horizontalTab;
    result.push(value);
  }
  return result.join("");
}

// ../node_modules/.pnpm/micromark@4.0.2/node_modules/micromark/dev/lib/parse.js
function parse5(options) {
  const settings = options || {};
  const constructs2 = (
    /** @type {FullNormalizedExtension} */
    combineExtensions([constructs_exports, ...settings.extensions || []])
  );
  const parser = {
    constructs: constructs2,
    content: create11(content4),
    defined: [],
    document: create11(document2),
    flow: create11(flow2),
    lazy: {},
    string: create11(string),
    text: create11(text6)
  };
  return parser;
  function create11(initial) {
    return creator;
    function creator(from3) {
      return createTokenizer(parser, initial, from3);
    }
  }
}

// ../node_modules/.pnpm/micromark@4.0.2/node_modules/micromark/dev/lib/postprocess.js
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}

// ../node_modules/.pnpm/micromark@4.0.2/node_modules/micromark/dev/lib/preprocess.js
var search2 = /[\0\t\n\r]/g;
function preprocess() {
  let column = 1;
  let buffer = "";
  let start = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value, encoding, end) {
    const chunks = [];
    let match;
    let next2;
    let startPosition;
    let endPosition;
    let code5;
    value = buffer + (typeof value === "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value));
    startPosition = 0;
    buffer = "";
    if (start) {
      if (value.charCodeAt(0) === codes.byteOrderMarker) {
        startPosition++;
      }
      start = void 0;
    }
    while (startPosition < value.length) {
      search2.lastIndex = startPosition;
      match = search2.exec(value);
      endPosition = match && match.index !== void 0 ? match.index : value.length;
      code5 = value.charCodeAt(endPosition);
      if (!match) {
        buffer = value.slice(startPosition);
        break;
      }
      if (code5 === codes.lf && startPosition === endPosition && atCarriageReturn) {
        chunks.push(codes.carriageReturnLineFeed);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(codes.carriageReturn);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        switch (code5) {
          case codes.nul: {
            chunks.push(codes.replacementCharacter);
            column++;
            break;
          }
          case codes.ht: {
            next2 = Math.ceil(column / constants.tabSize) * constants.tabSize;
            chunks.push(codes.horizontalTab);
            while (column++ < next2) chunks.push(codes.virtualSpace);
            break;
          }
          case codes.lf: {
            chunks.push(codes.lineFeed);
            column = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn) chunks.push(codes.carriageReturn);
      if (buffer) chunks.push(buffer);
      chunks.push(codes.eof);
    }
    return chunks;
  }
}

// ../node_modules/.pnpm/mdast-util-from-markdown@2.0.2/node_modules/mdast-util-from-markdown/dev/lib/index.js
var own8 = {}.hasOwnProperty;
function fromMarkdown(value, encoding, options) {
  if (typeof encoding !== "string") {
    options = encoding;
    encoding = void 0;
  }
  return compiler(options)(
    postprocess(
      parse5(options).document().write(preprocess()(value, encoding, true))
    )
  );
}
function compiler(options) {
  const config = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: opener(link3),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading4),
      blockQuote: opener(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer,
      codeFencedFenceMeta: buffer,
      codeIndented: opener(codeFlow, buffer),
      codeText: opener(codeText2, buffer),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition3),
      definitionDestinationString: buffer,
      definitionLabelString: buffer,
      definitionTitleString: buffer,
      emphasis: opener(emphasis3),
      hardBreakEscape: opener(hardBreak3),
      hardBreakTrailing: opener(hardBreak3),
      htmlFlow: opener(html7, buffer),
      htmlFlowData: onenterdata,
      htmlText: opener(html7, buffer),
      htmlTextData: onenterdata,
      image: opener(image3),
      label: buffer,
      link: opener(link3),
      listItem: opener(listItem3),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list7, onenterlistordered),
      listUnordered: opener(list7),
      paragraph: opener(paragraph3),
      reference: onenterreference,
      referenceString: buffer,
      resourceDestinationString: buffer,
      resourceTitleString: buffer,
      setextHeading: opener(heading4),
      strong: opener(strong4),
      thematicBreak: opener(thematicBreak4)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      characterReference: onexitcharacterreference,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  };
  configure2(config, (options || {}).mdastExtensions || []);
  const data = {};
  return compile2;
  function compile2(events) {
    let tree = { type: "root", children: [] };
    const context = {
      stack: [tree],
      tokenStack: [],
      config,
      enter: enter2,
      exit: exit3,
      buffer,
      resume,
      data
    };
    const listStack = [];
    let index4 = -1;
    while (++index4 < events.length) {
      if (events[index4][1].type === types.listOrdered || events[index4][1].type === types.listUnordered) {
        if (events[index4][0] === "enter") {
          listStack.push(index4);
        } else {
          const tail = listStack.pop();
          ok(typeof tail === "number", "expected list ot be open");
          index4 = prepareList(events, tail, index4);
        }
      }
    }
    index4 = -1;
    while (++index4 < events.length) {
      const handler = config[events[index4][0]];
      if (own8.call(handler, events[index4][1].type)) {
        handler[events[index4][1].type].call(
          Object.assign(
            { sliceSerialize: events[index4][2].sliceSerialize },
            context
          ),
          events[index4][1]
        );
      }
    }
    if (context.tokenStack.length > 0) {
      const tail = context.tokenStack[context.tokenStack.length - 1];
      const handler = tail[1] || defaultOnError;
      handler.call(context, void 0, tail[0]);
    }
    tree.position = {
      start: point4(
        events.length > 0 ? events[0][1].start : { line: 1, column: 1, offset: 0 }
      ),
      end: point4(
        events.length > 0 ? events[events.length - 2][1].end : { line: 1, column: 1, offset: 0 }
      )
    };
    index4 = -1;
    while (++index4 < config.transforms.length) {
      tree = config.transforms[index4](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start, length3) {
    let index4 = start - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem4;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index4 <= length3) {
      const event = events[index4];
      switch (event[1].type) {
        case types.listUnordered:
        case types.listOrdered:
        case types.blockQuote: {
          if (event[0] === "enter") {
            containerBalance++;
          } else {
            containerBalance--;
          }
          atMarker = void 0;
          break;
        }
        case types.lineEndingBlank: {
          if (event[0] === "enter") {
            if (listItem4 && !atMarker && !containerBalance && !firstBlankLineIndex) {
              firstBlankLineIndex = index4;
            }
            atMarker = void 0;
          }
          break;
        }
        case types.linePrefix:
        case types.listItemValue:
        case types.listItemMarker:
        case types.listItemPrefix:
        case types.listItemPrefixWhitespace: {
          break;
        }
        default: {
          atMarker = void 0;
        }
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === types.listItemPrefix || containerBalance === -1 && event[0] === "exit" && (event[1].type === types.listUnordered || event[1].type === types.listOrdered)) {
        if (listItem4) {
          let tailIndex = index4;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === types.lineEnding || tailEvent[1].type === types.lineEndingBlank) {
              if (tailEvent[0] === "exit") continue;
              if (lineIndex) {
                events[lineIndex][1].type = types.lineEndingBlank;
                listSpread = true;
              }
              tailEvent[1].type = types.lineEnding;
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === types.linePrefix || tailEvent[1].type === types.blockQuotePrefix || tailEvent[1].type === types.blockQuotePrefixWhitespace || tailEvent[1].type === types.blockQuoteMarker || tailEvent[1].type === types.listItemIndent) {
            } else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem4._spread = true;
          }
          listItem4.end = Object.assign(
            {},
            lineIndex ? events[lineIndex][1].start : event[1].end
          );
          events.splice(lineIndex || index4, 0, ["exit", listItem4, event[2]]);
          index4++;
          length3++;
        }
        if (event[1].type === types.listItemPrefix) {
          const item = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          listItem4 = item;
          events.splice(index4, 0, ["enter", item, event[2]]);
          index4++;
          length3++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start][1]._spread = listSpread;
    return length3;
  }
  function opener(create11, and) {
    return open;
    function open(token) {
      enter2.call(this, create11(token), token);
      if (and) and.call(this, token);
    }
  }
  function buffer() {
    this.stack.push({ type: "fragment", children: [] });
  }
  function enter2(node2, token, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    ok(parent, "expected `parent`");
    ok("children" in parent, "expected `parent`");
    const siblings2 = parent.children;
    siblings2.push(node2);
    this.stack.push(node2);
    this.tokenStack.push([token, errorHandler || void 0]);
    node2.position = {
      start: point4(token.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function closer(and) {
    return close;
    function close(token) {
      if (and) and.call(this, token);
      exit3.call(this, token);
    }
  }
  function exit3(token, onExitError) {
    const node2 = this.stack.pop();
    ok(node2, "expected `node`");
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error(
        "Cannot close `" + token.type + "` (" + stringifyPosition({ start: token.start, end: token.end }) + "): its not open"
      );
    } else if (open[0].type !== token.type) {
      if (onExitError) {
        onExitError.call(this, token, open[0]);
      } else {
        const handler = open[1] || defaultOnError;
        handler.call(this, token, open[0]);
      }
    }
    ok(node2.type !== "fragment", "unexpected fragment `exit`ed");
    ok(node2.position, "expected `position` to be defined");
    node2.position.end = point4(token.end);
  }
  function resume() {
    return toString2(this.stack.pop());
  }
  function onenterlistordered() {
    this.data.expectingFirstListItemValue = true;
  }
  function onenterlistitemvalue(token) {
    if (this.data.expectingFirstListItemValue) {
      const ancestor = this.stack[this.stack.length - 2];
      ok(ancestor, "expected nodes on stack");
      ok(ancestor.type === "list", "expected list on stack");
      ancestor.start = Number.parseInt(
        this.sliceSerialize(token),
        constants.numericBaseDecimal
      );
      this.data.expectingFirstListItemValue = void 0;
    }
  }
  function onexitcodefencedfenceinfo() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.lang = data2;
  }
  function onexitcodefencedfencemeta() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.meta = data2;
  }
  function onexitcodefencedfence() {
    if (this.data.flowCodeInside) return;
    this.buffer();
    this.data.flowCodeInside = true;
  }
  function onexitcodefenced() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    this.data.flowCodeInside = void 0;
  }
  function onexitcodeindented() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.value = data2.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.label = label;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.title = data2;
  }
  function onexitdefinitiondestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.url = data2;
  }
  function onexitatxheadingsequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "heading", "expected heading on stack");
    if (!node2.depth) {
      const depth = this.sliceSerialize(token).length;
      ok(
        depth === 1 || depth === 2 || depth === 3 || depth === 4 || depth === 5 || depth === 6,
        "expected `depth` between `1` and `6`"
      );
      node2.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    this.data.setextHeadingSlurpLineEnding = true;
  }
  function onexitsetextheadinglinesequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "heading", "expected heading on stack");
    node2.depth = this.sliceSerialize(token).codePointAt(0) === codes.equalsTo ? 1 : 2;
  }
  function onexitsetextheading() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function onenterdata(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok("children" in node2, "expected parent on stack");
    const siblings2 = node2.children;
    let tail = siblings2[siblings2.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text10();
      tail.position = {
        start: point4(token.start),
        // @ts-expect-error: well add `end` later.
        end: void 0
      };
      siblings2.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token) {
    const tail = this.stack.pop();
    ok(tail, "expected a `node` to be on the stack");
    ok("value" in tail, "expected a `literal` to be on the stack");
    ok(tail.position, "expected `node` to have an open position");
    tail.value += this.sliceSerialize(token);
    tail.position.end = point4(token.end);
  }
  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1];
    ok(context, "expected `node`");
    if (this.data.atHardBreak) {
      ok("children" in context, "expected `parent`");
      const tail = context.children[context.children.length - 1];
      ok(tail.position, "expected tail to have a starting position");
      tail.position.end = point4(token.end);
      this.data.atHardBreak = void 0;
      return;
    }
    if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }
  function onexithardbreak() {
    this.data.atHardBreak = true;
  }
  function onexithtmlflow() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "html", "expected html on stack");
    node2.value = data2;
  }
  function onexithtmltext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "html", "expected html on stack");
    node2.value = data2;
  }
  function onexitcodetext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "inlineCode", "expected inline code on stack");
    node2.value = data2;
  }
  function onexitlink() {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitimage() {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "image", "expected image on stack");
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitlabeltext(token) {
    const string3 = this.sliceSerialize(token);
    const ancestor = this.stack[this.stack.length - 2];
    ok(ancestor, "expected ancestor on stack");
    ok(
      ancestor.type === "image" || ancestor.type === "link",
      "expected image or link on stack"
    );
    ancestor.label = decodeString(string3);
    ancestor.identifier = normalizeIdentifier(string3).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    ok(fragment, "expected node on stack");
    ok(fragment.type === "fragment", "expected fragment on stack");
    const value = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    this.data.inReference = true;
    if (node2.type === "link") {
      const children = fragment.children;
      node2.children = children;
    } else {
      node2.alt = value;
    }
  }
  function onexitresourcedestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    node2.url = data2;
  }
  function onexitresourcetitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    node2.title = data2;
  }
  function onexitresource() {
    this.data.inReference = void 0;
  }
  function onenterreference() {
    this.data.referenceType = "collapsed";
  }
  function onexitreferencestring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image reference or link reference on stack"
    );
    node2.label = label;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
    this.data.referenceType = "full";
  }
  function onexitcharacterreferencemarker(token) {
    ok(
      token.type === "characterReferenceMarkerNumeric" || token.type === "characterReferenceMarkerHexadecimal"
    );
    this.data.characterReferenceType = token.type;
  }
  function onexitcharacterreferencevalue(token) {
    const data2 = this.sliceSerialize(token);
    const type = this.data.characterReferenceType;
    let value;
    if (type) {
      value = decodeNumericCharacterReference(
        data2,
        type === types.characterReferenceMarkerNumeric ? constants.numericBaseDecimal : constants.numericBaseHexadecimal
      );
      this.data.characterReferenceType = void 0;
    } else {
      const result = decodeNamedCharacterReference(data2);
      ok(result !== false, "expected reference to decode");
      value = result;
    }
    const tail = this.stack[this.stack.length - 1];
    ok(tail, "expected `node`");
    ok("value" in tail, "expected `node.value`");
    tail.value += value;
  }
  function onexitcharacterreference(token) {
    const tail = this.stack.pop();
    ok(tail, "expected `node`");
    ok(tail.position, "expected `node.position`");
    tail.position.end = point4(token.end);
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    node2.url = this.sliceSerialize(token);
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    node2.url = "mailto:" + this.sliceSerialize(token);
  }
  function blockQuote2() {
    return { type: "blockquote", children: [] };
  }
  function codeFlow() {
    return { type: "code", lang: null, meta: null, value: "" };
  }
  function codeText2() {
    return { type: "inlineCode", value: "" };
  }
  function definition3() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis3() {
    return { type: "emphasis", children: [] };
  }
  function heading4() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function hardBreak3() {
    return { type: "break" };
  }
  function html7() {
    return { type: "html", value: "" };
  }
  function image3() {
    return { type: "image", title: null, url: "", alt: null };
  }
  function link3() {
    return { type: "link", title: null, url: "", children: [] };
  }
  function list7(token) {
    return {
      type: "list",
      ordered: token.type === "listOrdered",
      start: null,
      spread: token._spread,
      children: []
    };
  }
  function listItem3(token) {
    return {
      type: "listItem",
      spread: token._spread,
      checked: null,
      children: []
    };
  }
  function paragraph3() {
    return { type: "paragraph", children: [] };
  }
  function strong4() {
    return { type: "strong", children: [] };
  }
  function text10() {
    return { type: "text", value: "" };
  }
  function thematicBreak4() {
    return { type: "thematicBreak" };
  }
}
function point4(d) {
  return { line: d.line, column: d.column, offset: d.offset };
}
function configure2(combined, extensions) {
  let index4 = -1;
  while (++index4 < extensions.length) {
    const value = extensions[index4];
    if (Array.isArray(value)) {
      configure2(combined, value);
    } else {
      extension(combined, value);
    }
  }
}
function extension(combined, extension2) {
  let key2;
  for (key2 in extension2) {
    if (own8.call(extension2, key2)) {
      switch (key2) {
        case "canContainEols": {
          const right = extension2[key2];
          if (right) {
            combined[key2].push(...right);
          }
          break;
        }
        case "transforms": {
          const right = extension2[key2];
          if (right) {
            combined[key2].push(...right);
          }
          break;
        }
        case "enter":
        case "exit": {
          const right = extension2[key2];
          if (right) {
            Object.assign(combined[key2], right);
          }
          break;
        }
      }
    }
  }
}
function defaultOnError(left, right) {
  if (left) {
    throw new Error(
      "Cannot close `" + left.type + "` (" + stringifyPosition({ start: left.start, end: left.end }) + "): a different token (`" + right.type + "`, " + stringifyPosition({ start: right.start, end: right.end }) + ") is open"
    );
  } else {
    throw new Error(
      "Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({ start: right.start, end: right.end }) + ") is still open"
    );
  }
}

// ../node_modules/.pnpm/remark-parse@11.0.0/node_modules/remark-parse/lib/index.js
function remarkParse(options) {
  const self2 = this;
  self2.parser = parser;
  function parser(doc2) {
    return fromMarkdown(doc2, {
      ...self2.data("settings"),
      ...options,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: self2.data("micromarkExtensions") || [],
      mdastExtensions: self2.data("fromMarkdownExtensions") || []
    });
  }
}

// ../node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/blockquote.js
function blockquote3(state, node2) {
  const result = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: state.wrap(state.all(node2), true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// ../node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/break.js
function hardBreak2(state, node2) {
  const result = { type: "element", tagName: "br", properties: {}, children: [] };
  state.patch(node2, result);
  return [state.applyData(node2, result), { type: "text", value: "\n" }];
}

// ../node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/code.js
function code4(state, node2) {
  const value = node2.value ? node2.value + "\n" : "";
  const properties = {};
  if (node2.lang) {
    properties.className = ["language-" + node2.lang];
  }
  let result = {
    type: "element",
    tagName: "code",
    properties,
    children: [{ type: "text", value }]
  };
  if (node2.meta) {
    result.data = { meta: node2.meta };
  }
  state.patch(node2, result);
  result = state.applyData(node2, result);
  result = { type: "element", tagName: "pre", properties: {}, children: [result] };
  state.patch(node2, result);
  return result;
}

// ../node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/delete.js
function strikethrough(state, node2) {
  const result = {
    type: "element",
    tagName: "del",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// ../node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/emphasis.js
function emphasis2(state, node2) {
  const result = {
    type: "element",
    tagName: "em",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// ../node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js
function footnoteReference2(state, node2) {
  const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
  const id2 = String(node2.identifier).toUpperCase();
  const safeId = normalizeUri(id2.toLowerCase());
  const index4 = state.footnoteOrder.indexOf(id2);
  let counter;
  let reuseCounter = state.footnoteCounts.get(id2);
  if (reuseCounter === void 0) {
    reuseCounter = 0;
    state.footnoteOrder.push(id2);
    counter = state.footnoteOrder.length;
  } else {
    counter = index4 + 1;
  }
  reuseCounter += 1;
  state.footnoteCounts.set(id2, reuseCounter);
  const link3 = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + clobberPrefix + "fn-" + safeId,
      id: clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
      dataFootnoteRef: true,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(counter) }]
  };
  state.patch(node2, link3);
  const sup = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [link3]
  };
  state.patch(node2, sup);
  return state.applyData(node2, sup);
}

// ../node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/heading.js
function heading3(state, node2) {
  const result = {
    type: "element",
    tagName: "h" + node2.depth,
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// ../node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/html.js
function html4(state, node2) {
  if (state.options.allowDangerousHtml) {
    const result = { type: "raw", value: node2.value };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  return void 0;
}

// ../node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/revert.js
function revert(state, node2) {
  const subtype = node2.referenceType;
  let suffix = "]";
  if (subtype === "collapsed") {
    suffix += "[]";
  } else if (subtype === "full") {
    suffix += "[" + (node2.label || node2.identifier) + "]";
  }
  if (node2.type === "imageReference") {
    return [{ type: "text", value: "![" + node2.alt + suffix }];
  }
  const contents = state.all(node2);
  const head2 = contents[0];
  if (head2 && head2.type === "text") {
    head2.value = "[" + head2.value;
  } else {
    contents.unshift({ type: "text", value: "[" });
  }
  const tail = contents[contents.length - 1];
  if (tail && tail.type === "text") {
    tail.value += suffix;
  } else {
    contents.push({ type: "text", value: suffix });
  }
  return contents;
}

// ../node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/image-reference.js
function imageReference2(state, node2) {
  const id2 = String(node2.identifier).toUpperCase();
  const definition3 = state.definitionById.get(id2);
  if (!definition3) {
    return revert(state, node2);
  }
  const properties = { src: normalizeUri(definition3.url || ""), alt: node2.alt };
  if (definition3.title !== null && definition3.title !== void 0) {
    properties.title = definition3.title;
  }
  const result = { type: "element", tagName: "img", properties, children: [] };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// ../node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/image.js
function image2(state, node2) {
  const properties = { src: normalizeUri(node2.url) };
  if (node2.alt !== null && node2.alt !== void 0) {
    properties.alt = node2.alt;
  }
  if (node2.title !== null && node2.title !== void 0) {
    properties.title = node2.title;
  }
  const result = { type: "element", tagName: "img", properties, children: [] };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// ../node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/inline-code.js
function inlineCode3(state, node2) {
  const text10 = { type: "text", value: node2.value.replace(/\r?\n|\r/g, " ") };
  state.patch(node2, text10);
  const result = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [text10]
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// ../node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/link-reference.js
function linkReference2(state, node2) {
  const id2 = String(node2.identifier).toUpperCase();
  const definition3 = state.definitionById.get(id2);
  if (!definition3) {
    return revert(state, node2);
  }
  const properties = { href: normalizeUri(definition3.url || "") };
  if (definition3.title !== null && definition3.title !== void 0) {
    properties.title = definition3.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties,
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// ../node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/link.js
function link2(state, node2) {
  const properties = { href: normalizeUri(node2.url) };
  if (node2.title !== null && node2.title !== void 0) {
    properties.title = node2.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties,
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// ../node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/list-item.js
function listItem2(state, node2, parent) {
  const results = state.all(node2);
  const loose = parent ? listLoose(parent) : listItemLoose(node2);
  const properties = {};
  const children = [];
  if (typeof node2.checked === "boolean") {
    const head2 = results[0];
    let paragraph3;
    if (head2 && head2.type === "element" && head2.tagName === "p") {
      paragraph3 = head2;
    } else {
      paragraph3 = { type: "element", tagName: "p", properties: {}, children: [] };
      results.unshift(paragraph3);
    }
    if (paragraph3.children.length > 0) {
      paragraph3.children.unshift({ type: "text", value: " " });
    }
    paragraph3.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: node2.checked, disabled: true },
      children: []
    });
    properties.className = ["task-list-item"];
  }
  let index4 = -1;
  while (++index4 < results.length) {
    const child = results[index4];
    if (loose || index4 !== 0 || child.type !== "element" || child.tagName !== "p") {
      children.push({ type: "text", value: "\n" });
    }
    if (child.type === "element" && child.tagName === "p" && !loose) {
      children.push(...child.children);
    } else {
      children.push(child);
    }
  }
  const tail = results[results.length - 1];
  if (tail && (loose || tail.type !== "element" || tail.tagName !== "p")) {
    children.push({ type: "text", value: "\n" });
  }
  const result = { type: "element", tagName: "li", properties, children };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function listLoose(node2) {
  let loose = false;
  if (node2.type === "list") {
    loose = node2.spread || false;
    const children = node2.children;
    let index4 = -1;
    while (!loose && ++index4 < children.length) {
      loose = listItemLoose(children[index4]);
    }
  }
  return loose;
}
function listItemLoose(node2) {
  const spread = node2.spread;
  return spread === null || spread === void 0 ? node2.children.length > 1 : spread;
}

// ../node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/list.js
function list6(state, node2) {
  const properties = {};
  const results = state.all(node2);
  let index4 = -1;
  if (typeof node2.start === "number" && node2.start !== 1) {
    properties.start = node2.start;
  }
  while (++index4 < results.length) {
    const child = results[index4];
    if (child.type === "element" && child.tagName === "li" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes("task-list-item")) {
      properties.className = ["contains-task-list"];
      break;
    }
  }
  const result = {
    type: "element",
    tagName: node2.ordered ? "ol" : "ul",
    properties,
    children: state.wrap(results, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// ../node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/paragraph.js
function paragraph2(state, node2) {
  const result = {
    type: "element",
    tagName: "p",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// ../node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/root.js
function root4(state, node2) {
  const result = { type: "root", children: state.wrap(state.all(node2)) };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// ../node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/strong.js
function strong3(state, node2) {
  const result = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// ../node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/table.js
function table2(state, node2) {
  const rows = state.all(node2);
  const firstRow = rows.shift();
  const tableContent = [];
  if (firstRow) {
    const head2 = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: state.wrap([firstRow], true)
    };
    state.patch(node2.children[0], head2);
    tableContent.push(head2);
  }
  if (rows.length > 0) {
    const body3 = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: state.wrap(rows, true)
    };
    const start = pointStart(node2.children[1]);
    const end = pointEnd(node2.children[node2.children.length - 1]);
    if (start && end) body3.position = { start, end };
    tableContent.push(body3);
  }
  const result = {
    type: "element",
    tagName: "table",
    properties: {},
    children: state.wrap(tableContent, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// ../node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/table-row.js
function tableRow2(state, node2, parent) {
  const siblings2 = parent ? parent.children : void 0;
  const rowIndex = siblings2 ? siblings2.indexOf(node2) : 1;
  const tagName = rowIndex === 0 ? "th" : "td";
  const align = parent && parent.type === "table" ? parent.align : void 0;
  const length3 = align ? align.length : node2.children.length;
  let cellIndex = -1;
  const cells2 = [];
  while (++cellIndex < length3) {
    const cell2 = node2.children[cellIndex];
    const properties = {};
    const alignValue = align ? align[cellIndex] : void 0;
    if (alignValue) {
      properties.align = alignValue;
    }
    let result2 = { type: "element", tagName, properties, children: [] };
    if (cell2) {
      result2.children = state.all(cell2);
      state.patch(cell2, result2);
      result2 = state.applyData(cell2, result2);
    }
    cells2.push(result2);
  }
  const result = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: state.wrap(cells2, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// ../node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/table-cell.js
function tableCell2(state, node2) {
  const result = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// ../node_modules/.pnpm/trim-lines@3.0.1/node_modules/trim-lines/index.js
var tab = 9;
var space = 32;
function trimLines(value) {
  const source = String(value);
  const search3 = /\r?\n|\r/g;
  let match = search3.exec(source);
  let last2 = 0;
  const lines = [];
  while (match) {
    lines.push(
      trimLine(source.slice(last2, match.index), last2 > 0, true),
      match[0]
    );
    last2 = match.index + match[0].length;
    match = search3.exec(source);
  }
  lines.push(trimLine(source.slice(last2), last2 > 0, false));
  return lines.join("");
}
function trimLine(value, start, end) {
  let startIndex = 0;
  let endIndex = value.length;
  if (start) {
    let code5 = value.codePointAt(startIndex);
    while (code5 === tab || code5 === space) {
      startIndex++;
      code5 = value.codePointAt(startIndex);
    }
  }
  if (end) {
    let code5 = value.codePointAt(endIndex - 1);
    while (code5 === tab || code5 === space) {
      endIndex--;
      code5 = value.codePointAt(endIndex - 1);
    }
  }
  return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
}

// ../node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/text.js
function text8(state, node2) {
  const result = { type: "text", value: trimLines(String(node2.value)) };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// ../node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js
function thematicBreak3(state, node2) {
  const result = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// ../node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/index.js
var handlers2 = {
  blockquote: blockquote3,
  break: hardBreak2,
  code: code4,
  delete: strikethrough,
  emphasis: emphasis2,
  footnoteReference: footnoteReference2,
  heading: heading3,
  html: html4,
  imageReference: imageReference2,
  image: image2,
  inlineCode: inlineCode3,
  linkReference: linkReference2,
  link: link2,
  listItem: listItem2,
  list: list6,
  paragraph: paragraph2,
  // @ts-expect-error: root is different, but hard to type.
  root: root4,
  strong: strong3,
  table: table2,
  tableCell: tableCell2,
  tableRow: tableRow2,
  text: text8,
  thematicBreak: thematicBreak3,
  toml: ignore2,
  yaml: ignore2,
  definition: ignore2,
  footnoteDefinition: ignore2
};
function ignore2() {
  return void 0;
}

// ../node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/footer.js
function defaultFootnoteBackContent(_, rereferenceIndex) {
  const result = [{ type: "text", value: "" }];
  if (rereferenceIndex > 1) {
    result.push({
      type: "element",
      tagName: "sup",
      properties: {},
      children: [{ type: "text", value: String(rereferenceIndex) }]
    });
  }
  return result;
}
function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {
  return "Back to reference " + (referenceIndex + 1) + (rereferenceIndex > 1 ? "-" + rereferenceIndex : "");
}
function footer(state) {
  const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
  const footnoteBackContent = state.options.footnoteBackContent || defaultFootnoteBackContent;
  const footnoteBackLabel = state.options.footnoteBackLabel || defaultFootnoteBackLabel;
  const footnoteLabel = state.options.footnoteLabel || "Footnotes";
  const footnoteLabelTagName = state.options.footnoteLabelTagName || "h2";
  const footnoteLabelProperties = state.options.footnoteLabelProperties || {
    className: ["sr-only"]
  };
  const listItems = [];
  let referenceIndex = -1;
  while (++referenceIndex < state.footnoteOrder.length) {
    const definition3 = state.footnoteById.get(
      state.footnoteOrder[referenceIndex]
    );
    if (!definition3) {
      continue;
    }
    const content5 = state.all(definition3);
    const id2 = String(definition3.identifier).toUpperCase();
    const safeId = normalizeUri(id2.toLowerCase());
    let rereferenceIndex = 0;
    const backReferences = [];
    const counts = state.footnoteCounts.get(id2);
    while (counts !== void 0 && ++rereferenceIndex <= counts) {
      if (backReferences.length > 0) {
        backReferences.push({ type: "text", value: " " });
      }
      let children = typeof footnoteBackContent === "string" ? footnoteBackContent : footnoteBackContent(referenceIndex, rereferenceIndex);
      if (typeof children === "string") {
        children = { type: "text", value: children };
      }
      backReferences.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + clobberPrefix + "fnref-" + safeId + (rereferenceIndex > 1 ? "-" + rereferenceIndex : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof footnoteBackLabel === "string" ? footnoteBackLabel : footnoteBackLabel(referenceIndex, rereferenceIndex),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(children) ? children : [children]
      });
    }
    const tail = content5[content5.length - 1];
    if (tail && tail.type === "element" && tail.tagName === "p") {
      const tailTail = tail.children[tail.children.length - 1];
      if (tailTail && tailTail.type === "text") {
        tailTail.value += " ";
      } else {
        tail.children.push({ type: "text", value: " " });
      }
      tail.children.push(...backReferences);
    } else {
      content5.push(...backReferences);
    }
    const listItem3 = {
      type: "element",
      tagName: "li",
      properties: { id: clobberPrefix + "fn-" + safeId },
      children: state.wrap(content5, true)
    };
    state.patch(definition3, listItem3);
    listItems.push(listItem3);
  }
  if (listItems.length === 0) {
    return;
  }
  return {
    type: "element",
    tagName: "section",
    properties: { dataFootnotes: true, className: ["footnotes"] },
    children: [
      {
        type: "element",
        tagName: footnoteLabelTagName,
        properties: {
          ...esm_default(footnoteLabelProperties),
          id: "footnote-label"
        },
        children: [{ type: "text", value: footnoteLabel }]
      },
      { type: "text", value: "\n" },
      {
        type: "element",
        tagName: "ol",
        properties: {},
        children: state.wrap(listItems, true)
      },
      { type: "text", value: "\n" }
    ]
  };
}

// ../node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/state.js
var own9 = {}.hasOwnProperty;
var emptyOptions6 = {};
function createState2(tree, options) {
  const settings = options || emptyOptions6;
  const definitionById = /* @__PURE__ */ new Map();
  const footnoteById = /* @__PURE__ */ new Map();
  const footnoteCounts = /* @__PURE__ */ new Map();
  const handlers3 = { ...handlers2, ...settings.handlers };
  const state = {
    all: all9,
    applyData,
    definitionById,
    footnoteById,
    footnoteCounts,
    footnoteOrder: [],
    handlers: handlers3,
    one: one6,
    options: settings,
    patch: patch3,
    wrap: wrap3
  };
  visit(tree, function(node2) {
    if (node2.type === "definition" || node2.type === "footnoteDefinition") {
      const map6 = node2.type === "definition" ? definitionById : footnoteById;
      const id2 = String(node2.identifier).toUpperCase();
      if (!map6.has(id2)) {
        map6.set(id2, node2);
      }
    }
  });
  return state;
  function one6(node2, parent) {
    const type = node2.type;
    const handle4 = state.handlers[type];
    if (own9.call(state.handlers, type) && handle4) {
      return handle4(state, node2, parent);
    }
    if (state.options.passThrough && state.options.passThrough.includes(type)) {
      if ("children" in node2) {
        const { children, ...shallow } = node2;
        const result = esm_default(shallow);
        result.children = state.all(node2);
        return result;
      }
      return esm_default(node2);
    }
    const unknown3 = state.options.unknownHandler || defaultUnknownHandler;
    return unknown3(state, node2, parent);
  }
  function all9(parent) {
    const values2 = [];
    if ("children" in parent) {
      const nodes = parent.children;
      let index4 = -1;
      while (++index4 < nodes.length) {
        const result = state.one(nodes[index4], parent);
        if (result) {
          if (index4 && nodes[index4 - 1].type === "break") {
            if (!Array.isArray(result) && result.type === "text") {
              result.value = trimMarkdownSpaceStart(result.value);
            }
            if (!Array.isArray(result) && result.type === "element") {
              const head2 = result.children[0];
              if (head2 && head2.type === "text") {
                head2.value = trimMarkdownSpaceStart(head2.value);
              }
            }
          }
          if (Array.isArray(result)) {
            values2.push(...result);
          } else {
            values2.push(result);
          }
        }
      }
    }
    return values2;
  }
}
function patch3(from3, to3) {
  if (from3.position) to3.position = position3(from3);
}
function applyData(from3, to3) {
  let result = to3;
  if (from3 && from3.data) {
    const hName = from3.data.hName;
    const hChildren = from3.data.hChildren;
    const hProperties = from3.data.hProperties;
    if (typeof hName === "string") {
      if (result.type === "element") {
        result.tagName = hName;
      } else {
        const children = "children" in result ? result.children : [result];
        result = { type: "element", tagName: hName, properties: {}, children };
      }
    }
    if (result.type === "element" && hProperties) {
      Object.assign(result.properties, esm_default(hProperties));
    }
    if ("children" in result && result.children && hChildren !== null && hChildren !== void 0) {
      result.children = hChildren;
    }
  }
  return result;
}
function defaultUnknownHandler(state, node2) {
  const data = node2.data || {};
  const result = "value" in node2 && !(own9.call(data, "hProperties") || own9.call(data, "hChildren")) ? { type: "text", value: node2.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function wrap3(nodes, loose) {
  const result = [];
  let index4 = -1;
  if (loose) {
    result.push({ type: "text", value: "\n" });
  }
  while (++index4 < nodes.length) {
    if (index4) result.push({ type: "text", value: "\n" });
    result.push(nodes[index4]);
  }
  if (loose && nodes.length > 0) {
    result.push({ type: "text", value: "\n" });
  }
  return result;
}
function trimMarkdownSpaceStart(value) {
  let index4 = 0;
  let code5 = value.charCodeAt(index4);
  while (code5 === 9 || code5 === 32) {
    index4++;
    code5 = value.charCodeAt(index4);
  }
  return value.slice(index4);
}

// ../node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/index.js
function toHast(tree, options) {
  const state = createState2(tree, options);
  const node2 = state.one(tree, void 0);
  const foot = footer(state);
  const result = Array.isArray(node2) ? { type: "root", children: node2 } : node2 || { type: "root", children: [] };
  if (foot) {
    ok("children" in result);
    result.children.push({ type: "text", value: "\n" }, foot);
  }
  return result;
}

// ../node_modules/.pnpm/remark-rehype@11.1.2/node_modules/remark-rehype/lib/index.js
function remarkRehype(destination, options) {
  if (destination && "run" in destination) {
    return async function(tree, file) {
      const hastTree = (
        /** @type {HastRoot} */
        toHast(tree, { file, ...options })
      );
      await destination.run(hastTree, file);
    };
  }
  return function(tree, file) {
    return (
      /** @type {HastRoot} */
      toHast(tree, { file, ...destination || options })
    );
  };
}

// ../node_modules/.pnpm/html-void-elements@3.0.0/node_modules/html-void-elements/index.js
var htmlVoidElements = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];

// ../node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/core.js
var defaultSubsetRegex = /["&'<>`]/g;
var surrogatePairsRegex = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
var controlCharactersRegex = (
  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
  /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g
);
var regexEscapeRegex = /[|\\{}()[\]^$+*?.]/g;
var subsetToRegexCache = /* @__PURE__ */ new WeakMap();
function core(value, options) {
  value = value.replace(
    options.subset ? charactersToExpressionCached(options.subset) : defaultSubsetRegex,
    basic2
  );
  if (options.subset || options.escapeOnly) {
    return value;
  }
  return value.replace(surrogatePairsRegex, surrogate).replace(controlCharactersRegex, basic2);
  function surrogate(pair, index4, all9) {
    return options.format(
      (pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536,
      all9.charCodeAt(index4 + 2),
      options
    );
  }
  function basic2(character, index4, all9) {
    return options.format(
      character.charCodeAt(0),
      all9.charCodeAt(index4 + 1),
      options
    );
  }
}
function charactersToExpressionCached(subset) {
  let cached = subsetToRegexCache.get(subset);
  if (!cached) {
    cached = charactersToExpression(subset);
    subsetToRegexCache.set(subset, cached);
  }
  return cached;
}
function charactersToExpression(subset) {
  const groups = [];
  let index4 = -1;
  while (++index4 < subset.length) {
    groups.push(subset[index4].replace(regexEscapeRegex, "\\$&"));
  }
  return new RegExp("(?:" + groups.join("|") + ")", "g");
}

// ../node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/util/to-hexadecimal.js
var hexadecimalRegex = /[\dA-Fa-f]/;
function toHexadecimal(code5, next2, omit) {
  const value = "&#x" + code5.toString(16).toUpperCase();
  return omit && next2 && !hexadecimalRegex.test(String.fromCharCode(next2)) ? value : value + ";";
}

// ../node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/util/to-decimal.js
var decimalRegex = /\d/;
function toDecimal(code5, next2, omit) {
  const value = "&#" + String(code5);
  return omit && next2 && !decimalRegex.test(String.fromCharCode(next2)) ? value : value + ";";
}

// ../node_modules/.pnpm/character-entities-legacy@3.0.0/node_modules/character-entities-legacy/index.js
var characterEntitiesLegacy = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
];

// ../node_modules/.pnpm/character-entities-html4@2.1.0/node_modules/character-entities-html4/index.js
var characterEntitiesHtml4 = {
  nbsp: "",
  iexcl: "",
  cent: "",
  pound: "",
  curren: "",
  yen: "",
  brvbar: "",
  sect: "",
  uml: "",
  copy: "",
  ordf: "",
  laquo: "",
  not: "",
  shy: "",
  reg: "",
  macr: "",
  deg: "",
  plusmn: "",
  sup2: "",
  sup3: "",
  acute: "",
  micro: "",
  para: "",
  middot: "",
  cedil: "",
  sup1: "",
  ordm: "",
  raquo: "",
  frac14: "",
  frac12: "",
  frac34: "",
  iquest: "",
  Agrave: "",
  Aacute: "",
  Acirc: "",
  Atilde: "",
  Auml: "",
  Aring: "",
  AElig: "",
  Ccedil: "",
  Egrave: "",
  Eacute: "",
  Ecirc: "",
  Euml: "",
  Igrave: "",
  Iacute: "",
  Icirc: "",
  Iuml: "",
  ETH: "",
  Ntilde: "",
  Ograve: "",
  Oacute: "",
  Ocirc: "",
  Otilde: "",
  Ouml: "",
  times: "",
  Oslash: "",
  Ugrave: "",
  Uacute: "",
  Ucirc: "",
  Uuml: "",
  Yacute: "",
  THORN: "",
  szlig: "",
  agrave: "",
  aacute: "",
  acirc: "",
  atilde: "",
  auml: "",
  aring: "",
  aelig: "",
  ccedil: "",
  egrave: "",
  eacute: "",
  ecirc: "",
  euml: "",
  igrave: "",
  iacute: "",
  icirc: "",
  iuml: "",
  eth: "",
  ntilde: "",
  ograve: "",
  oacute: "",
  ocirc: "",
  otilde: "",
  ouml: "",
  divide: "",
  oslash: "",
  ugrave: "",
  uacute: "",
  ucirc: "",
  uuml: "",
  yacute: "",
  thorn: "",
  yuml: "",
  fnof: "",
  Alpha: "",
  Beta: "",
  Gamma: "",
  Delta: "",
  Epsilon: "",
  Zeta: "",
  Eta: "",
  Theta: "",
  Iota: "",
  Kappa: "",
  Lambda: "",
  Mu: "",
  Nu: "",
  Xi: "",
  Omicron: "",
  Pi: "",
  Rho: "",
  Sigma: "",
  Tau: "",
  Upsilon: "",
  Phi: "",
  Chi: "",
  Psi: "",
  Omega: "",
  alpha: "",
  beta: "",
  gamma: "",
  delta: "",
  epsilon: "",
  zeta: "",
  eta: "",
  theta: "",
  iota: "",
  kappa: "",
  lambda: "",
  mu: "",
  nu: "",
  xi: "",
  omicron: "",
  pi: "",
  rho: "",
  sigmaf: "",
  sigma: "",
  tau: "",
  upsilon: "",
  phi: "",
  chi: "",
  psi: "",
  omega: "",
  thetasym: "",
  upsih: "",
  piv: "",
  bull: "",
  hellip: "",
  prime: "",
  Prime: "",
  oline: "",
  frasl: "",
  weierp: "",
  image: "",
  real: "",
  trade: "",
  alefsym: "",
  larr: "",
  uarr: "",
  rarr: "",
  darr: "",
  harr: "",
  crarr: "",
  lArr: "",
  uArr: "",
  rArr: "",
  dArr: "",
  hArr: "",
  forall: "",
  part: "",
  exist: "",
  empty: "",
  nabla: "",
  isin: "",
  notin: "",
  ni: "",
  prod: "",
  sum: "",
  minus: "",
  lowast: "",
  radic: "",
  prop: "",
  infin: "",
  ang: "",
  and: "",
  or: "",
  cap: "",
  cup: "",
  int: "",
  there4: "",
  sim: "",
  cong: "",
  asymp: "",
  ne: "",
  equiv: "",
  le: "",
  ge: "",
  sub: "",
  sup: "",
  nsub: "",
  sube: "",
  supe: "",
  oplus: "",
  otimes: "",
  perp: "",
  sdot: "",
  lceil: "",
  rceil: "",
  lfloor: "",
  rfloor: "",
  lang: "",
  rang: "",
  loz: "",
  spades: "",
  clubs: "",
  hearts: "",
  diams: "",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "",
  oelig: "",
  Scaron: "",
  scaron: "",
  Yuml: "",
  circ: "",
  tilde: "",
  ensp: "",
  emsp: "",
  thinsp: "",
  zwnj: "",
  zwj: "",
  lrm: "",
  rlm: "",
  ndash: "",
  mdash: "",
  lsquo: "",
  rsquo: "",
  sbquo: "",
  ldquo: "",
  rdquo: "",
  bdquo: "",
  dagger: "",
  Dagger: "",
  permil: "",
  lsaquo: "",
  rsaquo: "",
  euro: ""
};

// ../node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/constant/dangerous.js
var dangerous = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
];

// ../node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/util/to-named.js
var own10 = {}.hasOwnProperty;
var characters = {};
var key;
for (key in characterEntitiesHtml4) {
  if (own10.call(characterEntitiesHtml4, key)) {
    characters[characterEntitiesHtml4[key]] = key;
  }
}
var notAlphanumericRegex = /[^\dA-Za-z]/;
function toNamed(code5, next2, omit, attribute) {
  const character = String.fromCharCode(code5);
  if (own10.call(characters, character)) {
    const name = characters[character];
    const value = "&" + name;
    if (omit && characterEntitiesLegacy.includes(name) && !dangerous.includes(name) && (!attribute || next2 && next2 !== 61 && notAlphanumericRegex.test(String.fromCharCode(next2)))) {
      return value;
    }
    return value + ";";
  }
  return "";
}

// ../node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/util/format-smart.js
function formatSmart(code5, next2, options) {
  let numeric = toHexadecimal(code5, next2, options.omitOptionalSemicolons);
  let named;
  if (options.useNamedReferences || options.useShortestReferences) {
    named = toNamed(
      code5,
      next2,
      options.omitOptionalSemicolons,
      options.attribute
    );
  }
  if ((options.useShortestReferences || !named) && options.useShortestReferences) {
    const decimal = toDecimal(code5, next2, options.omitOptionalSemicolons);
    if (decimal.length < numeric.length) {
      numeric = decimal;
    }
  }
  return named && (!options.useShortestReferences || named.length < numeric.length) ? named : numeric;
}

// ../node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/index.js
function stringifyEntities(value, options) {
  return core(value, Object.assign({ format: formatSmart }, options));
}

// ../node_modules/.pnpm/hast-util-to-html@9.0.5/node_modules/hast-util-to-html/lib/handle/comment.js
var htmlCommentRegex = /^>|^->|<!--|-->|--!>|<!-$/g;
var bogusCommentEntitySubset = [">"];
var commentEntitySubset = ["<", ">"];
function comment3(node2, _1, _2, state) {
  return state.settings.bogusComments ? "<?" + stringifyEntities(
    node2.value,
    Object.assign({}, state.settings.characterReferences, {
      subset: bogusCommentEntitySubset
    })
  ) + ">" : "<!--" + node2.value.replace(htmlCommentRegex, encode3) + "-->";
  function encode3($0) {
    return stringifyEntities(
      $0,
      Object.assign({}, state.settings.characterReferences, {
        subset: commentEntitySubset
      })
    );
  }
}

// ../node_modules/.pnpm/hast-util-to-html@9.0.5/node_modules/hast-util-to-html/lib/handle/doctype.js
function doctype2(_1, _2, _3, state) {
  return "<!" + (state.settings.upperDoctype ? "DOCTYPE" : "doctype") + (state.settings.tightDoctype ? "" : " ") + "html>";
}

// ../node_modules/.pnpm/hast-util-to-html@9.0.5/node_modules/hast-util-to-html/lib/omission/util/siblings.js
var siblingAfter = siblings(1);
var siblingBefore = siblings(-1);
var emptyChildren = [];
function siblings(increment2) {
  return sibling;
  function sibling(parent, index4, includeWhitespace) {
    const siblings2 = parent ? parent.children : emptyChildren;
    let offset4 = (index4 || 0) + increment2;
    let next2 = siblings2[offset4];
    if (!includeWhitespace) {
      while (next2 && whitespace(next2)) {
        offset4 += increment2;
        next2 = siblings2[offset4];
      }
    }
    return next2;
  }
}

// ../node_modules/.pnpm/hast-util-to-html@9.0.5/node_modules/hast-util-to-html/lib/omission/omission.js
var own11 = {}.hasOwnProperty;
function omission(handlers3) {
  return omit;
  function omit(node2, index4, parent) {
    return own11.call(handlers3, node2.tagName) && handlers3[node2.tagName](node2, index4, parent);
  }
}

// ../node_modules/.pnpm/hast-util-to-html@9.0.5/node_modules/hast-util-to-html/lib/omission/closing.js
var closing = omission({
  body,
  caption: headOrColgroupOrCaption,
  colgroup: headOrColgroupOrCaption,
  dd,
  dt: dt2,
  head: headOrColgroupOrCaption,
  html: html5,
  li: li2,
  optgroup,
  option,
  p: p3,
  rp: rubyElement,
  rt: rubyElement,
  tbody,
  td: cells,
  tfoot,
  th: cells,
  thead,
  tr: tr2
});
function headOrColgroupOrCaption(_, index4, parent) {
  const next2 = siblingAfter(parent, index4, true);
  return !next2 || next2.type !== "comment" && !(next2.type === "text" && whitespace(next2.value.charAt(0)));
}
function html5(_, index4, parent) {
  const next2 = siblingAfter(parent, index4);
  return !next2 || next2.type !== "comment";
}
function body(_, index4, parent) {
  const next2 = siblingAfter(parent, index4);
  return !next2 || next2.type !== "comment";
}
function p3(_, index4, parent) {
  const next2 = siblingAfter(parent, index4);
  return next2 ? next2.type === "element" && (next2.tagName === "address" || next2.tagName === "article" || next2.tagName === "aside" || next2.tagName === "blockquote" || next2.tagName === "details" || next2.tagName === "div" || next2.tagName === "dl" || next2.tagName === "fieldset" || next2.tagName === "figcaption" || next2.tagName === "figure" || next2.tagName === "footer" || next2.tagName === "form" || next2.tagName === "h1" || next2.tagName === "h2" || next2.tagName === "h3" || next2.tagName === "h4" || next2.tagName === "h5" || next2.tagName === "h6" || next2.tagName === "header" || next2.tagName === "hgroup" || next2.tagName === "hr" || next2.tagName === "main" || next2.tagName === "menu" || next2.tagName === "nav" || next2.tagName === "ol" || next2.tagName === "p" || next2.tagName === "pre" || next2.tagName === "section" || next2.tagName === "table" || next2.tagName === "ul") : !parent || // Confusing parent.
  !(parent.type === "element" && (parent.tagName === "a" || parent.tagName === "audio" || parent.tagName === "del" || parent.tagName === "ins" || parent.tagName === "map" || parent.tagName === "noscript" || parent.tagName === "video"));
}
function li2(_, index4, parent) {
  const next2 = siblingAfter(parent, index4);
  return !next2 || next2.type === "element" && next2.tagName === "li";
}
function dt2(_, index4, parent) {
  const next2 = siblingAfter(parent, index4);
  return Boolean(
    next2 && next2.type === "element" && (next2.tagName === "dt" || next2.tagName === "dd")
  );
}
function dd(_, index4, parent) {
  const next2 = siblingAfter(parent, index4);
  return !next2 || next2.type === "element" && (next2.tagName === "dt" || next2.tagName === "dd");
}
function rubyElement(_, index4, parent) {
  const next2 = siblingAfter(parent, index4);
  return !next2 || next2.type === "element" && (next2.tagName === "rp" || next2.tagName === "rt");
}
function optgroup(_, index4, parent) {
  const next2 = siblingAfter(parent, index4);
  return !next2 || next2.type === "element" && next2.tagName === "optgroup";
}
function option(_, index4, parent) {
  const next2 = siblingAfter(parent, index4);
  return !next2 || next2.type === "element" && (next2.tagName === "option" || next2.tagName === "optgroup");
}
function thead(_, index4, parent) {
  const next2 = siblingAfter(parent, index4);
  return Boolean(
    next2 && next2.type === "element" && (next2.tagName === "tbody" || next2.tagName === "tfoot")
  );
}
function tbody(_, index4, parent) {
  const next2 = siblingAfter(parent, index4);
  return !next2 || next2.type === "element" && (next2.tagName === "tbody" || next2.tagName === "tfoot");
}
function tfoot(_, index4, parent) {
  return !siblingAfter(parent, index4);
}
function tr2(_, index4, parent) {
  const next2 = siblingAfter(parent, index4);
  return !next2 || next2.type === "element" && next2.tagName === "tr";
}
function cells(_, index4, parent) {
  const next2 = siblingAfter(parent, index4);
  return !next2 || next2.type === "element" && (next2.tagName === "td" || next2.tagName === "th");
}

// ../node_modules/.pnpm/hast-util-to-html@9.0.5/node_modules/hast-util-to-html/lib/omission/opening.js
var opening = omission({
  body: body2,
  colgroup,
  head,
  html: html6,
  tbody: tbody2
});
function html6(node2) {
  const head2 = siblingAfter(node2, -1);
  return !head2 || head2.type !== "comment";
}
function head(node2) {
  const seen = /* @__PURE__ */ new Set();
  for (const child2 of node2.children) {
    if (child2.type === "element" && (child2.tagName === "base" || child2.tagName === "title")) {
      if (seen.has(child2.tagName)) return false;
      seen.add(child2.tagName);
    }
  }
  const child = node2.children[0];
  return !child || child.type === "element";
}
function body2(node2) {
  const head2 = siblingAfter(node2, -1, true);
  return !head2 || head2.type !== "comment" && !(head2.type === "text" && whitespace(head2.value.charAt(0))) && !(head2.type === "element" && (head2.tagName === "meta" || head2.tagName === "link" || head2.tagName === "script" || head2.tagName === "style" || head2.tagName === "template"));
}
function colgroup(node2, index4, parent) {
  const previous3 = siblingBefore(parent, index4);
  const head2 = siblingAfter(node2, -1, true);
  if (parent && previous3 && previous3.type === "element" && previous3.tagName === "colgroup" && closing(previous3, parent.children.indexOf(previous3), parent)) {
    return false;
  }
  return Boolean(head2 && head2.type === "element" && head2.tagName === "col");
}
function tbody2(node2, index4, parent) {
  const previous3 = siblingBefore(parent, index4);
  const head2 = siblingAfter(node2, -1);
  if (parent && previous3 && previous3.type === "element" && (previous3.tagName === "thead" || previous3.tagName === "tbody") && closing(previous3, parent.children.indexOf(previous3), parent)) {
    return false;
  }
  return Boolean(head2 && head2.type === "element" && head2.tagName === "tr");
}

// ../node_modules/.pnpm/hast-util-to-html@9.0.5/node_modules/hast-util-to-html/lib/handle/element.js
var constants2 = {
  // See: <https://html.spec.whatwg.org/#attribute-name-state>.
  name: [
    ["	\n\f\r &/=>".split(""), "	\n\f\r \"&'/=>`".split("")],
    [`\0	
\f\r "&'/<=>`.split(""), "\0	\n\f\r \"&'/<=>`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
  unquoted: [
    ["	\n\f\r &>".split(""), "\0	\n\f\r \"&'<=>`".split("")],
    ["\0	\n\f\r \"&'<=>`".split(""), "\0	\n\f\r \"&'<=>`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
  single: [
    ["&'".split(""), "\"&'`".split("")],
    ["\0&'".split(""), "\0\"&'`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
  double: [
    ['"&'.split(""), "\"&'`".split("")],
    ['\0"&'.split(""), "\0\"&'`".split("")]
  ]
};
function element6(node2, index4, parent, state) {
  const schema = state.schema;
  const omit = schema.space === "svg" ? false : state.settings.omitOptionalTags;
  let selfClosing = schema.space === "svg" ? state.settings.closeEmptyElements : state.settings.voids.includes(node2.tagName.toLowerCase());
  const parts = [];
  let last2;
  if (schema.space === "html" && node2.tagName === "svg") {
    state.schema = svg2;
  }
  const attributes = serializeAttributes2(state, node2.properties);
  const content5 = state.all(
    schema.space === "html" && node2.tagName === "template" ? node2.content : node2
  );
  state.schema = schema;
  if (content5) selfClosing = false;
  if (attributes || !omit || !opening(node2, index4, parent)) {
    parts.push("<", node2.tagName, attributes ? " " + attributes : "");
    if (selfClosing && (schema.space === "svg" || state.settings.closeSelfClosing)) {
      last2 = attributes.charAt(attributes.length - 1);
      if (!state.settings.tightSelfClosing || last2 === "/" || last2 && last2 !== '"' && last2 !== "'") {
        parts.push(" ");
      }
      parts.push("/");
    }
    parts.push(">");
  }
  parts.push(content5);
  if (!selfClosing && (!omit || !closing(node2, index4, parent))) {
    parts.push("</" + node2.tagName + ">");
  }
  return parts.join("");
}
function serializeAttributes2(state, properties) {
  const values2 = [];
  let index4 = -1;
  let key2;
  if (properties) {
    for (key2 in properties) {
      if (properties[key2] !== null && properties[key2] !== void 0) {
        const value = serializeAttribute(state, key2, properties[key2]);
        if (value) values2.push(value);
      }
    }
  }
  while (++index4 < values2.length) {
    const last2 = state.settings.tightAttributes ? values2[index4].charAt(values2[index4].length - 1) : void 0;
    if (index4 !== values2.length - 1 && last2 !== '"' && last2 !== "'") {
      values2[index4] += " ";
    }
  }
  return values2.join("");
}
function serializeAttribute(state, key2, value) {
  const info = find3(state.schema, key2);
  const x4 = state.settings.allowParseErrors && state.schema.space === "html" ? 0 : 1;
  const y2 = state.settings.allowDangerousCharacters ? 0 : 1;
  let quote = state.quote;
  let result;
  if (info.overloadedBoolean && (value === info.attribute || value === "")) {
    value = true;
  } else if ((info.boolean || info.overloadedBoolean) && (typeof value !== "string" || value === info.attribute || value === "")) {
    value = Boolean(value);
  }
  if (value === null || value === void 0 || value === false || typeof value === "number" && Number.isNaN(value)) {
    return "";
  }
  const name = stringifyEntities(
    info.attribute,
    Object.assign({}, state.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: constants2.name[x4][y2]
    })
  );
  if (value === true) return name;
  value = Array.isArray(value) ? (info.commaSeparated ? stringify3 : stringify4)(value, {
    padLeft: !state.settings.tightCommaSeparatedLists
  }) : String(value);
  if (state.settings.collapseEmptyAttributes && !value) return name;
  if (state.settings.preferUnquoted) {
    result = stringifyEntities(
      value,
      Object.assign({}, state.settings.characterReferences, {
        attribute: true,
        subset: constants2.unquoted[x4][y2]
      })
    );
  }
  if (result !== value) {
    if (state.settings.quoteSmart && ccount(value, quote) > ccount(value, state.alternative)) {
      quote = state.alternative;
    }
    result = quote + stringifyEntities(
      value,
      Object.assign({}, state.settings.characterReferences, {
        // Always encode without parse errors in non-HTML.
        subset: (quote === "'" ? constants2.single : constants2.double)[x4][y2],
        attribute: true
      })
    ) + quote;
  }
  return name + (result ? "=" + result : result);
}

// ../node_modules/.pnpm/hast-util-to-html@9.0.5/node_modules/hast-util-to-html/lib/handle/text.js
var textEntitySubset = ["<", "&"];
function text9(node2, _, parent, state) {
  return parent && parent.type === "element" && (parent.tagName === "script" || parent.tagName === "style") ? node2.value : stringifyEntities(
    node2.value,
    Object.assign({}, state.settings.characterReferences, {
      subset: textEntitySubset
    })
  );
}

// ../node_modules/.pnpm/hast-util-to-html@9.0.5/node_modules/hast-util-to-html/lib/handle/raw.js
function raw(node2, index4, parent, state) {
  return state.settings.allowDangerousHtml ? node2.value : text9(node2, index4, parent, state);
}

// ../node_modules/.pnpm/hast-util-to-html@9.0.5/node_modules/hast-util-to-html/lib/handle/root.js
function root5(node2, _1, _2, state) {
  return state.all(node2);
}

// ../node_modules/.pnpm/hast-util-to-html@9.0.5/node_modules/hast-util-to-html/lib/handle/index.js
var handle3 = zwitch("type", {
  invalid: invalid2,
  unknown: unknown2,
  handlers: { comment: comment3, doctype: doctype2, element: element6, raw, root: root5, text: text9 }
});
function invalid2(node2) {
  throw new Error("Expected node, not `" + node2 + "`");
}
function unknown2(node_) {
  const node2 = (
    /** @type {Nodes} */
    node_
  );
  throw new Error("Cannot compile unknown node `" + node2.type + "`");
}

// ../node_modules/.pnpm/hast-util-to-html@9.0.5/node_modules/hast-util-to-html/lib/index.js
var emptyOptions7 = {};
var emptyCharacterReferences = {};
var emptyChildren2 = [];
function toHtml(tree, options) {
  const options_ = options || emptyOptions7;
  const quote = options_.quote || '"';
  const alternative = quote === '"' ? "'" : '"';
  if (quote !== '"' && quote !== "'") {
    throw new Error("Invalid quote `" + quote + "`, expected `'` or `\"`");
  }
  const state = {
    one: one5,
    all: all8,
    settings: {
      omitOptionalTags: options_.omitOptionalTags || false,
      allowParseErrors: options_.allowParseErrors || false,
      allowDangerousCharacters: options_.allowDangerousCharacters || false,
      quoteSmart: options_.quoteSmart || false,
      preferUnquoted: options_.preferUnquoted || false,
      tightAttributes: options_.tightAttributes || false,
      upperDoctype: options_.upperDoctype || false,
      tightDoctype: options_.tightDoctype || false,
      bogusComments: options_.bogusComments || false,
      tightCommaSeparatedLists: options_.tightCommaSeparatedLists || false,
      tightSelfClosing: options_.tightSelfClosing || false,
      collapseEmptyAttributes: options_.collapseEmptyAttributes || false,
      allowDangerousHtml: options_.allowDangerousHtml || false,
      voids: options_.voids || htmlVoidElements,
      characterReferences: options_.characterReferences || emptyCharacterReferences,
      closeSelfClosing: options_.closeSelfClosing || false,
      closeEmptyElements: options_.closeEmptyElements || false
    },
    schema: options_.space === "svg" ? svg2 : html2,
    quote,
    alternative
  };
  return state.one(
    Array.isArray(tree) ? { type: "root", children: tree } : tree,
    void 0,
    void 0
  );
}
function one5(node2, index4, parent) {
  return handle3(node2, index4, parent, this);
}
function all8(parent) {
  const results = [];
  const children = parent && parent.children || emptyChildren2;
  let index4 = -1;
  while (++index4 < children.length) {
    results[index4] = this.one(children[index4], index4, parent);
  }
  return results.join("");
}

// ../node_modules/.pnpm/rehype-stringify@10.0.1/node_modules/rehype-stringify/lib/index.js
function rehypeStringify(options) {
  const self2 = this;
  const settings = { ...self2.data("settings"), ...options };
  self2.compiler = compiler2;
  function compiler2(tree) {
    return toHtml(tree, settings);
  }
}

// ../node_modules/.pnpm/@blocknote+core@0.41.1_@tip_88da0e2ca7990b1ebffff41010f54baa/node_modules/@blocknote/core/dist/blocknote.js
var qt2 = Object.defineProperty;
var Yt2 = (n, t, e) => t in n ? qt2(n, t, { enumerable: true, configurable: true, writable: true, value: e }) : n[t] = e;
var h3 = (n, t, e) => Yt2(n, typeof t != "symbol" ? t + "" : t, e);
function hn2(n, t) {
  const e = [
    {
      tag: `[data-inline-content-type="${n.type}"]`,
      contentElement: (o) => {
        const r = o;
        return r.matches("[data-editable]") ? r : r.querySelector("[data-editable]") || r;
      }
    }
  ];
  return t && e.push({
    tag: "*",
    getAttrs(o) {
      if (typeof o == "string")
        return false;
      const r = t == null ? void 0 : t(o);
      return r === void 0 ? false : r;
    }
  }), e;
}
function un2(n, t, e, o = "before") {
  const r = typeof e == "string" ? e : e.id, s2 = G(n), i2 = t.map(
    (d) => Y(d, s2)
  ), c = un(r, n.doc);
  if (!c)
    throw new Error(`Block with ID ${r} not found`);
  let a2 = c.posBeforeNode;
  return o === "after" && (a2 += c.node.nodeSize), n.step(
    new ReplaceStep(a2, a2, new Slice(Fragment.from(i2), 0, 0))
  ), i2.map(
    (d) => X(d, s2)
  );
}
function We(n, t, e) {
  const o = G(n), r = e.map(
    (d) => Y(d, o)
  ), s2 = new Set(
    t.map(
      (d) => typeof d == "string" ? d : d.id
    )
  ), i2 = [], c = typeof t[0] == "string" ? t[0] : t[0].id;
  let a2 = 0;
  if (n.doc.descendants((d, u) => {
    if (s2.size === 0)
      return false;
    if (!d.type.isInGroup("bnBlock") || !s2.has(d.attrs.id))
      return true;
    if (i2.push(X(d, o)), s2.delete(d.attrs.id), e.length > 0 && d.attrs.id === c) {
      const f2 = n.doc.nodeSize;
      n.insert(u, r);
      const b2 = n.doc.nodeSize;
      a2 += f2 - b2;
    }
    const p5 = n.doc.nodeSize, m = n.doc.resolve(u - a2);
    m.node().type.name === "blockGroup" && m.node(m.depth - 1).type.name !== "doc" && m.node().childCount === 1 ? n.delete(m.before(), m.after()) : n.delete(u - a2, u - a2 + d.nodeSize);
    const g = n.doc.nodeSize;
    return a2 += p5 - g, false;
  }), s2.size > 0) {
    const d = [...s2].join(`
`);
    throw Error(
      "Blocks with the following IDs could not be found in the editor: " + d
    );
  }
  return { insertedBlocks: r.map(
    (d) => X(d, o)
  ), removedBlocks: i2 };
}
function yt(n) {
  const t = Array.from(n.classList).filter(
    (e) => !e.startsWith("bn-")
  ) || [];
  t.length > 0 ? n.className = t.join(" ") : n.removeAttribute("class");
}
function Ct(n, t, e, o) {
  var c;
  let r;
  if (t)
    if (typeof t == "string")
      r = O([t], n.pmSchema);
    else if (Array.isArray(t))
      r = O(t, n.pmSchema);
    else if (t.type === "tableContent")
      r = nt(t, n.pmSchema);
    else
      throw new Z(t.type);
  else throw new Error("blockContent is required");
  const i2 = ((o == null ? void 0 : o.document) ?? document).createDocumentFragment();
  for (const a2 of r)
    if (a2.type.name !== "text" && n.schema.inlineContentSchema[a2.type.name]) {
      const l2 = n.schema.inlineContentSpecs[a2.type.name].implementation;
      if (l2) {
        const d = Jt(
          a2,
          n.schema.inlineContentSchema,
          n.schema.styleSchema
        ), u = l2.toExternalHTML ? l2.toExternalHTML(
          d,
          n
        ) : l2.render.call(
          {
            renderType: "dom",
            props: void 0
          },
          d,
          () => {
          },
          n
        );
        if (u) {
          if (i2.appendChild(u.dom), u.contentDOM) {
            const p5 = e.serializeFragment(
              a2.content,
              o
            );
            u.contentDOM.dataset.editable = "", u.contentDOM.appendChild(p5);
          }
          continue;
        }
      }
    } else if (a2.type.name === "text") {
      let l2 = document.createTextNode(
        a2.textContent
      );
      for (const d of a2.marks.toReversed())
        if (d.type.name in n.schema.styleSpecs) {
          const u = (n.schema.styleSpecs[d.type.name].implementation.toExternalHTML ?? n.schema.styleSpecs[d.type.name].implementation.render)(d.attrs.stringValue, n);
          u.contentDOM.appendChild(l2), l2 = u.dom;
        } else {
          const u = d.type.spec.toDOM(d, true), p5 = DOMSerializer.renderSpec(document, u);
          p5.contentDOM.appendChild(l2), l2 = p5.dom;
        }
      i2.appendChild(l2);
    } else {
      const l2 = e.serializeFragment(
        Fragment.from([a2]),
        o
      );
      i2.appendChild(l2);
    }
  return i2.childNodes.length === 1 && ((c = i2.firstChild) == null ? void 0 : c.nodeType) === 1 && yt(i2.firstChild), i2;
}
function pn2(n, t, e, o, r, s2, i2) {
  var b2, k2, w3, D2, F3, J3, Q, Z2, ee2;
  const c = (i2 == null ? void 0 : i2.document) ?? document, a2 = t.pmSchema.nodes.blockContainer, l2 = e.props || {};
  for (const [v2, M3] of Object.entries(
    t.schema.blockSchema[e.type].propSchema
  ))
    !(v2 in l2) && M3.default !== void 0 && (l2[v2] = M3.default);
  const d = (k2 = (b2 = a2.spec) == null ? void 0 : b2.toDOM) == null ? void 0 : k2.call(
    b2,
    a2.create({
      id: e.id,
      ...l2
    })
  ), u = Array.from(d.dom.attributes), p5 = t.blockImplementations[e.type].implementation, m = ((w3 = p5.toExternalHTML) == null ? void 0 : w3.call(
    {},
    { ...e, props: l2 },
    t
  )) || p5.render.call(
    {},
    { ...e, props: l2 },
    t
  ), g = c.createDocumentFragment();
  if (m.dom.classList.contains("bn-block-content")) {
    const v2 = [
      ...u,
      ...Array.from(m.dom.attributes)
    ].filter(
      (M3) => M3.name.startsWith("data") && M3.name !== "data-content-type" && M3.name !== "data-file-block" && M3.name !== "data-node-view-wrapper" && M3.name !== "data-node-type" && M3.name !== "data-id" && M3.name !== "data-editable"
    );
    for (const M3 of v2)
      m.dom.firstChild.setAttribute(M3.name, M3.value);
    yt(m.dom.firstChild), g.append(...Array.from(m.dom.childNodes));
  } else
    g.append(m.dom);
  if (m.contentDOM && e.content) {
    const v2 = Ct(
      t,
      e.content,
      // TODO
      o,
      i2
    );
    m.contentDOM.appendChild(v2);
  }
  let f2;
  if (r.has(e.type) ? f2 = "OL" : s2.has(e.type) && (f2 = "UL"), f2) {
    if (((D2 = n.lastChild) == null ? void 0 : D2.nodeName) !== f2) {
      const v2 = c.createElement(f2);
      f2 === "OL" && "start" in l2 && l2.start && (l2 == null ? void 0 : l2.start) !== 1 && v2.setAttribute("start", l2.start + ""), n.append(v2);
    }
    n.lastChild.appendChild(g);
  } else
    n.append(g);
  if (e.children && e.children.length > 0) {
    const v2 = c.createDocumentFragment();
    if (vt(
      v2,
      t,
      e.children,
      o,
      r,
      s2,
      i2
    ), ((F3 = n.lastChild) == null ? void 0 : F3.nodeName) === "UL" || ((J3 = n.lastChild) == null ? void 0 : J3.nodeName) === "OL")
      for (; ((Q = v2.firstChild) == null ? void 0 : Q.nodeName) === "UL" || ((Z2 = v2.firstChild) == null ? void 0 : Z2.nodeName) === "OL"; )
        n.lastChild.lastChild.appendChild(v2.firstChild);
    t.pmSchema.nodes[e.type].isInGroup("blockContent") ? n.append(v2) : (ee2 = m.contentDOM) == null || ee2.append(v2);
  }
}
var vt = (n, t, e, o, r, s2, i2) => {
  for (const c of e)
    pn2(
      n,
      t,
      c,
      o,
      r,
      s2,
      i2
    );
};
var mn2 = (n, t, e, o, r, s2) => {
  const c = ((s2 == null ? void 0 : s2.document) ?? document).createDocumentFragment();
  return vt(
    c,
    n,
    t,
    e,
    o,
    r,
    s2
  ), c;
};
var Se = (n, t) => {
  const e = DOMSerializer.fromSchema(n);
  return {
    exportBlocks: (o, r) => {
      const s2 = mn2(
        t,
        o,
        e,
        /* @__PURE__ */ new Set(["numberedListItem"]),
        /* @__PURE__ */ new Set(["bulletListItem", "checkListItem", "toggleListItem"]),
        r
      ), i2 = document.createElement("div");
      return i2.append(s2), i2.innerHTML;
    },
    exportInlineContent: (o, r) => {
      const s2 = Ct(
        t,
        o,
        e,
        r
      ), i2 = document.createElement("div");
      return i2.append(s2.cloneNode(true)), i2.innerHTML;
    }
  };
};
function fn2(n, t, e, o, r) {
  let s2;
  if (t)
    if (typeof t == "string")
      s2 = O([t], n.pmSchema, o);
    else if (Array.isArray(t))
      s2 = O(t, n.pmSchema, o);
    else if (t.type === "tableContent")
      s2 = nt(t, n.pmSchema);
    else
      throw new Z(t.type);
  else throw new Error("blockContent is required");
  const c = ((r == null ? void 0 : r.document) ?? document).createDocumentFragment();
  for (const a2 of s2)
    if (a2.type.name !== "text" && n.schema.inlineContentSchema[a2.type.name]) {
      const l2 = n.schema.inlineContentSpecs[a2.type.name].implementation;
      if (l2) {
        const d = Jt(
          a2,
          n.schema.inlineContentSchema,
          n.schema.styleSchema
        ), u = l2.render.call(
          {
            renderType: "dom",
            props: void 0
          },
          d,
          () => {
          },
          n
        );
        if (u) {
          if (c.appendChild(u.dom), u.contentDOM) {
            const p5 = e.serializeFragment(
              a2.content,
              r
            );
            u.contentDOM.dataset.editable = "", u.contentDOM.appendChild(p5);
          }
          continue;
        }
      }
    } else if (a2.type.name === "text") {
      let l2 = document.createTextNode(
        a2.textContent
      );
      for (const d of a2.marks.toReversed())
        if (d.type.name in n.schema.styleSpecs) {
          const u = n.schema.styleSpecs[d.type.name].implementation.render(d.attrs.stringValue, n);
          u.contentDOM.appendChild(l2), l2 = u.dom;
        } else {
          const u = d.type.spec.toDOM(d, true), p5 = DOMSerializer.renderSpec(document, u);
          p5.contentDOM.appendChild(l2), l2 = p5.dom;
        }
      c.appendChild(l2);
    } else {
      const l2 = e.serializeFragment(
        Fragment.from([a2]),
        r
      );
      c.appendChild(l2);
    }
  return c;
}
function gn2(n, t, e, o) {
  var u, p5, m, g, f2;
  const r = n.pmSchema.nodes.blockContainer, s2 = t.props || {};
  for (const [b2, k2] of Object.entries(
    n.schema.blockSchema[t.type].propSchema
  ))
    !(b2 in s2) && k2.default !== void 0 && (s2[b2] = k2.default);
  const i2 = t.children || [], a2 = n.blockImplementations[t.type].implementation.render.call(
    {
      renderType: "dom",
      props: void 0
    },
    { ...t, props: s2, children: i2 },
    n
  );
  if (a2.contentDOM && t.content) {
    const b2 = fn2(
      n,
      t.content,
      // TODO
      e,
      t.type,
      o
    );
    a2.contentDOM.appendChild(b2);
  }
  if (n.pmSchema.nodes[t.type].isInGroup("bnBlock")) {
    if (t.children && t.children.length > 0) {
      const b2 = St(
        n,
        t.children,
        e,
        o
      );
      (u = a2.contentDOM) == null || u.append(b2);
    }
    return a2.dom;
  }
  const d = (m = (p5 = r.spec) == null ? void 0 : p5.toDOM) == null ? void 0 : m.call(
    p5,
    r.create({
      id: t.id,
      ...s2
    })
  );
  return (g = d.contentDOM) == null || g.appendChild(a2.dom), t.children && t.children.length > 0 && ((f2 = d.contentDOM) == null || f2.appendChild(
    Bt(n, t.children, e, o)
  )), d.dom;
}
function St(n, t, e, o) {
  const s2 = ((o == null ? void 0 : o.document) ?? document).createDocumentFragment();
  for (const i2 of t) {
    const c = gn2(n, i2, e, o);
    s2.appendChild(c);
  }
  return s2;
}
var Bt = (n, t, e, o) => {
  var c;
  const r = n.pmSchema.nodes.blockGroup, s2 = r.spec.toDOM(r.create({})), i2 = St(n, t, e, o);
  return (c = s2.contentDOM) == null || c.appendChild(i2), s2.dom;
};
var bn2 = (n, t) => {
  const e = DOMSerializer.fromSchema(n);
  return {
    serializeBlocks: (o, r) => Bt(t, o, e, r).outerHTML
  };
};
function kn2(n, t) {
  if (t === 0)
    return;
  const e = n.resolve(t);
  for (let o = e.depth; o > 0; o--) {
    const r = e.node(o);
    if (dn(r))
      return r.attrs.id;
  }
}
function wn2(n) {
  return n.getMeta("paste") ? { type: "paste" } : n.getMeta("uiEvent") === "drop" ? { type: "drop" } : n.getMeta("history$") ? {
    type: n.getMeta("history$").redo ? "redo" : "undo"
  } : n.getMeta("y-sync$") ? n.getMeta("y-sync$").isUndoRedoOperation ? { type: "undo-redo" } : { type: "yjs-remote" } : { type: "local" };
}
function Xe2(n) {
  const t = "__root__", e = {}, o = {}, r = G(n);
  return n.descendants((s2, i2) => {
    if (!dn(s2))
      return true;
    const c = kn2(n, i2), a2 = c ?? t;
    o[a2] || (o[a2] = []);
    const l2 = X(s2, r);
    return e[s2.attrs.id] = { block: l2, parentId: c }, o[a2].push(s2.attrs.id), true;
  }), { byId: e, childrenByParent: o };
}
function yn2(n, t) {
  const e = /* @__PURE__ */ new Set();
  if (!n || !t)
    return e;
  const o = new Set(n), r = t.filter((f2) => o.has(f2)), s2 = n.filter(
    (f2) => r.includes(f2)
  );
  if (s2.length <= 1 || r.length <= 1)
    return e;
  const i2 = {};
  for (let f2 = 0; f2 < s2.length; f2++)
    i2[s2[f2]] = f2;
  const c = r.map((f2) => i2[f2]), a2 = c.length, l2 = [], d = [], u = new Array(a2).fill(-1), p5 = (f2, b2) => {
    let k2 = 0, w3 = f2.length;
    for (; k2 < w3; ) {
      const D2 = k2 + w3 >>> 1;
      f2[D2] < b2 ? k2 = D2 + 1 : w3 = D2;
    }
    return k2;
  };
  for (let f2 = 0; f2 < a2; f2++) {
    const b2 = c[f2], k2 = p5(l2, b2);
    k2 > 0 && (u[f2] = d[k2 - 1]), k2 === l2.length ? (l2.push(b2), d.push(f2)) : (l2[k2] = b2, d[k2] = f2);
  }
  const m = /* @__PURE__ */ new Set();
  let g = d[d.length - 1] ?? -1;
  for (; g !== -1; )
    m.add(g), g = u[g];
  for (let f2 = 0; f2 < r.length; f2++)
    m.has(f2) || e.add(r[f2]);
  return e;
}
function Et(n, t = []) {
  const e = wn2(n), o = combineTransactionSteps(n.before, [
    n,
    ...t
  ]), r = Xe2(
    o.before
  ), s2 = Xe2(
    o.doc
  ), i2 = [], c = /* @__PURE__ */ new Set();
  Object.keys(s2.byId).filter((m) => !(m in r.byId)).forEach((m) => {
    i2.push({
      type: "insert",
      block: s2.byId[m].block,
      source: e,
      prevBlock: void 0
    }), c.add(m);
  }), Object.keys(r.byId).filter((m) => !(m in s2.byId)).forEach((m) => {
    i2.push({
      type: "delete",
      block: r.byId[m].block,
      source: e,
      prevBlock: void 0
    }), c.add(m);
  }), Object.keys(s2.byId).filter((m) => m in r.byId).forEach((m) => {
    var k2, w3;
    const g = r.byId[m], f2 = s2.byId[m];
    g.parentId !== f2.parentId ? (i2.push({
      type: "move",
      block: f2.block,
      prevBlock: g.block,
      source: e,
      prevParent: g.parentId ? (k2 = r.byId[g.parentId]) == null ? void 0 : k2.block : void 0,
      currentParent: f2.parentId ? (w3 = s2.byId[f2.parentId]) == null ? void 0 : w3.block : void 0
    }), c.add(m)) : (0, import_fast_deep_equal.default)(
      { ...g.block, children: void 0 },
      { ...f2.block, children: void 0 }
    ) || (i2.push({
      type: "update",
      block: f2.block,
      prevBlock: g.block,
      source: e
    }), c.add(m));
  });
  const a2 = r.childrenByParent, l2 = s2.childrenByParent, d = "__root__", u = /* @__PURE__ */ new Set([
    ...Object.keys(a2),
    ...Object.keys(l2)
  ]), p5 = /* @__PURE__ */ new Set();
  return u.forEach((m) => {
    const g = yn2(
      a2[m],
      l2[m]
    );
    g.size !== 0 && g.forEach((f2) => {
      var D2, F3;
      const b2 = r.byId[f2], k2 = s2.byId[f2];
      !b2 || !k2 || b2.parentId !== k2.parentId || c.has(f2) || (b2.parentId ?? d) !== m || p5.has(f2) || (p5.add(f2), i2.push({
        type: "move",
        block: k2.block,
        prevBlock: b2.block,
        source: e,
        prevParent: b2.parentId ? (D2 = r.byId[b2.parentId]) == null ? void 0 : D2.block : void 0,
        currentParent: k2.parentId ? (F3 = s2.byId[k2.parentId]) == null ? void 0 : F3.block : void 0
      }), c.add(f2));
    });
  }), i2;
}
var Oe2 = [
  "vscode-editor-data",
  "blocknote/html",
  "text/markdown",
  "text/html",
  "text/plain",
  "Files"
];
function Cn2(n, t) {
  if (!n.startsWith(".") || !t.startsWith("."))
    throw new Error("The strings provided are not valid file extensions.");
  return n === t;
}
function vn2(n, t) {
  const e = n.split("/"), o = t.split("/");
  if (e.length !== 2)
    throw new Error(`The string ${n} is not a valid MIME type.`);
  if (o.length !== 2)
    throw new Error(`The string ${t} is not a valid MIME type.`);
  return e[1] === "*" || o[1] === "*" ? e[0] === o[0] : (e[0] === "*" || o[0] === "*" || e[0] === o[0]) && e[1] === o[1];
}
function Je2(n, t, e, o = "after") {
  let r;
  return Array.isArray(t.content) && t.content.length === 0 ? r = n.updateBlock(t, e).id : r = n.insertBlocks(
    [e],
    t,
    o
  )[0].id, r;
}
async function Mt(n, t) {
  var s2;
  if (!t.uploadFile) {
    console.warn(
      "Attempted ot insert file, but uploadFile is not set in the BlockNote editor options"
    );
    return;
  }
  const e = "dataTransfer" in n ? n.dataTransfer : n.clipboardData;
  if (e === null)
    return;
  let o = null;
  for (const i2 of Oe2)
    if (e.types.includes(i2)) {
      o = i2;
      break;
    }
  if (o !== "Files")
    return;
  const r = e.items;
  if (r) {
    n.preventDefault();
    for (let i2 = 0; i2 < r.length; i2++) {
      let c = "file";
      for (const l2 of Object.values(t.schema.blockSpecs))
        for (const d of ((s2 = l2.implementation.meta) == null ? void 0 : s2.fileBlockAccept) || []) {
          const u = d.startsWith("."), p5 = r[i2].getAsFile();
          if (p5 && (!u && p5.type && vn2(r[i2].type, d) || u && Cn2(
            "." + p5.name.split(".").pop(),
            d
          ))) {
            c = l2.config.type;
            break;
          }
        }
      const a2 = r[i2].getAsFile();
      if (a2) {
        const l2 = {
          type: c,
          props: {
            name: a2.name
          }
        };
        let d;
        if (n.type === "paste") {
          const m = t.getTextCursorPosition().block;
          d = Je2(t, m, l2);
        } else if (n.type === "drop") {
          const m = {
            left: n.clientX,
            top: n.clientY
          }, g = t.prosemirrorView.posAtCoords(m);
          if (!g)
            return;
          d = t.transact((f2) => {
            const b2 = fe(f2.doc, g.pos), k2 = t.prosemirrorView.dom.querySelector(
              `[data-id="${b2.node.attrs.id}"]`
            ), w3 = k2 == null ? void 0 : k2.getBoundingClientRect();
            return Je2(
              t,
              t.getBlock(b2.node.attrs.id),
              l2,
              w3 && (w3.top + w3.bottom) / 2 > m.top ? "before" : "after"
            );
          });
        } else
          return;
        const u = await t.uploadFile(a2, d), p5 = typeof u == "string" ? {
          props: {
            url: u
          }
        } : { ...u };
        t.updateBlock(d, p5);
      }
    }
  }
}
var Sn2 = (n) => Extension.create({
  name: "dropFile",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        props: {
          handleDOMEvents: {
            drop(t, e) {
              if (!n.isEditable)
                return;
              let o = null;
              for (const r of Oe2)
                if (e.dataTransfer.types.includes(r)) {
                  o = r;
                  break;
                }
              return o === null ? true : o === "Files" ? (Mt(e, n), true) : false;
            }
          }
        }
      })
    ];
  }
});
var Bn2 = /(^|\n) {0,3}#{1,6} {1,8}[^\n]{1,64}\r?\n\r?\n\s{0,32}\S/;
var En2 = /(_|__|\*|\*\*|~~|==|\+\+)(?!\s)(?:[^\s](?:.{0,62}[^\s])?|\S)(?=\1)/;
var Mn2 = /\[[^\]]{1,128}\]\(https?:\/\/\S{1,999}\)/;
var Pn2 = /(?:\s|^)`(?!\s)(?:[^\s`](?:[^`]{0,46}[^\s`])?|[^\s`])`([^\w]|$)/;
var Tn2 = /(?:^|\n)\s{0,5}-\s{1}[^\n]+\n\s{0,15}-\s/;
var xn2 = /(?:^|\n)\s{0,5}\d+\.\s{1}[^\n]+\n\s{0,15}\d+\.\s/;
var In2 = /\n{2} {0,3}-{2,48}\n{2}/;
var Ln2 = /(?:\n|^)(```|~~~|\$\$)(?!`|~)[^\s]{0,64} {0,64}[^\n]{0,64}\n[\s\S]{0,9999}?\s*\1 {0,64}(?:\n+|$)/;
var Dn2 = /(?:\n|^)(?!\s)\w[^\n]{0,64}\r?\n(-|=)\1{0,64}\n\n\s{0,64}(\w|$)/;
var An2 = /(?:^|(\r?\n\r?\n))( {0,3}>[^\n]{1,333}\n){1,999}($|(\r?\n))/;
var _n2 = /^\s*\|(.+\|)+\s*$/m;
var On2 = /^\s*\|(\s*[-:]+[-:]\s*\|)+\s*$/m;
var Hn2 = /^\s*\|(.+\|)+\s*$/m;
var Nn2 = (n) => Bn2.test(n) || En2.test(n) || Mn2.test(n) || Pn2.test(n) || Tn2.test(n) || xn2.test(n) || In2.test(n) || Ln2.test(n) || Dn2.test(n) || An2.test(n) || _n2.test(n) || On2.test(n) || Hn2.test(n);
async function Un2(n, t) {
  const { schema: e } = t.state;
  if (!n.clipboardData)
    return false;
  const o = n.clipboardData.getData("text/plain");
  if (!o)
    return false;
  if (!e.nodes.codeBlock)
    return t.pasteText(o), true;
  const r = n.clipboardData.getData("vscode-editor-data"), s2 = r ? JSON.parse(r) : void 0, i2 = s2 == null ? void 0 : s2.mode;
  return i2 ? (t.pasteHTML(
    `<pre><code class="language-${i2}">${o.replace(
      /\r\n?/g,
      `
`
    )}</code></pre>`
  ), true) : false;
}
function Rn2({
  event: n,
  editor: t,
  prioritizeMarkdownOverHTML: e,
  plainTextAsMarkdown: o
}) {
  var c;
  if (t.transact(
    (a2) => a2.selection.$from.parent.type.spec.code && a2.selection.$to.parent.type.spec.code
  )) {
    const a2 = (c = n.clipboardData) == null ? void 0 : c.getData("text/plain");
    if (a2)
      return t.pasteText(a2), true;
  }
  let s2;
  for (const a2 of Oe2)
    if (n.clipboardData.types.includes(a2)) {
      s2 = a2;
      break;
    }
  if (!s2)
    return true;
  if (s2 === "vscode-editor-data")
    return Un2(n, t.prosemirrorView), true;
  if (s2 === "Files")
    return Mt(n, t), true;
  const i2 = n.clipboardData.getData(s2);
  if (s2 === "blocknote/html")
    return t.pasteHTML(i2, true), true;
  if (s2 === "text/markdown")
    return t.pasteMarkdown(i2), true;
  if (e) {
    const a2 = n.clipboardData.getData("text/plain");
    if (Nn2(a2))
      return t.pasteMarkdown(a2), true;
  }
  return s2 === "text/html" ? (t.pasteHTML(i2), true) : o ? (t.pasteMarkdown(i2), true) : (t.pasteText(i2), true);
}
var Vn2 = (n, t) => Extension.create({
  name: "pasteFromClipboard",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        props: {
          handleDOMEvents: {
            paste(e, o) {
              if (o.preventDefault(), !!n.isEditable)
                return t({
                  event: o,
                  editor: n,
                  defaultPasteHandler: ({
                    prioritizeMarkdownOverHTML: r = true,
                    plainTextAsMarkdown: s2 = true
                  } = {}) => Rn2({
                    event: o,
                    editor: n,
                    prioritizeMarkdownOverHTML: r,
                    plainTextAsMarkdown: s2
                  })
                });
            }
          }
        }
      })
    ];
  }
});
function $n2() {
  const n = (t) => {
    let e = t.children.length;
    for (let o = 0; o < e; o++) {
      const r = t.children[o];
      if (r.type === "element" && (n(r), r.tagName === "u"))
        if (r.children.length > 0) {
          t.children.splice(o, 1, ...r.children);
          const s2 = r.children.length - 1;
          e += s2, o += s2;
        } else
          t.children.splice(o, 1), e--, o--;
    }
  };
  return n;
}
function Fn2() {
  const n = (t) => {
    var e;
    if (t.children && "length" in t.children && t.children.length)
      for (let o = t.children.length - 1; o >= 0; o--) {
        const r = t.children[o], s2 = o + 1 < t.children.length ? t.children[o + 1] : void 0;
        r.type === "element" && r.tagName === "input" && ((e = r.properties) == null ? void 0 : e.type) === "checkbox" && (s2 == null ? void 0 : s2.type) === "element" && s2.tagName === "p" ? (s2.tagName = "span", s2.children.splice(
          0,
          0,
          fromDom(document.createTextNode(" "))
        )) : n(r);
      }
  };
  return n;
}
function zn2() {
  return (n) => {
    visit(n, "element", (t, e, o) => {
      var r, s2, i2, c;
      if (o && t.tagName === "video") {
        const a2 = ((r = t.properties) == null ? void 0 : r.src) || ((s2 = t.properties) == null ? void 0 : s2["data-url"]) || "", l2 = ((i2 = t.properties) == null ? void 0 : i2.title) || ((c = t.properties) == null ? void 0 : c["data-name"]) || "";
        o.children[e] = {
          type: "text",
          value: `![${l2}](${a2})`
        };
      }
    });
  };
}
function He2(n) {
  return unified().use(rehypeParse, { fragment: true }).use(zn2).use($n2).use(Fn2).use(rehypeRemark).use(remarkGfm).use(remarkStringify, {
    handlers: { text: (e) => e.value }
  }).processSync(n).value;
}
function Gn2(n, t, e, o) {
  const s2 = Se(t, e).exportBlocks(n, o);
  return He2(s2);
}
function Pt(n) {
  const t = [];
  return n.descendants((e) => {
    var r, s2;
    const o = G(e);
    return e.type.name === "blockContainer" && ((r = e.firstChild) == null ? void 0 : r.type.name) === "blockGroup" ? true : e.type.name === "columnList" && e.childCount === 1 ? ((s2 = e.firstChild) == null || s2.forEach((i2) => {
      t.push(X(i2, o));
    }), false) : e.type.isInGroup("bnBlock") ? (t.push(X(e, o)), false) : true;
  }), t;
}
function jn2(n, t, e) {
  var c;
  let o = false;
  const r = n.state.selection instanceof CellSelection;
  if (!r) {
    const a2 = n.state.doc.slice(
      n.state.selection.from,
      n.state.selection.to,
      false
    ).content, l2 = [];
    for (let d = 0; d < a2.childCount; d++)
      l2.push(a2.child(d));
    o = l2.find(
      (d) => d.type.isInGroup("bnBlock") || d.type.name === "blockGroup" || d.type.spec.group === "blockContent"
    ) === void 0, o && (t = a2);
  }
  let s2;
  const i2 = Se(
    n.state.schema,
    e
  );
  if (r) {
    ((c = t.firstChild) == null ? void 0 : c.type.name) === "table" && (t = t.firstChild.content);
    const a2 = Xt(
      t,
      e.schema.inlineContentSchema,
      e.schema.styleSchema
    );
    s2 = `<table>${i2.exportInlineContent(
      a2,
      {}
    )}</table>`;
  } else if (o) {
    const a2 = Ce(
      t,
      e.schema.inlineContentSchema,
      e.schema.styleSchema
    );
    s2 = i2.exportInlineContent(a2, {});
  } else {
    const a2 = Pt(t);
    s2 = i2.exportBlocks(a2, {});
  }
  return s2;
}
function Tt(n, t) {
  "node" in n.state.selection && n.state.selection.node.type.spec.group === "blockContent" && t.transact(
    (i2) => i2.setSelection(
      new NodeSelection(i2.doc.resolve(n.state.selection.from - 1))
    )
  );
  const e = n.serializeForClipboard(
    n.state.selection.content()
  ).dom.innerHTML, o = n.state.selection.content().content, r = jn2(
    n,
    o,
    t
  ), s2 = He2(r);
  return { clipboardHTML: e, externalHTML: r, markdown: s2 };
}
var Qe2 = () => {
  const n = window.getSelection();
  if (!n || n.isCollapsed)
    return true;
  let t = n.focusNode;
  for (; t; ) {
    if (t instanceof HTMLElement && t.getAttribute("contenteditable") === "false")
      return true;
    t = t.parentElement;
  }
  return false;
};
var Ze2 = (n, t, e) => {
  e.preventDefault(), e.clipboardData.clearData();
  const { clipboardHTML: o, externalHTML: r, markdown: s2 } = Tt(
    t,
    n
  );
  e.clipboardData.setData("blocknote/html", o), e.clipboardData.setData("text/html", r), e.clipboardData.setData("text/plain", s2);
};
var Kn2 = (n) => Extension.create({
  name: "copyToClipboard",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        props: {
          handleDOMEvents: {
            copy(t, e) {
              return Qe2() || Ze2(n, t, e), true;
            },
            cut(t, e) {
              return Qe2() || (Ze2(n, t, e), t.editable && t.dispatch(t.state.tr.deleteSelection())), true;
            },
            // This is for the use-case in which only a block without content
            // is selected, e.g. an image block, and dragged (not using the
            // drag handle).
            dragstart(t, e) {
              if (!("node" in t.state.selection) || t.state.selection.node.type.spec.group !== "blockContent")
                return;
              n.transact(
                (i2) => i2.setSelection(
                  new NodeSelection(
                    i2.doc.resolve(t.state.selection.from - 1)
                  )
                )
              ), e.preventDefault(), e.dataTransfer.clearData();
              const { clipboardHTML: o, externalHTML: r, markdown: s2 } = Tt(t, n);
              return e.dataTransfer.setData("blocknote/html", o), e.dataTransfer.setData("text/html", r), e.dataTransfer.setData("text/plain", s2), true;
            }
          }
        }
      })
    ];
  }
});
var qn2 = Extension.create({
  name: "blockBackgroundColor",
  addGlobalAttributes() {
    return [
      {
        types: ["tableCell", "tableHeader"],
        attributes: {
          backgroundColor: sr()
        }
      }
    ];
  }
});
var Yn2 = class extends Sn {
  constructor() {
    super();
    h3(this, "beforeChangeCallbacks", []);
    this.addProsemirrorPlugin(
      new Plugin({
        key: new PluginKey("blockChange"),
        filterTransaction: (e) => {
          let o;
          return this.beforeChangeCallbacks.reduce((r, s2) => r === false ? r : s2({
            getChanges() {
              return o || (o = Et(e), o);
            },
            tr: e
          }) !== false, true);
        }
      })
    );
  }
  static key() {
    return "blockChange";
  }
  subscribe(e) {
    return this.beforeChangeCallbacks.push(e), () => {
      this.beforeChangeCallbacks = this.beforeChangeCallbacks.filter(
        (o) => o !== e
      );
    };
  }
};
var j2 = class j3 extends Sn {
  constructor(e) {
    super();
    h3(this, "provider");
    h3(this, "recentlyUpdatedCursors");
    h3(this, "renderCursor", (e2, o) => {
      let r = this.recentlyUpdatedCursors.get(o);
      if (!r) {
        const s2 = (this.collaboration.renderCursor ?? j3.defaultCursorRender)(e2);
        this.collaboration.showCursorLabels !== "always" && (s2.addEventListener("mouseenter", () => {
          const i2 = this.recentlyUpdatedCursors.get(o);
          i2.element.setAttribute("data-active", ""), i2.hideTimeout && (clearTimeout(i2.hideTimeout), this.recentlyUpdatedCursors.set(o, {
            element: i2.element,
            hideTimeout: void 0
          }));
        }), s2.addEventListener("mouseleave", () => {
          const i2 = this.recentlyUpdatedCursors.get(o);
          this.recentlyUpdatedCursors.set(o, {
            element: i2.element,
            hideTimeout: setTimeout(() => {
              i2.element.removeAttribute("data-active");
            }, 2e3)
          });
        })), r = {
          element: s2,
          hideTimeout: void 0
        }, this.recentlyUpdatedCursors.set(o, r);
      }
      return r.element;
    });
    h3(this, "updateUser", (e2) => {
      this.provider.awareness.setLocalStateField("user", e2);
    });
    this.collaboration = e, this.provider = e.provider, this.recentlyUpdatedCursors = /* @__PURE__ */ new Map(), this.provider.awareness.setLocalStateField("user", e.user), e.showCursorLabels !== "always" && this.provider.awareness.on(
      "change",
      ({
        updated: o
      }) => {
        for (const r of o) {
          const s2 = this.recentlyUpdatedCursors.get(r);
          s2 && (s2.element.setAttribute("data-active", ""), s2.hideTimeout && clearTimeout(s2.hideTimeout), this.recentlyUpdatedCursors.set(r, {
            element: s2.element,
            hideTimeout: setTimeout(() => {
              s2.element.removeAttribute("data-active");
            }, 2e3)
          }));
        }
      }
    ), this.addProsemirrorPlugin(
      yCursorPlugin(this.provider.awareness, {
        selectionBuilder: defaultSelectionBuilder,
        cursorBuilder: this.renderCursor
      })
    );
  }
  static key() {
    return "yCursorPlugin";
  }
  get priority() {
    return 999;
  }
  /**
   * Determine whether the foreground color should be white or black based on a provided background color
   * Inspired by: https://stackoverflow.com/a/3943023
   *
   */
  static isDarkColor(e) {
    const o = e.charAt(0) === "#" ? e.substring(1, 7) : e, r = parseInt(o.substring(0, 2), 16), s2 = parseInt(o.substring(2, 4), 16), i2 = parseInt(o.substring(4, 6), 16), a2 = [r / 255, s2 / 255, i2 / 255].map((d) => d <= 0.03928 ? d / 12.92 : Math.pow((d + 0.055) / 1.055, 2.4));
    return 0.2126 * a2[0] + 0.7152 * a2[1] + 0.0722 * a2[2] <= 0.179;
  }
};
h3(j2, "defaultCursorRender", (e) => {
  const o = document.createElement("span");
  o.classList.add("bn-collaboration-cursor__base");
  const r = document.createElement("span");
  r.setAttribute("contentedEditable", "false"), r.classList.add("bn-collaboration-cursor__caret"), r.setAttribute(
    "style",
    `background-color: ${e.color}; color: ${j2.isDarkColor(e.color) ? "white" : "black"}`
  );
  const s2 = document.createElement("span");
  return s2.classList.add("bn-collaboration-cursor__label"), s2.setAttribute(
    "style",
    `background-color: ${e.color}; color: ${j2.isDarkColor(e.color) ? "white" : "black"}`
  ), s2.insertBefore(document.createTextNode(e.name), null), r.insertBefore(s2, null), o.insertBefore(document.createTextNode(""), null), o.insertBefore(r, null), o.insertBefore(document.createTextNode(""), null), o;
});
var se2 = j2;
var ge2 = class extends Sn {
  static key() {
    return "ySyncPlugin";
  }
  constructor(t) {
    super(), this.addProsemirrorPlugin(ySyncPlugin(t));
  }
  get priority() {
    return 1001;
  }
};
var be2 = class extends Sn {
  static key() {
    return "yUndoPlugin";
  }
  constructor({ editor: t }) {
    super(), this.addProsemirrorPlugin(yUndoPlugin({ trackedOrigins: [t] }));
  }
  get priority() {
    return 1e3;
  }
};
var xt = class extends Sn {
  constructor({
    editor: e,
    collaboration: o
  }) {
    super(e);
    h3(this, "editor");
    h3(this, "collaboration");
    h3(this, "forkedState");
    this.editor = e, this.collaboration = o;
  }
  static key() {
    return "ForkYDocPlugin";
  }
  /**
   * To find a fragment in another ydoc, we need to search for it.
   */
  findTypeInOtherYdoc(e, o) {
    const r = e.doc;
    if (e._item === null) {
      const s2 = Array.from(r.share.keys()).find(
        (i2) => r.share.get(i2) === e
      );
      if (s2 == null)
        throw new Error("type does not exist in other ydoc");
      return o.get(s2, e.constructor);
    } else {
      const s2 = e._item, i2 = o.store.clients.get(s2.id.client) ?? [], c = findIndexSS(i2, s2.id.clock);
      return i2[c].content.type;
    }
  }
  /**
   * Whether the editor is editing a forked document,
   * preserving a reference to the original document and the forked document.
   */
  get isForkedFromRemote() {
    return this.forkedState !== void 0;
  }
  /**
   * Fork the Y.js document from syncing to the remote,
   * allowing modifications to the document without affecting the remote.
   * These changes can later be rolled back or applied to the remote.
   */
  fork() {
    var s2;
    if (this.isForkedFromRemote)
      return;
    const e = (s2 = this.collaboration) == null ? void 0 : s2.fragment;
    if (!e)
      throw new Error("No fragment to fork from");
    const o = new Doc();
    applyUpdate(o, encodeStateAsUpdate(e.doc));
    const r = this.findTypeInOtherYdoc(e, o);
    this.forkedState = {
      undoStack: yUndoPluginKey.getState(this.editor.prosemirrorState).undoManager.undoStack,
      originalFragment: e,
      forkedFragment: r
    }, this.editor._tiptapEditor.unregisterPlugin([
      yCursorPluginKey,
      yUndoPluginKey,
      ySyncPluginKey
    ]), this.editor._tiptapEditor.registerPlugin(
      new ge2(r).plugins[0]
    ), this.editor._tiptapEditor.registerPlugin(
      new be2({ editor: this.editor }).plugins[0]
    ), this.emit("forked", true);
  }
  /**
   * Resume syncing the Y.js document to the remote
   * If `keepChanges` is true, any changes that have been made to the forked document will be applied to the original document.
   * Otherwise, the original document will be restored and the changes will be discarded.
   */
  merge({ keepChanges: e }) {
    if (!this.forkedState)
      return;
    this.editor._tiptapEditor.unregisterPlugin(ySyncPluginKey), this.editor._tiptapEditor.unregisterPlugin(yUndoPluginKey);
    const { originalFragment: o, forkedFragment: r, undoStack: s2 } = this.forkedState;
    if (this.editor.extensions.ySyncPlugin = new ge2(o), this.editor.extensions.yCursorPlugin = new se2(
      this.collaboration
    ), this.editor.extensions.yUndoPlugin = new be2({
      editor: this.editor
    }), this.editor._tiptapEditor.registerPlugin(
      this.editor.extensions.ySyncPlugin.plugins[0]
    ), this.editor._tiptapEditor.registerPlugin(
      this.editor.extensions.yCursorPlugin.plugins[0]
    ), this.editor._tiptapEditor.registerPlugin(
      this.editor.extensions.yUndoPlugin.plugins[0]
    ), yUndoPluginKey.getState(
      this.editor.prosemirrorState
    ).undoManager.undoStack = s2, e) {
      const i2 = encodeStateAsUpdate(
        r.doc,
        encodeStateVector(o.doc)
      );
      applyUpdate(o.doc, i2, this.editor);
    }
    this.forkedState = void 0, this.emit("forked", false);
  }
};
var It = (n, t) => {
  t(n), n.forEach((e) => {
    e instanceof YXmlElement && It(e, t);
  });
};
var Wn2 = (n, t) => {
  const e = {};
  n.forEach((o) => {
    o instanceof YXmlElement && It(o, (r) => {
      if (r.nodeName === "blockContainer" && r.hasAttribute("id")) {
        const s2 = {
          textColor: r.getAttribute("textColor"),
          backgroundColor: r.getAttribute("backgroundColor")
        };
        s2.textColor === C.textColor.default && (s2.textColor = void 0), s2.backgroundColor === C.backgroundColor.default && (s2.backgroundColor = void 0), (s2.textColor || s2.backgroundColor) && (e[r.getAttribute("id")] = s2);
      }
    });
  }), t.doc.descendants((o, r) => {
    o.type.name === "blockContainer" && e[o.attrs.id] && (t = t.setNodeMarkup(
      r + 1,
      void 0,
      e[o.attrs.id]
    ));
  });
};
var Xn2 = [Wn2];
var Ne2 = class _Ne extends Sn {
  constructor(e) {
    const o = new PluginKey(_Ne.key());
    super();
    h3(this, "migrationDone", false);
    this.addProsemirrorPlugin(
      new Plugin({
        key: o,
        appendTransaction: (r, s2, i2) => {
          if (this.migrationDone || r.length !== 1 || !r[0].getMeta(ySyncPluginKey))
            return;
          const c = i2.tr;
          for (const a2 of Xn2)
            a2(e, c);
          return this.migrationDone = true, c;
        }
      })
    );
  }
  static key() {
    return "schemaMigrationPlugin";
  }
};
var ke2 = Mark.create({
  name: "comment",
  excludes: "",
  inclusive: false,
  keepOnSplit: true,
  addAttributes() {
    return {
      // orphans are marks that currently don't have an active thread. It could be
      // that users have resolved the thread. Resolved threads by default are not shown in the document,
      // but we need to keep the mark (positioning) data so we can still "revive" it when the thread is unresolved
      // or we enter a "comments" view that includes resolved threads.
      orphan: {
        parseHTML: (n) => !!n.getAttribute("data-orphan"),
        renderHTML: (n) => n.orphan ? {
          "data-orphan": "true"
        } : {},
        default: false
      },
      threadId: {
        parseHTML: (n) => n.getAttribute("data-bn-thread-id"),
        renderHTML: (n) => ({
          "data-bn-thread-id": n.threadId
        }),
        default: ""
      }
    };
  },
  renderHTML({ HTMLAttributes: n }) {
    return [
      "span",
      mergeAttributes(n, {
        class: "bn-thread-mark"
      })
    ];
  },
  parseHTML() {
    return [{ tag: "span.bn-thread-mark" }];
  },
  extendMarkSchema(n) {
    return n.name === "comment" ? {
      blocknoteIgnore: true
    } : {};
  }
});
var Jn2 = class extends xn {
  constructor(e) {
    super();
    h3(this, "userCache", /* @__PURE__ */ new Map());
    h3(this, "loadingUsers", /* @__PURE__ */ new Set());
    this.resolveUsers = e;
  }
  /**
   * Load information about users based on an array of user ids.
   */
  async loadUsers(e) {
    const o = e.filter(
      (r) => !this.userCache.has(r) && !this.loadingUsers.has(r)
    );
    if (o.length !== 0) {
      for (const r of o)
        this.loadingUsers.add(r);
      try {
        const r = await this.resolveUsers(o);
        for (const s2 of r)
          this.userCache.set(s2.id, s2);
        this.emit("update", this.userCache);
      } finally {
        for (const r of o)
          this.loadingUsers.delete(r);
      }
    }
  }
  /**
   * Retrieve information about a user based on their id, if cached.
   *
   * The user will have to be loaded via `loadUsers` first
   */
  getUser(e) {
    return this.userCache.get(e);
  }
  /**
   * Subscribe to changes in the user store.
   *
   * @param cb - The callback to call when the user store changes.
   * @returns A function to unsubscribe from the user store.
   */
  subscribe(e) {
    return this.on("update", e);
  }
};
var ce2 = new PluginKey("blocknote-comments");
var Qn2 = "SET_SELECTED_THREAD_ID";
function Zn2(n, t) {
  const e = /* @__PURE__ */ new Map();
  return n.descendants((o, r) => {
    o.marks.forEach((s2) => {
      if (s2.type.name === t) {
        const i2 = s2.attrs.threadId;
        if (!i2)
          return;
        const c = r, a2 = c + o.nodeSize, l2 = e.get(i2) ?? {
          from: 1 / 0,
          to: 0
        };
        e.set(i2, {
          from: Math.min(c, l2.from),
          to: Math.max(a2, l2.to)
        });
      }
    });
  }), e;
}
var Lt = class extends Sn {
  constructor(e, o, r, s2, i2) {
    super();
    h3(this, "userStore");
    h3(this, "pendingComment", false);
    h3(this, "selectedThreadId");
    h3(this, "threadPositions", /* @__PURE__ */ new Map());
    h3(this, "updateMarksFromThreads", (e2) => {
      this.editor.transact((o2) => {
        o2.doc.descendants((r2, s3) => {
          r2.marks.forEach((i3) => {
            if (i3.type.name === this.markType) {
              const c2 = i3.type, a2 = i3.attrs.threadId, l2 = e2.get(a2), d = !!(!l2 || l2.resolved || l2.deletedAt);
              if (d !== i3.attrs.orphan) {
                const u = Math.max(s3, 0), p5 = Math.min(
                  s3 + r2.nodeSize,
                  o2.doc.content.size - 1,
                  o2.doc.content.size - 1
                );
                o2.removeMark(u, p5, i3), o2.addMark(
                  u,
                  p5,
                  c2.create({
                    ...i3.attrs,
                    orphan: d
                  })
                ), d && this.selectedThreadId === a2 && (this.selectedThreadId = void 0, this.emitStateUpdate());
              }
            }
          });
        });
      });
    });
    if (this.editor = e, this.threadStore = o, this.markType = r, this.resolveUsers = s2, this.commentEditorSchema = i2, !s2)
      throw new Error("resolveUsers is required for comments");
    this.userStore = new Jn2(s2), this.threadStore.subscribe(this.updateMarksFromThreads), e.onCreate(() => {
      this.updateMarksFromThreads(this.threadStore.getThreads()), e.onSelectionChange(() => {
        this.pendingComment && (this.pendingComment = false, this.emitStateUpdate());
      });
    });
    const c = this;
    this.addProsemirrorPlugin(
      new Plugin({
        key: ce2,
        state: {
          init() {
            return {
              decorations: DecorationSet.empty
            };
          },
          apply(a2, l2) {
            const d = a2.getMeta(ce2);
            if (!a2.docChanged && !d)
              return l2;
            const u = a2.docChanged ? Zn2(a2.doc, c.markType) : c.threadPositions;
            (u.size > 0 || c.threadPositions.size > 0) && (c.threadPositions = u, c.emitStateUpdate());
            const p5 = [];
            if (c.selectedThreadId) {
              const m = u.get(
                c.selectedThreadId
              );
              m && p5.push(
                Decoration.inline(
                  m.from,
                  m.to,
                  {
                    class: "bn-thread-mark-selected"
                  }
                )
              );
            }
            return {
              decorations: DecorationSet.create(a2.doc, p5)
            };
          }
        },
        props: {
          decorations(a2) {
            var l2;
            return ((l2 = ce2.getState(a2)) == null ? void 0 : l2.decorations) ?? DecorationSet.empty;
          },
          /**
           * Handle click on a thread mark and mark it as selected
           */
          handleClick: (a2, l2, d) => {
            if (d.button !== 0)
              return;
            const u = a2.state.doc.nodeAt(l2);
            if (!u) {
              c.selectThread(void 0);
              return;
            }
            const p5 = u.marks.find(
              (g) => g.type.name === r && g.attrs.orphan !== true
            ), m = p5 == null ? void 0 : p5.attrs.threadId;
            c.selectThread(m, false);
          }
        }
      })
    );
  }
  static key() {
    return "comments";
  }
  emitStateUpdate() {
    this.emit("update", {
      selectedThreadId: this.selectedThreadId,
      pendingComment: this.pendingComment,
      threadPositions: this.threadPositions
    });
  }
  /**
   * Subscribe to state updates
   */
  onUpdate(e) {
    return this.on("update", e);
  }
  /**
   * Set the selected thread
   */
  selectThread(e, o = true) {
    var r, s2;
    if (this.selectedThreadId !== e && (this.selectedThreadId = e, this.emitStateUpdate(), this.editor.transact(
      (i2) => i2.setMeta(ce2, {
        name: Qn2
      })
    ), e && o)) {
      const i2 = this.threadPositions.get(e);
      if (!i2)
        return;
      (s2 = (r = this.editor.prosemirrorView) == null ? void 0 : r.domAtPos(i2.from).node) == null || s2.scrollIntoView({
        behavior: "smooth",
        block: "center"
      });
    }
  }
  /**
   * Start a pending comment (e.g.: when clicking the "Add comment" button)
   */
  startPendingComment() {
    this.pendingComment = true, this.emitStateUpdate();
  }
  /**
   * Stop a pending comment (e.g.: user closes the comment composer)
   */
  stopPendingComment() {
    this.pendingComment = false, this.emitStateUpdate();
  }
  /**
   * Create a thread at the current selection
   */
  async createThread(e) {
    const o = await this.threadStore.createThread(e);
    if (this.threadStore.addThreadToDocument) {
      const r = this.editor.prosemirrorView, s2 = r.state.selection, i2 = ySyncPluginKey.getState(r.state), c = {
        prosemirror: {
          head: s2.head,
          anchor: s2.anchor
        },
        yjs: i2 ? getRelativeSelection(i2.binding, r.state) : void 0
        // if we're not using yjs
      };
      await this.threadStore.addThreadToDocument({
        threadId: o.id,
        selection: c
      });
    } else
      this.editor._tiptapEditor.commands.setMark(this.markType, {
        orphan: false,
        threadId: o.id
      });
  }
};
var er2 = class {
  constructor(t, e, o, r) {
    h3(this, "state");
    h3(this, "emitUpdate");
    h3(this, "mouseDownHandler", () => {
      var t2;
      (t2 = this.state) != null && t2.show && (this.state.show = false, this.emitUpdate());
    });
    h3(this, "dragstartHandler", () => {
      var t2;
      (t2 = this.state) != null && t2.show && (this.state.show = false, this.emitUpdate());
    });
    h3(this, "scrollHandler", () => {
      var t2;
      if ((t2 = this.state) != null && t2.show) {
        const e2 = this.pmView.root.querySelector(
          `[data-node-type="blockContainer"][data-id="${this.state.block.id}"]`
        );
        if (!e2)
          return;
        this.state.referencePos = e2.getBoundingClientRect(), this.emitUpdate();
      }
    });
    h3(this, "closeMenu", () => {
      var t2;
      (t2 = this.state) != null && t2.show && (this.state.show = false, this.emitUpdate());
    });
    this.editor = t, this.pluginKey = e, this.pmView = o, this.emitUpdate = () => {
      if (!this.state)
        throw new Error("Attempting to update uninitialized file panel");
      r(this.state);
    }, o.dom.addEventListener("mousedown", this.mouseDownHandler), o.dom.addEventListener("dragstart", this.dragstartHandler), o.root.addEventListener("scroll", this.scrollHandler, true);
  }
  update(t, e) {
    var c, a2;
    const o = this.pluginKey.getState(t.state), r = this.pluginKey.getState(e);
    if (!((c = this.state) != null && c.show) && (o != null && o.block) && this.editor.isEditable) {
      const l2 = this.pmView.root.querySelector(
        `[data-node-type="blockContainer"][data-id="${o.block.id}"]`
      );
      if (!l2)
        return;
      this.state = {
        show: true,
        referencePos: l2.getBoundingClientRect(),
        block: o.block
      }, this.emitUpdate();
      return;
    }
    const s2 = (o == null ? void 0 : o.block) && !(r != null && r.block), i2 = !(o != null && o.block) && (r == null ? void 0 : r.block);
    s2 && this.state && !this.state.show && (this.state.show = true, this.emitUpdate()), i2 && ((a2 = this.state) != null && a2.show) && (this.state.show = false, this.emitUpdate());
  }
  destroy() {
    this.pmView.dom.removeEventListener("mousedown", this.mouseDownHandler), this.pmView.dom.removeEventListener("dragstart", this.dragstartHandler), this.pmView.root.removeEventListener("scroll", this.scrollHandler, true);
  }
};
var Me = new PluginKey(
  "FilePanelPlugin"
);
var tr3 = class extends Sn {
  constructor(e) {
    super();
    h3(this, "view");
    h3(this, "closeMenu", () => {
      var e2;
      return (e2 = this.view) == null ? void 0 : e2.closeMenu();
    });
    this.addProsemirrorPlugin(
      new Plugin({
        key: Me,
        view: (o) => (this.view = new er2(
          e,
          Me,
          o,
          (r) => {
            this.emit("update", r);
          }
        ), this.view),
        props: {
          handleKeyDown: (o, r) => {
            var s2;
            return r.key === "Escape" && this.shown ? ((s2 = this.view) == null || s2.closeMenu(), true) : false;
          }
        },
        state: {
          init: () => ({
            block: void 0
          }),
          apply: (o, r) => {
            const s2 = o.getMeta(Me);
            return s2 || (!o.getMeta(ySyncPluginKey) && (o.selectionSet || o.docChanged) ? { block: void 0 } : r);
          }
        }
      })
    );
  }
  static key() {
    return "filePanel";
  }
  get shown() {
    var e, o;
    return ((o = (e = this.view) == null ? void 0 : e.state) == null ? void 0 : o.show) || false;
  }
  onUpdate(e) {
    return this.on("update", e);
  }
};
var or2 = class {
  constructor(t, e, o) {
    h3(this, "state");
    h3(this, "emitUpdate");
    h3(this, "preventHide", false);
    h3(this, "preventShow", false);
    h3(this, "shouldShow", ({ view: t2, state: e2, from: o2, to: r }) => {
      const { doc: s2, selection: i2 } = e2, { empty: c } = i2, a2 = !s2.textBetween(o2, r).length && isTextSelection(e2.selection);
      if (i2.$from.parent.type.spec.code || isNodeSelection(i2) && i2.node.type.spec.code || c || a2)
        return false;
      const l2 = document.activeElement;
      return !(!this.isElementWithinEditorWrapper(l2) && t2.editable);
    });
    h3(this, "blurHandler", (t2) => {
      var o2;
      if (this.preventHide) {
        this.preventHide = false;
        return;
      }
      const e2 = this.pmView.dom.parentElement;
      t2 && t2.relatedTarget && // Element is inside the editor.
      (e2 === t2.relatedTarget || e2.contains(t2.relatedTarget) || t2.relatedTarget.matches(
        ".bn-ui-container, .bn-ui-container *"
      )) || (o2 = this.state) != null && o2.show && (this.state.show = false, this.emitUpdate());
    });
    h3(this, "isElementWithinEditorWrapper", (t2) => {
      if (!t2)
        return false;
      const e2 = this.pmView.dom.parentElement;
      return e2 ? e2.contains(t2) : false;
    });
    h3(this, "viewMousedownHandler", (t2) => {
      (!this.isElementWithinEditorWrapper(t2.target) || t2.button === 0) && (this.preventShow = true);
    });
    h3(this, "mouseupHandler", () => {
      this.preventShow && (this.preventShow = false, setTimeout(() => this.update(this.pmView)));
    });
    h3(this, "dragHandler", () => {
      var t2;
      (t2 = this.state) != null && t2.show && (this.state.show = false, this.emitUpdate());
    });
    h3(this, "scrollHandler", () => {
      var t2;
      (t2 = this.state) != null && t2.show && (this.state.referencePos = this.getSelectionBoundingBox(), this.emitUpdate());
    });
    h3(this, "closeMenu", () => {
      var t2;
      (t2 = this.state) != null && t2.show && (this.state.show = false, this.emitUpdate());
    });
    this.editor = t, this.pmView = e, this.emitUpdate = () => {
      if (!this.state)
        throw new Error(
          "Attempting to update uninitialized formatting toolbar"
        );
      o(this.state);
    }, e.dom.addEventListener("mousedown", this.viewMousedownHandler), e.root.addEventListener("mouseup", this.mouseupHandler), e.dom.addEventListener("dragstart", this.dragHandler), e.dom.addEventListener("dragover", this.dragHandler), e.dom.addEventListener("blur", this.blurHandler), e.root.addEventListener("scroll", this.scrollHandler, true);
  }
  update(t, e) {
    var m, g, f2;
    const { state: o, composing: r } = t, { doc: s2, selection: i2 } = o, c = e && e.doc.eq(s2) && e.selection.eq(i2);
    if (r || c)
      return;
    const { ranges: a2 } = i2, l2 = Math.min(...a2.map((b2) => b2.$from.pos)), d = Math.max(...a2.map((b2) => b2.$to.pos)), u = this.shouldShow({
      view: t,
      state: o,
      from: l2,
      to: d
    }), p5 = typeof Range.prototype.getClientRects > "u";
    if (!this.preventShow && (u || this.preventHide) && !p5) {
      const b2 = this.getSelectionBoundingBox();
      if (b2.height === 0 && b2.width === 0) {
        queueMicrotask(() => {
          const w3 = {
            show: true,
            referencePos: this.getSelectionBoundingBox()
          };
          this.state = w3, this.emitUpdate(), t.dispatch(
            t.state.tr.setSelection(
              TextSelection.create(
                t.state.doc,
                t.state.selection.from + 1,
                t.state.selection.to
              )
            )
          ), t.dispatch(
            t.state.tr.setSelection(
              TextSelection.create(
                t.state.doc,
                t.state.selection.from - 1,
                t.state.selection.to
              )
            )
          );
        });
        return;
      }
      const k2 = {
        show: true,
        referencePos: this.getSelectionBoundingBox()
      };
      (k2.show !== ((m = this.state) == null ? void 0 : m.show) || k2.referencePos.toJSON() !== ((g = this.state) == null ? void 0 : g.referencePos.toJSON())) && (this.state = k2, this.emitUpdate());
      return;
    }
    if ((f2 = this.state) != null && f2.show && !this.preventHide && (!u || this.preventShow || !this.editor.isEditable)) {
      this.state.show = false, this.emitUpdate();
      return;
    }
  }
  destroy() {
    this.pmView.dom.removeEventListener("mousedown", this.viewMousedownHandler), this.pmView.root.removeEventListener("mouseup", this.mouseupHandler), this.pmView.dom.removeEventListener("dragstart", this.dragHandler), this.pmView.dom.removeEventListener("dragover", this.dragHandler), this.pmView.dom.removeEventListener("blur", this.blurHandler), this.pmView.root.removeEventListener("scroll", this.scrollHandler, true);
  }
  getSelectionBoundingBox() {
    const { state: t } = this.pmView, { selection: e } = t, { ranges: o } = e, r = Math.min(...o.map((i2) => i2.$from.pos)), s2 = Math.max(...o.map((i2) => i2.$to.pos));
    if (isNodeSelection(e)) {
      const i2 = this.pmView.nodeDOM(r);
      if (i2)
        return i2.getBoundingClientRect();
    }
    return posToDOMRect(this.pmView, r, s2);
  }
};
var nr2 = new PluginKey(
  "FormattingToolbarPlugin"
);
var rr2 = class extends Sn {
  constructor(e) {
    super();
    h3(this, "view");
    h3(this, "closeMenu", () => this.view.closeMenu());
    this.addProsemirrorPlugin(
      new Plugin({
        key: nr2,
        view: (o) => (this.view = new or2(e, o, (r) => {
          this.emit("update", r);
        }), this.view),
        props: {
          handleKeyDown: (o, r) => r.key === "Escape" && this.shown ? (this.view.closeMenu(), true) : false
        }
      })
    );
  }
  static key() {
    return "formattingToolbar";
  }
  get shown() {
    var e, o;
    return ((o = (e = this.view) == null ? void 0 : e.state) == null ? void 0 : o.show) || false;
  }
  onUpdate(e) {
    return this.on("update", e);
  }
};
var sr2 = Node3.create({
  name: "hardBreak",
  inline: true,
  group: "inline",
  selectable: false,
  linebreakReplacement: true,
  priority: 10,
  parseHTML() {
    return [{ tag: "br" }];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["br", mergeAttributes(this.options.HTMLAttributes, n)];
  },
  renderText() {
    return `
`;
  }
});
var et2 = (n, t) => {
  const e = n.resolve(t);
  if (e.depth <= 1)
    return;
  const o = e.posAtIndex(
    e.index(e.depth - 1),
    e.depth - 1
  );
  return Zt(
    n.resolve(o)
  );
};
var pe2 = (n, t) => {
  const e = n.resolve(t), o = e.index();
  if (o === 0)
    return;
  const r = e.posAtIndex(o - 1);
  return Zt(
    n.resolve(r)
  );
};
var Dt2 = (n, t) => {
  for (; t.childContainer; ) {
    const e = t.childContainer.node, o = n.resolve(t.childContainer.beforePos + 1).posAtIndex(e.childCount - 1);
    t = Zt(n.resolve(o));
  }
  return t;
};
var ir2 = (n, t) => n.isBlockContainer && n.blockContent.node.type.spec.content === "inline*" && n.blockContent.node.childCount > 0 && t.isBlockContainer && t.blockContent.node.type.spec.content === "inline*";
var ar2 = (n, t, e, o) => {
  if (!o.isBlockContainer)
    throw new Error(
      `Attempted to merge block at position ${o.bnBlock.beforePos} into previous block at position ${e.bnBlock.beforePos}, but next block is not a block container`
    );
  if (o.childContainer) {
    const r = n.doc.resolve(
      o.childContainer.beforePos + 1
    ), s2 = n.doc.resolve(
      o.childContainer.afterPos - 1
    ), i2 = r.blockRange(s2);
    if (t) {
      const c = n.doc.resolve(o.bnBlock.beforePos);
      n.tr.lift(i2, c.depth);
    }
  }
  if (t) {
    if (!e.isBlockContainer)
      throw new Error(
        `Attempted to merge block at position ${o.bnBlock.beforePos} into previous block at position ${e.bnBlock.beforePos}, but previous block is not a block container`
      );
    t(
      n.tr.delete(
        e.blockContent.afterPos - 1,
        o.blockContent.beforePos + 1
      )
    );
  }
  return true;
};
var tt2 = (n) => ({
  state: t,
  dispatch: e
}) => {
  const o = t.doc.resolve(n), r = Zt(o), s2 = pe2(
    t.doc,
    r.bnBlock.beforePos
  );
  if (!s2)
    return false;
  const i2 = Dt2(
    t.doc,
    s2
  );
  return ir2(i2, r) ? ar2(t, e, i2, r) : false;
};
function cr2(n, t, e) {
  const { $from: o, $to: r } = n.selection, s2 = o.blockRange(
    r,
    (g) => g.childCount > 0 && (g.type.name === "blockGroup" || g.type.name === "column")
    // change necessary to not look at first item child type
  );
  if (!s2)
    return false;
  const i2 = s2.startIndex;
  if (i2 === 0)
    return false;
  const a2 = s2.parent.child(i2 - 1);
  if (a2.type !== t)
    return false;
  const l2 = a2.lastChild && a2.lastChild.type === e, d = Fragment.from(l2 ? t.create() : null), u = new Slice(
    Fragment.from(
      t.create(null, Fragment.from(e.create(null, d)))
      // change necessary to create "groupType" instead of parent.type
    ),
    l2 ? 3 : 1,
    0
  ), p5 = s2.start, m = s2.end;
  return n.step(
    new ReplaceAroundStep(
      p5 - (l2 ? 3 : 1),
      m,
      p5,
      m,
      u,
      1,
      true
    )
  ).scrollIntoView(), true;
}
function At(n) {
  return n.transact((t) => cr2(
    t,
    n.pmSchema.nodes.blockContainer,
    n.pmSchema.nodes.blockGroup
  ));
}
function lr2(n) {
  n._tiptapEditor.commands.liftListItem("blockContainer");
}
function dr2(n) {
  return n.transact((t) => {
    const { bnBlock: e } = Gt(t);
    return t.doc.resolve(e.beforePos).nodeBefore !== null;
  });
}
function hr3(n) {
  return n.transact((t) => {
    const { bnBlock: e } = Gt(t);
    return t.doc.resolve(e.beforePos).depth > 1;
  });
}
var ur2 = Extension.create({
  priority: 50,
  // TODO: The shortcuts need a refactor. Do we want to use a command priority
  //  design as there is now, or clump the logic into a single function?
  addKeyboardShortcuts() {
    const n = () => this.editor.commands.first(({ chain: o, commands: r }) => [
      // Deletes the selection if it's not empty.
      () => r.deleteSelection(),
      // Undoes an input rule if one was triggered in the last editor state change.
      () => r.undoInputRule(),
      // Reverts block content type to a paragraph if the selection is at the start of the block.
      () => r.command(({ state: s2 }) => {
        const i2 = Ge(s2);
        if (!i2.isBlockContainer)
          return false;
        const c = s2.selection.from === i2.blockContent.beforePos + 1, a2 = i2.blockContent.node.type.name === "paragraph";
        return c && !a2 ? r.command(
          nr(i2.bnBlock.beforePos, {
            type: "paragraph",
            props: {}
          })
        ) : false;
      }),
      // Removes a level of nesting if the block is indented if the selection is at the start of the block.
      () => r.command(({ state: s2 }) => {
        const i2 = Ge(s2);
        if (!i2.isBlockContainer)
          return false;
        const { blockContent: c } = i2;
        return s2.selection.from === c.beforePos + 1 ? r.liftListItem("blockContainer") : false;
      }),
      // Merges block with the previous one if it isn't indented, and the selection is at the start of the
      // block. The target block for merging must contain inline content.
      () => r.command(({ state: s2 }) => {
        const i2 = Ge(s2);
        if (!i2.isBlockContainer)
          return false;
        const { bnBlock: c, blockContent: a2 } = i2, l2 = s2.selection.from === a2.beforePos + 1, d = s2.selection.empty, u = c.beforePos;
        return l2 && d ? o().command(tt2(u)).scrollIntoView().run() : false;
      }),
      () => r.command(({ state: s2, dispatch: i2 }) => {
        const c = Ge(s2);
        if (!c.isBlockContainer || !(s2.selection.from === c.blockContent.beforePos + 1) || pe2(
          s2.doc,
          c.bnBlock.beforePos
        ))
          return false;
        const d = et2(
          s2.doc,
          c.bnBlock.beforePos
        );
        if ((d == null ? void 0 : d.blockNoteType) !== "column")
          return false;
        const u = d, p5 = et2(
          s2.doc,
          u.bnBlock.beforePos
        );
        if ((p5 == null ? void 0 : p5.blockNoteType) !== "columnList")
          throw new Error("parent of column is not a column list");
        const m = u.childContainer.node.childCount === 1, g = m && p5.childContainer.node.childCount === 2, f2 = p5.childContainer.node.firstChild === u.bnBlock.node;
        if (i2) {
          const b2 = s2.doc.slice(
            c.bnBlock.beforePos,
            c.bnBlock.afterPos,
            false
          );
          if (g)
            if (f2) {
              s2.tr.step(
                new ReplaceAroundStep(
                  // replace entire column list
                  p5.bnBlock.beforePos,
                  p5.bnBlock.afterPos,
                  // select content of remaining column:
                  u.bnBlock.afterPos + 1,
                  p5.bnBlock.afterPos - 2,
                  b2,
                  b2.size,
                  // append existing content to blockToMove
                  false
                )
              );
              const k2 = s2.tr.doc.resolve(u.bnBlock.beforePos);
              s2.tr.setSelection(TextSelection.between(k2, k2));
            } else {
              s2.tr.step(
                new ReplaceAroundStep(
                  // replace entire column list
                  p5.bnBlock.beforePos,
                  p5.bnBlock.afterPos,
                  // select content of existing column:
                  p5.bnBlock.beforePos + 2,
                  u.bnBlock.beforePos - 1,
                  b2,
                  0,
                  // prepend existing content to blockToMove
                  false
                )
              );
              const k2 = s2.tr.doc.resolve(
                s2.tr.mapping.map(u.bnBlock.beforePos - 1)
              );
              s2.tr.setSelection(TextSelection.between(k2, k2));
            }
          else if (m)
            if (f2) {
              s2.tr.delete(
                u.bnBlock.beforePos,
                u.bnBlock.afterPos
              ), s2.tr.insert(
                p5.bnBlock.beforePos,
                b2.content
              );
              const k2 = s2.tr.doc.resolve(
                p5.bnBlock.beforePos
              );
              s2.tr.setSelection(TextSelection.between(k2, k2));
            } else
              s2.tr.delete(
                u.bnBlock.beforePos - 1,
                u.bnBlock.beforePos + 1
              );
          else {
            s2.tr.delete(
              c.bnBlock.beforePos,
              c.bnBlock.afterPos
            ), f2 ? s2.tr.insert(
              p5.bnBlock.beforePos - 1,
              b2.content
            ) : s2.tr.insert(
              u.bnBlock.beforePos - 1,
              b2.content
            );
            const k2 = s2.tr.doc.resolve(u.bnBlock.beforePos - 1);
            s2.tr.setSelection(TextSelection.between(k2, k2));
          }
        }
        return true;
      }),
      // Deletes the current block if it's an empty block with inline content,
      // and moves the selection to the previous block.
      () => r.command(({ state: s2 }) => {
        const i2 = Ge(s2);
        if (!i2.isBlockContainer)
          return false;
        if (i2.blockContent.node.childCount === 0 && i2.blockContent.node.type.spec.content === "inline*") {
          const a2 = pe2(
            s2.doc,
            i2.bnBlock.beforePos
          );
          if (!a2 || !a2.isBlockContainer)
            return false;
          let l2 = o();
          if (a2.blockContent.node.type.spec.content === "tableRow+") {
            const g = i2.bnBlock.beforePos - 1 - 1 - 1 - 1 - 1;
            l2 = l2.setTextSelection(
              g
            );
          } else if (a2.blockContent.node.type.spec.content === "") {
            const d = a2.blockContent.afterPos - a2.blockContent.node.nodeSize;
            l2 = l2.setNodeSelection(
              d
            );
          } else {
            const d = a2.blockContent.afterPos - a2.blockContent.node.nodeSize;
            l2 = l2.setTextSelection(d);
          }
          return l2.deleteRange({
            from: i2.bnBlock.beforePos,
            to: i2.bnBlock.afterPos
          }).scrollIntoView().run();
        }
        return false;
      }),
      // Deletes previous block if it contains no content and isn't a table,
      // when the selection is empty and at the start of the block. Moves the
      // current block into the deleted block's place.
      () => r.command(({ state: s2 }) => {
        const i2 = Ge(s2);
        if (!i2.isBlockContainer)
          throw new Error("todo");
        const c = s2.selection.from === i2.blockContent.beforePos + 1, a2 = s2.selection.empty, l2 = pe2(
          s2.doc,
          i2.bnBlock.beforePos
        );
        if (l2 && c && a2) {
          const d = Dt2(
            s2.doc,
            l2
          );
          if (!d.isBlockContainer)
            throw new Error("todo");
          if (d.blockContent.node.type.spec.content === "" || d.blockContent.node.type.spec.content === "inline*" && d.blockContent.node.childCount === 0)
            return o().cut(
              {
                from: i2.bnBlock.beforePos,
                to: i2.bnBlock.afterPos
              },
              d.bnBlock.afterPos
            ).deleteRange({
              from: d.bnBlock.beforePos,
              to: d.bnBlock.afterPos
            }).run();
        }
        return false;
      })
    ]), t = () => this.editor.commands.first(({ commands: o }) => [
      // Deletes the selection if it's not empty.
      () => o.deleteSelection(),
      // Merges block with the next one (at the same nesting level or lower),
      // if one exists, the block has no children, and the selection is at the
      // end of the block.
      () => o.command(({ state: r }) => {
        const s2 = Ge(r);
        if (!s2.isBlockContainer)
          return false;
        const {
          bnBlock: i2,
          blockContent: c,
          childContainer: a2
        } = s2, { depth: l2 } = r.doc.resolve(i2.beforePos), d = i2.afterPos === r.doc.nodeSize - 3, u = r.selection.from === c.afterPos - 1, p5 = r.selection.empty;
        if (!d && u && p5 && !(a2 !== void 0)) {
          let g = l2, f2 = i2.afterPos + 1, b2 = r.doc.resolve(f2).depth;
          for (; b2 < g; )
            g = b2, f2 += 2, b2 = r.doc.resolve(f2).depth;
          return o.command(tt2(f2 - 1));
        }
        return false;
      })
    ]), e = (o = false) => this.editor.commands.first(({ commands: r, tr: s2 }) => [
      // Removes a level of nesting if the block is empty & indented, while the selection is also empty & at the start
      // of the block.
      () => r.command(({ state: i2 }) => {
        const c = Ge(i2);
        if (!c.isBlockContainer)
          return false;
        const { bnBlock: a2, blockContent: l2 } = c, { depth: d } = i2.doc.resolve(a2.beforePos), u = i2.selection.$anchor.parentOffset === 0, p5 = i2.selection.anchor === i2.selection.head, m = l2.node.childCount === 0, g = d > 1;
        return u && p5 && m && g ? r.liftListItem("blockContainer") : false;
      }),
      // Creates a hard break if block is configured to do so.
      () => r.command(({ state: i2 }) => {
        var l2;
        const c = Ge(i2), a2 = ((l2 = this.options.editor.schema.blockSchema[c.blockNoteType].meta) == null ? void 0 : l2.hardBreakShortcut) ?? "shift+enter";
        if (a2 === "none")
          return false;
        if (
          // If shortcut is not configured, or is configured as "shift+enter",
          // create a hard break for shift+enter, but not for enter.
          a2 === "shift+enter" && o || // If shortcut is configured as "enter", create a hard break for
          // both enter and shift+enter.
          a2 === "enter"
        ) {
          const d = s2.storedMarks || s2.selection.$head.marks().filter(
            (u) => this.editor.extensionManager.splittableMarks.includes(
              u.type.name
            )
          );
          return s2.insert(
            s2.selection.head,
            s2.doc.type.schema.nodes.hardBreak.create()
          ).ensureMarks(d), true;
        }
        return false;
      }),
      // Creates a new block and moves the selection to it if the current one is empty, while the selection is also
      // empty & at the start of the block.
      () => r.command(({ state: i2, dispatch: c }) => {
        const a2 = Ge(i2);
        if (!a2.isBlockContainer)
          return false;
        const { bnBlock: l2, blockContent: d } = a2, u = i2.selection.$anchor.parentOffset === 0, p5 = i2.selection.anchor === i2.selection.head, m = d.node.childCount === 0;
        if (u && p5 && m) {
          const g = l2.afterPos, f2 = g + 2;
          if (c) {
            const b2 = i2.schema.nodes.blockContainer.createAndFill();
            i2.tr.insert(g, b2).scrollIntoView(), i2.tr.setSelection(
              new TextSelection(i2.doc.resolve(f2))
            );
          }
          return true;
        }
        return false;
      }),
      // Splits the current block, moving content inside that's after the cursor to a new text block below. Also
      // deletes the selection beforehand, if it's not empty.
      () => r.command(({ state: i2, chain: c }) => {
        const a2 = Ge(i2);
        if (!a2.isBlockContainer)
          return false;
        const { blockContent: l2 } = a2, d = i2.selection.$anchor.parentOffset === 0;
        return l2.node.childCount === 0 ? false : (c().deleteSelection().command(
          cr(
            i2.selection.from,
            d,
            d
          )
        ).run(), true);
      })
    ]);
    return {
      Backspace: n,
      Delete: t,
      Enter: () => e(),
      "Shift-Enter": () => e(true),
      // Always returning true for tab key presses ensures they're not captured by the browser. Otherwise, they blur the
      // editor since the browser will try to use tab for keyboard navigation.
      Tab: () => {
        var o, r, s2;
        return this.options.tabBehavior !== "prefer-indent" && ((o = this.options.editor.formattingToolbar) != null && o.shown || (r = this.options.editor.linkToolbar) != null && r.shown || (s2 = this.options.editor.filePanel) != null && s2.shown) ? false : At(this.options.editor);
      },
      "Shift-Tab": () => {
        var o, r, s2;
        return this.options.tabBehavior !== "prefer-indent" && ((o = this.options.editor.formattingToolbar) != null && o.shown || (r = this.options.editor.linkToolbar) != null && r.shown || (s2 = this.options.editor.filePanel) != null && s2.shown) ? false : (this.editor.commands.liftListItem("blockContainer"), true);
      },
      "Shift-Mod-ArrowUp": () => (this.options.editor.moveBlocksUp(), true),
      "Shift-Mod-ArrowDown": () => (this.options.editor.moveBlocksDown(), true),
      "Mod-z": () => this.options.editor.undo(),
      "Mod-y": () => this.options.editor.redo(),
      "Shift-Mod-z": () => this.options.editor.redo()
    };
  }
});
var pr2 = class {
  constructor(t, e, o) {
    h3(this, "state");
    h3(this, "emitUpdate");
    h3(this, "menuUpdateTimer");
    h3(this, "startMenuUpdateTimer");
    h3(this, "stopMenuUpdateTimer");
    h3(this, "mouseHoveredLinkMark");
    h3(this, "mouseHoveredLinkMarkRange");
    h3(this, "keyboardHoveredLinkMark");
    h3(this, "keyboardHoveredLinkMarkRange");
    h3(this, "linkMark");
    h3(this, "linkMarkRange");
    h3(this, "mouseOverHandler", (t2) => {
      if (this.mouseHoveredLinkMark = void 0, this.mouseHoveredLinkMarkRange = void 0, this.stopMenuUpdateTimer(), t2.target instanceof HTMLAnchorElement && t2.target.nodeName === "A") {
        const e2 = t2.target, o2 = this.pmView.posAtDOM(e2, 0) + 1, r = this.pmView.state.doc.resolve(o2), s2 = r.marks();
        for (const i2 of s2)
          if (i2.type.name === this.pmView.state.schema.mark("link").type.name) {
            this.mouseHoveredLinkMark = i2, this.mouseHoveredLinkMarkRange = getMarkRange(r, i2.type, i2.attrs) || void 0;
            break;
          }
      }
      return this.startMenuUpdateTimer(), false;
    });
    h3(this, "clickHandler", (t2) => {
      var o2;
      const e2 = this.pmView.dom.parentElement;
      this.linkMark && // An element is clicked.
      t2 && t2.target && // The clicked element is not the editor.
      !(e2 === t2.target || e2.contains(t2.target)) && (o2 = this.state) != null && o2.show && (this.state.show = false, this.emitUpdate());
    });
    h3(this, "scrollHandler", () => {
      var t2;
      this.linkMark !== void 0 && (t2 = this.state) != null && t2.show && (this.state.referencePos = posToDOMRect(
        this.pmView,
        this.linkMarkRange.from,
        this.linkMarkRange.to
      ), this.emitUpdate());
    });
    h3(this, "closeMenu", () => {
      var t2;
      (t2 = this.state) != null && t2.show && (this.state.show = false, this.emitUpdate());
    });
    this.editor = t, this.pmView = e, this.emitUpdate = () => {
      if (!this.state)
        throw new Error("Attempting to update uninitialized link toolbar");
      o(this.state);
    }, this.startMenuUpdateTimer = () => {
      this.menuUpdateTimer = setTimeout(() => {
        this.update(this.pmView, void 0, true);
      }, 250);
    }, this.stopMenuUpdateTimer = () => (this.menuUpdateTimer && (clearTimeout(this.menuUpdateTimer), this.menuUpdateTimer = void 0), false), this.pmView.dom.addEventListener("mouseover", this.mouseOverHandler), this.pmView.root.addEventListener(
      "click",
      this.clickHandler,
      true
    ), this.pmView.root.addEventListener("scroll", this.scrollHandler, true);
  }
  editLink(t, e) {
    var o;
    this.editor.transact((r) => {
      const s2 = G(r);
      r.insertText(e, this.linkMarkRange.from, this.linkMarkRange.to), r.addMark(
        this.linkMarkRange.from,
        this.linkMarkRange.from + e.length,
        s2.mark("link", { href: t })
      );
    }), this.pmView.focus(), (o = this.state) != null && o.show && (this.state.show = false, this.emitUpdate());
  }
  deleteLink() {
    var t;
    this.editor.transact(
      (e) => e.removeMark(
        this.linkMarkRange.from,
        this.linkMarkRange.to,
        this.linkMark.type
      ).setMeta("preventAutolink", true)
    ), this.pmView.focus(), (t = this.state) != null && t.show && (this.state.show = false, this.emitUpdate());
  }
  update(t, e, o = false) {
    var c;
    const { state: r } = t;
    if (e && e.selection.from === r.selection.from && e.selection.to === r.selection.to || !this.pmView.hasFocus())
      return;
    const i2 = this.linkMark;
    if (this.linkMark = void 0, this.linkMarkRange = void 0, this.keyboardHoveredLinkMark = void 0, this.keyboardHoveredLinkMarkRange = void 0, this.pmView.state.selection.empty) {
      const a2 = this.pmView.state.selection.$from.marks();
      for (const l2 of a2)
        if (l2.type.name === this.pmView.state.schema.mark("link").type.name) {
          this.keyboardHoveredLinkMark = l2, this.keyboardHoveredLinkMarkRange = getMarkRange(
            this.pmView.state.selection.$from,
            l2.type,
            l2.attrs
          ) || void 0;
          break;
        }
    }
    if (this.mouseHoveredLinkMark && o && (this.linkMark = this.mouseHoveredLinkMark, this.linkMarkRange = this.mouseHoveredLinkMarkRange), this.keyboardHoveredLinkMark && (this.linkMark = this.keyboardHoveredLinkMark, this.linkMarkRange = this.keyboardHoveredLinkMarkRange), this.linkMark && this.editor.isEditable) {
      this.state = {
        show: true,
        referencePos: posToDOMRect(
          this.pmView,
          this.linkMarkRange.from,
          this.linkMarkRange.to
        ),
        url: this.linkMark.attrs.href,
        text: this.pmView.state.doc.textBetween(
          this.linkMarkRange.from,
          this.linkMarkRange.to
        )
      }, this.emitUpdate();
      return;
    }
    if ((c = this.state) != null && c.show && i2 && (!this.linkMark || !this.editor.isEditable)) {
      this.state.show = false, this.emitUpdate();
      return;
    }
  }
  destroy() {
    this.pmView.dom.removeEventListener("mouseover", this.mouseOverHandler), this.pmView.root.removeEventListener("scroll", this.scrollHandler, true), this.pmView.root.removeEventListener(
      "click",
      this.clickHandler,
      true
    );
  }
};
var mr2 = new PluginKey("LinkToolbarPlugin");
var fr2 = class extends Sn {
  constructor(e) {
    super();
    h3(this, "view");
    h3(this, "editLink", (e2, o) => {
      this.view.editLink(e2, o);
    });
    h3(this, "deleteLink", () => {
      this.view.deleteLink();
    });
    h3(this, "startHideTimer", () => {
      this.view.startMenuUpdateTimer();
    });
    h3(this, "stopHideTimer", () => {
      this.view.stopMenuUpdateTimer();
    });
    h3(this, "closeMenu", () => this.view.closeMenu());
    this.addProsemirrorPlugin(
      new Plugin({
        key: mr2,
        view: (o) => (this.view = new pr2(e, o, (r) => {
          this.emit("update", r);
        }), this.view),
        props: {
          handleKeyDown: (o, r) => r.key === "Escape" && this.shown ? (this.view.closeMenu(), true) : false
        }
      })
    );
  }
  static key() {
    return "linkToolbar";
  }
  onUpdate(e) {
    return this.on("update", e);
  }
  get shown() {
    var e, o;
    return ((o = (e = this.view) == null ? void 0 : e.state) == null ? void 0 : o.show) || false;
  }
};
var gr2 = [
  "http",
  "https",
  "ftp",
  "ftps",
  "mailto",
  "tel",
  "callto",
  "sms",
  "cid",
  "xmpp"
];
var br4 = "https";
var kr2 = new PluginKey("node-selection-keyboard");
var wr = class extends Sn {
  static key() {
    return "nodeSelectionKeyboard";
  }
  constructor() {
    super(), this.addProsemirrorPlugin(
      new Plugin({
        key: kr2,
        props: {
          handleKeyDown: (t, e) => {
            if ("node" in t.state.selection) {
              if (e.ctrlKey || e.metaKey)
                return false;
              if (e.key.length === 1)
                return e.preventDefault(), true;
              if (e.key === "Enter" && !e.shiftKey && !e.altKey && !e.ctrlKey && !e.metaKey) {
                const o = t.state.tr;
                return t.dispatch(
                  o.insert(
                    t.state.tr.selection.$to.after(),
                    t.state.schema.nodes.paragraph.createChecked()
                  ).setSelection(
                    new TextSelection(
                      o.doc.resolve(t.state.tr.selection.$to.after() + 1)
                    )
                  )
                ), true;
              }
            }
            return false;
          }
        }
      })
    );
  }
};
var yr = new PluginKey("blocknote-placeholder");
var Cr = class extends Sn {
  static key() {
    return "placeholder";
  }
  constructor(t, e) {
    super(), this.addProsemirrorPlugin(
      new Plugin({
        key: yr,
        view: (o) => {
          const r = `placeholder-selector-${v4_default()}`;
          o.dom.classList.add(r);
          const s2 = document.createElement("style"), i2 = t._tiptapEditor.options.injectNonce;
          i2 && s2.setAttribute("nonce", i2), o.root instanceof window.ShadowRoot ? o.root.append(s2) : o.root.head.appendChild(s2);
          const c = s2.sheet, a2 = (l2 = "") => `.${r} .bn-block-content${l2} .bn-inline-content:has(> .ProseMirror-trailingBreak:only-child):before`;
          try {
            const {
              default: l2,
              emptyDocument: d,
              ...u
            } = e;
            for (const [g, f2] of Object.entries(u)) {
              const b2 = `[data-content-type="${g}"]`;
              c.insertRule(
                `${a2(b2)} { content: ${JSON.stringify(
                  f2
                )}; }`
              );
            }
            const p5 = "[data-is-only-empty-block]", m = "[data-is-empty-and-focused]";
            c.insertRule(
              `${a2(p5)} { content: ${JSON.stringify(
                d
              )}; }`
            ), c.insertRule(
              `${a2(m)} { content: ${JSON.stringify(
                l2
              )}; }`
            );
          } catch (l2) {
            console.warn(
              "Failed to insert placeholder CSS rule - this is likely due to the browser not supporting certain CSS pseudo-element selectors (:has, :only-child:, or :before)",
              l2
            );
          }
          return {
            destroy: () => {
              o.root instanceof window.ShadowRoot ? o.root.removeChild(s2) : o.root.head.removeChild(s2);
            }
          };
        },
        props: {
          decorations: (o) => {
            const { doc: r, selection: s2 } = o;
            if (!t.isEditable || !s2.empty || s2.$from.parent.type.spec.code)
              return;
            const i2 = [];
            o.doc.content.size === 6 && i2.push(
              Decoration.node(2, 4, {
                "data-is-only-empty-block": "true"
              })
            );
            const c = s2.$anchor, a2 = c.parent;
            if (a2.content.size === 0) {
              const l2 = c.before();
              i2.push(
                Decoration.node(l2, l2 + a2.nodeSize, {
                  "data-is-empty-and-focused": "true"
                })
              );
            }
            return DecorationSet.create(r, i2);
          }
        }
      })
    );
  }
};
var ot2 = new PluginKey("previous-blocks");
var vr = {
  // Numbered List Items
  index: "index",
  // Headings
  level: "level",
  // All Blocks
  type: "type",
  depth: "depth",
  "depth-change": "depth-change"
};
var Sr = class extends Sn {
  static key() {
    return "previousBlockType";
  }
  constructor() {
    super();
    let t;
    this.addProsemirrorPlugin(
      new Plugin({
        key: ot2,
        view(e) {
          return {
            update: async (o, r) => {
              var s2;
              ((s2 = this.key) == null ? void 0 : s2.getState(o.state).updatedBlocks.size) > 0 && (t = setTimeout(() => {
                o.dispatch(
                  o.state.tr.setMeta(ot2, { clearUpdate: true })
                );
              }, 0));
            },
            destroy: () => {
              t && clearTimeout(t);
            }
          };
        },
        state: {
          init() {
            return {
              // Block attributes, by block ID, from just before the previous transaction.
              prevTransactionOldBlockAttrs: {},
              // Block attributes, by block ID, from just before the current transaction.
              currentTransactionOldBlockAttrs: {},
              // Set of IDs of blocks whose attributes changed from the current transaction.
              updatedBlocks: /* @__PURE__ */ new Set()
            };
          },
          apply(e, o, r, s2) {
            if (o.currentTransactionOldBlockAttrs = {}, o.updatedBlocks.clear(), !e.docChanged || r.doc.eq(s2.doc))
              return o;
            const i2 = {}, c = findChildren(
              r.doc,
              (d) => d.attrs.id
            ), a2 = new Map(
              c.map((d) => [d.node.attrs.id, d])
            ), l2 = findChildren(
              s2.doc,
              (d) => d.attrs.id
            );
            for (const d of l2) {
              const u = a2.get(d.node.attrs.id), p5 = u == null ? void 0 : u.node.firstChild, m = d.node.firstChild;
              if (u && p5 && m) {
                const g = {
                  index: m.attrs.index,
                  level: m.attrs.level,
                  type: m.type.name,
                  depth: s2.doc.resolve(d.pos).depth
                }, f2 = {
                  index: p5.attrs.index,
                  level: p5.attrs.level,
                  type: p5.type.name,
                  depth: r.doc.resolve(u.pos).depth
                };
                i2[d.node.attrs.id] = f2, o.currentTransactionOldBlockAttrs[d.node.attrs.id] = f2, JSON.stringify(f2) !== JSON.stringify(g) && (f2["depth-change"] = f2.depth - g.depth, o.updatedBlocks.add(d.node.attrs.id));
              }
            }
            return o.prevTransactionOldBlockAttrs = i2, o;
          }
        },
        props: {
          decorations(e) {
            const o = this.getState(e);
            if (o.updatedBlocks.size === 0)
              return;
            const r = [];
            return e.doc.descendants((s2, i2) => {
              if (!s2.attrs.id || !o.updatedBlocks.has(s2.attrs.id))
                return;
              const c = o.currentTransactionOldBlockAttrs[s2.attrs.id], a2 = {};
              for (const [d, u] of Object.entries(c))
                a2["data-prev-" + vr[d]] = u || "none";
              const l2 = Decoration.node(i2, i2 + s2.nodeSize, {
                ...a2
              });
              r.push(l2);
            }), DecorationSet.create(e.doc, r);
          }
        }
      })
    );
  }
};
var nt2 = new PluginKey("blocknote-show-selection");
var Br = class extends Sn {
  constructor(e) {
    super();
    h3(this, "enabled", false);
    this.editor = e, this.addProsemirrorPlugin(
      new Plugin({
        key: nt2,
        props: {
          decorations: (o) => {
            const { doc: r, selection: s2 } = o;
            if (!this.enabled)
              return DecorationSet.empty;
            const i2 = Decoration.inline(s2.from, s2.to, {
              "data-show-selection": "true"
            });
            return DecorationSet.create(r, [i2]);
          }
        }
      })
    );
  }
  static key() {
    return "showSelection";
  }
  setEnabled(e) {
    this.enabled !== e && (this.enabled = e, this.editor.transact((o) => o.setMeta(nt2, {})));
  }
  getEnabled() {
    return this.enabled;
  }
};
function _t2(n, t) {
  var e, o;
  for (; n && n.parentElement && n.parentElement !== t.dom && ((e = n.getAttribute) == null ? void 0 : e.call(n, "data-node-type")) !== "blockContainer"; )
    n = n.parentElement;
  if (((o = n.getAttribute) == null ? void 0 : o.call(n, "data-node-type")) === "blockContainer")
    return { node: n, id: n.getAttribute("data-id") };
}
var z2 = class _z extends Selection {
  constructor(e, o) {
    super(e, o);
    h3(this, "nodes");
    const r = e.node();
    this.nodes = [], e.doc.nodesBetween(e.pos, o.pos, (s2, i2, c) => {
      if (c !== null && c.eq(r))
        return this.nodes.push(s2), false;
    });
  }
  static create(e, o, r = o) {
    return new _z(e.resolve(o), e.resolve(r));
  }
  content() {
    return new Slice(Fragment.from(this.nodes), 0, 0);
  }
  eq(e) {
    if (!(e instanceof _z) || this.nodes.length !== e.nodes.length || this.from !== e.from || this.to !== e.to)
      return false;
    for (let o = 0; o < this.nodes.length; o++)
      if (!this.nodes[o].eq(e.nodes[o]))
        return false;
    return true;
  }
  map(e, o) {
    const r = o.mapResult(this.from), s2 = o.mapResult(this.to);
    return s2.deleted ? Selection.near(e.resolve(r.pos)) : r.deleted ? Selection.near(e.resolve(s2.pos)) : new _z(
      e.resolve(r.pos),
      e.resolve(s2.pos)
    );
  }
  toJSON() {
    return { type: "multiple-node", anchor: this.anchor, head: this.head };
  }
};
Selection.jsonID("multiple-node", z2);
var N2;
function Er(n, t) {
  let e, o;
  const r = t.resolve(n.from).node().type.spec.group === "blockContent", s2 = t.resolve(n.to).node().type.spec.group === "blockContent", i2 = Math.min(n.$anchor.depth, n.$head.depth);
  if (r && s2) {
    const c = n.$from.start(i2 - 1), a2 = n.$to.end(i2 - 1);
    e = t.resolve(c - 1).pos, o = t.resolve(a2 + 1).pos;
  } else
    e = n.from, o = n.to;
  return { from: e, to: o };
}
function rt2(n, t, e = t) {
  t === e && (e += n.state.doc.resolve(t + 1).node().nodeSize);
  const o = n.domAtPos(t).node.cloneNode(true), r = n.domAtPos(t).node, s2 = (u, p5) => Array.prototype.indexOf.call(u.children, p5), i2 = s2(
    r,
    // Expects from position to be just before the first selected block.
    n.domAtPos(t + 1).node.parentElement
  ), c = s2(
    r,
    // Expects to position to be just after the last selected block.
    n.domAtPos(e - 1).node.parentElement
  );
  for (let u = r.childElementCount - 1; u >= 0; u--)
    (u > c || u < i2) && o.removeChild(o.children[u]);
  Ot(n.root), N2 = o;
  const a2 = N2.getElementsByTagName("iframe");
  for (let u = 0; u < a2.length; u++) {
    const p5 = a2[u], m = p5.parentElement;
    m && m.removeChild(p5);
  }
  const d = n.dom.className.split(" ").filter(
    (u) => u !== "ProseMirror" && u !== "bn-root" && u !== "bn-editor"
  ).join(" ");
  N2.className = N2.className + " bn-drag-preview " + d, n.root instanceof ShadowRoot ? n.root.appendChild(N2) : n.root.body.appendChild(N2);
}
function Ot(n) {
  N2 !== void 0 && (n instanceof ShadowRoot ? n.removeChild(N2) : n.body.removeChild(N2), N2 = void 0);
}
function Mr(n, t, e) {
  if (!n.dataTransfer || e.headless)
    return;
  const o = e.prosemirrorView, r = un(t.id, o.state.doc);
  if (!r)
    throw new Error(`Block with ID ${t.id} not found`);
  const s2 = r.posBeforeNode;
  if (s2 != null) {
    const i2 = o.state.selection, c = o.state.doc, { from: a2, to: l2 } = Er(i2, c), d = a2 <= s2 && s2 < l2, u = i2.$anchor.node() !== i2.$head.node() || i2 instanceof z2;
    d && u ? (o.dispatch(
      o.state.tr.setSelection(z2.create(c, a2, l2))
    ), rt2(o, a2, l2)) : (o.dispatch(
      o.state.tr.setSelection(NodeSelection.create(o.state.doc, s2))
    ), rt2(o, s2));
    const p5 = o.state.selection.content(), m = e.pmSchema, g = o.serializeForClipboard(p5).dom.innerHTML, f2 = Se(m, e), b2 = Pt(p5.content), k2 = f2.exportBlocks(b2, {}), w3 = He2(k2);
    n.dataTransfer.clearData(), n.dataTransfer.setData("blocknote/html", g), n.dataTransfer.setData("text/html", k2), n.dataTransfer.setData("text/plain", w3), n.dataTransfer.effectAllowed = "move", n.dataTransfer.setDragImage(N2, 0, 0);
  }
}
var st2 = 250;
function Ie2(n, t, e = true) {
  const o = n.root.elementsFromPoint(t.left, t.top);
  for (const r of o)
    if (n.dom.contains(r))
      return e && r.closest("[data-node-type=columnList]") ? Ie2(
        n,
        {
          // TODO can we do better than this?
          left: t.left + 50,
          // bit hacky, but if we're inside a column, offset x position to right to account for the width of sidemenu itself
          top: t.top
        },
        false
      ) : _t2(r, n);
}
function Pr(n, t) {
  if (!t.dom.firstChild)
    return;
  const e = t.dom.firstChild.getBoundingClientRect(), o = {
    // Clamps the x position to the editor's bounding box.
    left: Math.min(
      Math.max(e.left + 10, n.x),
      e.right - 10
    ),
    top: n.y
  }, r = Ie2(t, o);
  if (!r)
    return;
  const s2 = r.node.getBoundingClientRect();
  return Ie2(
    t,
    {
      left: s2.right - 10,
      top: n.y
    },
    false
  );
}
var Tr = class {
  constructor(t, e, o) {
    h3(this, "state");
    h3(this, "emitUpdate");
    h3(this, "mousePos");
    h3(this, "hoveredBlock");
    h3(this, "menuFrozen", false);
    h3(this, "isDragOrigin", false);
    h3(this, "updateState", (t2) => {
      this.state = t2, this.emitUpdate(this.state);
    });
    h3(this, "updateStateFromMousePos", () => {
      var o2, r, s2, i2, c;
      if (this.menuFrozen || !this.mousePos)
        return;
      const t2 = this.findClosestEditorElement({
        clientX: this.mousePos.x,
        clientY: this.mousePos.y
      });
      if ((t2 == null ? void 0 : t2.element) !== this.pmView.dom || t2.distance > st2) {
        (o2 = this.state) != null && o2.show && (this.state.show = false, this.updateState(this.state));
        return;
      }
      const e2 = Pr(this.mousePos, this.pmView);
      if (!e2 || !this.editor.isEditable) {
        (r = this.state) != null && r.show && (this.state.show = false, this.updateState(this.state));
        return;
      }
      if (!((s2 = this.state) != null && s2.show && ((i2 = this.hoveredBlock) != null && i2.hasAttribute("data-id")) && ((c = this.hoveredBlock) == null ? void 0 : c.getAttribute("data-id")) === e2.id) && (this.hoveredBlock = e2.node, this.editor.isEditable)) {
        const a2 = e2.node.getBoundingClientRect(), l2 = e2.node.closest("[data-node-type=column]");
        this.state = {
          show: true,
          referencePos: new DOMRect(
            l2 ? (
              // We take the first child as column elements have some default
              // padding. This is a little weird since this child element will
              // be the first block, but since it's always non-nested and we
              // only take the x coordinate, it's ok.
              l2.firstElementChild.getBoundingClientRect().x
            ) : this.pmView.dom.firstChild.getBoundingClientRect().x,
            a2.y,
            a2.width,
            a2.height
          ),
          block: this.editor.getBlock(
            this.hoveredBlock.getAttribute("data-id")
          )
        }, this.updateState(this.state);
      }
    });
    h3(this, "onDragStart", (t2) => {
      var i2;
      const e2 = (i2 = t2.dataTransfer) == null ? void 0 : i2.getData("blocknote/html");
      if (!e2 || this.pmView.dragging)
        return;
      const o2 = document.createElement("div");
      o2.innerHTML = e2;
      const s2 = DOMParser2.fromSchema(this.pmView.state.schema).parse(o2, {
        topNode: this.pmView.state.schema.nodes.blockGroup.create()
      });
      this.pmView.dragging = {
        slice: new Slice(s2.content, 0, 0),
        move: true
      };
    });
    h3(this, "findClosestEditorElement", (t2) => {
      const e2 = Array.from(this.pmView.root.querySelectorAll(".bn-editor"));
      if (e2.length === 0)
        return null;
      let o2 = e2[0], r = Number.MAX_VALUE;
      return e2.forEach((s2) => {
        const i2 = s2.querySelector(".bn-block-group").getBoundingClientRect(), c = t2.clientX < i2.left ? i2.left - t2.clientX : t2.clientX > i2.right ? t2.clientX - i2.right : 0, a2 = t2.clientY < i2.top ? i2.top - t2.clientY : t2.clientY > i2.bottom ? t2.clientY - i2.bottom : 0, l2 = Math.sqrt(
          Math.pow(c, 2) + Math.pow(a2, 2)
        );
        l2 < r && (r = l2, o2 = s2);
      }), {
        element: o2,
        distance: r
      };
    });
    h3(this, "onDragOver", (t2) => {
      if (t2.synthetic)
        return;
      const e2 = this.getDragEventContext(t2);
      if (!e2 || !e2.isDropPoint) {
        this.closeDropCursor();
        return;
      }
      e2.isDropPoint && !e2.isDropWithinEditorBounds && this.dispatchSyntheticEvent(t2);
    });
    h3(this, "closeDropCursor", () => {
      const t2 = new Event("dragleave", { bubbles: false });
      t2.synthetic = true, this.pmView.dom.dispatchEvent(t2);
    });
    h3(this, "getDragEventContext", (t2) => {
      var a2;
      const e2 = !((a2 = t2.dataTransfer) != null && a2.types.includes("blocknote/html")) && !!this.pmView.dragging, o2 = !!this.isDragOrigin, r = e2 || o2, s2 = this.findClosestEditorElement(t2);
      if (!s2 || s2.distance > st2)
        return;
      const i2 = s2.element === this.pmView.dom, c = i2 && s2.distance === 0;
      if (!(!i2 && !r))
        return {
          isDropPoint: i2,
          isDropWithinEditorBounds: c,
          isDragOrigin: r
        };
    });
    h3(this, "onDrop", (t2) => {
      if (t2.synthetic)
        return;
      const e2 = this.getDragEventContext(t2);
      if (!e2) {
        this.closeDropCursor();
        return;
      }
      const { isDropPoint: o2, isDropWithinEditorBounds: r, isDragOrigin: s2 } = e2;
      if (!r && o2 && this.dispatchSyntheticEvent(t2), o2) {
        if (this.pmView.dragging)
          return;
        this.pmView.dispatch(
          this.pmView.state.tr.setSelection(
            TextSelection.create(
              this.pmView.state.tr.doc,
              this.pmView.state.tr.selection.anchor
            )
          )
        );
        return;
      } else if (s2) {
        setTimeout(
          () => this.pmView.dispatch(this.pmView.state.tr.deleteSelection()),
          0
        );
        return;
      }
    });
    h3(this, "onDragEnd", (t2) => {
      t2.synthetic || (this.pmView.dragging = null);
    });
    h3(this, "onKeyDown", (t2) => {
      var e2;
      (e2 = this.state) != null && e2.show && this.editor.isFocused() && (this.state.show = false, this.emitUpdate(this.state));
    });
    h3(this, "onMouseMove", (t2) => {
      var s2;
      if (this.menuFrozen)
        return;
      this.mousePos = { x: t2.clientX, y: t2.clientY };
      const e2 = this.pmView.dom.getBoundingClientRect(), o2 = this.mousePos.x > e2.left && this.mousePos.x < e2.right && this.mousePos.y > e2.top && this.mousePos.y < e2.bottom, r = this.pmView.dom.parentElement;
      if (
        // Cursor is within the editor area
        o2 && // An element is hovered
        t2 && t2.target && // Element is outside the editor
        !(r === t2.target || r.contains(t2.target))
      ) {
        (s2 = this.state) != null && s2.show && (this.state.show = false, this.emitUpdate(this.state));
        return;
      }
      this.updateStateFromMousePos();
    });
    h3(this, "onScroll", () => {
      var t2;
      (t2 = this.state) != null && t2.show && (this.state.referencePos = this.hoveredBlock.getBoundingClientRect(), this.emitUpdate(this.state)), this.updateStateFromMousePos();
    });
    this.editor = t, this.pmView = e, this.emitUpdate = () => {
      if (!this.state)
        throw new Error("Attempting to update uninitialized side menu");
      o(this.state);
    }, this.pmView.root.addEventListener(
      "dragstart",
      this.onDragStart
    ), this.pmView.root.addEventListener(
      "dragover",
      this.onDragOver
    ), this.pmView.root.addEventListener(
      "drop",
      this.onDrop,
      true
    ), this.pmView.root.addEventListener(
      "dragend",
      this.onDragEnd,
      true
    ), this.pmView.root.addEventListener(
      "mousemove",
      this.onMouseMove,
      true
    ), this.pmView.root.addEventListener(
      "keydown",
      this.onKeyDown,
      true
    ), e.root.addEventListener("scroll", this.onScroll, true);
  }
  dispatchSyntheticEvent(t) {
    const e = new Event(t.type, t), o = this.pmView.dom.firstChild.getBoundingClientRect();
    e.clientX = t.clientX, e.clientY = t.clientY, e.clientX = Math.min(
      Math.max(t.clientX, o.left),
      o.left + o.width
    ), e.clientY = Math.min(
      Math.max(t.clientY, o.top),
      o.top + o.height
    ), e.dataTransfer = t.dataTransfer, e.preventDefault = () => t.preventDefault(), e.synthetic = true, this.pmView.dom.dispatchEvent(e);
  }
  // Needed in cases where the editor state updates without the mouse cursor
  // moving, as some state updates can require a side menu update. For example,
  // adding a button to the side menu which removes the block can cause the
  // block below to jump up into the place of the removed block when clicked,
  // allowing the user to click the button again without moving the cursor. This
  // would otherwise not update the side menu, and so clicking the button again
  // would attempt to remove the same block again, causing an error.
  update(t, e) {
    var r;
    !e.doc.eq(this.pmView.state.doc) && ((r = this.state) != null && r.show) && this.updateStateFromMousePos();
  }
  destroy() {
    var t;
    (t = this.state) != null && t.show && (this.state.show = false, this.emitUpdate(this.state)), this.pmView.root.removeEventListener(
      "mousemove",
      this.onMouseMove,
      true
    ), this.pmView.root.removeEventListener(
      "dragstart",
      this.onDragStart
    ), this.pmView.root.removeEventListener(
      "dragover",
      this.onDragOver
    ), this.pmView.root.removeEventListener(
      "drop",
      this.onDrop,
      true
    ), this.pmView.root.removeEventListener(
      "dragend",
      this.onDragEnd,
      true
    ), this.pmView.root.removeEventListener(
      "keydown",
      this.onKeyDown,
      true
    ), this.pmView.root.removeEventListener("scroll", this.onScroll, true);
  }
};
var xr = new PluginKey("SideMenuPlugin");
var Ir = class extends Sn {
  constructor(e) {
    super();
    h3(this, "view");
    h3(this, "blockDragStart", (e2, o) => {
      this.view && (this.view.isDragOrigin = true), Mr(e2, o, this.editor);
    });
    h3(this, "blockDragEnd", () => {
      Ot(this.editor.prosemirrorView.root), this.view && (this.view.isDragOrigin = false);
    });
    h3(this, "freezeMenu", () => {
      this.view.menuFrozen = true, this.view.state.show = true, this.view.emitUpdate(this.view.state);
    });
    h3(this, "unfreezeMenu", () => {
      this.view.menuFrozen = false, this.view.state.show = false, this.view.emitUpdate(this.view.state);
    });
    this.editor = e, this.addProsemirrorPlugin(
      new Plugin({
        key: xr,
        view: (o) => (this.view = new Tr(e, o, (r) => {
          this.emit("update", r);
        }), this.view)
      })
    );
  }
  static key() {
    return "sideMenu";
  }
  onUpdate(e) {
    return this.on("update", e);
  }
};
var le2 = /* @__PURE__ */ new Map();
function Lr(n) {
  if (le2.has(n))
    return le2.get(n);
  const t = new Mapping();
  return n._tiptapEditor.on("transaction", ({ transaction: e }) => {
    t.appendMapping(e.mapping);
  }), n._tiptapEditor.on("destroy", () => {
    le2.delete(n);
  }), le2.set(n, t), t;
}
function Dr(n, t, e = "left") {
  const o = ySyncPluginKey.getState(n.prosemirrorState);
  if (!o) {
    const s2 = Lr(n), i2 = s2.maps.length;
    return () => s2.slice(i2).map(t, e === "left" ? -1 : 1);
  }
  const r = absolutePositionToRelativePosition(
    // Track the position after the position if we are on the right side
    t + (e === "right" ? 1 : -1),
    o.binding.type,
    o.binding.mapping
  );
  return () => {
    const s2 = ySyncPluginKey.getState(
      n.prosemirrorState
    ), i2 = relativePositionToAbsolutePosition(
      s2.doc,
      s2.binding.type,
      r,
      s2.binding.mapping
    );
    if (i2 === null)
      throw new Error("Position not found, cannot track positions");
    return i2 + (e === "right" ? -1 : 1);
  };
}
var Ar = findParentNode((n) => n.type.name === "blockContainer");
var _r = class {
  constructor(t, e, o) {
    h3(this, "state");
    h3(this, "emitUpdate");
    h3(this, "rootEl");
    h3(this, "pluginState");
    h3(this, "handleScroll", () => {
      var t2, e2;
      if ((t2 = this.state) != null && t2.show) {
        const o2 = (e2 = this.rootEl) == null ? void 0 : e2.querySelector(
          `[data-decoration-id="${this.pluginState.decorationId}"]`
        );
        if (!o2)
          return;
        this.state.referencePos = o2.getBoundingClientRect(), this.emitUpdate(this.pluginState.triggerCharacter);
      }
    });
    h3(this, "closeMenu", () => {
      this.editor.transact((t2) => t2.setMeta(K3, null));
    });
    h3(this, "clearQuery", () => {
      this.pluginState !== void 0 && this.editor._tiptapEditor.chain().focus().deleteRange({
        from: this.pluginState.queryStartPos() - (this.pluginState.deleteTriggerCharacter ? this.pluginState.triggerCharacter.length : 0),
        to: this.editor.transact((t2) => t2.selection.from)
      }).run();
    });
    var r;
    this.editor = t, this.pluginState = void 0, this.emitUpdate = (s2) => {
      var i2;
      if (!this.state)
        throw new Error("Attempting to update uninitialized suggestions menu");
      e(s2, {
        ...this.state,
        ignoreQueryLength: (i2 = this.pluginState) == null ? void 0 : i2.ignoreQueryLength
      });
    }, this.rootEl = o.root, (r = this.rootEl) == null || r.addEventListener("scroll", this.handleScroll, true);
  }
  update(t, e) {
    var l2;
    const o = K3.getState(e), r = K3.getState(
      t.state
    ), s2 = o === void 0 && r !== void 0, i2 = o !== void 0 && r === void 0;
    if (!s2 && !(o !== void 0 && r !== void 0) && !i2)
      return;
    if (this.pluginState = i2 ? o : r, i2 || !this.editor.isEditable) {
      this.state && (this.state.show = false), this.emitUpdate(this.pluginState.triggerCharacter);
      return;
    }
    const a2 = (l2 = this.rootEl) == null ? void 0 : l2.querySelector(
      `[data-decoration-id="${this.pluginState.decorationId}"]`
    );
    this.editor.isEditable && a2 && (this.state = {
      show: true,
      referencePos: a2.getBoundingClientRect(),
      query: this.pluginState.query
    }, this.emitUpdate(this.pluginState.triggerCharacter));
  }
  destroy() {
    var t;
    (t = this.rootEl) == null || t.removeEventListener("scroll", this.handleScroll, true);
  }
};
var K3 = new PluginKey("SuggestionMenuPlugin");
var Or = class extends Sn {
  constructor(e) {
    super();
    h3(this, "view");
    h3(this, "triggerCharacters", []);
    h3(this, "addTriggerCharacter", (e2) => {
      this.triggerCharacters.push(e2);
    });
    h3(this, "removeTriggerCharacter", (e2) => {
      this.triggerCharacters = this.triggerCharacters.filter(
        (o2) => o2 !== e2
      );
    });
    h3(this, "closeMenu", () => this.view.closeMenu());
    h3(this, "clearQuery", () => this.view.clearQuery());
    const o = this.triggerCharacters;
    this.addProsemirrorPlugin(
      new Plugin({
        key: K3,
        view: (r) => (this.view = new _r(
          e,
          (s2, i2) => {
            this.emit(`update ${s2}`, i2);
          },
          r
        ), this.view),
        state: {
          // Initialize the plugin's internal state.
          init() {
          },
          // Apply changes to the plugin state from an editor transaction.
          apply: (r, s2, i2, c) => {
            if (r.selection.$from.parent.type.spec.code)
              return s2;
            const a2 = r.getMeta(K3);
            if (typeof a2 == "object" && a2 !== null) {
              s2 && this.closeMenu();
              const d = Dr(
                e,
                c.selection.from - // Need to account for the trigger char that was inserted, so we offset the position by the length of the trigger character.
                a2.triggerCharacter.length
              );
              return {
                triggerCharacter: a2.triggerCharacter,
                deleteTriggerCharacter: a2.deleteTriggerCharacter !== false,
                // When reading the queryStartPos, we offset the result by the length of the trigger character, to make it easy on the caller
                queryStartPos: () => d() + a2.triggerCharacter.length,
                query: "",
                decorationId: `id_${Math.floor(Math.random() * 4294967295)}`,
                ignoreQueryLength: a2 == null ? void 0 : a2.ignoreQueryLength
              };
            }
            if (s2 === void 0)
              return s2;
            if (
              // Highlighting text should hide the menu.
              c.selection.from !== c.selection.to || // Transactions with plugin metadata should hide the menu.
              a2 === null || // Certain mouse events should hide the menu.
              // TODO: Change to global mousedown listener.
              r.getMeta("focus") || r.getMeta("blur") || r.getMeta("pointer") || // Moving the caret before the character which triggered the menu should hide it.
              s2.triggerCharacter !== void 0 && c.selection.from < s2.queryStartPos() || // Moving the caret to a new block should hide the menu.
              !c.selection.$from.sameParent(
                c.doc.resolve(s2.queryStartPos())
              )
            )
              return;
            const l2 = { ...s2 };
            return l2.query = c.doc.textBetween(
              s2.queryStartPos(),
              c.selection.from
            ), l2;
          }
        },
        props: {
          handleTextInput(r, s2, i2, c) {
            if (s2 === i2) {
              const a2 = r.state.doc;
              for (const l2 of o) {
                const d = l2.length > 1 ? a2.textBetween(s2 - l2.length, s2) + c : c;
                if (l2 === d)
                  return r.dispatch(r.state.tr.insertText(c)), r.dispatch(
                    r.state.tr.setMeta(K3, {
                      triggerCharacter: d
                    }).scrollIntoView()
                  ), true;
              }
            }
            return false;
          },
          // Setup decorator on the currently active suggestion.
          decorations(r) {
            const s2 = this.getState(r);
            if (s2 === void 0)
              return null;
            if (!s2.deleteTriggerCharacter) {
              const i2 = Ar(r.selection);
              if (i2)
                return DecorationSet.create(r.doc, [
                  Decoration.node(
                    i2.pos,
                    i2.pos + i2.node.nodeSize,
                    {
                      nodeName: "span",
                      class: "bn-suggestion-decorator",
                      "data-decoration-id": s2.decorationId
                    }
                  )
                ]);
            }
            return DecorationSet.create(r.doc, [
              Decoration.inline(
                s2.queryStartPos() - s2.triggerCharacter.length,
                s2.queryStartPos(),
                {
                  nodeName: "span",
                  class: "bn-suggestion-decorator",
                  "data-decoration-id": s2.decorationId
                }
              )
            ]);
          }
        }
      })
    );
  }
  static key() {
    return "suggestionMenu";
  }
  onUpdate(e, o) {
    return this.triggerCharacters.includes(e) || this.addTriggerCharacter(e), this.on(`update ${e}`, o);
  }
  get shown() {
    var e, o;
    return ((o = (e = this.view) == null ? void 0 : e.state) == null ? void 0 : o.show) || false;
  }
};
var Hr = Mark.create({
  name: "insertion",
  inclusive: false,
  excludes: "deletion modification insertion",
  addAttributes() {
    return {
      id: { default: null, validate: "number" }
      // note: validate is supported in prosemirror but not in tiptap, so this doesn't actually work (considered not critical)
    };
  },
  extendMarkSchema(n) {
    return n.name !== "insertion" ? {} : {
      blocknoteIgnore: true,
      inclusive: false,
      toDOM(t, e) {
        return [
          "ins",
          {
            "data-id": String(t.attrs.id),
            "data-inline": String(e),
            ...!e && { style: "display: contents" }
            // changed to "contents" to make this work for table rows
          },
          0
        ];
      },
      parseDOM: [
        {
          tag: "ins",
          getAttrs(t) {
            return t.dataset.id ? {
              id: parseInt(t.dataset.id, 10)
            } : false;
          }
        }
      ]
    };
  }
});
var Nr = Mark.create({
  name: "deletion",
  inclusive: false,
  excludes: "insertion modification deletion",
  addAttributes() {
    return {
      id: { default: null, validate: "number" }
      // note: validate is supported in prosemirror but not in tiptap
    };
  },
  extendMarkSchema(n) {
    return n.name !== "deletion" ? {} : {
      blocknoteIgnore: true,
      inclusive: false,
      // attrs: {
      //   id: { validate: "number" },
      // },
      toDOM(t, e) {
        return [
          "del",
          {
            "data-id": String(t.attrs.id),
            "data-inline": String(e),
            ...!e && { style: "display: contents" }
            // changed to "contents" to make this work for table rows
          },
          0
        ];
      },
      parseDOM: [
        {
          tag: "del",
          getAttrs(t) {
            return t.dataset.id ? {
              id: parseInt(t.dataset.id, 10)
            } : false;
          }
        }
      ]
    };
  }
});
var Ur = Mark.create({
  name: "modification",
  inclusive: false,
  excludes: "deletion insertion",
  addAttributes() {
    return {
      id: { default: null, validate: "number" },
      type: { validate: "string" },
      attrName: { default: null, validate: "string|null" },
      previousValue: { default: null },
      newValue: { default: null }
    };
  },
  extendMarkSchema(n) {
    return n.name !== "modification" ? {} : {
      blocknoteIgnore: true,
      inclusive: false,
      // attrs: {
      //   id: { validate: "number" },
      //   type: { validate: "string" },
      //   attrName: { default: null, validate: "string|null" },
      //   previousValue: { default: null },
      //   newValue: { default: null },
      // },
      toDOM(t, e) {
        return [
          e ? "span" : "div",
          {
            "data-type": "modification",
            "data-id": String(t.attrs.id),
            "data-mod-type": t.attrs.type,
            "data-mod-prev-val": JSON.stringify(t.attrs.previousValue),
            // TODO: Try to serialize marks with toJSON?
            "data-mod-new-val": JSON.stringify(t.attrs.newValue)
          },
          0
        ];
      },
      parseDOM: [
        {
          tag: "span[data-type='modification']",
          getAttrs(t) {
            return t.dataset.id ? {
              id: parseInt(t.dataset.id, 10),
              type: t.dataset.modType,
              previousValue: t.dataset.modPrevVal,
              newValue: t.dataset.modNewVal
            } : false;
          }
        },
        {
          tag: "div[data-type='modification']",
          getAttrs(t) {
            return t.dataset.id ? {
              id: parseInt(t.dataset.id, 10),
              type: t.dataset.modType,
              previousValue: t.dataset.modPrevVal
            } : false;
          }
        }
      ]
    };
  }
});
var x2;
function it2(n) {
  x2 || (x2 = document.createElement("div"), x2.innerHTML = "_", x2.style.opacity = "0", x2.style.height = "1px", x2.style.width = "1px", n instanceof Document ? n.body.appendChild(x2) : n.appendChild(x2));
}
function Rr(n) {
  x2 && (n instanceof Document ? n.body.removeChild(x2) : n.removeChild(x2), x2 = void 0);
}
function de(n) {
  return Array.prototype.indexOf.call(n.parentElement.childNodes, n);
}
function Vr(n) {
  let t = n;
  for (; t && t.nodeName !== "TD" && t.nodeName !== "TH" && !t.classList.contains("tableWrapper"); ) {
    if (t.classList.contains("ProseMirror"))
      return;
    const e = t.parentNode;
    if (!e || !(e instanceof Element))
      return;
    t = e;
  }
  return t.nodeName === "TD" || t.nodeName === "TH" ? {
    type: "cell",
    domNode: t,
    tbodyNode: t.closest("tbody")
  } : {
    type: "wrapper",
    domNode: t,
    tbodyNode: t.querySelector("tbody")
  };
}
function $r(n, t) {
  const e = t.querySelectorAll(n);
  for (let o = 0; o < e.length; o++)
    e[o].style.visibility = "hidden";
}
var Fr = class {
  constructor(t, e, o) {
    h3(this, "state");
    h3(this, "emitUpdate");
    h3(this, "tableId");
    h3(this, "tablePos");
    h3(this, "tableElement");
    h3(this, "menuFrozen", false);
    h3(this, "mouseState", "up");
    h3(this, "prevWasEditable", null);
    h3(this, "viewMousedownHandler", () => {
      this.mouseState = "down";
    });
    h3(this, "mouseUpHandler", (t2) => {
      this.mouseState = "up", this.mouseMoveHandler(t2);
    });
    h3(this, "mouseMoveHandler", (t2) => {
      var l2, d, u, p5, m, g, f2;
      if (this.menuFrozen || this.mouseState === "selecting" || !(t2.target instanceof Element) || !this.pmView.dom.contains(t2.target))
        return;
      const e2 = Vr(t2.target);
      if ((e2 == null ? void 0 : e2.type) === "cell" && this.mouseState === "down" && !((l2 = this.state) != null && l2.draggingState)) {
        this.mouseState = "selecting", (d = this.state) != null && d.show && (this.state.show = false, this.state.showAddOrRemoveRowsButton = false, this.state.showAddOrRemoveColumnsButton = false, this.emitUpdate());
        return;
      }
      if (!e2 || !this.editor.isEditable) {
        (u = this.state) != null && u.show && (this.state.show = false, this.state.showAddOrRemoveRowsButton = false, this.state.showAddOrRemoveColumnsButton = false, this.emitUpdate());
        return;
      }
      if (!e2.tbodyNode)
        return;
      const o2 = e2.tbodyNode.getBoundingClientRect(), r = _t2(e2.domNode, this.pmView);
      if (!r)
        return;
      this.tableElement = r.node;
      let s2;
      const i2 = this.editor.transact(
        (b2) => un(r.id, b2.doc)
      );
      if (!i2)
        throw new Error(`Block with ID ${r.id} not found`);
      const c = X(
        i2.node,
        this.editor.pmSchema,
        this.editor.schema.blockSchema,
        this.editor.schema.inlineContentSchema,
        this.editor.schema.styleSchema
      );
      if (E(this.editor, "table") && (this.tablePos = i2.posBeforeNode + 1, s2 = c), !s2)
        return;
      this.tableId = r.id;
      const a2 = (p5 = e2.domNode.closest(".tableWrapper")) == null ? void 0 : p5.querySelector(".table-widgets-container");
      if ((e2 == null ? void 0 : e2.type) === "wrapper") {
        const b2 = t2.clientY >= o2.bottom - 1 && // -1 to account for fractions of pixels in "bottom"
        t2.clientY < o2.bottom + 20, k2 = t2.clientX >= o2.right - 1 && t2.clientX < o2.right + 20, w3 = t2.clientX > o2.right || t2.clientY > o2.bottom;
        this.state = {
          ...this.state,
          show: true,
          showAddOrRemoveRowsButton: b2,
          showAddOrRemoveColumnsButton: k2,
          referencePosTable: o2,
          block: s2,
          widgetContainer: a2,
          colIndex: w3 || (m = this.state) == null ? void 0 : m.colIndex,
          rowIndex: w3 || (g = this.state) == null ? void 0 : g.rowIndex,
          referencePosCell: w3 || (f2 = this.state) == null ? void 0 : f2.referencePosCell
        };
      } else {
        const b2 = de(e2.domNode), k2 = de(e2.domNode.parentElement), w3 = e2.domNode.getBoundingClientRect();
        if (this.state !== void 0 && this.state.show && this.tableId === r.id && this.state.rowIndex === k2 && this.state.colIndex === b2)
          return;
        this.state = {
          show: true,
          showAddOrRemoveColumnsButton: b2 === s2.content.rows[0].cells.length - 1,
          showAddOrRemoveRowsButton: k2 === s2.content.rows.length - 1,
          referencePosTable: o2,
          block: s2,
          draggingState: void 0,
          referencePosCell: w3,
          colIndex: b2,
          rowIndex: k2,
          widgetContainer: a2
        };
      }
      return this.emitUpdate(), false;
    });
    h3(this, "dragOverHandler", (t2) => {
      var p5;
      if (((p5 = this.state) == null ? void 0 : p5.draggingState) === void 0)
        return;
      t2.preventDefault(), t2.dataTransfer.dropEffect = "move", $r(
        ".prosemirror-dropcursor-block, .prosemirror-dropcursor-inline",
        this.pmView.root
      );
      const e2 = {
        left: Math.min(
          Math.max(t2.clientX, this.state.referencePosTable.left + 1),
          this.state.referencePosTable.right - 1
        ),
        top: Math.min(
          Math.max(t2.clientY, this.state.referencePosTable.top + 1),
          this.state.referencePosTable.bottom - 1
        )
      }, o2 = this.pmView.root.elementsFromPoint(e2.left, e2.top).filter(
        (m) => m.tagName === "TD" || m.tagName === "TH"
      );
      if (o2.length === 0)
        return;
      const r = o2[0];
      let s2 = false;
      const i2 = de(r.parentElement), c = de(r), a2 = this.state.draggingState.draggedCellOrientation === "row" ? this.state.rowIndex : this.state.colIndex, d = (this.state.draggingState.draggedCellOrientation === "row" ? i2 : c) !== a2;
      (this.state.rowIndex !== i2 || this.state.colIndex !== c) && (this.state.rowIndex = i2, this.state.colIndex = c, this.state.referencePosCell = r.getBoundingClientRect(), s2 = true);
      const u = this.state.draggingState.draggedCellOrientation === "row" ? e2.top : e2.left;
      this.state.draggingState.mousePos !== u && (this.state.draggingState.mousePos = u, s2 = true), s2 && this.emitUpdate(), d && this.editor.transact((m) => m.setMeta(oe, true));
    });
    h3(this, "dropHandler", (t2) => {
      if (this.mouseState = "up", this.state === void 0 || this.state.draggingState === void 0)
        return false;
      if (this.state.rowIndex === void 0 || this.state.colIndex === void 0)
        throw new Error(
          "Attempted to drop table row or column, but no table block was hovered prior."
        );
      t2.preventDefault();
      const { draggingState: e2, colIndex: o2, rowIndex: r } = this.state, s2 = this.state.block.content.columnWidths;
      if (e2.draggedCellOrientation === "row") {
        if (!Yo(
          this.state.block,
          e2.originalIndex,
          r
        ))
          return false;
        const i2 = Jo(
          this.state.block,
          e2.originalIndex,
          r
        );
        this.editor.updateBlock(this.state.block, {
          type: "table",
          content: {
            ...this.state.block.content,
            rows: i2
          }
        });
      } else {
        if (!er(
          this.state.block,
          e2.originalIndex,
          o2
        ))
          return false;
        const i2 = Xo(
          this.state.block,
          e2.originalIndex,
          o2
        ), [c] = s2.splice(e2.originalIndex, 1);
        s2.splice(o2, 0, c), this.editor.updateBlock(this.state.block, {
          type: "table",
          content: {
            ...this.state.block.content,
            columnWidths: s2,
            rows: i2
          }
        });
      }
      return this.editor.setTextCursorPosition(this.state.block.id), true;
    });
    this.editor = t, this.pmView = e, this.emitUpdate = () => {
      if (!this.state)
        throw new Error("Attempting to update uninitialized image toolbar");
      o(this.state);
    }, e.dom.addEventListener("mousemove", this.mouseMoveHandler), e.dom.addEventListener("mousedown", this.viewMousedownHandler), window.addEventListener("mouseup", this.mouseUpHandler), e.root.addEventListener(
      "dragover",
      this.dragOverHandler
    ), e.root.addEventListener(
      "drop",
      this.dropHandler
    );
  }
  // Updates drag handles when the table is modified or removed.
  update() {
    var r;
    if (!this.state || !this.state.show)
      return;
    if (this.state.block = this.editor.getBlock(this.state.block.id), !this.state.block || this.state.block.type !== "table" || // when collaborating, the table element might be replaced and out of date
    // because yjs replaces the element when for example you change the color via the side menu
    !((r = this.tableElement) != null && r.isConnected)) {
      this.state.show = false, this.state.showAddOrRemoveRowsButton = false, this.state.showAddOrRemoveColumnsButton = false, this.emitUpdate();
      return;
    }
    const { height: t, width: e } = et(
      this.state.block
    );
    this.state.rowIndex !== void 0 && this.state.colIndex !== void 0 && (this.state.rowIndex >= t && (this.state.rowIndex = t - 1), this.state.colIndex >= e && (this.state.colIndex = e - 1));
    const o = this.tableElement.querySelector("tbody");
    if (!o)
      throw new Error(
        "Table block does not contain a 'tbody' HTML element. This should never happen."
      );
    if (this.state.rowIndex !== void 0 && this.state.colIndex !== void 0) {
      const i2 = o.children[this.state.rowIndex].children[this.state.colIndex];
      i2 ? this.state.referencePosCell = i2.getBoundingClientRect() : (this.state.rowIndex = void 0, this.state.colIndex = void 0);
    }
    this.state.referencePosTable = o.getBoundingClientRect(), this.emitUpdate();
  }
  destroy() {
    this.pmView.dom.removeEventListener("mousemove", this.mouseMoveHandler), window.removeEventListener("mouseup", this.mouseUpHandler), this.pmView.dom.removeEventListener("mousedown", this.viewMousedownHandler), this.pmView.root.removeEventListener(
      "dragover",
      this.dragOverHandler
    ), this.pmView.root.removeEventListener(
      "drop",
      this.dropHandler
    );
  }
};
var oe = new PluginKey("TableHandlesPlugin");
var zr = class extends Sn {
  constructor(e) {
    super();
    h3(this, "view");
    h3(this, "colDragStart", (e2) => {
      if (this.view.state === void 0 || this.view.state.colIndex === void 0)
        throw new Error(
          "Attempted to drag table column, but no table block was hovered prior."
        );
      this.view.state.draggingState = {
        draggedCellOrientation: "col",
        originalIndex: this.view.state.colIndex,
        mousePos: e2.clientX
      }, this.view.emitUpdate(), this.editor.transact(
        (o) => o.setMeta(oe, {
          draggedCellOrientation: this.view.state.draggingState.draggedCellOrientation,
          originalIndex: this.view.state.colIndex,
          newIndex: this.view.state.colIndex,
          tablePos: this.view.tablePos
        })
      ), !this.editor.headless && (it2(this.editor.prosemirrorView.root), e2.dataTransfer.setDragImage(x2, 0, 0), e2.dataTransfer.effectAllowed = "move");
    });
    h3(this, "rowDragStart", (e2) => {
      if (this.view.state === void 0 || this.view.state.rowIndex === void 0)
        throw new Error(
          "Attempted to drag table row, but no table block was hovered prior."
        );
      this.view.state.draggingState = {
        draggedCellOrientation: "row",
        originalIndex: this.view.state.rowIndex,
        mousePos: e2.clientY
      }, this.view.emitUpdate(), this.editor.transact(
        (o) => o.setMeta(oe, {
          draggedCellOrientation: this.view.state.draggingState.draggedCellOrientation,
          originalIndex: this.view.state.rowIndex,
          newIndex: this.view.state.rowIndex,
          tablePos: this.view.tablePos
        })
      ), !this.editor.headless && (it2(this.editor.prosemirrorView.root), e2.dataTransfer.setDragImage(x2, 0, 0), e2.dataTransfer.effectAllowed = "copyMove");
    });
    h3(this, "dragEnd", () => {
      if (this.view.state === void 0)
        throw new Error(
          "Attempted to drag table row, but no table block was hovered prior."
        );
      this.view.state.draggingState = void 0, this.view.emitUpdate(), this.editor.transact((e2) => e2.setMeta(oe, null)), !this.editor.headless && Rr(this.editor.prosemirrorView.root);
    });
    h3(this, "freezeHandles", () => {
      this.view.menuFrozen = true;
    });
    h3(this, "unfreezeHandles", () => {
      this.view.menuFrozen = false;
    });
    h3(this, "getCellsAtRowHandle", (e2, o) => an(e2, o));
    h3(this, "getCellsAtColumnHandle", (e2, o) => cn(e2, o));
    h3(this, "setCellSelection", (e2, o, r = o) => {
      const s2 = this.view;
      if (!s2)
        throw new Error("Table handles view not initialized");
      const i2 = e2.doc.resolve(s2.tablePos + 1), c = e2.doc.resolve(
        i2.posAtIndex(o.row) + 1
      ), a2 = e2.doc.resolve(
        // No need for +1, since CellSelection expects the position before the cell
        c.posAtIndex(o.col)
      ), l2 = e2.doc.resolve(
        i2.posAtIndex(r.row) + 1
      ), d = e2.doc.resolve(
        // No need for +1, since CellSelection expects the position before the cell
        l2.posAtIndex(r.col)
      ), u = e2.tr;
      return u.setSelection(
        new CellSelection(a2, d)
      ), e2.apply(u);
    });
    h3(this, "addRowOrColumn", (e2, o) => {
      this.editor.exec((r, s2) => {
        const i2 = this.setCellSelection(
          r,
          o.orientation === "row" ? { row: e2, col: 0 } : { row: 0, col: e2 }
        );
        return o.orientation === "row" ? o.side === "above" ? addRowBefore(i2, s2) : addRowAfter(i2, s2) : o.side === "left" ? addColumnBefore(i2, s2) : addColumnAfter(i2, s2);
      });
    });
    h3(this, "removeRowOrColumn", (e2, o) => o === "row" ? this.editor.exec((r, s2) => {
      const i2 = this.setCellSelection(r, {
        row: e2,
        col: 0
      });
      return deleteRow(i2, s2);
    }) : this.editor.exec((r, s2) => {
      const i2 = this.setCellSelection(r, {
        row: 0,
        col: e2
      });
      return deleteColumn(i2, s2);
    }));
    h3(this, "mergeCells", (e2) => this.editor.exec((o, r) => {
      const s2 = e2 ? this.setCellSelection(
        o,
        e2.relativeStartCell,
        e2.relativeEndCell
      ) : o;
      return mergeCells(s2, r);
    }));
    h3(this, "splitCell", (e2) => this.editor.exec((o, r) => {
      const s2 = e2 ? this.setCellSelection(o, e2) : o;
      return splitCell(s2, r);
    }));
    h3(this, "getCellSelection", () => this.editor.transact((e2) => {
      const o = e2.selection;
      let r = o.$from, s2 = o.$to;
      if (fr(o)) {
        const { ranges: g } = o;
        g.forEach((f2) => {
          r = f2.$from.min(r ?? f2.$from), s2 = f2.$to.max(s2 ?? f2.$to);
        });
      } else if (r = e2.doc.resolve(
        o.$from.pos - o.$from.parentOffset - 1
      ), s2 = e2.doc.resolve(
        o.$to.pos - o.$to.parentOffset - 1
      ), r.pos === 0 || s2.pos === 0)
        return;
      const i2 = e2.doc.resolve(
        r.pos - r.parentOffset - 1
      ), c = e2.doc.resolve(s2.pos - s2.parentOffset - 1), a2 = e2.doc.resolve(i2.pos - i2.parentOffset - 1), l2 = r.index(i2.depth), d = i2.index(a2.depth), u = s2.index(c.depth), p5 = c.index(a2.depth), m = [];
      for (let g = d; g <= p5; g++)
        for (let f2 = l2; f2 <= u; f2++)
          m.push({ row: g, col: f2 });
      return {
        from: {
          row: d,
          col: l2
        },
        to: {
          row: p5,
          col: u
        },
        cells: m
      };
    }));
    h3(this, "getMergeDirection", (e2) => this.editor.transact((o) => {
      const r = fr(o.selection) ? o.selection : void 0;
      if (!r || !e2 || // Only offer the merge button if there is more than one cell selected.
      r.ranges.length <= 1)
        return;
      const s2 = this.getCellSelection();
      if (s2)
        return tr(s2.from, s2.to, e2) ? "vertical" : "horizontal";
    }));
    h3(this, "cropEmptyRowsOrColumns", (e2, o) => Ko(e2, o));
    h3(this, "addRowsOrColumns", (e2, o, r) => Qo(e2, o, r));
    this.editor = e, this.addProsemirrorPlugin(
      new Plugin({
        key: oe,
        view: (o) => (this.view = new Fr(e, o, (r) => {
          this.emit("update", r);
        }), this.view),
        // We use decorations to render the drop cursor when dragging a table row
        // or column. The decorations are updated in the `dragOverHandler` method.
        props: {
          decorations: (o) => {
            if (this.view === void 0 || this.view.state === void 0 || this.view.state.draggingState === void 0 || this.view.tablePos === void 0)
              return;
            const r = this.view.state.draggingState.draggedCellOrientation === "row" ? this.view.state.rowIndex : this.view.state.colIndex;
            if (r === void 0)
              return;
            const s2 = [], { block: i2, draggingState: c } = this.view.state, { originalIndex: a2, draggedCellOrientation: l2 } = c;
            if (r === a2 || !i2 || l2 === "row" && !Yo(i2, a2, r) || l2 === "col" && !er(i2, a2, r))
              return DecorationSet.create(o.doc, s2);
            const d = o.doc.resolve(this.view.tablePos + 1);
            return this.view.state.draggingState.draggedCellOrientation === "row" ? an(
              this.view.state.block,
              r
            ).forEach(({ row: p5, col: m }) => {
              const g = o.doc.resolve(
                d.posAtIndex(p5) + 1
              ), f2 = o.doc.resolve(
                g.posAtIndex(m) + 1
              ), b2 = f2.node(), k2 = f2.pos + (r > a2 ? b2.nodeSize - 2 : 0);
              s2.push(
                // The widget is a small bar which spans the width of the cell.
                Decoration.widget(k2, () => {
                  const w3 = document.createElement("div");
                  return w3.className = "bn-table-drop-cursor", w3.style.left = "0", w3.style.right = "0", r > a2 ? w3.style.bottom = "-2px" : w3.style.top = "-3px", w3.style.height = "4px", w3;
                })
              );
            }) : cn(
              this.view.state.block,
              r
            ).forEach(({ row: p5, col: m }) => {
              const g = o.doc.resolve(
                d.posAtIndex(p5) + 1
              ), f2 = o.doc.resolve(
                g.posAtIndex(m) + 1
              ), b2 = f2.node(), k2 = f2.pos + (r > a2 ? b2.nodeSize - 2 : 0);
              s2.push(
                // The widget is a small bar which spans the height of the cell.
                Decoration.widget(k2, () => {
                  const w3 = document.createElement("div");
                  return w3.className = "bn-table-drop-cursor", w3.style.top = "0", w3.style.bottom = "0", r > a2 ? w3.style.right = "-2px" : w3.style.left = "-3px", w3.style.width = "4px", w3;
                })
              );
            }), DecorationSet.create(o.doc, s2);
          }
        }
      })
    );
  }
  static key() {
    return "tableHandles";
  }
  onUpdate(e) {
    return this.on("update", e);
  }
};
var Gr = Extension.create({
  name: "textAlignment",
  addGlobalAttributes() {
    return [
      {
        // Generally text alignment is handled through props using the custom
        // blocks API. Tables are the only blocks that are created as TipTap
        // nodes and ported to blocks, so we need to add text alignment in a
        // separate extension.
        types: ["tableCell", "tableHeader"],
        attributes: {
          textAlignment: {
            default: "left",
            parseHTML: (n) => n.getAttribute("data-text-alignment"),
            renderHTML: (n) => n.textAlignment === "left" ? {} : {
              "data-text-alignment": n.textAlignment
            }
          }
        }
      }
    ];
  }
});
var jr = Extension.create({
  name: "blockTextColor",
  addGlobalAttributes() {
    return [
      {
        types: ["table", "tableCell", "tableHeader"],
        attributes: {
          textColor: ar()
        }
      }
    ];
  }
});
var Kr = Extension.create({
  name: "trailingNode",
  addProseMirrorPlugins() {
    const n = new PluginKey(this.name);
    return [
      new Plugin({
        key: n,
        appendTransaction: (t, e, o) => {
          const { doc: r, tr: s2, schema: i2 } = o, c = n.getState(o), a2 = r.content.size - 2, l2 = i2.nodes.blockContainer, d = i2.nodes.paragraph;
          if (c)
            return s2.insert(
              a2,
              l2.create(void 0, d.create())
            );
        },
        state: {
          init: (t, e) => {
          },
          apply: (t, e) => {
            if (!t.docChanged)
              return e;
            let o = t.doc.lastChild;
            if (!o || o.type.name !== "blockGroup")
              throw new Error("Expected blockGroup");
            if (o = o.lastChild, !o || o.type.name !== "blockContainer")
              return true;
            const r = o.firstChild;
            if (!r)
              throw new Error("Expected blockContent");
            return o.nodeSize > 4 || r.type.spec.content !== "inline*";
          }
        }
      })
    ];
  }
});
var qr = {
  blockColor: "data-block-color",
  blockStyle: "data-block-style",
  id: "data-id",
  depth: "data-depth",
  depthChange: "data-depth-change"
};
var Yr = Node3.create({
  name: "blockContainer",
  group: "blockGroupChild bnBlock",
  // A block always contains content, and optionally a blockGroup which contains nested blocks
  content: "blockContent blockGroup?",
  // Ensures content-specific keyboard handlers trigger first.
  priority: 50,
  defining: true,
  marks: "insertion modification deletion",
  parseHTML() {
    return [
      {
        tag: "div[data-node-type=" + this.name + "]",
        getAttrs: (n) => {
          if (typeof n == "string")
            return false;
          const t = {};
          for (const [e, o] of Object.entries(qr))
            n.getAttribute(o) && (t[e] = n.getAttribute(o));
          return t;
        }
      },
      // Ignore `blockOuter` divs, but parse the `blockContainer` divs inside them.
      {
        tag: 'div[data-node-type="blockOuter"]',
        skip: true
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    var r;
    const t = document.createElement("div");
    t.className = "bn-block-outer", t.setAttribute("data-node-type", "blockOuter");
    for (const [s2, i2] of Object.entries(n))
      s2 !== "class" && t.setAttribute(s2, i2);
    const e = {
      ...((r = this.options.domAttributes) == null ? void 0 : r.block) || {},
      ...n
    }, o = document.createElement("div");
    o.className = U("bn-block", e.class), o.setAttribute("data-node-type", this.name);
    for (const [s2, i2] of Object.entries(e))
      s2 !== "class" && o.setAttribute(s2, i2);
    return t.appendChild(o), {
      dom: t,
      contentDOM: o
    };
  }
});
var Wr = Node3.create({
  name: "blockGroup",
  group: "childContainer",
  content: "blockGroupChild+",
  marks: "deletion insertion modification",
  parseHTML() {
    return [
      {
        tag: "div",
        getAttrs: (n) => typeof n == "string" ? false : n.getAttribute("data-node-type") === "blockGroup" ? null : false
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    var o;
    const t = {
      ...((o = this.options.domAttributes) == null ? void 0 : o.blockGroup) || {},
      ...n
    }, e = document.createElement("div");
    e.className = U(
      "bn-block-group",
      t.class
    ), e.setAttribute("data-node-type", "blockGroup");
    for (const [r, s2] of Object.entries(t))
      r !== "class" && e.setAttribute(r, s2);
    return {
      dom: e,
      contentDOM: e
    };
  }
});
var Xr = Node3.create({
  name: "doc",
  topNode: true,
  content: "blockGroup",
  marks: "insertion modification deletion"
});
var Jr = (n) => {
  var r;
  const t = {}, e = Qr(n);
  for (const s2 of e)
    t[s2.name] = s2;
  n.collaboration && (t.ySyncPlugin = new ge2(n.collaboration.fragment), t.yUndoPlugin = new be2({ editor: n.editor }), (r = n.collaboration.provider) != null && r.awareness && (t.yCursorPlugin = new se2(n.collaboration)), t.forkYDocPlugin = new xt({
    editor: n.editor,
    collaboration: n.collaboration
  }), t.schemaMigrationPlugin = new Ne2(
    n.collaboration.fragment
  )), t.formattingToolbar = new rr2(
    n.editor
  ), t.linkToolbar = new fr2(n.editor), t.sideMenu = new Ir(n.editor), t.suggestionMenus = new Or(n.editor), t.filePanel = new tr3(n.editor), t.placeholder = new Cr(n.editor, n.placeholders), (n.animations ?? true) && (t.animations = new Sr()), n.tableHandles && (t.tableHandles = new zr(n.editor)), t.nodeSelectionKeyboard = new wr(), t.blockChange = new Yn2(), t.showSelection = new Br(n.editor), n.comments && (t.comments = new Lt(
    n.editor,
    n.comments.threadStore,
    ke2.name,
    n.comments.resolveUsers,
    n.comments.schema
  ));
  const o = n.disableExtensions || [];
  for (const s2 of o)
    delete t[s2];
  return t;
};
var at2 = false;
var Qr = (n) => {
  const t = [
    extensions_exports.ClipboardTextSerializer,
    extensions_exports.Commands,
    extensions_exports.Editable,
    extensions_exports.FocusEvents,
    extensions_exports.Tabindex,
    // DevTools,
    Gapcursor,
    // DropCursor,
    Extension.create({
      name: "dropCursor",
      addProseMirrorPlugins: () => [
        n.dropCursor({
          width: 5,
          color: "#ddeeff",
          editor: n.editor
        })
      ]
    }),
    qe.configure({
      // everything from bnBlock group (nodes that represent a BlockNote block should have an id)
      types: ["blockContainer", "columnList", "column"],
      setIdAttribute: n.setIdAttribute
    }),
    sr2,
    // Comments,
    // basics:
    Text,
    // marks:
    Hr,
    Nr,
    Ur,
    Link.extend({
      inclusive: false
    }).configure({
      defaultProtocol: br4,
      // only call this once if we have multiple editors installed. Or fix https://github.com/ueberdosis/tiptap/issues/5450
      protocols: at2 ? [] : gr2
    }),
    ...Object.values(n.styleSpecs).map((e) => e.implementation.mark.configure({
      editor: n.editor
    })),
    jr,
    qn2,
    Gr,
    // make sure escape blurs editor, so that we can tab to other elements in the host page (accessibility)
    Extension.create({
      name: "OverrideEscape",
      addKeyboardShortcuts() {
        return {
          Escape: () => n.editor.suggestionMenus.shown ? false : this.editor.commands.blur()
        };
      }
    }),
    // nodes
    Xr,
    Yr.configure({
      editor: n.editor,
      domAttributes: n.domAttributes
    }),
    ur2.configure({
      editor: n.editor,
      tabBehavior: n.tabBehavior
    }),
    Wr.configure({
      domAttributes: n.domAttributes
    }),
    ...Object.values(n.inlineContentSpecs).filter((e) => e.config !== "link" && e.config !== "text").map((e) => e.implementation.node.configure({
      editor: n.editor
    })),
    ...Object.values(n.blockSpecs).flatMap((e) => [
      // the node extension implementations
      ..."node" in e.implementation ? [
        e.implementation.node.configure({
          editor: n.editor,
          domAttributes: n.domAttributes
        })
      ] : []
    ]),
    Kn2(n.editor),
    Vn2(
      n.editor,
      n.pasteHandler || ((e) => e.defaultPasteHandler())
    ),
    Sn2(n.editor),
    // This needs to be at the bottom of this list, because Key events (such as enter, when selecting a /command),
    // should be handled before Enter handlers in other components like splitListItem
    ...n.trailingBlock === void 0 || n.trailingBlock ? [Kr] : [],
    ...n.comments ? [ke2] : []
  ];
  return at2 = true, n.collaboration || t.push(UndoRedo), t;
};
function Zr(n) {
  return n.transact((t) => {
    const e = fe(t.doc, t.selection.anchor);
    if (t.selection instanceof CellSelection)
      return {
        type: "cell",
        anchorBlockId: e.node.attrs.id,
        anchorCellOffset: t.selection.$anchorCell.pos - e.posBeforeNode,
        headCellOffset: t.selection.$headCell.pos - e.posBeforeNode
      };
    if (t.selection instanceof NodeSelection)
      return {
        type: "node",
        anchorBlockId: e.node.attrs.id
      };
    {
      const o = fe(t.doc, t.selection.head);
      return {
        type: "text",
        anchorBlockId: e.node.attrs.id,
        headBlockId: o.node.attrs.id,
        anchorOffset: t.selection.anchor - e.posBeforeNode,
        headOffset: t.selection.head - o.posBeforeNode
      };
    }
  });
}
function es(n, t) {
  var r, s2;
  const e = (r = un(t.anchorBlockId, n.doc)) == null ? void 0 : r.posBeforeNode;
  if (e === void 0)
    throw new Error(
      `Could not find block with ID ${t.anchorBlockId} to update selection`
    );
  let o;
  if (t.type === "cell")
    o = CellSelection.create(
      n.doc,
      e + t.anchorCellOffset,
      e + t.headCellOffset
    );
  else if (t.type === "node")
    o = NodeSelection.create(n.doc, e + 1);
  else {
    const i2 = (s2 = un(t.headBlockId, n.doc)) == null ? void 0 : s2.posBeforeNode;
    if (i2 === void 0)
      throw new Error(
        `Could not find block with ID ${t.headBlockId} to update selection`
      );
    o = TextSelection.create(
      n.doc,
      e + t.anchorOffset,
      i2 + t.headOffset
    );
  }
  n.setSelection(o);
}
function Le2(n) {
  return n.map((t) => t.type === "columnList" ? t.children.map((e) => Le2(e.children)).flat() : {
    ...t,
    children: Le2(t.children)
  }).flat();
}
function Ht(n, t, e) {
  n.transact((o) => {
    var i2;
    const r = ((i2 = n.getSelection()) == null ? void 0 : i2.blocks) || [
      n.getTextCursorPosition().block
    ], s2 = Zr(n);
    n.removeBlocks(r), n.insertBlocks(Le2(r), t, e), es(o, s2);
  });
}
function Nt(n) {
  return !n || n.type !== "columnList";
}
function Ut2(n, t, e) {
  let o, r;
  if (t ? t.children.length > 0 ? (o = t.children[t.children.length - 1], r = "after") : (o = t, r = "before") : e && (o = e, r = "before"), !o || !r)
    return;
  const s2 = n.getParentBlock(o);
  return Nt(s2) ? { referenceBlock: o, placement: r } : Ut2(
    n,
    r === "after" ? o : n.getPrevBlock(o),
    s2
  );
}
function Rt2(n, t, e) {
  let o, r;
  if (t ? t.children.length > 0 ? (o = t.children[0], r = "before") : (o = t, r = "after") : e && (o = e, r = "after"), !o || !r)
    return;
  const s2 = n.getParentBlock(o);
  return Nt(s2) ? { referenceBlock: o, placement: r } : Rt2(
    n,
    r === "before" ? o : n.getNextBlock(o),
    s2
  );
}
function ts(n) {
  n.transact(() => {
    const t = n.getSelection(), e = (t == null ? void 0 : t.blocks[0]) || n.getTextCursorPosition().block, o = Ut2(
      n,
      n.getPrevBlock(e),
      n.getParentBlock(e)
    );
    o && Ht(
      n,
      o.referenceBlock,
      o.placement
    );
  });
}
function os(n) {
  n.transact(() => {
    const t = n.getSelection(), e = (t == null ? void 0 : t.blocks[(t == null ? void 0 : t.blocks.length) - 1]) || n.getTextCursorPosition().block, o = Rt2(
      n,
      n.getNextBlock(e),
      n.getParentBlock(e)
    );
    o && Ht(
      n,
      o.referenceBlock,
      o.placement
    );
  });
}
function ns(n, t) {
  const e = typeof t == "string" ? t : t.id, o = G(n), r = un(e, n);
  if (r)
    return X(r.node, o);
}
function rs(n, t) {
  const e = typeof t == "string" ? t : t.id, o = un(e, n), r = G(n);
  if (!o)
    return;
  const i2 = n.resolve(o.posBeforeNode).nodeBefore;
  if (i2)
    return X(i2, r);
}
function ss(n, t) {
  const e = typeof t == "string" ? t : t.id, o = un(e, n), r = G(n);
  if (!o)
    return;
  const i2 = n.resolve(
    o.posBeforeNode + o.node.nodeSize
  ).nodeAfter;
  if (i2)
    return X(i2, r);
}
function is2(n, t) {
  const e = typeof t == "string" ? t : t.id, o = G(n), r = un(e, n);
  if (!r)
    return;
  const s2 = n.resolve(r.posBeforeNode), i2 = s2.node(), c = s2.node(-1), a2 = c.type.name !== "doc" ? i2.type.name === "blockGroup" ? c : i2 : void 0;
  if (a2)
    return X(a2, o);
}
var as = class {
  constructor(t) {
    this.editor = t;
  }
  /**
   * Gets a snapshot of all top-level (non-nested) blocks in the editor.
   * @returns A snapshot of all top-level (non-nested) blocks in the editor.
   */
  get document() {
    return this.editor.transact((t) => Uo(t.doc, this.editor.pmSchema));
  }
  /**
   * Gets a snapshot of an existing block from the editor.
   * @param blockIdentifier The identifier of an existing block that should be
   * retrieved.
   * @returns The block that matches the identifier, or `undefined` if no
   * matching block was found.
   */
  getBlock(t) {
    return this.editor.transact((e) => ns(e.doc, t));
  }
  /**
   * Gets a snapshot of the previous sibling of an existing block from the
   * editor.
   * @param blockIdentifier The identifier of an existing block for which the
   * previous sibling should be retrieved.
   * @returns The previous sibling of the block that matches the identifier.
   * `undefined` if no matching block was found, or it's the first child/block
   * in the document.
   */
  getPrevBlock(t) {
    return this.editor.transact((e) => rs(e.doc, t));
  }
  /**
   * Gets a snapshot of the next sibling of an existing block from the editor.
   * @param blockIdentifier The identifier of an existing block for which the
   * next sibling should be retrieved.
   * @returns The next sibling of the block that matches the identifier.
   * `undefined` if no matching block was found, or it's the last child/block in
   * the document.
   */
  getNextBlock(t) {
    return this.editor.transact((e) => ss(e.doc, t));
  }
  /**
   * Gets a snapshot of the parent of an existing block from the editor.
   * @param blockIdentifier The identifier of an existing block for which the
   * parent should be retrieved.
   * @returns The parent of the block that matches the identifier. `undefined`
   * if no matching block was found, or the block isn't nested.
   */
  getParentBlock(t) {
    return this.editor.transact(
      (e) => is2(e.doc, t)
    );
  }
  /**
   * Traverses all blocks in the editor depth-first, and executes a callback for each.
   * @param callback The callback to execute for each block. Returning `false` stops the traversal.
   * @param reverse Whether the blocks should be traversed in reverse order.
   */
  forEachBlock(t, e = false) {
    const o = this.document.slice();
    e && o.reverse();
    function r(s2) {
      for (const i2 of s2) {
        if (t(i2) === false)
          return false;
        const c = e ? i2.children.slice().reverse() : i2.children;
        if (!r(c))
          return false;
      }
      return true;
    }
    r(o);
  }
  /**
   * Inserts new blocks into the editor. If a block's `id` is undefined, BlockNote generates one automatically. Throws an
   * error if the reference block could not be found.
   * @param blocksToInsert An array of partial blocks that should be inserted.
   * @param referenceBlock An identifier for an existing block, at which the new blocks should be inserted.
   * @param placement Whether the blocks should be inserted just before, just after, or nested inside the
   * `referenceBlock`.
   */
  insertBlocks(t, e, o = "before") {
    return this.editor.transact(
      (r) => un2(r, t, e, o)
    );
  }
  /**
   * Updates an existing block in the editor. Since updatedBlock is a PartialBlock object, some fields might not be
   * defined. These undefined fields are kept as-is from the existing block. Throws an error if the block to update could
   * not be found.
   * @param blockToUpdate The block that should be updated.
   * @param update A partial block which defines how the existing block should be changed.
   */
  updateBlock(t, e) {
    return this.editor.transact((o) => or(o, t, e));
  }
  /**
   * Removes existing blocks from the editor. Throws an error if any of the blocks could not be found.
   * @param blocksToRemove An array of identifiers for existing blocks that should be removed.
   */
  removeBlocks(t) {
    return this.editor.transact(
      (e) => We(e, t, []).removedBlocks
    );
  }
  /**
   * Replaces existing blocks in the editor with new blocks. If the blocks that should be removed are not adjacent or
   * are at different nesting levels, `blocksToInsert` will be inserted at the position of the first block in
   * `blocksToRemove`. Throws an error if any of the blocks to remove could not be found.
   * @param blocksToRemove An array of blocks that should be replaced.
   * @param blocksToInsert An array of partial blocks to replace the old ones with.
   */
  replaceBlocks(t, e) {
    return this.editor.transact(
      (o) => We(o, t, e)
    );
  }
  /**
   * Checks if the block containing the text cursor can be nested.
   */
  canNestBlock() {
    return dr2(this.editor);
  }
  /**
   * Nests the block containing the text cursor into the block above it.
   */
  nestBlock() {
    At(this.editor);
  }
  /**
   * Checks if the block containing the text cursor is nested.
   */
  canUnnestBlock() {
    return hr3(this.editor);
  }
  /**
   * Lifts the block containing the text cursor out of its parent.
   */
  unnestBlock() {
    lr2(this.editor);
  }
  /**
   * Moves the selected blocks up. If the previous block has children, moves
   * them to the end of its children. If there is no previous block, but the
   * current blocks share a common parent, moves them out of & before it.
   */
  moveBlocksUp() {
    return ts(this.editor);
  }
  /**
   * Moves the selected blocks down. If the next block has children, moves
   * them to the start of its children. If there is no next block, but the
   * current blocks share a common parent, moves them out of & after it.
   */
  moveBlocksDown() {
    return os(this.editor);
  }
};
var cs = class {
  constructor(t, e) {
    h3(this, "editor");
    h3(this, "options");
    h3(this, "_commentsPlugin");
    h3(this, "_forkYDocPlugin");
    h3(this, "_syncPlugin");
    h3(this, "_undoPlugin");
    h3(this, "_cursorPlugin");
    this.editor = t, this.options = e;
  }
  /**
   * Get the sync plugin instance
   */
  get syncPlugin() {
    return this._syncPlugin;
  }
  /**
   * Get the undo plugin instance
   */
  get undoPlugin() {
    return this._undoPlugin;
  }
  /**
   * Get the cursor plugin instance
   */
  get cursorPlugin() {
    return this._cursorPlugin;
  }
  /**
   * Get the fork YDoc plugin instance
   */
  get forkYDocPlugin() {
    return this._forkYDocPlugin;
  }
  // Initialize collaboration plugins
  initExtensions() {
    var e;
    const t = {};
    if (this._syncPlugin = new ge2(this.options.fragment), t.ySyncPlugin = this._syncPlugin, this._undoPlugin = new be2({ editor: this.editor }), t.yUndoPlugin = this._undoPlugin, (e = this.options.provider) != null && e.awareness && (this._cursorPlugin = new se2(this.options), t.yCursorPlugin = this._cursorPlugin), this._forkYDocPlugin = new xt({
      editor: this.editor,
      collaboration: this.options
    }), t.forkYDocPlugin = this._forkYDocPlugin, this.options.comments) {
      if (!this.options.resolveUsers)
        throw new Error("resolveUsers is required when using comments");
      this._commentsPlugin = new Lt(
        this.editor,
        this.options.comments.threadStore,
        ke2.name,
        this.options.resolveUsers,
        this.options.comments.schema
      ), t.comments = this._commentsPlugin, t.commentMark = ke2;
    }
    return t;
  }
  /**
   * Update the user info for the current user that's shown to other collaborators
   */
  updateUserInfo(t) {
    const e = this.cursorPlugin;
    if (!e)
      throw new Error(
        "Cannot update collaboration user info when collaboration is disabled."
      );
    e.updateUser(t);
  }
  /**
   * Get the collaboration undo command
   */
  getUndoCommand() {
    return undoCommand;
  }
  /**
   * Get the collaboration redo command
   */
  getRedoCommand() {
    return redoCommand;
  }
  /**
   * Check if initial content should be avoided due to collaboration
   */
  shouldAvoidInitialContent() {
    return !!this.options.provider;
  }
  /**
   * Get the collaboration options
   */
  getOptions() {
    return this.options;
  }
  /**
   * Get the comments plugin if available
   */
  get comments() {
    return this._commentsPlugin;
  }
  /**
   * Check if comments are enabled
   */
  get hasComments() {
    return !!this.options.comments;
  }
  /**
   * Get the resolveUsers function
   */
  get resolveUsers() {
    return this.options.resolveUsers;
  }
};
var ls = class extends xn {
  constructor(t) {
    super(), this.editor = t, t.onCreate(() => {
      t._tiptapEditor.on(
        "update",
        ({ transaction: e, appendedTransactions: o }) => {
          this.emit("onChange", t, {
            getChanges() {
              return Et(
                e,
                o
              );
            }
          });
        }
      ), t._tiptapEditor.on("selectionUpdate", ({ transaction: e }) => {
        this.emit("onSelectionChange", { editor: t, transaction: e });
      }), t._tiptapEditor.on("mount", () => {
        this.emit("onMount", { editor: t });
      }), t._tiptapEditor.on("unmount", () => {
        this.emit("onUnmount", { editor: t });
      });
    });
  }
  /**
   * Register a callback that will be called when the editor changes.
   */
  onChange(t) {
    return this.on("onChange", t), () => {
      this.off("onChange", t);
    };
  }
  /**
   * Register a callback that will be called when the selection changes.
   */
  onSelectionChange(t, e = false) {
    const o = (r) => {
      r.transaction.getMeta("$y-sync") && !e || t(this.editor);
    };
    return this.on("onSelectionChange", o), () => {
      this.off("onSelectionChange", o);
    };
  }
  /**
   * Register a callback that will be called when the editor is mounted.
   */
  onMount(t) {
    return this.on("onMount", t), () => {
      this.off("onMount", t);
    };
  }
  /**
   * Register a callback that will be called when the editor is unmounted.
   */
  onUnmount(t) {
    return this.on("onUnmount", t), () => {
      this.off("onUnmount", t);
    };
  }
};
function ds(n) {
  return Array.prototype.indexOf.call(n.parentElement.childNodes, n);
}
function hs(n) {
  return n.nodeType === 3 && !/\S/.test(n.nodeValue || "");
}
function us(n) {
  n.querySelectorAll("li > ul, li > ol").forEach((t) => {
    const e = ds(t), o = t.parentElement, r = Array.from(o.childNodes).slice(
      e + 1
    );
    t.remove(), r.forEach((s2) => {
      s2.remove();
    }), o.insertAdjacentElement("afterend", t), r.reverse().forEach((s2) => {
      if (hs(s2))
        return;
      const i2 = document.createElement("li");
      i2.append(s2), t.insertAdjacentElement("afterend", i2);
    }), o.childNodes.length === 0 && o.remove();
  });
}
function ps(n) {
  n.querySelectorAll("li + ul, li + ol").forEach((t) => {
    var s2, i2;
    const e = t.previousElementSibling, o = document.createElement("div");
    e.insertAdjacentElement("afterend", o), o.append(e);
    const r = document.createElement("div");
    for (r.setAttribute("data-node-type", "blockGroup"), o.append(r); ((s2 = o.nextElementSibling) == null ? void 0 : s2.nodeName) === "UL" || ((i2 = o.nextElementSibling) == null ? void 0 : i2.nodeName) === "OL"; )
      r.append(o.nextElementSibling);
  });
}
var ct2 = null;
function ms() {
  return ct2 || (ct2 = document.implementation.createHTMLDocument("title"));
}
function fs(n) {
  if (typeof n == "string") {
    const t = ms().createElement("div");
    t.innerHTML = n, n = t;
  }
  return us(n), ps(n), n;
}
function Vt2(n, t) {
  const e = fs(n), r = DOMParser2.fromSchema(t).parse(e, {
    topNode: t.nodes.blockGroup.create()
  }), s2 = [];
  for (let i2 = 0; i2 < r.childCount; i2++)
    s2.push(X(r.child(i2), t));
  return s2;
}
function gs(n, t) {
  const e = t.value ? t.value : "", o = {};
  t.lang && (o["data-language"] = t.lang);
  let r = {
    type: "element",
    tagName: "code",
    properties: o,
    children: [{ type: "text", value: e }]
  };
  return t.meta && (r.data = { meta: t.meta }), n.patch(t, r), r = n.applyData(t, r), r = {
    type: "element",
    tagName: "pre",
    properties: {},
    children: [r]
  }, n.patch(t, r), r;
}
function bs(n, t) {
  var s2;
  const e = String((t == null ? void 0 : t.url) || ""), o = t != null && t.title ? String(t.title) : void 0;
  let r = {
    type: "element",
    tagName: "video",
    properties: {
      src: e,
      "data-name": o,
      "data-url": e,
      controls: true
    },
    children: []
  };
  return (s2 = n.patch) == null || s2.call(n, t, r), r = n.applyData ? n.applyData(t, r) : r, r;
}
function $t2(n) {
  return unified().use(remarkParse).use(remarkGfm).use(remarkRehype, {
    handlers: {
      ...handlers2,
      image: (e, o) => {
        const r = String((o == null ? void 0 : o.url) || "");
        return $o(r) ? bs(e, o) : handlers2.image(e, o);
      },
      code: gs
    }
  }).use(rehypeStringify).processSync(n).value;
}
function ks(n, t) {
  const e = $t2(n);
  return Vt2(e, t);
}
var ws = class {
  constructor(t) {
    this.editor = t;
  }
  /**
   * Exports blocks into a simplified HTML string. To better conform to HTML standards, children of blocks which aren't list
   * items are un-nested in the output HTML.
   *
   * @param blocks An array of blocks that should be serialized into HTML.
   * @returns The blocks, serialized as an HTML string.
   */
  blocksToHTMLLossy(t = this.editor.document) {
    return Se(
      this.editor.pmSchema,
      this.editor
    ).exportBlocks(t, {});
  }
  /**
   * Serializes blocks into an HTML string in the format that would normally be rendered by the editor.
   *
   * Use this method if you want to server-side render HTML (for example, a blog post that has been edited in BlockNote)
   * and serve it to users without loading the editor on the client (i.e.: displaying the blog post)
   *
   * @param blocks An array of blocks that should be serialized into HTML.
   * @returns The blocks, serialized as an HTML string.
   */
  blocksToFullHTML(t) {
    return bn2(
      this.editor.pmSchema,
      this.editor
    ).serializeBlocks(t, {});
  }
  /**
   * Parses blocks from an HTML string. Tries to create `Block` objects out of any HTML block-level elements, and
   * `InlineNode` objects from any HTML inline elements, though not all element types are recognized. If BlockNote
   * doesn't recognize an HTML element's tag, it will parse it as a paragraph or plain text.
   * @param html The HTML string to parse blocks from.
   * @returns The blocks parsed from the HTML string.
   */
  tryParseHTMLToBlocks(t) {
    return Vt2(t, this.editor.pmSchema);
  }
  /**
   * Serializes blocks into a Markdown string. The output is simplified as Markdown does not support all features of
   * BlockNote - children of blocks which aren't list items are un-nested and certain styles are removed.
   * @param blocks An array of blocks that should be serialized into Markdown.
   * @returns The blocks, serialized as a Markdown string.
   */
  blocksToMarkdownLossy(t = this.editor.document) {
    return Gn2(t, this.editor.pmSchema, this.editor, {});
  }
  /**
   * Creates a list of blocks from a Markdown string. Tries to create `Block` and `InlineNode` objects based on
   * Markdown syntax, though not all symbols are recognized. If BlockNote doesn't recognize a symbol, it will parse it
   * as text.
   * @param markdown The Markdown string to parse blocks from.
   * @returns The blocks parsed from the Markdown string.
   */
  tryParseMarkdownToBlocks(t) {
    return ks(t, this.editor.pmSchema);
  }
  /**
   * Paste HTML into the editor. Defaults to converting HTML to BlockNote HTML.
   * @param html The HTML to paste.
   * @param raw Whether to paste the HTML as is, or to convert it to BlockNote HTML.
   */
  pasteHTML(t, e = false) {
    var r;
    let o = t;
    if (!e) {
      const s2 = this.tryParseHTMLToBlocks(t);
      o = this.blocksToFullHTML(s2);
    }
    o && ((r = this.editor.prosemirrorView) == null || r.pasteHTML(o));
  }
  /**
   * Paste text into the editor. Defaults to interpreting text as markdown.
   * @param text The text to paste.
   */
  pasteText(t) {
    var e;
    return (e = this.editor.prosemirrorView) == null ? void 0 : e.pasteText(t);
  }
  /**
   * Paste markdown into the editor.
   * @param markdown The markdown to paste.
   */
  pasteMarkdown(t) {
    const e = $t2(t);
    return this.pasteHTML(e);
  }
};
var ys = class {
  constructor(t) {
    this.editor = t;
  }
  /**
   * Shorthand to get a typed extension from the editor, by
   * just passing in the extension class.
   *
   * @param ext - The extension class to get
   * @param key - optional, the key of the extension in the extensions object (defaults to the extension name)
   * @returns The extension instance
   */
  extension(t, e = t.key()) {
    const o = this.editor.extensions[e];
    if (!o)
      throw new Error(`Extension ${e} not found`);
    return o;
  }
  /**
   * Get all extensions
   */
  getExtensions() {
    return this.editor.extensions;
  }
  /**
   * Get a specific extension by key
   */
  getExtension(t) {
    return this.editor.extensions[t];
  }
  /**
   * Check if an extension exists
   */
  hasExtension(t) {
    return t in this.editor.extensions;
  }
  // Plugin getters - these provide access to the core BlockNote plugins
  /**
   * Get the formatting toolbar plugin
   */
  get formattingToolbar() {
    return this.editor.extensions.formattingToolbar;
  }
  /**
   * Get the link toolbar plugin
   */
  get linkToolbar() {
    return this.editor.extensions.linkToolbar;
  }
  /**
   * Get the side menu plugin
   */
  get sideMenu() {
    return this.editor.extensions.sideMenu;
  }
  /**
   * Get the suggestion menus plugin
   */
  get suggestionMenus() {
    return this.editor.extensions.suggestionMenus;
  }
  /**
   * Get the file panel plugin (if available)
   */
  get filePanel() {
    return this.editor.extensions.filePanel;
  }
  /**
   * Get the table handles plugin (if available)
   */
  get tableHandles() {
    return this.editor.extensions.tableHandles;
  }
  /**
   * Get the show selection plugin
   */
  get showSelectionPlugin() {
    return this.editor.extensions.showSelection;
  }
  /**
   * Check if collaboration is enabled (Yjs or Liveblocks)
   */
  get isCollaborationEnabled() {
    return this.hasExtension("ySyncPlugin") || this.hasExtension("liveblocksExtension");
  }
};
function Cs(n) {
  const t = G(n);
  if (n.selection.empty || "node" in n.selection)
    return;
  const e = n.doc.resolve(
    fe(n.doc, n.selection.from).posBeforeNode
  ), o = n.doc.resolve(
    fe(n.doc, n.selection.to).posBeforeNode
  ), r = (l2, d) => {
    const u = e.posAtIndex(l2, d), p5 = n.doc.resolve(u).nodeAfter;
    if (!p5)
      throw new Error(
        `Error getting selection - node not found at position ${u}`
      );
    return X(p5, t);
  }, s2 = [], i2 = e.sharedDepth(o.pos), c = e.index(i2), a2 = o.index(i2);
  if (e.depth > i2) {
    s2.push(X(e.nodeAfter, t));
    for (let l2 = e.depth; l2 > i2; l2--)
      if (e.node(l2).type.isInGroup("childContainer")) {
        const u = e.index(l2) + 1, p5 = e.node(l2).childCount;
        for (let m = u; m < p5; m++)
          s2.push(r(m, l2));
      }
  } else
    s2.push(r(c, i2));
  for (let l2 = c + 1; l2 <= a2; l2++)
    s2.push(r(l2, i2));
  if (s2.length === 0)
    throw new Error(
      `Error getting selection - selection doesn't span any blocks (${n.selection})`
    );
  return {
    blocks: s2
  };
}
function vs(n, t, e) {
  const o = typeof t == "string" ? t : t.id, r = typeof e == "string" ? e : e.id, s2 = G(n), i2 = me(s2);
  if (o === r)
    throw new Error(
      `Attempting to set selection with the same anchor and head blocks (id ${o})`
    );
  const c = un(o, n.doc);
  if (!c)
    throw new Error(`Block with ID ${o} not found`);
  const a2 = un(r, n.doc);
  if (!a2)
    throw new Error(`Block with ID ${r} not found`);
  const l2 = z(c), d = z(a2), u = i2.blockSchema[l2.blockNoteType], p5 = i2.blockSchema[d.blockNoteType];
  if (!l2.isBlockContainer || u.content === "none")
    throw new Error(
      `Attempting to set selection anchor in block without content (id ${o})`
    );
  if (!d.isBlockContainer || p5.content === "none")
    throw new Error(
      `Attempting to set selection anchor in block without content (id ${r})`
    );
  let m, g;
  if (u.content === "table") {
    const f2 = TableMap.get(l2.blockContent.node);
    m = l2.blockContent.beforePos + f2.positionAt(0, 0, l2.blockContent.node) + 1 + 2;
  } else
    m = l2.blockContent.beforePos + 1;
  if (p5.content === "table") {
    const f2 = TableMap.get(d.blockContent.node), b2 = d.blockContent.beforePos + f2.positionAt(
      f2.height - 1,
      f2.width - 1,
      d.blockContent.node
    ) + 1, k2 = n.doc.resolve(b2).nodeAfter.nodeSize;
    g = b2 + k2 - 2;
  } else
    g = d.blockContent.afterPos - 1;
  n.setSelection(TextSelection.create(n.doc, m, g));
}
function Ss(n) {
  const t = G(n);
  let e = n.selection.$from, o = n.selection.$to;
  for (; o.parentOffset >= o.parent.nodeSize - 2 && o.depth > 0; )
    o = n.doc.resolve(o.pos + 1);
  for (; o.parentOffset === 0 && o.depth > 0; )
    o = n.doc.resolve(o.pos - 1);
  for (; e.parentOffset === 0 && e.depth > 0; )
    e = n.doc.resolve(e.pos - 1);
  for (; e.parentOffset >= e.parent.nodeSize - 2 && e.depth > 0; )
    e = n.doc.resolve(e.pos + 1);
  const r = zo(
    n.doc.slice(e.pos, o.pos, true),
    t
  );
  return {
    _meta: {
      startPos: e.pos,
      endPos: o.pos
    },
    ...r
  };
}
function Bs(n) {
  const { bnBlock: t } = Gt(n), e = G(n.doc), o = n.doc.resolve(t.beforePos), r = o.nodeBefore, s2 = n.doc.resolve(t.afterPos).nodeAfter;
  let i2;
  return o.depth > 1 && (i2 = o.node(), i2.type.isInGroup("bnBlock") || (i2 = o.node(o.depth - 1))), {
    block: X(t.node, e),
    prevBlock: r === null ? void 0 : X(r, e),
    nextBlock: s2 === null ? void 0 : X(s2, e),
    parentBlock: i2 === void 0 ? void 0 : X(i2, e)
  };
}
function Ft2(n, t, e = "start") {
  const o = typeof t == "string" ? t : t.id, r = G(n.doc), s2 = me(r), i2 = un(o, n.doc);
  if (!i2)
    throw new Error(`Block with ID ${o} not found`);
  const c = z(i2), a2 = s2.blockSchema[c.blockNoteType].content;
  if (c.isBlockContainer) {
    const l2 = c.blockContent;
    if (a2 === "none") {
      n.setSelection(NodeSelection.create(n.doc, l2.beforePos));
      return;
    }
    if (a2 === "inline")
      e === "start" ? n.setSelection(
        TextSelection.create(n.doc, l2.beforePos + 1)
      ) : n.setSelection(
        TextSelection.create(n.doc, l2.afterPos - 1)
      );
    else if (a2 === "table")
      e === "start" ? n.setSelection(
        TextSelection.create(n.doc, l2.beforePos + 4)
      ) : n.setSelection(
        TextSelection.create(n.doc, l2.afterPos - 4)
      );
    else
      throw new Z(a2);
  } else {
    const l2 = e === "start" ? c.childContainer.node.firstChild : c.childContainer.node.lastChild;
    Ft2(n, l2.attrs.id, e);
  }
}
var Es = class {
  constructor(t) {
    this.editor = t;
  }
  /**
   * Gets a snapshot of the current selection. This contains all blocks (included nested blocks)
   * that the selection spans across.
   *
   * If the selection starts / ends halfway through a block, the returned data will contain the entire block.
   */
  getSelection() {
    return this.editor.transact((t) => Cs(t));
  }
  /**
   * Gets a snapshot of the current selection. This contains all blocks (included nested blocks)
   * that the selection spans across.
   *
   * If the selection starts / ends halfway through a block, the returned block will be
   * only the part of the block that is included in the selection.
   */
  getSelectionCutBlocks() {
    return this.editor.transact((t) => Ss(t));
  }
  /**
   * Sets the selection to a range of blocks.
   * @param startBlock The identifier of the block that should be the start of the selection.
   * @param endBlock The identifier of the block that should be the end of the selection.
   */
  setSelection(t, e) {
    return this.editor.transact((o) => vs(o, t, e));
  }
  /**
   * Gets a snapshot of the current text cursor position.
   * @returns A snapshot of the current text cursor position.
   */
  getTextCursorPosition() {
    return this.editor.transact((t) => Bs(t));
  }
  /**
   * Sets the text cursor position to the start or end of an existing block. Throws an error if the target block could
   * not be found.
   * @param targetBlock The identifier of an existing block that the text cursor should be moved to.
   * @param placement Whether the text cursor should be placed at the start or end of the block.
   */
  setTextCursorPosition(t, e = "start") {
    return this.editor.transact(
      (o) => Ft2(o, t, e)
    );
  }
  /**
   * Gets the bounding box of the current selection.
   */
  getSelectionBoundingBox() {
    if (!this.editor.prosemirrorView)
      return;
    const { selection: t } = this.editor.prosemirrorState, { ranges: e } = t, o = Math.min(...e.map((s2) => s2.$from.pos)), r = Math.max(...e.map((s2) => s2.$to.pos));
    if (isNodeSelection(t)) {
      const s2 = this.editor.prosemirrorView.nodeDOM(o);
      if (s2)
        return s2.getBoundingClientRect();
    }
    return posToDOMRect(this.editor.prosemirrorView, o, r);
  }
};
var Ms = class {
  constructor(t, e) {
    h3(this, "activeTransaction", null);
    h3(this, "isInCan", false);
    this.editor = t, this.options = e;
  }
  /**
   * For any command that can be executed, you can check if it can be executed by calling `editor.can(command)`.
   * @example
   * ```ts
   * if (editor.can(editor.undo)) {
   *   // show button
   * } else {
   *   // hide button
   * }
   */
  can(t) {
    try {
      return this.isInCan = true, t();
    } finally {
      this.isInCan = false;
    }
  }
  /**
   * Execute a prosemirror command. This is mostly for backwards compatibility with older code.
   *
   * @note You should prefer the {@link transact} method when possible, as it will automatically handle the dispatching of the transaction and work across blocknote transactions.
   *
   * @example
   * ```ts
   * editor.exec((state, dispatch, view) => {
   *   dispatch(state.tr.insertText("Hello, world!"));
   * });
   * ```
   */
  exec(t) {
    if (this.activeTransaction)
      throw new Error(
        "`exec` should not be called within a `transact` call, move the `exec` call outside of the `transact` call"
      );
    if (this.isInCan)
      return this.canExec(t);
    const e = this.prosemirrorState, o = this.prosemirrorView;
    return t(e, (s2) => this.prosemirrorView.dispatch(s2), o);
  }
  /**
   * Check if a command can be executed. A command should return `false` if it is not valid in the current state.
   *
   * @example
   * ```ts
   * if (editor.canExec(command)) {
   *   // show button
   * } else {
   *   // hide button
   * }
   * ```
   */
  canExec(t) {
    if (this.activeTransaction)
      throw new Error(
        "`canExec` should not be called within a `transact` call, move the `canExec` call outside of the `transact` call"
      );
    const e = this.prosemirrorState, o = this.prosemirrorView;
    return t(e, void 0, o);
  }
  /**
   * Execute a function within a "blocknote transaction".
   * All changes to the editor within the transaction will be grouped together, so that
   * we can dispatch them as a single operation (thus creating only a single undo step)
   *
   * @note There is no need to dispatch the transaction, as it will be automatically dispatched when the callback is complete.
   *
   * @example
   * ```ts
   * // All changes to the editor will be grouped together
   * editor.transact((tr) => {
   *   tr.insertText("Hello, world!");
   * // These two operations will be grouped together in a single undo step
   *   editor.transact((tr) => {
   *     tr.insertText("Hello, world!");
   *   });
   * });
   * ```
   */
  transact(t) {
    if (this.activeTransaction)
      return t(this.activeTransaction);
    try {
      this.activeTransaction = this.editor._tiptapEditor.state.tr;
      const e = t(this.activeTransaction), o = this.activeTransaction;
      return this.activeTransaction = null, o && // Only dispatch if the transaction was actually modified in some way
      (o.docChanged || o.selectionSet || o.scrolledIntoView || o.storedMarksSet || !o.isGeneric) && this.prosemirrorView.dispatch(o), e;
    } finally {
      this.activeTransaction = null;
    }
  }
  /**
   * Get the underlying prosemirror state
   * @note Prefer using `editor.transact` to read the current editor state, as that will ensure the state is up to date
   * @see https://prosemirror.net/docs/ref/#state.EditorState
   */
  get prosemirrorState() {
    if (this.activeTransaction)
      throw new Error(
        "`prosemirrorState` should not be called within a `transact` call, move the `prosemirrorState` call outside of the `transact` call or use `editor.transact` to read the current editor state"
      );
    return this.editor._tiptapEditor.state;
  }
  /**
   * Get the underlying prosemirror view
   * @see https://prosemirror.net/docs/ref/#view.EditorView
   */
  get prosemirrorView() {
    return this.editor._tiptapEditor.view;
  }
  isFocused() {
    var t;
    return ((t = this.prosemirrorView) == null ? void 0 : t.hasFocus()) || false;
  }
  focus() {
    var t;
    (t = this.prosemirrorView) == null || t.focus();
  }
  /**
   * Checks if the editor is currently editable, or if it's locked.
   * @returns True if the editor is editable, false otherwise.
   */
  get isEditable() {
    if (!this.editor._tiptapEditor) {
      if (!this.editor.headless)
        throw new Error("no editor, but also not headless?");
      return false;
    }
    return this.editor._tiptapEditor.isEditable === void 0 ? true : this.editor._tiptapEditor.isEditable;
  }
  /**
   * Makes the editor editable or locks it, depending on the argument passed.
   * @param editable True to make the editor editable, or false to lock it.
   */
  set isEditable(t) {
    if (!this.editor._tiptapEditor) {
      if (!this.editor.headless)
        throw new Error("no editor, but also not headless?");
      return;
    }
    this.editor._tiptapEditor.options.editable !== t && this.editor._tiptapEditor.setEditable(t);
  }
  /**
   * Undo the last action.
   */
  undo() {
    var t;
    return this.exec(((t = this.options) == null ? void 0 : t.undo) ?? undo);
  }
  /**
   * Redo the last action.
   */
  redo() {
    var t;
    return this.exec(((t = this.options) == null ? void 0 : t.redo) ?? redo);
  }
};
function Ps(n, t, e, o = { updateSelection: true }) {
  let { from: r, to: s2 } = typeof t == "number" ? { from: t, to: t } : { from: t.from, to: t.to }, i2 = true, c = true, a2 = "";
  if (e.forEach((l2) => {
    l2.check(), i2 && l2.isText && l2.marks.length === 0 ? a2 += l2.text : i2 = false, c = c ? l2.isBlock : false;
  }), r === s2 && c) {
    const { parent: l2 } = n.doc.resolve(r);
    l2.isTextblock && !l2.type.spec.code && !l2.childCount && (r -= 1, s2 += 1);
  }
  return i2 ? n.insertText(a2, r, s2) : n.replaceWith(r, s2, e), o.updateSelection && selectionToInsertionEnd(n, n.steps.length - 1, -1), true;
}
var Ts = class {
  constructor(t) {
    this.editor = t;
  }
  /**
   * Insert a piece of content at the current cursor position.
   *
   * @param content can be a string, or array of partial inline content elements
   */
  insertInlineContent(t, { updateSelection: e = false } = {}) {
    const o = O(t, this.editor.pmSchema);
    this.editor.transact((r) => {
      Ps(
        r,
        {
          from: r.selection.from,
          to: r.selection.to
        },
        o,
        {
          updateSelection: e
        }
      );
    });
  }
  /**
   * Gets the active text styles at the text cursor position or at the end of the current selection if it's active.
   */
  getActiveStyles() {
    return this.editor.transact((t) => {
      const e = {}, o = t.selection.$to.marks();
      for (const r of o) {
        const s2 = this.editor.schema.styleSchema[r.type.name];
        if (!s2) {
          r.type.name !== "link" && // "blocknoteIgnore" tagged marks (such as comments) are also not considered BlockNote "styles"
          !r.type.spec.blocknoteIgnore && console.warn("mark not found in styleschema", r.type.name);
          continue;
        }
        s2.propSchema === "boolean" ? e[s2.type] = true : e[s2.type] = r.attrs.stringValue;
      }
      return e;
    });
  }
  /**
   * Adds styles to the currently selected content.
   * @param styles The styles to add.
   */
  addStyles(t) {
    for (const [e, o] of Object.entries(t)) {
      const r = this.editor.schema.styleSchema[e];
      if (!r)
        throw new Error(`style ${e} not found in styleSchema`);
      if (r.propSchema === "boolean")
        this.editor._tiptapEditor.commands.setMark(e);
      else if (r.propSchema === "string")
        this.editor._tiptapEditor.commands.setMark(e, {
          stringValue: o
        });
      else
        throw new Z(r.propSchema);
    }
  }
  /**
   * Removes styles from the currently selected content.
   * @param styles The styles to remove.
   */
  removeStyles(t) {
    for (const e of Object.keys(t))
      this.editor._tiptapEditor.commands.unsetMark(e);
  }
  /**
   * Toggles styles on the currently selected content.
   * @param styles The styles to toggle.
   */
  toggleStyles(t) {
    for (const [e, o] of Object.entries(t)) {
      const r = this.editor.schema.styleSchema[e];
      if (!r)
        throw new Error(`style ${e} not found in styleSchema`);
      if (r.propSchema === "boolean")
        this.editor._tiptapEditor.commands.toggleMark(e);
      else if (r.propSchema === "string")
        this.editor._tiptapEditor.commands.toggleMark(e, {
          stringValue: o
        });
      else
        throw new Z(r.propSchema);
    }
  }
  /**
   * Gets the currently selected text.
   */
  getSelectedText() {
    return this.editor.transact((t) => t.doc.textBetween(t.selection.from, t.selection.to));
  }
  /**
   * Gets the URL of the last link in the current selection, or `undefined` if there are no links in the selection.
   */
  getSelectedLinkUrl() {
    return this.editor._tiptapEditor.getAttributes("link").href;
  }
  /**
   * Creates a new link to replace the selected content.
   * @param url The link URL.
   * @param text The text to display the link with.
   */
  createLink(t, e) {
    if (t === "")
      return;
    const o = this.editor.pmSchema.mark("link", { href: t });
    this.editor.transact((r) => {
      const { from: s2, to: i2 } = r.selection;
      e ? r.insertText(e, s2, i2).addMark(s2, s2 + e.length, o) : r.setSelection(TextSelection.create(r.doc, i2)).addMark(
        s2,
        i2,
        o
      );
    });
  }
};
function xs(n, t) {
  const e = [];
  return n.forEach((o, r, s2) => {
    s2 !== t && e.push(o);
  }), Fragment.from(e);
}
function Is(n, t) {
  const e = [];
  for (let o = 0; o < n.childCount; o++)
    if (n.child(o).type.name === "tableRow")
      if (e.length > 0 && e[e.length - 1].type.name === "table") {
        const r = e[e.length - 1], s2 = r.copy(r.content.addToEnd(n.child(o)));
        e[e.length - 1] = s2;
      } else {
        const r = t.nodes.table.createChecked(
          void 0,
          n.child(o)
        );
        e.push(r);
      }
    else
      e.push(n.child(o));
  return n = Fragment.from(e), n;
}
function Ls(n, t) {
  let e = Fragment.from(n.content);
  if (e = Is(e, t.state.schema), !Ds(e, t))
    return new Slice(e, n.openStart, n.openEnd);
  for (let o = 0; o < e.childCount; o++)
    if (e.child(o).type.spec.group === "blockContent") {
      const r = [e.child(o)];
      if (o + 1 < e.childCount && e.child(o + 1).type.name === "blockGroup") {
        const i2 = e.child(o + 1).child(0).child(0);
        (i2.type.name === "bulletListItem" || i2.type.name === "numberedListItem" || i2.type.name === "checkListItem") && (r.push(e.child(o + 1)), e = xs(e, o + 1));
      }
      const s2 = t.state.schema.nodes.blockContainer.createChecked(
        void 0,
        r
      );
      e = e.replaceChild(o, s2);
    }
  return new Slice(e, n.openStart, n.openEnd);
}
function Ds(n, t) {
  var s2, i2;
  const e = n.childCount === 1, o = ((s2 = n.firstChild) == null ? void 0 : s2.type.spec.content) === "inline*", r = ((i2 = n.firstChild) == null ? void 0 : i2.type.spec.content) === "tableRow+";
  if (e) {
    if (o)
      return false;
    if (r) {
      const c = Ge(t.state);
      if (c.isBlockContainer)
        return !(c.blockContent.node.type.spec.content === "tableRow+");
    }
  }
  return true;
}
var As = {
  enableInputRules: true,
  enablePasteRules: true,
  enableCoreExtensions: false
};
var zt2 = class _zt extends xn {
  constructor(e) {
    var l2, d, u, p5, m, g, f2, b2, k2, w3, D2, F3, J3, Q, Z2, ee2, v2, M3, Ue2;
    super();
    h3(this, "pmSchema");
    h3(this, "extensions", {});
    h3(this, "_tiptapEditor");
    h3(this, "elementRenderer", null);
    h3(this, "blockCache", /* @__PURE__ */ new WeakMap());
    h3(this, "dictionary");
    h3(this, "schema");
    h3(this, "blockImplementations");
    h3(this, "inlineContentImplementations");
    h3(this, "styleImplementations");
    h3(this, "uploadFile");
    h3(this, "onUploadStartCallbacks", []);
    h3(this, "onUploadEndCallbacks", []);
    h3(this, "resolveFileUrl");
    h3(this, "resolveUsers");
    h3(this, "settings");
    h3(this, "_blockManager");
    h3(this, "_collaborationManager");
    h3(this, "_eventManager");
    h3(this, "_exportManager");
    h3(this, "_extensionManager");
    h3(this, "_selectionManager");
    h3(this, "_stateManager");
    h3(this, "_styleManager");
    h3(this, "mount", (e2) => {
      this._tiptapEditor.mount({ mount: e2 });
    });
    h3(this, "unmount", () => {
      this._tiptapEditor.unmount();
    });
    this.options = e;
    const o = e;
    if (o.onEditorContentChange)
      throw new Error(
        "onEditorContentChange initialization option is deprecated, use <BlockNoteView onChange={...} />, the useEditorChange(...) hook, or editor.onChange(...)"
      );
    if (o.onTextCursorPositionChange)
      throw new Error(
        "onTextCursorPositionChange initialization option is deprecated, use <BlockNoteView onSelectionChange={...} />, the useEditorSelectionChange(...) hook, or editor.onSelectionChange(...)"
      );
    if (o.onEditorReady)
      throw new Error(
        "onEditorReady is deprecated. Editor is immediately ready for use after creation."
      );
    if (o.editable)
      throw new Error(
        "editable initialization option is deprecated, use <BlockNoteView editable={true/false} />, or alternatively editor.isEditable = true/false"
      );
    this.dictionary = e.dictionary || i, this.settings = {
      tables: {
        splitCells: ((l2 = e == null ? void 0 : e.tables) == null ? void 0 : l2.splitCells) ?? false,
        cellBackgroundColor: ((d = e == null ? void 0 : e.tables) == null ? void 0 : d.cellBackgroundColor) ?? false,
        cellTextColor: ((u = e == null ? void 0 : e.tables) == null ? void 0 : u.cellTextColor) ?? false,
        headers: ((p5 = e == null ? void 0 : e.tables) == null ? void 0 : p5.headers) ?? false
      }
    };
    const r = {
      defaultStyles: true,
      schema: e.schema || ht.create(),
      ...e,
      placeholders: {
        ...this.dictionary.placeholders,
        ...e.placeholders
      }
    };
    if (r.collaboration || r.comments) {
      const y2 = {
        // Use collaboration options if available, otherwise provide defaults
        fragment: ((m = r.collaboration) == null ? void 0 : m.fragment) || new YXmlFragment(),
        user: ((g = r.collaboration) == null ? void 0 : g.user) || {
          name: "User",
          color: "#FF0000"
        },
        provider: ((f2 = r.collaboration) == null ? void 0 : f2.provider) || null,
        renderCursor: (b2 = r.collaboration) == null ? void 0 : b2.renderCursor,
        showCursorLabels: (k2 = r.collaboration) == null ? void 0 : k2.showCursorLabels,
        comments: r.comments,
        resolveUsers: r.resolveUsers
      };
      this._collaborationManager = new cs(
        this,
        y2
      );
    } else
      this._collaborationManager = void 0;
    if (r.comments && !r.resolveUsers)
      throw new Error("resolveUsers is required when using comments");
    this.schema = r.schema, this.blockImplementations = r.schema.blockSpecs, this.inlineContentImplementations = r.schema.inlineContentSpecs, this.styleImplementations = r.schema.styleSpecs, this.extensions = {
      ...Jr({
        editor: this,
        domAttributes: r.domAttributes || {},
        blockSpecs: this.schema.blockSpecs,
        styleSpecs: this.schema.styleSpecs,
        inlineContentSpecs: this.schema.inlineContentSpecs,
        collaboration: r.collaboration,
        trailingBlock: r.trailingBlock,
        disableExtensions: r.disableExtensions,
        setIdAttribute: r.setIdAttribute,
        animations: r.animations ?? true,
        tableHandles: E(this, "table"),
        dropCursor: this.options.dropCursor ?? dropCursor,
        placeholders: r.placeholders,
        tabBehavior: r.tabBehavior,
        pasteHandler: r.pasteHandler
      }),
      ...(w3 = this._collaborationManager) == null ? void 0 : w3.initExtensions()
    }, (((D2 = r._tiptapOptions) == null ? void 0 : D2.extensions) || []).forEach((y2) => {
      this.extensions[y2.name] = y2;
    });
    for (let y2 of r.extensions || []) {
      typeof y2 == "function" && (y2 = y2(this));
      const C3 = y2.key ?? y2.constructor.key();
      if (!C3)
        throw new Error(
          `Extension ${y2.constructor.name} does not have a key method`
        );
      if (this.extensions[C3])
        throw new Error(
          `Extension ${y2.constructor.name} already exists with key ${C3}`
        );
      this.extensions[C3] = y2;
    }
    if (Object.entries(r._extensions || {}).forEach(([y2, C3]) => {
      const P2 = typeof C3 == "function" ? C3(this) : C3;
      if (!("plugin" in P2)) {
        this.extensions[y2] = P2;
        return;
      }
      this.extensions[y2] = new class extends Sn {
        static key() {
          return y2;
        }
        constructor() {
          super(), this.addProsemirrorPlugin(P2.plugin);
        }
        get priority() {
          return P2.priority;
        }
      }();
    }), r.uploadFile) {
      const y2 = r.uploadFile;
      this.uploadFile = async (C3, H2) => {
        this.onUploadStartCallbacks.forEach(
          (P2) => P2.apply(this, [H2])
        );
        try {
          return await y2(C3, H2);
        } finally {
          this.onUploadEndCallbacks.forEach(
            (P2) => P2.apply(this, [H2])
          );
        }
      };
    }
    this.resolveFileUrl = r.resolveFileUrl;
    const s2 = "ySyncPlugin" in this.extensions || "liveblocksExtension" in this.extensions;
    s2 && r.initialContent && console.warn(
      "When using Collaboration, initialContent might cause conflicts, because changes should come from the collaboration provider"
    );
    const i2 = Object.fromEntries(
      Object.values(this.schema.blockSpecs).map((y2) => y2.extensions).filter((y2) => y2 !== void 0).flat().map((y2) => [y2.key ?? y2.constructor.key(), y2])
    ), c = [
      ...Object.entries({ ...this.extensions, ...i2 }).map(
        ([y2, C3]) => {
          if (C3 instanceof Extension || C3 instanceof Node3 || C3 instanceof Mark)
            return C3;
          if (C3 instanceof Sn)
            return !C3.plugins.length && !C3.keyboardShortcuts && !C3.inputRules && !C3.tiptapExtensions ? void 0 : Extension.create({
              name: y2,
              priority: C3.priority,
              addProseMirrorPlugins: () => C3.plugins,
              addExtensions: () => C3.tiptapExtensions || [],
              // TODO maybe collect all input rules from all extensions into one plugin
              // TODO consider using the prosemirror-inputrules package instead
              addInputRules: C3.inputRules ? () => C3.inputRules.map(
                (H2) => new InputRule({
                  find: H2.find,
                  handler: ({ range: P2, match: Be, state: Re3 }) => {
                    const Ve2 = H2.replace({
                      match: Be,
                      range: P2,
                      editor: this
                    });
                    if (Ve2) {
                      const Gt2 = this.getTextCursorPosition();
                      if (this.schema.blockSchema[Gt2.block.type].content !== "inline")
                        return;
                      const jt2 = Gt(
                        Re3.tr
                      ), Kt2 = Re3.tr.deleteRange(
                        P2.from,
                        P2.to
                      );
                      ye(
                        Kt2,
                        jt2.bnBlock.beforePos,
                        Ve2
                      );
                      return;
                    }
                    return null;
                  }
                })
              ) : void 0,
              addKeyboardShortcuts: C3.keyboardShortcuts ? () => Object.fromEntries(
                Object.entries(C3.keyboardShortcuts).map(
                  ([H2, P2]) => [
                    H2,
                    () => P2({ editor: this })
                  ]
                )
              ) : void 0
            });
        }
      )
    ].filter((y2) => y2 !== void 0), a2 = {
      ...As,
      ...r._tiptapOptions,
      element: null,
      autofocus: r.autofocus ?? false,
      extensions: c,
      editorProps: {
        ...(F3 = r._tiptapOptions) == null ? void 0 : F3.editorProps,
        attributes: {
          // As of TipTap v2.5.0 the tabIndex is removed when the editor is not
          // editable, so you can't focus it. We want to revert this as we have
          // UI behaviour that relies on it.
          tabIndex: "0",
          ...(Q = (J3 = r._tiptapOptions) == null ? void 0 : J3.editorProps) == null ? void 0 : Q.attributes,
          ...(Z2 = r.domAttributes) == null ? void 0 : Z2.editor,
          class: U(
            "bn-editor",
            r.defaultStyles ? "bn-default-styles" : "",
            ((v2 = (ee2 = r.domAttributes) == null ? void 0 : ee2.editor) == null ? void 0 : v2.class) || ""
          )
        },
        transformPasted: Ls
      }
    };
    try {
      const y2 = r.initialContent || (s2 ? [
        {
          type: "paragraph",
          id: "initialBlockId"
        }
      ] : [
        {
          type: "paragraph",
          id: qe.options.generateID()
        }
      ]);
      if (!Array.isArray(y2) || y2.length === 0)
        throw new Error(
          "initialContent must be a non-empty array of blocks, received: " + y2
        );
      const C3 = getSchema(a2.extensions), H2 = y2.map(
        (Be) => Y(Be, C3, this.schema.styleSchema).toJSON()
      ), P2 = createDocument(
        {
          type: "doc",
          content: [
            {
              type: "blockGroup",
              content: H2
            }
          ]
        },
        C3,
        a2.parseOptions
      );
      this._tiptapEditor = new Editor({
        ...a2,
        content: P2.toJSON()
      }), this.pmSchema = this._tiptapEditor.schema;
    } catch (y2) {
      throw new Error(
        "Error creating document from blocks passed as `initialContent`",
        { cause: y2 }
      );
    }
    this.pmSchema.cached.blockNoteEditor = this, this._blockManager = new as(this), this._eventManager = new ls(this), this._exportManager = new ws(this), this._extensionManager = new ys(this), this._selectionManager = new Es(this), this._stateManager = new Ms(
      this,
      s2 ? {
        undo: (M3 = this._collaborationManager) == null ? void 0 : M3.getUndoCommand(),
        redo: (Ue2 = this._collaborationManager) == null ? void 0 : Ue2.getRedoCommand()
      } : void 0
    ), this._styleManager = new Ts(this), this.emit("create");
  }
  get formattingToolbar() {
    return this._extensionManager.formattingToolbar;
  }
  get linkToolbar() {
    return this._extensionManager.linkToolbar;
  }
  get sideMenu() {
    return this._extensionManager.sideMenu;
  }
  get suggestionMenus() {
    return this._extensionManager.suggestionMenus;
  }
  get filePanel() {
    return this._extensionManager.filePanel;
  }
  get tableHandles() {
    return this._extensionManager.tableHandles;
  }
  get comments() {
    var e;
    return (e = this._collaborationManager) == null ? void 0 : e.comments;
  }
  get showSelectionPlugin() {
    return this._extensionManager.showSelectionPlugin;
  }
  /**
   * The plugin for forking a document, only defined if in collaboration mode
   */
  get forkYDocPlugin() {
    var e;
    return (e = this._collaborationManager) == null ? void 0 : e.forkYDocPlugin;
  }
  static create(e) {
    return new _zt(e ?? {});
  }
  /**
   * Execute a prosemirror command. This is mostly for backwards compatibility with older code.
   *
   * @note You should prefer the {@link transact} method when possible, as it will automatically handle the dispatching of the transaction and work across blocknote transactions.
   *
   * @example
   * ```ts
   * editor.exec((state, dispatch, view) => {
   *   dispatch(state.tr.insertText("Hello, world!"));
   * });
   * ```
   */
  exec(e) {
    return this._stateManager.exec(e);
  }
  /**
   * Check if a command can be executed. A command should return `false` if it is not valid in the current state.
   *
   * @example
   * ```ts
   * if (editor.canExec(command)) {
   *   // show button
   * } else {
   *   // hide button
   * }
   * ```
   */
  canExec(e) {
    return this._stateManager.canExec(e);
  }
  /**
   * Execute a function within a "blocknote transaction".
   * All changes to the editor within the transaction will be grouped together, so that
   * we can dispatch them as a single operation (thus creating only a single undo step)
   *
   * @note There is no need to dispatch the transaction, as it will be automatically dispatched when the callback is complete.
   *
   * @example
   * ```ts
   * // All changes to the editor will be grouped together
   * editor.transact((tr) => {
   *   tr.insertText("Hello, world!");
   * // These two operations will be grouped together in a single undo step
   *   editor.transact((tr) => {
   *     tr.insertText("Hello, world!");
   *   });
   * });
   * ```
   */
  transact(e) {
    return this._stateManager.transact(e);
  }
  // TO DISCUSS
  /**
   * Shorthand to get a typed extension from the editor, by
   * just passing in the extension class.
   *
   * @param ext - The extension class to get
   * @param key - optional, the key of the extension in the extensions object (defaults to the extension name)
   * @returns The extension instance
   */
  extension(e, o = e.key()) {
    return this._extensionManager.extension(e, o);
  }
  /**
   * Get the underlying prosemirror state
   * @note Prefer using `editor.transact` to read the current editor state, as that will ensure the state is up to date
   * @see https://prosemirror.net/docs/ref/#state.EditorState
   */
  get prosemirrorState() {
    return this._stateManager.prosemirrorState;
  }
  /**
   * Get the underlying prosemirror view
   * @see https://prosemirror.net/docs/ref/#view.EditorView
   */
  get prosemirrorView() {
    return this._stateManager.prosemirrorView;
  }
  get domElement() {
    var e;
    return (e = this.prosemirrorView) == null ? void 0 : e.dom;
  }
  isFocused() {
    var e;
    return ((e = this.prosemirrorView) == null ? void 0 : e.hasFocus()) || false;
  }
  get headless() {
    return !this._tiptapEditor.isInitialized;
  }
  focus() {
    this.headless || this.prosemirrorView.focus();
  }
  onUploadStart(e) {
    return this.onUploadStartCallbacks.push(e), () => {
      const o = this.onUploadStartCallbacks.indexOf(e);
      o > -1 && this.onUploadStartCallbacks.splice(o, 1);
    };
  }
  onUploadEnd(e) {
    return this.onUploadEndCallbacks.push(e), () => {
      const o = this.onUploadEndCallbacks.indexOf(e);
      o > -1 && this.onUploadEndCallbacks.splice(o, 1);
    };
  }
  /**
   * @deprecated, use `editor.document` instead
   */
  get topLevelBlocks() {
    return this.document;
  }
  /**
   * Gets a snapshot of all top-level (non-nested) blocks in the editor.
   * @returns A snapshot of all top-level (non-nested) blocks in the editor.
   */
  get document() {
    return this._blockManager.document;
  }
  /**
   * Gets a snapshot of an existing block from the editor.
   * @param blockIdentifier The identifier of an existing block that should be
   * retrieved.
   * @returns The block that matches the identifier, or `undefined` if no
   * matching block was found.
   */
  getBlock(e) {
    return this._blockManager.getBlock(e);
  }
  /**
   * Gets a snapshot of the previous sibling of an existing block from the
   * editor.
   * @param blockIdentifier The identifier of an existing block for which the
   * previous sibling should be retrieved.
   * @returns The previous sibling of the block that matches the identifier.
   * `undefined` if no matching block was found, or it's the first child/block
   * in the document.
   */
  getPrevBlock(e) {
    return this._blockManager.getPrevBlock(e);
  }
  /**
   * Gets a snapshot of the next sibling of an existing block from the editor.
   * @param blockIdentifier The identifier of an existing block for which the
   * next sibling should be retrieved.
   * @returns The next sibling of the block that matches the identifier.
   * `undefined` if no matching block was found, or it's the last child/block in
   * the document.
   */
  getNextBlock(e) {
    return this._blockManager.getNextBlock(e);
  }
  /**
   * Gets a snapshot of the parent of an existing block from the editor.
   * @param blockIdentifier The identifier of an existing block for which the
   * parent should be retrieved.
   * @returns The parent of the block that matches the identifier. `undefined`
   * if no matching block was found, or the block isn't nested.
   */
  getParentBlock(e) {
    return this._blockManager.getParentBlock(e);
  }
  /**
   * Traverses all blocks in the editor depth-first, and executes a callback for each.
   * @param callback The callback to execute for each block. Returning `false` stops the traversal.
   * @param reverse Whether the blocks should be traversed in reverse order.
   */
  forEachBlock(e, o = false) {
    this._blockManager.forEachBlock(e, o);
  }
  /**
   * Executes a callback whenever the editor's contents change.
   * @param callback The callback to execute.
   *
   * @deprecated use {@link BlockNoteEditor.onChange} instead
   */
  onEditorContentChange(e) {
    this._tiptapEditor.on("update", e);
  }
  /**
   * Executes a callback whenever the editor's selection changes.
   * @param callback The callback to execute.
   *
   * @deprecated use `onSelectionChange` instead
   */
  onEditorSelectionChange(e) {
    this._tiptapEditor.on("selectionUpdate", e);
  }
  /**
   * Gets a snapshot of the current text cursor position.
   * @returns A snapshot of the current text cursor position.
   */
  getTextCursorPosition() {
    return this._selectionManager.getTextCursorPosition();
  }
  /**
   * Sets the text cursor position to the start or end of an existing block. Throws an error if the target block could
   * not be found.
   * @param targetBlock The identifier of an existing block that the text cursor should be moved to.
   * @param placement Whether the text cursor should be placed at the start or end of the block.
   */
  setTextCursorPosition(e, o = "start") {
    return this._selectionManager.setTextCursorPosition(e, o);
  }
  /**
   * Gets a snapshot of the current selection. This contains all blocks (included nested blocks)
   * that the selection spans across.
   *
   * If the selection starts / ends halfway through a block, the returned data will contain the entire block.
   */
  getSelection() {
    return this._selectionManager.getSelection();
  }
  /**
   * Gets a snapshot of the current selection. This contains all blocks (included nested blocks)
   * that the selection spans across.
   *
   * If the selection starts / ends halfway through a block, the returned block will be
   * only the part of the block that is included in the selection.
   */
  getSelectionCutBlocks() {
    return this._selectionManager.getSelectionCutBlocks();
  }
  /**
   * Sets the selection to a range of blocks.
   * @param startBlock The identifier of the block that should be the start of the selection.
   * @param endBlock The identifier of the block that should be the end of the selection.
   */
  setSelection(e, o) {
    return this._selectionManager.setSelection(e, o);
  }
  /**
   * Checks if the editor is currently editable, or if it's locked.
   * @returns True if the editor is editable, false otherwise.
   */
  get isEditable() {
    return this._stateManager.isEditable;
  }
  /**
   * Makes the editor editable or locks it, depending on the argument passed.
   * @param editable True to make the editor editable, or false to lock it.
   */
  set isEditable(e) {
    this._stateManager.isEditable = e;
  }
  /**
   * Inserts new blocks into the editor. If a block's `id` is undefined, BlockNote generates one automatically. Throws an
   * error if the reference block could not be found.
   * @param blocksToInsert An array of partial blocks that should be inserted.
   * @param referenceBlock An identifier for an existing block, at which the new blocks should be inserted.
   * @param placement Whether the blocks should be inserted just before, just after, or nested inside the
   * `referenceBlock`.
   */
  insertBlocks(e, o, r = "before") {
    return this._blockManager.insertBlocks(
      e,
      o,
      r
    );
  }
  /**
   * Updates an existing block in the editor. Since updatedBlock is a PartialBlock object, some fields might not be
   * defined. These undefined fields are kept as-is from the existing block. Throws an error if the block to update could
   * not be found.
   * @param blockToUpdate The block that should be updated.
   * @param update A partial block which defines how the existing block should be changed.
   */
  updateBlock(e, o) {
    return this._blockManager.updateBlock(e, o);
  }
  /**
   * Removes existing blocks from the editor. Throws an error if any of the blocks could not be found.
   * @param blocksToRemove An array of identifiers for existing blocks that should be removed.
   */
  removeBlocks(e) {
    return this._blockManager.removeBlocks(e);
  }
  /**
   * Replaces existing blocks in the editor with new blocks. If the blocks that should be removed are not adjacent or
   * are at different nesting levels, `blocksToInsert` will be inserted at the position of the first block in
   * `blocksToRemove`. Throws an error if any of the blocks to remove could not be found.
   * @param blocksToRemove An array of blocks that should be replaced.
   * @param blocksToInsert An array of partial blocks to replace the old ones with.
   */
  replaceBlocks(e, o) {
    return this._blockManager.replaceBlocks(e, o);
  }
  /**
   * Undo the last action.
   */
  undo() {
    return this._stateManager.undo();
  }
  /**
   * Redo the last action.
   */
  redo() {
    return this._stateManager.redo();
  }
  /**
   * Insert a piece of content at the current cursor position.
   *
   * @param content can be a string, or array of partial inline content elements
   */
  insertInlineContent(e, { updateSelection: o = false } = {}) {
    this._styleManager.insertInlineContent(e, { updateSelection: o });
  }
  /**
   * Gets the active text styles at the text cursor position or at the end of the current selection if it's active.
   */
  getActiveStyles() {
    return this._styleManager.getActiveStyles();
  }
  /**
   * Adds styles to the currently selected content.
   * @param styles The styles to add.
   */
  addStyles(e) {
    this._styleManager.addStyles(e);
  }
  /**
   * Removes styles from the currently selected content.
   * @param styles The styles to remove.
   */
  removeStyles(e) {
    this._styleManager.removeStyles(e);
  }
  /**
   * Toggles styles on the currently selected content.
   * @param styles The styles to toggle.
   */
  toggleStyles(e) {
    this._styleManager.toggleStyles(e);
  }
  /**
   * Gets the currently selected text.
   */
  getSelectedText() {
    return this._styleManager.getSelectedText();
  }
  /**
   * Gets the URL of the last link in the current selection, or `undefined` if there are no links in the selection.
   */
  getSelectedLinkUrl() {
    return this._styleManager.getSelectedLinkUrl();
  }
  /**
   * Creates a new link to replace the selected content.
   * @param url The link URL.
   * @param text The text to display the link with.
   */
  createLink(e, o) {
    this._styleManager.createLink(e, o);
  }
  /**
   * Checks if the block containing the text cursor can be nested.
   */
  canNestBlock() {
    return this._blockManager.canNestBlock();
  }
  /**
   * Nests the block containing the text cursor into the block above it.
   */
  nestBlock() {
    this._blockManager.nestBlock();
  }
  /**
   * Checks if the block containing the text cursor is nested.
   */
  canUnnestBlock() {
    return this._blockManager.canUnnestBlock();
  }
  /**
   * Lifts the block containing the text cursor out of its parent.
   */
  unnestBlock() {
    this._blockManager.unnestBlock();
  }
  /**
   * Moves the selected blocks up. If the previous block has children, moves
   * them to the end of its children. If there is no previous block, but the
   * current blocks share a common parent, moves them out of & before it.
   */
  moveBlocksUp() {
    return this._blockManager.moveBlocksUp();
  }
  /**
   * Moves the selected blocks down. If the next block has children, moves
   * them to the start of its children. If there is no next block, but the
   * current blocks share a common parent, moves them out of & after it.
   */
  moveBlocksDown() {
    return this._blockManager.moveBlocksDown();
  }
  /**
   * Exports blocks into a simplified HTML string. To better conform to HTML standards, children of blocks which aren't list
   * items are un-nested in the output HTML.
   *
   * @param blocks An array of blocks that should be serialized into HTML.
   * @returns The blocks, serialized as an HTML string.
   */
  blocksToHTMLLossy(e = this.document) {
    return this._exportManager.blocksToHTMLLossy(e);
  }
  /**
   * Serializes blocks into an HTML string in the format that would normally be rendered by the editor.
   *
   * Use this method if you want to server-side render HTML (for example, a blog post that has been edited in BlockNote)
   * and serve it to users without loading the editor on the client (i.e.: displaying the blog post)
   *
   * @param blocks An array of blocks that should be serialized into HTML.
   * @returns The blocks, serialized as an HTML string.
   */
  blocksToFullHTML(e) {
    return this._exportManager.blocksToFullHTML(e);
  }
  /**
   * Parses blocks from an HTML string. Tries to create `Block` objects out of any HTML block-level elements, and
   * `InlineNode` objects from any HTML inline elements, though not all element types are recognized. If BlockNote
   * doesn't recognize an HTML element's tag, it will parse it as a paragraph or plain text.
   * @param html The HTML string to parse blocks from.
   * @returns The blocks parsed from the HTML string.
   */
  tryParseHTMLToBlocks(e) {
    return this._exportManager.tryParseHTMLToBlocks(e);
  }
  /**
   * Serializes blocks into a Markdown string. The output is simplified as Markdown does not support all features of
   * BlockNote - children of blocks which aren't list items are un-nested and certain styles are removed.
   * @param blocks An array of blocks that should be serialized into Markdown.
   * @returns The blocks, serialized as a Markdown string.
   */
  blocksToMarkdownLossy(e = this.document) {
    return this._exportManager.blocksToMarkdownLossy(e);
  }
  /**
   * Creates a list of blocks from a Markdown string. Tries to create `Block` and `InlineNode` objects based on
   * Markdown syntax, though not all symbols are recognized. If BlockNote doesn't recognize a symbol, it will parse it
   * as text.
   * @param markdown The Markdown string to parse blocks from.
   * @returns The blocks parsed from the Markdown string.
   */
  tryParseMarkdownToBlocks(e) {
    return this._exportManager.tryParseMarkdownToBlocks(e);
  }
  /**
   * Updates the user info for the current user that's shown to other collaborators.
   */
  updateCollaborationUserInfo(e) {
    if (!this._collaborationManager)
      throw new Error(
        "Cannot update collaboration user info when collaboration is disabled."
      );
    this._collaborationManager.updateUserInfo(e);
  }
  /**
   * A callback function that runs whenever the editor's contents change.
   *
   * @param callback The callback to execute.
   * @returns A function to remove the callback.
   */
  onChange(e) {
    return this._eventManager.onChange(e);
  }
  /**
   * A callback function that runs whenever the text cursor position or selection changes.
   *
   * @param callback The callback to execute.
   * @returns A function to remove the callback.
   */
  onSelectionChange(e, o) {
    return this._eventManager.onSelectionChange(
      e,
      o
    );
  }
  /**
   * A callback function that runs when the editor has been initialized.
   *
   * This can be useful for plugins to initialize themselves after the editor has been initialized.
   *
   * @param callback The callback to execute.
   * @returns A function to remove the callback.
   */
  onCreate(e) {
    return this.on("create", e), () => {
      this.off("create", e);
    };
  }
  /**
   * A callback function that runs when the editor has been mounted.
   *
   * This can be useful for plugins to initialize themselves after the editor has been mounted.
   *
   * @param callback The callback to execute.
   * @returns A function to remove the callback.
   */
  onMount(e) {
    this._eventManager.onMount(e);
  }
  /**
   * A callback function that runs when the editor has been unmounted.
   *
   * This can be useful for plugins to clean up themselves after the editor has been unmounted.
   *
   * @param callback The callback to execute.
   * @returns A function to remove the callback.
   */
  onUnmount(e) {
    this._eventManager.onUnmount(e);
  }
  /**
   * Gets the bounding box of the current selection.
   * @returns The bounding box of the current selection.
   */
  getSelectionBoundingBox() {
    return this._selectionManager.getSelectionBoundingBox();
  }
  get isEmpty() {
    const e = this.document;
    return e.length === 0 || e.length === 1 && e[0].type === "paragraph" && e[0].content.length === 0;
  }
  openSuggestionMenu(e, o) {
    this.prosemirrorView && (this.focus(), this.transact((r) => {
      o != null && o.deleteTriggerCharacter && r.insertText(e), r.scrollIntoView().setMeta(this.suggestionMenus.plugins[0], {
        triggerCharacter: e,
        deleteTriggerCharacter: (o == null ? void 0 : o.deleteTriggerCharacter) || false,
        ignoreQueryLength: (o == null ? void 0 : o.ignoreQueryLength) || false
      });
    }));
  }
  // `forceSelectionVisible` determines whether the editor selection is shows
  // even when the editor is not focused. This is useful for e.g. creating new
  // links, so the user still sees the affected content when an input field is
  // focused.
  // TODO: Reconsider naming?
  getForceSelectionVisible() {
    return this.showSelectionPlugin.getEnabled();
  }
  setForceSelectionVisible(e) {
    this.showSelectionPlugin.setEnabled(e);
  }
  /**
   * Paste HTML into the editor. Defaults to converting HTML to BlockNote HTML.
   * @param html The HTML to paste.
   * @param raw Whether to paste the HTML as is, or to convert it to BlockNote HTML.
   */
  pasteHTML(e, o = false) {
    this._exportManager.pasteHTML(e, o);
  }
  /**
   * Paste text into the editor. Defaults to interpreting text as markdown.
   * @param text The text to paste.
   */
  pasteText(e) {
    return this._exportManager.pasteText(e);
  }
  /**
   * Paste markdown into the editor.
   * @param markdown The markdown to paste.
   */
  pasteMarkdown(e) {
    return this._exportManager.pasteMarkdown(e);
  }
};
var he2;
async function _s() {
  return he2 || (he2 = (async () => {
    const [n, t] = await Promise.all([
      import("./module-JA6VK3RG.js"),
      // use a dynamic import to encourage bundle-splitting
      // and a smaller initial client bundle size
      import("./native-XL4Y4U4G.js")
    ]), e = "default" in n ? n.default : n, o = "default" in t ? t.default : t;
    return await e.init({ data: o }), { emojiMart: e, emojiData: o };
  })(), he2);
}
async function pi(n, t) {
  if (!("text" in n.schema.inlineContentSchema) || n.schema.inlineContentSchema.text !== kr.text)
    return [];
  const { emojiData: e, emojiMart: o } = await _s();
  return (t.trim() === "" ? Object.values(e.emojis) : await o.SearchIndex.search(t)).map((s2) => ({
    id: s2.skins[0].native,
    onItemClick: () => n.insertInlineContent(s2.skins[0].native + " ")
  }));
}

// ../node_modules/.pnpm/@blocknote+react@0.41.1_@fl_ddc1412596b7ba85ddc96cb299de0146/node_modules/@blocknote/react/dist/blocknote-react.js
var import_react_dom5 = __toESM(require_react_dom());

// ../node_modules/.pnpm/@tiptap+react@3.8.0_@floati_b838fd8dd473c1e3ebfdf956d843bdd7/node_modules/@tiptap/react/dist/index.js
var import_react3 = __toESM(require_react());
var import_react4 = __toESM(require_react());
var import_react_dom3 = __toESM(require_react_dom());
var import_shim = __toESM(require_shim());
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var import_react5 = __toESM(require_react());
var import_shim2 = __toESM(require_shim());
var import_react6 = __toESM(require_react2());
var import_react7 = __toESM(require_react());
var import_with_selector = __toESM(require_with_selector());
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var import_react8 = __toESM(require_react());
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var import_react9 = __toESM(require_react());
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var import_react10 = __toESM(require_react());
var import_react11 = __toESM(require_react());
var import_react_dom4 = __toESM(require_react_dom());
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var import_react12 = __toESM(require_react());
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
var mergeRefs = (...refs) => {
  return (node2) => {
    refs.forEach((ref) => {
      if (typeof ref === "function") {
        ref(node2);
      } else if (ref) {
        ;
        ref.current = node2;
      }
    });
  };
};
var Portals = ({ contentComponent }) => {
  const renderers = (0, import_shim.useSyncExternalStore)(
    contentComponent.subscribe,
    contentComponent.getSnapshot,
    contentComponent.getServerSnapshot
  );
  return (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, { children: Object.values(renderers) });
};
function getInstance() {
  const subscribers = /* @__PURE__ */ new Set();
  let renderers = {};
  return {
    /**
     * Subscribe to the editor instance's changes.
     */
    subscribe(callback) {
      subscribers.add(callback);
      return () => {
        subscribers.delete(callback);
      };
    },
    getSnapshot() {
      return renderers;
    },
    getServerSnapshot() {
      return renderers;
    },
    /**
     * Adds a new NodeView Renderer to the editor.
     */
    setRenderer(id2, renderer) {
      renderers = {
        ...renderers,
        [id2]: import_react_dom3.default.createPortal(renderer.reactElement, renderer.element, id2)
      };
      subscribers.forEach((subscriber) => subscriber());
    },
    /**
     * Removes a NodeView Renderer from the editor.
     */
    removeRenderer(id2) {
      const nextRenderers = { ...renderers };
      delete nextRenderers[id2];
      renderers = nextRenderers;
      subscribers.forEach((subscriber) => subscriber());
    }
  };
}
var PureEditorContent = class extends import_react4.default.Component {
  constructor(props) {
    var _a2;
    super(props);
    this.editorContentRef = import_react4.default.createRef();
    this.initialized = false;
    this.state = {
      hasContentComponentInitialized: Boolean((_a2 = props.editor) == null ? void 0 : _a2.contentComponent)
    };
  }
  componentDidMount() {
    this.init();
  }
  componentDidUpdate() {
    this.init();
  }
  init() {
    const editor = this.props.editor;
    if (editor && !editor.isDestroyed && editor.options.element) {
      if (editor.contentComponent) {
        return;
      }
      const element7 = this.editorContentRef.current;
      element7.append(editor.view.dom);
      editor.setOptions({
        element: element7
      });
      editor.contentComponent = getInstance();
      if (!this.state.hasContentComponentInitialized) {
        this.unsubscribeToContentComponent = editor.contentComponent.subscribe(() => {
          this.setState((prevState) => {
            if (!prevState.hasContentComponentInitialized) {
              return {
                hasContentComponentInitialized: true
              };
            }
            return prevState;
          });
          if (this.unsubscribeToContentComponent) {
            this.unsubscribeToContentComponent();
          }
        });
      }
      editor.createNodeViews();
      this.initialized = true;
    }
  }
  componentWillUnmount() {
    var _a2;
    const editor = this.props.editor;
    if (!editor) {
      return;
    }
    this.initialized = false;
    if (!editor.isDestroyed) {
      editor.view.setProps({
        nodeViews: {}
      });
    }
    if (this.unsubscribeToContentComponent) {
      this.unsubscribeToContentComponent();
    }
    editor.contentComponent = null;
    try {
      if (!((_a2 = editor.view.dom) == null ? void 0 : _a2.firstChild)) {
        return;
      }
      const newElement = document.createElement("div");
      newElement.append(editor.view.dom);
      editor.setOptions({
        element: newElement
      });
    } catch {
    }
  }
  render() {
    const { editor, innerRef, ...rest } = this.props;
    return (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [
      (0, import_jsx_runtime3.jsx)("div", { ref: mergeRefs(innerRef, this.editorContentRef), ...rest }),
      (editor == null ? void 0 : editor.contentComponent) && (0, import_jsx_runtime3.jsx)(Portals, { contentComponent: editor.contentComponent })
    ] });
  }
};
var EditorContentWithKey = (0, import_react4.forwardRef)(
  (props, ref) => {
    const key2 = import_react4.default.useMemo(() => {
      return Math.floor(Math.random() * 4294967295).toString();
    }, [props.editor]);
    return import_react4.default.createElement(PureEditorContent, {
      key: key2,
      innerRef: ref,
      ...props
    });
  }
);
var EditorContent = import_react4.default.memo(EditorContentWithKey);
var isSSR = typeof window === "undefined";
var isNext = isSSR || Boolean(typeof window !== "undefined" && window.next);
var EditorContext = (0, import_react3.createContext)({
  editor: null
});
var EditorConsumer = EditorContext.Consumer;
var ReactNodeViewContext = (0, import_react8.createContext)({
  onDragStart: () => {
  },
  nodeViewContentChildren: void 0,
  nodeViewContentRef: () => {
  }
});
var useReactNodeView = () => (0, import_react8.useContext)(ReactNodeViewContext);
var NodeViewWrapper = import_react9.default.forwardRef((props, ref) => {
  const { onDragStart } = useReactNodeView();
  const Tag = props.as || "div";
  return (
    // @ts-ignore
    (0, import_jsx_runtime6.jsx)(
      Tag,
      {
        ...props,
        ref,
        "data-node-view-wrapper": "",
        onDragStart,
        style: {
          whiteSpace: "normal",
          ...props.style
        }
      }
    )
  );
});
function isClassComponent(Component) {
  return !!(typeof Component === "function" && Component.prototype && Component.prototype.isReactComponent);
}
function isForwardRefComponent(Component) {
  return !!(typeof Component === "object" && Component.$$typeof && (Component.$$typeof.toString() === "Symbol(react.forward_ref)" || Component.$$typeof.description === "react.forward_ref"));
}
function isMemoComponent(Component) {
  return !!(typeof Component === "object" && Component.$$typeof && (Component.$$typeof.toString() === "Symbol(react.memo)" || Component.$$typeof.description === "react.memo"));
}
function canReceiveRef(Component) {
  if (isClassComponent(Component)) {
    return true;
  }
  if (isForwardRefComponent(Component)) {
    return true;
  }
  if (isMemoComponent(Component)) {
    const wrappedComponent = Component.type;
    if (wrappedComponent) {
      return isClassComponent(wrappedComponent) || isForwardRefComponent(wrappedComponent);
    }
  }
  return false;
}
function isReact19Plus() {
  try {
    if (import_react11.version) {
      const majorVersion = parseInt(import_react11.version.split(".")[0], 10);
      return majorVersion >= 19;
    }
  } catch {
  }
  return false;
}
var ReactRenderer = class {
  /**
   * Immediately creates element and renders the provided React component.
   */
  constructor(component, { editor, props = {}, as: as2 = "div", className = "" }) {
    this.ref = null;
    this.id = Math.floor(Math.random() * 4294967295).toString();
    this.component = component;
    this.editor = editor;
    this.props = props;
    this.element = document.createElement(as2);
    this.element.classList.add("react-renderer");
    if (className) {
      this.element.classList.add(...className.split(" "));
    }
    if (this.editor.isInitialized) {
      (0, import_react_dom4.flushSync)(() => {
        this.render();
      });
    } else {
      queueMicrotask(() => {
        this.render();
      });
    }
  }
  /**
   * Render the React component.
   */
  render() {
    var _a2;
    const Component = this.component;
    const props = this.props;
    const editor = this.editor;
    const isReact19 = isReact19Plus();
    const componentCanReceiveRef = canReceiveRef(Component);
    const elementProps = { ...props };
    if (elementProps.ref && !(isReact19 || componentCanReceiveRef)) {
      delete elementProps.ref;
    }
    if (!elementProps.ref && (isReact19 || componentCanReceiveRef)) {
      elementProps.ref = (ref) => {
        this.ref = ref;
      };
    }
    this.reactElement = (0, import_jsx_runtime7.jsx)(Component, { ...elementProps });
    (_a2 = editor == null ? void 0 : editor.contentComponent) == null ? void 0 : _a2.setRenderer(this.id, this);
  }
  /**
   * Re-renders the React component with new props.
   */
  updateProps(props = {}) {
    this.props = {
      ...this.props,
      ...props
    };
    this.render();
  }
  /**
   * Destroy the React component.
   */
  destroy() {
    var _a2;
    const editor = this.editor;
    (_a2 = editor == null ? void 0 : editor.contentComponent) == null ? void 0 : _a2.removeRenderer(this.id);
    try {
      if (this.element && this.element.parentNode) {
        this.element.parentNode.removeChild(this.element);
      }
    } catch {
    }
  }
  /**
   * Update the attributes of the element that holds the React component.
   */
  updateAttributes(attributes) {
    Object.keys(attributes).forEach((key2) => {
      this.element.setAttribute(key2, attributes[key2]);
    });
  }
};
var ReactMarkViewContext = import_react10.default.createContext({
  markViewContentRef: () => {
  }
});
var ReactMarkView = class extends MarkView {
  constructor(component, props, options) {
    super(component, props, options);
    const { as: as2 = "span", attrs, className = "" } = options || {};
    const componentProps = { ...props, updateAttributes: this.updateAttributes.bind(this) };
    this.contentDOMElement = document.createElement("span");
    const markViewContentRef = (el2) => {
      if (el2 && !el2.contains(this.contentDOMElement)) {
        el2.appendChild(this.contentDOMElement);
      }
    };
    const context = {
      markViewContentRef
    };
    const ReactMarkViewProvider = import_react10.default.memo((componentProps2) => {
      return (0, import_jsx_runtime8.jsx)(ReactMarkViewContext.Provider, { value: context, children: import_react10.default.createElement(component, componentProps2) });
    });
    ReactMarkViewProvider.displayName = "ReactMarkView";
    this.renderer = new ReactRenderer(ReactMarkViewProvider, {
      editor: props.editor,
      props: componentProps,
      as: as2,
      className: `mark-${props.mark.type.name} ${className}`.trim()
    });
    if (attrs) {
      this.renderer.updateAttributes(attrs);
    }
  }
  get dom() {
    return this.renderer.element;
  }
  get contentDOM() {
    return this.contentDOMElement;
  }
};
function ReactMarkViewRenderer(component, options = {}) {
  return (props) => new ReactMarkView(component, props, options);
}
var ReactNodeView = class extends NodeView {
  constructor(component, props, options) {
    super(component, props, options);
    if (!this.node.isLeaf) {
      if (this.options.contentDOMElementTag) {
        this.contentDOMElement = document.createElement(this.options.contentDOMElementTag);
      } else {
        this.contentDOMElement = document.createElement(this.node.isInline ? "span" : "div");
      }
      this.contentDOMElement.dataset.nodeViewContentReact = "";
      this.contentDOMElement.dataset.nodeViewWrapper = "";
      this.contentDOMElement.style.whiteSpace = "inherit";
      const contentTarget = this.dom.querySelector("[data-node-view-content]");
      if (!contentTarget) {
        return;
      }
      contentTarget.appendChild(this.contentDOMElement);
    }
  }
  /**
   * Setup the React component.
   * Called on initialization.
   */
  mount() {
    const props = {
      editor: this.editor,
      node: this.node,
      decorations: this.decorations,
      innerDecorations: this.innerDecorations,
      view: this.view,
      selected: false,
      extension: this.extension,
      HTMLAttributes: this.HTMLAttributes,
      getPos: () => this.getPos(),
      updateAttributes: (attributes = {}) => this.updateAttributes(attributes),
      deleteNode: () => this.deleteNode(),
      ref: (0, import_react12.createRef)()
    };
    if (!this.component.displayName) {
      const capitalizeFirstChar = (string3) => {
        return string3.charAt(0).toUpperCase() + string3.substring(1);
      };
      this.component.displayName = capitalizeFirstChar(this.extension.name);
    }
    const onDragStart = this.onDragStart.bind(this);
    const nodeViewContentRef = (element7) => {
      if (element7 && this.contentDOMElement && element7.firstChild !== this.contentDOMElement) {
        if (element7.hasAttribute("data-node-view-wrapper")) {
          element7.removeAttribute("data-node-view-wrapper");
        }
        element7.appendChild(this.contentDOMElement);
      }
    };
    const context = { onDragStart, nodeViewContentRef };
    const Component = this.component;
    const ReactNodeViewProvider = (0, import_react12.memo)((componentProps) => {
      return (0, import_jsx_runtime9.jsx)(ReactNodeViewContext.Provider, { value: context, children: (0, import_react12.createElement)(Component, componentProps) });
    });
    ReactNodeViewProvider.displayName = "ReactNodeView";
    let as2 = this.node.isInline ? "span" : "div";
    if (this.options.as) {
      as2 = this.options.as;
    }
    const { className = "" } = this.options;
    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this);
    this.renderer = new ReactRenderer(ReactNodeViewProvider, {
      editor: this.editor,
      props,
      as: as2,
      className: `node-${this.node.type.name} ${className}`.trim()
    });
    this.editor.on("selectionUpdate", this.handleSelectionUpdate);
    this.updateElementAttributes();
  }
  /**
   * Return the DOM element.
   * This is the element that will be used to display the node view.
   */
  get dom() {
    var _a2;
    if (this.renderer.element.firstElementChild && !((_a2 = this.renderer.element.firstElementChild) == null ? void 0 : _a2.hasAttribute("data-node-view-wrapper"))) {
      throw Error("Please use the NodeViewWrapper component for your node view.");
    }
    return this.renderer.element;
  }
  /**
   * Return the content DOM element.
   * This is the element that will be used to display the rich-text content of the node.
   */
  get contentDOM() {
    if (this.node.isLeaf) {
      return null;
    }
    return this.contentDOMElement;
  }
  /**
   * On editor selection update, check if the node is selected.
   * If it is, call `selectNode`, otherwise call `deselectNode`.
   */
  handleSelectionUpdate() {
    const { from: from3, to: to3 } = this.editor.state.selection;
    const pos = this.getPos();
    if (typeof pos !== "number") {
      return;
    }
    if (from3 <= pos && to3 >= pos + this.node.nodeSize) {
      if (this.renderer.props.selected) {
        return;
      }
      this.selectNode();
    } else {
      if (!this.renderer.props.selected) {
        return;
      }
      this.deselectNode();
    }
  }
  /**
   * On update, update the React component.
   * To prevent unnecessary updates, the `update` option can be used.
   */
  update(node2, decorations, innerDecorations) {
    const rerenderComponent = (props) => {
      this.renderer.updateProps(props);
      if (typeof this.options.attrs === "function") {
        this.updateElementAttributes();
      }
    };
    if (node2.type !== this.node.type) {
      return false;
    }
    if (typeof this.options.update === "function") {
      const oldNode = this.node;
      const oldDecorations = this.decorations;
      const oldInnerDecorations = this.innerDecorations;
      this.node = node2;
      this.decorations = decorations;
      this.innerDecorations = innerDecorations;
      return this.options.update({
        oldNode,
        oldDecorations,
        newNode: node2,
        newDecorations: decorations,
        oldInnerDecorations,
        innerDecorations,
        updateProps: () => rerenderComponent({ node: node2, decorations, innerDecorations })
      });
    }
    if (node2 === this.node && this.decorations === decorations && this.innerDecorations === innerDecorations) {
      return true;
    }
    this.node = node2;
    this.decorations = decorations;
    this.innerDecorations = innerDecorations;
    rerenderComponent({ node: node2, decorations, innerDecorations });
    return true;
  }
  /**
   * Select the node.
   * Add the `selected` prop and the `ProseMirror-selectednode` class.
   */
  selectNode() {
    this.renderer.updateProps({
      selected: true
    });
    this.renderer.element.classList.add("ProseMirror-selectednode");
  }
  /**
   * Deselect the node.
   * Remove the `selected` prop and the `ProseMirror-selectednode` class.
   */
  deselectNode() {
    this.renderer.updateProps({
      selected: false
    });
    this.renderer.element.classList.remove("ProseMirror-selectednode");
  }
  /**
   * Destroy the React component instance.
   */
  destroy() {
    this.renderer.destroy();
    this.editor.off("selectionUpdate", this.handleSelectionUpdate);
    this.contentDOMElement = null;
  }
  /**
   * Update the attributes of the top-level element that holds the React component.
   * Applying the attributes defined in the `attrs` option.
   */
  updateElementAttributes() {
    if (this.options.attrs) {
      let attrsObj = {};
      if (typeof this.options.attrs === "function") {
        const extensionAttributes = this.editor.extensionManager.attributes;
        const HTMLAttributes = getRenderedAttributes(this.node, extensionAttributes);
        attrsObj = this.options.attrs({ node: this.node, HTMLAttributes });
      } else {
        attrsObj = this.options.attrs;
      }
      this.renderer.updateAttributes(attrsObj);
    }
  }
};
function ReactNodeViewRenderer(component, options) {
  return (props) => {
    if (!props.editor.contentComponent) {
      return {};
    }
    return new ReactNodeView(component, props, options);
  };
}

// ../node_modules/.pnpm/@blocknote+react@0.41.1_@fl_ddc1412596b7ba85ddc96cb299de0146/node_modules/@blocknote/react/dist/blocknote-react.js
var import_client = __toESM(require_client());
var at3 = (0, import_react13.createContext)(void 0);
function F2(e) {
  return (0, import_react13.useContext)(at3);
}
function C2(e) {
  const t = F2();
  if (!(t != null && t.editor))
    throw new Error(
      "useBlockNoteEditor was called outside of a BlockNoteContext provider or BlockNoteView component"
    );
  return t.editor;
}
function he3(e, t, n) {
  const o = F2();
  t || (t = o == null ? void 0 : o.editor), (0, import_react13.useEffect)(() => {
    if (!t)
      throw new Error(
        "'editor' is required, either from BlockNoteContext or as a function argument"
      );
    return t.onSelectionChange(e, n);
  }, [e, t, n]);
}
function Bn3(e, t) {
  const n = C2();
  t = t || n;
  const [o, r] = (0, import_react13.useState)(() => {
    if (e)
      return t.getSelectionBoundingBox();
  }), i2 = (0, import_react13.useCallback)(() => {
    if (!e)
      return;
    const c = t.getSelectionBoundingBox();
    r(c);
  }, [t, e]);
  return he3(i2, t, true), (0, import_react13.useEffect)(() => {
    r(e ? t.getSelectionBoundingBox() : void 0);
  }, [e, t]), o;
}
function Sn3(e) {
  return e.getBoundingClientRect !== void 0;
}
function z3(e, t, n, o) {
  const { refs: r, update: i2, context: c, floatingStyles: s2, isPositioned: d } = useFloating2({
    open: e,
    ...o
  }), { isMounted: a2, styles: u } = useTransitionStyles(c), h4 = typeof (o == null ? void 0 : o.canDismiss) == "object" ? o.canDismiss : {
    enabled: o == null ? void 0 : o.canDismiss
  }, m = useDismiss(c, h4), { getReferenceProps: g, getFloatingProps: f2 } = useInteractions([m]);
  return (0, import_react13.useEffect)(() => {
    t !== null && (t instanceof HTMLElement || Sn3(t) ? r.setReference(t) : r.setReference({
      getBoundingClientRect: () => t
    }), i2());
  }, [t, r, i2]), (0, import_react13.useMemo)(() => ({
    isMounted: a2,
    ref: r.setFloating,
    setReference: r.setReference,
    style: {
      display: "flex",
      ...u,
      ...s2,
      zIndex: n
    },
    getFloatingProps: f2,
    getReferenceProps: g,
    isPositioned: d
  }), [
    d,
    s2,
    a2,
    r.setFloating,
    r.setReference,
    u,
    n,
    f2,
    g
  ]);
}
function D(e) {
  const [t, n] = (0, import_react13.useState)();
  return (0, import_react13.useEffect)(() => e((o) => {
    n({ ...o });
  }), [e]), t;
}
var Tn3 = (0, import_react13.createContext)(
  void 0
);
function p4() {
  return (0, import_react13.useContext)(Tn3);
}
var Te2 = (e = {}, t = []) => (0, import_react13.useMemo)(() => {
  const n = zt2.create(e);
  return window && (window.ProseMirror = n._tiptapEditor), n;
}, t);
function y() {
  return F2().editor.dictionary;
}
function J2(e, t) {
  const n = F2();
  t || (t = n == null ? void 0 : n.editor), (0, import_react13.useEffect)(() => {
    if (!t)
      throw new Error(
        "'editor' is required, either from BlockNoteContext or as a function argument"
      );
    return t.onChange(e);
  }, [e, t]);
}
var Le3 = (e) => {
  const [t, n] = (0, import_react13.useState)(false), [o, r] = (0, import_react13.useState)(e.editor.isEmpty), i2 = p4();
  J2(() => {
    r(e.editor.isEmpty);
  }, e.editor);
  const c = (0, import_react13.useCallback)(() => {
    n(true);
  }, []), s2 = (0, import_react13.useCallback)(() => {
    n(false);
  }, []);
  return (0, import_react13.useEffect)(() => {
    e.editable && e.autoFocus && e.editor.focus();
  }, [e.autoFocus, e.editable, e.editor]), (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, { children: [
    (0, import_jsx_runtime10.jsx)(
      i2.Comments.Editor,
      {
        autoFocus: e.autoFocus,
        className: "bn-comment-editor",
        editor: e.editor,
        onFocus: c,
        onBlur: s2,
        editable: e.editable
      }
    ),
    e.actions && (0, import_jsx_runtime10.jsx)("div", { className: "bn-comment-actions-wrapper", children: (0, import_jsx_runtime10.jsx)(e.actions, { isFocused: t, isEmpty: o }) })
  ] });
};
var { textColor: Sl, backgroundColor: Tl, ...Ln3 } = pt;
var _e2 = ht.create({
  blockSpecs: {
    paragraph: to()
  },
  styleSpecs: Ln3
});
function _n3() {
  const e = C2();
  if (!e.comments)
    throw new Error("Comments plugin not found");
  const t = e.comments, n = p4(), o = y(), r = Te2({
    trailingBlock: false,
    dictionary: {
      ...o,
      placeholders: {
        emptyDocument: o.placeholders.new_comment
      }
    },
    schema: e.comments.commentEditorSchema || _e2
  });
  return (0, import_jsx_runtime10.jsx)(n.Comments.Card, { className: "bn-thread", children: (0, import_jsx_runtime10.jsx)(
    Le3,
    {
      autoFocus: true,
      editable: true,
      editor: r,
      actions: ({ isEmpty: i2 }) => (0, import_jsx_runtime10.jsx)(
        n.Generic.Toolbar.Root,
        {
          className: U(
            "bn-action-toolbar",
            "bn-comment-actions"
          ),
          variant: "action-toolbar",
          children: (0, import_jsx_runtime10.jsx)(
            n.Generic.Toolbar.Button,
            {
              className: "bn-button",
              mainTooltip: "Save",
              variant: "compact",
              isDisabled: i2,
              onClick: async () => {
                await t.createThread({
                  initialComment: {
                    body: r.document
                  }
                }), t.stopPendingComment();
              },
              children: "Save"
            }
          )
        }
      )
    }
  ) });
}
var En3 = (e) => {
  const t = C2();
  if (!t.comments)
    throw new Error(
      "FloatingComposerController can only be used when BlockNote editor has enabled comments"
    );
  const n = t.comments;
  (0, import_react13.useEffect)(() => {
    const u = n.onUpdate(
      (h4) => t.setForceSelectionVisible(h4.pendingComment)
    );
    return () => u();
  }, [n, t]);
  const o = D(n.onUpdate.bind(n)), r = Bn3(o == null ? void 0 : o.pendingComment), { isMounted: i2, ref: c, style: s2, getFloatingProps: d } = z3(
    (o == null ? void 0 : o.pendingComment) || false,
    r || null,
    5e3,
    {
      placement: "bottom",
      middleware: [offset3(10), shift3(), flip3()],
      onOpenChange: (u) => {
        u || (n.stopPendingComment(), t.focus());
      },
      ...e.floatingOptions
    }
  );
  if (!i2 || !o)
    return null;
  const a2 = e.floatingComposer || _n3;
  return (0, import_jsx_runtime10.jsx)("div", { ref: c, style: s2, ...d(), children: (0, import_jsx_runtime10.jsx)(a2, {}) });
};
var st3 = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
};
var Fe = import_react13.default.createContext && import_react13.default.createContext(st3);
var Rn3 = ["attr", "size", "title"];
function In3(e, t) {
  if (e == null) return {};
  var n = Nn3(e, t), o, r;
  if (Object.getOwnPropertySymbols) {
    var i2 = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i2.length; r++)
      o = i2[r], !(t.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(e, o) && (n[o] = e[o]);
  }
  return n;
}
function Nn3(e, t) {
  if (e == null) return {};
  var n = {};
  for (var o in e)
    if (Object.prototype.hasOwnProperty.call(e, o)) {
      if (t.indexOf(o) >= 0) continue;
      n[o] = e[o];
    }
  return n;
}
function re3() {
  return re3 = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, re3.apply(this, arguments);
}
function Oe3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    t && (o = o.filter(function(r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function le3(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Oe3(Object(n), true).forEach(function(o) {
      Pn3(e, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Oe3(Object(n)).forEach(function(o) {
      Object.defineProperty(e, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return e;
}
function Pn3(e, t, n) {
  return t = Zn3(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: true, configurable: true, writable: true }) : e[t] = n, e;
}
function Zn3(e) {
  var t = An3(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function An3(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(e, t);
    if (typeof o != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function dt3(e) {
  return e && e.map((t, n) => import_react13.default.createElement(t.tag, le3({
    key: n
  }, t.attr), dt3(t.child)));
}
function k(e) {
  return (t) => import_react13.default.createElement(Dn3, re3({
    attr: le3({}, e.attr)
  }, t), dt3(e.child));
}
function Dn3(e) {
  var t = (n) => {
    var {
      attr: o,
      size: r,
      title: i2
    } = e, c = In3(e, Rn3), s2 = r || n.size || "1em", d;
    return n.className && (d = n.className), e.className && (d = (d ? d + " " : "") + e.className), import_react13.default.createElement("svg", re3({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, n.attr, o, c, {
      className: d,
      style: le3(le3({
        color: e.color || n.color
      }, n.style), e.style),
      height: s2,
      width: s2,
      xmlns: "http://www.w3.org/2000/svg"
    }), i2 && import_react13.default.createElement("title", null, i2), e.children);
  };
  return Fe !== void 0 ? import_react13.default.createElement(Fe.Consumer, null, (n) => t(n)) : t(st3);
}
function Fn3(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M8 7V11L2 6L8 1V5H13C17.4183 5 21 8.58172 21 13C21 17.4183 17.4183 21 13 21H4V19H13C16.3137 19 19 16.3137 19 13C19 9.68629 16.3137 7 13 7H8Z" }, child: [] }] })(e);
}
function ut2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M7.29117 20.8242L2 22L3.17581 16.7088C2.42544 15.3056 2 13.7025 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C10.2975 22 8.6944 21.5746 7.29117 20.8242ZM7.58075 18.711L8.23428 19.0605C9.38248 19.6745 10.6655 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 13.3345 4.32549 14.6175 4.93949 15.7657L5.28896 16.4192L4.63416 19.3658L7.58075 18.711Z" }, child: [] }] })(e);
}
function On3(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M7.24264 17.9967H3V13.754L14.435 2.319C14.8256 1.92848 15.4587 1.92848 15.8492 2.319L18.6777 5.14743C19.0682 5.53795 19.0682 6.17112 18.6777 6.56164L7.24264 17.9967ZM3 19.9967H21V21.9967H3V19.9967Z" }, child: [] }] })(e);
}
function Gn3(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M23 12L15.9289 19.0711L14.5147 17.6569L20.1716 12L14.5147 6.34317L15.9289 4.92896L23 12ZM3.82843 12L9.48528 17.6569L8.07107 19.0711L1 12L8.07107 4.92896L9.48528 6.34317L3.82843 12Z" }, child: [] }] })(e);
}
function Ee2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M3 8L9.00319 2H19.9978C20.5513 2 21 2.45531 21 2.9918V21.0082C21 21.556 20.5551 22 20.0066 22H3.9934C3.44476 22 3 21.5501 3 20.9932V8ZM10 4V9H5V20H19V4H10Z" }, child: [] }] })(e);
}
function Un3(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M3 4H21V6H3V4ZM5 19H19V21H5V19ZM3 14H21V16H3V14ZM5 9H19V11H5V9Z" }, child: [] }] })(e);
}
function zn3(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M3 4H21V6H3V4ZM3 19H21V21H3V19ZM3 14H21V16H3V14ZM3 9H21V11H3V9Z" }, child: [] }] })(e);
}
function jn3(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M3 4H21V6H3V4ZM3 19H17V21H3V19ZM3 14H21V16H3V14ZM3 9H17V11H3V9Z" }, child: [] }] })(e);
}
function Wn3(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M3 4H21V6H3V4ZM7 19H21V21H7V19ZM3 14H21V16H3V14ZM7 9H21V11H7V9Z" }, child: [] }] })(e);
}
function qn3(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M8 11H12.5C13.8807 11 15 9.88071 15 8.5C15 7.11929 13.8807 6 12.5 6H8V11ZM18 15.5C18 17.9853 15.9853 20 13.5 20H6V4H12.5C14.9853 4 17 6.01472 17 8.5C17 9.70431 16.5269 10.7981 15.7564 11.6058C17.0979 12.3847 18 13.837 18 15.5ZM8 13V18H13.5C14.8807 18 16 16.8807 16 15.5C16 14.1193 14.8807 13 13.5 13H8Z" }, child: [] }] })(e);
}
function $n3(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M3.41436 5.99995L5.70726 3.70706L4.29304 2.29285L0.585938 5.99995L4.29304 9.70706L5.70726 8.29285L3.41436 5.99995ZM9.58594 5.99995L7.29304 3.70706L8.70726 2.29285L12.4144 5.99995L8.70726 9.70706L7.29304 8.29285L9.58594 5.99995ZM14.0002 2.99995H21.0002C21.5524 2.99995 22.0002 3.44767 22.0002 3.99995V20C22.0002 20.5522 21.5524 21 21.0002 21H3.00015C2.44787 21 2.00015 20.5522 2.00015 20V12H4.00015V19H20.0002V4.99995H14.0002V2.99995Z" }, child: [] }] })(e);
}
function Ge2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M5.55397 22H3.3999L10.9999 3H12.9999L20.5999 22H18.4458L16.0458 16H7.95397L5.55397 22ZM8.75397 14H15.2458L11.9999 5.88517L8.75397 14Z" }, child: [] }] })(e);
}
function ie2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M13 20H11V13H4V20H2V4H4V11H11V4H13V20ZM21.0005 8V20H19.0005L19 10.204L17 10.74V8.67L19.5005 8H21.0005Z" }, child: [] }] })(e);
}
function ce3(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M4 4V11H11V4H13V20H11V13H4V20H2V4H4ZM18.5 8C20.5711 8 22.25 9.67893 22.25 11.75C22.25 12.6074 21.9623 13.3976 21.4781 14.0292L21.3302 14.2102L18.0343 18H22V20H15L14.9993 18.444L19.8207 12.8981C20.0881 12.5908 20.25 12.1893 20.25 11.75C20.25 10.7835 19.4665 10 18.5 10C17.5818 10 16.8288 10.7071 16.7558 11.6065L16.75 11.75H14.75C14.75 9.67893 16.4289 8 18.5 8Z" }, child: [] }] })(e);
}
function ae2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M22 8L21.9984 10L19.4934 12.883C21.0823 13.3184 22.25 14.7728 22.25 16.5C22.25 18.5711 20.5711 20.25 18.5 20.25C16.674 20.25 15.1528 18.9449 14.8184 17.2166L16.7821 16.8352C16.9384 17.6413 17.6481 18.25 18.5 18.25C19.4665 18.25 20.25 17.4665 20.25 16.5C20.25 15.5335 19.4665 14.75 18.5 14.75C18.214 14.75 17.944 14.8186 17.7056 14.9403L16.3992 13.3932L19.3484 10H15V8H22ZM4 4V11H11V4H13V20H11V13H4V20H2V4H4Z" }, child: [] }] })(e);
}
function mt2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M13 20H11V13H4V20H2V4H4V11H11V4H13V20ZM22 8V16H23.5V18H22V20H20V18H14.5V16.66L19.5 8H22ZM20 11.133L17.19 16H20V11.133Z" }, child: [] }] })(e);
}
function ht2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M22 8V10H17.6769L17.2126 12.6358C17.5435 12.5472 17.8912 12.5 18.25 12.5C20.4591 12.5 22.25 14.2909 22.25 16.5C22.25 18.7091 20.4591 20.5 18.25 20.5C16.4233 20.5 14.8827 19.2756 14.4039 17.6027L16.3271 17.0519C16.5667 17.8881 17.3369 18.5 18.25 18.5C19.3546 18.5 20.25 17.6046 20.25 16.5C20.25 15.3954 19.3546 14.5 18.25 14.5C17.6194 14.5 17.057 14.7918 16.6904 15.2478L14.8803 14.3439L16 8H22ZM4 4V11H11V4H13V20H11V13H4V20H2V4H4Z" }, child: [] }] })(e);
}
function gt2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M21.097 8L18.499 12.5C20.7091 12.5 22.5 14.2909 22.5 16.5C22.5 18.7091 20.7091 20.5 18.5 20.5C16.2909 20.5 14.5 18.7091 14.5 16.5C14.5 15.7636 14.699 15.0737 15.0461 14.4811L18.788 8H21.097ZM4 4V11H11V4H13V20H11V13H4V20H2V4H4ZM18.5 14.5C17.3954 14.5 16.5 15.3954 16.5 16.5C16.5 17.6046 17.3954 18.5 18.5 18.5C19.6046 18.5 20.5 17.6046 20.5 16.5C20.5 15.3954 19.6046 14.5 18.5 14.5Z" }, child: [] }] })(e);
}
function Xn3(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M3 4H21V6H3V4ZM3 19H21V21H3V19ZM11 14H21V16H11V14ZM11 9H21V11H11V9ZM3 12.5L7 9V16L3 12.5Z" }, child: [] }] })(e);
}
function Kn3(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M3 4H21V6H3V4ZM3 19H21V21H3V19ZM11 14H21V16H11V14ZM11 9H21V11H11V9ZM7 12.5L3 16V9L7 12.5Z" }, child: [] }] })(e);
}
function Ue(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M8 5H11V19H8V21H16V19H13V5H16V3H8V5ZM2 7C1.44772 7 1 7.44772 1 8V16C1 16.5523 1.44772 17 2 17H8V15H3V9H8V7H2ZM16 9H21V15H16V17H22C22.5523 17 23 16.5523 23 16V8C23 7.44772 22.5523 7 22 7H16V9Z" }, child: [] }] })(e);
}
function Yn3(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M15 20H7V18H9.92661L12.0425 6H9V4H17V6H14.0734L11.9575 18H15V20Z" }, child: [] }] })(e);
}
function Jn3(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M17 17H22V19H19V22H17V17ZM7 7H2V5H5V2H7V7ZM18.364 15.5355L16.9497 14.1213L18.364 12.7071C20.3166 10.7545 20.3166 7.58866 18.364 5.63604C16.4113 3.68342 13.2455 3.68342 11.2929 5.63604L9.87868 7.05025L8.46447 5.63604L9.87868 4.22183C12.6123 1.48816 17.0445 1.48816 19.7782 4.22183C22.5118 6.9555 22.5118 11.3877 19.7782 14.1213L18.364 15.5355ZM15.5355 18.364L14.1213 19.7782C11.3877 22.5118 6.9555 22.5118 4.22183 19.7782C1.48816 17.0445 1.48816 12.6123 4.22183 9.87868L5.63604 8.46447L7.05025 9.87868L5.63604 11.2929C3.68342 13.2455 3.68342 16.4113 5.63604 18.364C7.58866 20.3166 10.7545 20.3166 12.7071 18.364L14.1213 16.9497L15.5355 18.364ZM14.8284 7.75736L16.2426 9.17157L9.17157 16.2426L7.75736 14.8284L14.8284 7.75736Z" }, child: [] }] })(e);
}
function ft2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M18.3638 15.5355L16.9496 14.1213L18.3638 12.7071C20.3164 10.7545 20.3164 7.58866 18.3638 5.63604C16.4112 3.68341 13.2453 3.68341 11.2927 5.63604L9.87849 7.05025L8.46428 5.63604L9.87849 4.22182C12.6122 1.48815 17.0443 1.48815 19.778 4.22182C22.5117 6.95549 22.5117 11.3876 19.778 14.1213L18.3638 15.5355ZM15.5353 18.364L14.1211 19.7782C11.3875 22.5118 6.95531 22.5118 4.22164 19.7782C1.48797 17.0445 1.48797 12.6123 4.22164 9.87868L5.63585 8.46446L7.05007 9.87868L5.63585 11.2929C3.68323 13.2455 3.68323 16.4113 5.63585 18.364C7.58847 20.3166 10.7543 20.3166 12.7069 18.364L14.1211 16.9497L15.5353 18.364ZM14.8282 7.75736L16.2425 9.17157L9.17139 16.2426L7.75717 14.8284L14.8282 7.75736Z" }, child: [] }] })(e);
}
function bt(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M8.00008 6V9H5.00008V6H8.00008ZM3.00008 4V11H10.0001V4H3.00008ZM13.0001 4H21.0001V6H13.0001V4ZM13.0001 11H21.0001V13H13.0001V11ZM13.0001 18H21.0001V20H13.0001V18ZM10.7072 16.2071L9.29297 14.7929L6.00008 18.0858L4.20718 16.2929L2.79297 17.7071L6.00008 20.9142L10.7072 16.2071Z" }, child: [] }] })(e);
}
function Ct2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M8 4H21V6H8V4ZM5 3V6H6V7H3V6H4V4H3V3H5ZM3 14V11.5H5V11H3V10H6V12.5H4V13H6V14H3ZM5 19.5H3V18.5H5V18H3V17H6V21H3V20H5V19.5ZM8 11H21V13H8V11ZM8 18H21V20H8V18Z" }, child: [] }] })(e);
}
function pt2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M8 4H21V6H8V4ZM4.5 6.5C3.67157 6.5 3 5.82843 3 5C3 4.17157 3.67157 3.5 4.5 3.5C5.32843 3.5 6 4.17157 6 5C6 5.82843 5.32843 6.5 4.5 6.5ZM4.5 13.5C3.67157 13.5 3 12.8284 3 12C3 11.1716 3.67157 10.5 4.5 10.5C5.32843 10.5 6 11.1716 6 12C6 12.8284 5.32843 13.5 4.5 13.5ZM4.5 20.4C3.67157 20.4 3 19.7284 3 18.9C3 18.0716 3.67157 17.4 4.5 17.4C5.32843 17.4 6 18.0716 6 18.9C6 19.7284 5.32843 20.4 4.5 20.4ZM8 11H21V13H8V11ZM8 18H21V20H8V18Z" }, child: [] }] })(e);
}
function Qn3(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M20 3C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3H20ZM11 5H5V10.999H7V9L10 12L7 15V13H5V19H11V17H13V19H19V13H17V15L14 12L17 9V10.999H19V5H13V7H11V5ZM13 13V15H11V13H13ZM13 9V11H11V9H13Z" }, child: [] }] })(e);
}
function eo2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M21 20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3H20C20.5523 3 21 3.44772 21 4V20ZM19 11V5H13.001V7H15L12 10L9 7H11V5H5V11H7V13H5V19H11V17H9L12 14L15 17H13.001V19H19V13H17V11H19ZM11 13H9V11H11V13ZM15 13H13V11H15V13Z" }, child: [] }] })(e);
}
function kt(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M21 4H3V6H21V4ZM21 11H8V13H21V11ZM21 18H8V20H21V18ZM5 11H3V20H5V11Z" }, child: [] }] })(e);
}
function to2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M17.1538 14C17.3846 14.5161 17.5 15.0893 17.5 15.7196C17.5 17.0625 16.9762 18.1116 15.9286 18.867C14.8809 19.6223 13.4335 20 11.5862 20C9.94674 20 8.32335 19.6185 6.71592 18.8555V16.6009C8.23538 17.4783 9.7908 17.917 11.3822 17.917C13.9333 17.917 15.2128 17.1846 15.2208 15.7196C15.2208 15.0939 15.0049 14.5598 14.5731 14.1173C14.5339 14.0772 14.4939 14.0381 14.4531 14H3V12H21V14H17.1538ZM13.076 11H7.62908C7.4566 10.8433 7.29616 10.6692 7.14776 10.4778C6.71592 9.92084 6.5 9.24559 6.5 8.45207C6.5 7.21602 6.96583 6.165 7.89749 5.299C8.82916 4.43299 10.2706 4 12.2219 4C13.6934 4 15.1009 4.32808 16.4444 4.98426V7.13591C15.2448 6.44921 13.9293 6.10587 12.4978 6.10587C10.0187 6.10587 8.77917 6.88793 8.77917 8.45207C8.77917 8.87172 8.99709 9.23796 9.43293 9.55079C9.86878 9.86362 10.4066 10.1135 11.0463 10.3004C11.6665 10.4816 12.3431 10.7148 13.076 11H13.076Z" }, child: [] }] })(e);
}
function no2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M13 10V14H19V10H13ZM11 10H5V14H11V10ZM13 19H19V16H13V19ZM11 19V16H5V19H11ZM13 5V8H19V5H13ZM11 5H5V8H11V5ZM4 3H20C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3Z" }, child: [] }] })(e);
}
function Re2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M13 6V21H11V6H5V4H19V6H13Z" }, child: [] }] })(e);
}
function oo2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M8 3V12C8 14.2091 9.79086 16 12 16C14.2091 16 16 14.2091 16 12V3H18V12C18 15.3137 15.3137 18 12 18C8.68629 18 6 15.3137 6 12V3H8ZM4 20H20V22H4V20Z" }, child: [] }] })(e);
}
function ro2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M2 3.9934C2 3.44476 2.45531 3 2.9918 3H21.0082C21.556 3 22 3.44495 22 3.9934V20.0066C22 20.5552 21.5447 21 21.0082 21H2.9918C2.44405 21 2 20.5551 2 20.0066V3.9934ZM8 5V19H16V5H8ZM4 5V7H6V5H4ZM18 5V7H20V5H18ZM4 9V11H6V9H4ZM18 9V11H20V9H18ZM4 13V15H6V13H4ZM18 13V15H20V13H18ZM4 17V19H6V17H4ZM18 17V19H20V17H18Z" }, child: [] }] })(e);
}
function wt(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M5 11.1005L7 9.1005L12.5 14.6005L16 11.1005L19 14.1005V5H5V11.1005ZM4 3H20C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3ZM15.5 10C14.6716 10 14 9.32843 14 8.5C14 7.67157 14.6716 7 15.5 7C16.3284 7 17 7.67157 17 8.5C17 9.32843 16.3284 10 15.5 10Z" }, child: [] }] })(e);
}
function lo2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M21 15V18H24V20H21V23H19V20H16V18H19V15H21ZM21.0082 3C21.556 3 22 3.44495 22 3.9934L22.0007 13.3417C21.3749 13.1204 20.7015 13 20 13V5H4L4.001 19L13.2929 9.70715C13.6528 9.34604 14.22 9.31823 14.6123 9.62322L14.7065 9.70772L18.2521 13.2586C15.791 14.0069 14 16.2943 14 19C14 19.7015 14.1204 20.3749 14.3417 21.0007L2.9918 21C2.44405 21 2 20.5551 2 20.0066V3.9934C2 3.44476 2.45531 3 2.9918 3H21.0082ZM8 7C9.10457 7 10 7.89543 10 9C10 10.1046 9.10457 11 8 11C6.89543 11 6 10.1046 6 9C6 7.89543 6.89543 7 8 7Z" }, child: [] }] })(e);
}
function io2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M20 3C20.5523 3 21 3.44772 21 4V5.757L19 7.757V5H5V13.1L9 9.1005L13.328 13.429L12.0012 14.7562L11.995 18.995L16.2414 19.0012L17.571 17.671L18.8995 19H19V16.242L21 14.242V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3H20ZM21.7782 7.80761L23.1924 9.22183L15.4142 17L13.9979 16.9979L14 15.5858L21.7782 7.80761ZM15.5 7C16.3284 7 17 7.67157 17 8.5C17 9.32843 16.3284 10 15.5 10C14.6716 10 14 9.32843 14 8.5C14 7.67157 14.6716 7 15.5 7Z" }, child: [] }] })(e);
}
function vt2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M22 18V20H2V18H22ZM2 3.5L10 8.5L2 13.5V3.5ZM22 11V13H12V11H22ZM22 4V6H12V4H22Z" }, child: [] }] })(e);
}
function co2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M3 3.9934C3 3.44476 3.44495 3 3.9934 3H20.0066C20.5552 3 21 3.44495 21 3.9934V20.0066C21 20.5552 20.5551 21 20.0066 21H3.9934C3.44476 21 3 20.5551 3 20.0066V3.9934ZM10.6219 8.41459C10.5562 8.37078 10.479 8.34741 10.4 8.34741C10.1791 8.34741 10 8.52649 10 8.74741V15.2526C10 15.3316 10.0234 15.4088 10.0672 15.4745C10.1897 15.6583 10.4381 15.708 10.6219 15.5854L15.5008 12.3328C15.5447 12.3035 15.5824 12.2658 15.6117 12.2219C15.7343 12.0381 15.6846 11.7897 15.5008 11.6672L10.6219 8.41459Z" }, child: [] }] })(e);
}
function Ht2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M2 16.0001H5.88889L11.1834 20.3319C11.2727 20.405 11.3846 20.4449 11.5 20.4449C11.7761 20.4449 12 20.2211 12 19.9449V4.05519C12 3.93977 11.9601 3.8279 11.887 3.73857C11.7121 3.52485 11.3971 3.49335 11.1834 3.66821L5.88889 8.00007H2C1.44772 8.00007 1 8.44778 1 9.00007V15.0001C1 15.5524 1.44772 16.0001 2 16.0001ZM23 12C23 15.292 21.5539 18.2463 19.2622 20.2622L17.8445 18.8444C19.7758 17.1937 21 14.7398 21 12C21 9.26016 19.7758 6.80629 17.8445 5.15557L19.2622 3.73779C21.5539 5.75368 23 8.70795 23 12ZM18 12C18 10.0883 17.106 8.38548 15.7133 7.28673L14.2842 8.71584C15.3213 9.43855 16 10.64 16 12C16 13.36 15.3213 14.5614 14.2842 15.2841L15.7133 16.7132C17.106 15.6145 18 13.9116 18 12Z" }, child: [] }] })(e);
}
function ao2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M11 11V5H13V11H19V13H13V19H11V13H5V11H11Z" }, child: [] }] })(e);
}
function so2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M9.9997 15.1709L19.1921 5.97852L20.6063 7.39273L9.9997 17.9993L3.63574 11.6354L5.04996 10.2212L9.9997 15.1709Z" }, child: [] }] })(e);
}
function uo2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M17 6H22V8H20V21C20 21.5523 19.5523 22 19 22H5C4.44772 22 4 21.5523 4 21V8H2V6H7V3C7 2.44772 7.44772 2 8 2H16C16.5523 2 17 2.44772 17 3V6ZM18 8H6V20H18V8ZM9 4V6H15V4H9Z" }, child: [] }] })(e);
}
function mo2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M17 6H22V8H20V21C20 21.5523 19.5523 22 19 22H5C4.44772 22 4 21.5523 4 21V8H2V6H7V3C7 2.44772 7.44772 2 8 2H16C16.5523 2 17 2.44772 17 3V6ZM9 11V17H11V11H9ZM13 11V17H15V11H13ZM9 4V6H15V4H9Z" }, child: [] }] })(e);
}
function ho2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M4 19H20V12H22V20C22 20.5523 21.5523 21 21 21H3C2.44772 21 2 20.5523 2 20V12H4V19ZM14 9H19L12 16L5 9H10V3H14V9Z" }, child: [] }] })(e);
}
function go2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M10 6V8H5V19H16V14H18V20C18 20.5523 17.5523 21 17 21H4C3.44772 21 3 20.5523 3 20V7C3 6.44772 3.44772 6 4 6H10ZM21 3V12L17.206 8.207L11.2071 14.2071L9.79289 12.7929L15.792 6.793L12 3H21Z" }, child: [] }] })(e);
}
function fo2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M5 10C3.9 10 3 10.9 3 12C3 13.1 3.9 14 5 14C6.1 14 7 13.1 7 12C7 10.9 6.1 10 5 10ZM19 10C17.9 10 17 10.9 17 12C17 13.1 17.9 14 19 14C20.1 14 21 13.1 21 12C21 10.9 20.1 10 19 10ZM12 10C10.9 10 10 10.9 10 12C10 13.1 10.9 14 12 14C13.1 14 14 13.1 14 12C14 10.9 13.1 10 12 10Z" }, child: [] }] })(e);
}
function bo2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M5 11V13H19V11H5Z" }, child: [] }] })(e);
}
function Co2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM8 13C8 15.2091 9.79086 17 12 17C14.2091 17 16 15.2091 16 13H8ZM8 11C8.82843 11 9.5 10.3284 9.5 9.5C9.5 8.67157 8.82843 8 8 8C7.17157 8 6.5 8.67157 6.5 9.5C6.5 10.3284 7.17157 11 8 11ZM16 11C16.8284 11 17.5 10.3284 17.5 9.5C17.5 8.67157 16.8284 8 16 8C15.1716 8 14.5 8.67157 14.5 9.5C14.5 10.3284 15.1716 11 16 11Z" }, child: [] }] })(e);
}
function ze(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM8 13H16C16 15.2091 14.2091 17 12 17C9.79086 17 8 15.2091 8 13ZM8 11C7.17157 11 6.5 10.3284 6.5 9.5C6.5 8.67157 7.17157 8 8 8C8.82843 8 9.5 8.67157 9.5 9.5C9.5 10.3284 8.82843 11 8 11ZM16 11C15.1716 11 14.5 10.3284 14.5 9.5C14.5 8.67157 15.1716 8 16 8C16.8284 8 17.5 8.67157 17.5 9.5C17.5 10.3284 16.8284 11 16 11Z" }, child: [] }] })(e);
}
var ne2;
async function po2() {
  return ne2 || (ne2 = (async () => {
    const [e, t] = await Promise.all([
      import("./module-JA6VK3RG.js"),
      // use a dynamic import to encourage bundle-splitting
      // and a smaller initial client bundle size
      import("./native-XL4Y4U4G.js")
    ]), n = "default" in e ? e.default : e, o = "default" in t ? t.default : t;
    return await n.init({ data: o }), { emojiMart: n, emojiData: o };
  })(), ne2);
}
function ko2(e) {
  const t = (0, import_react13.useRef)(null), n = (0, import_react13.useRef)(null);
  return n.current && n.current.update(e), (0, import_react13.useEffect)(() => ((async () => {
    const { emojiMart: o } = await po2();
    n.current = new o.Picker({ ...e, ref: t });
  })(), () => {
    n.current = null;
  }), []), import_react13.default.createElement("div", { ref: t });
}
var je = (e) => {
  const [t, n] = (0, import_react13.useState)(false), o = p4(), r = F2();
  return (0, import_jsx_runtime10.jsxs)(o.Generic.Popover.Root, { opened: t, children: [
    (0, import_jsx_runtime10.jsx)(o.Generic.Popover.Trigger, { children: (0, import_jsx_runtime10.jsx)(
      "div",
      {
        onClick: (i2) => {
          i2.preventDefault(), i2.stopPropagation(), n(!t);
        },
        style: {
          display: "flex",
          justifyContent: "center",
          alignItems: "center"
        },
        children: e.children
      }
    ) }),
    (0, import_jsx_runtime10.jsx)(o.Generic.Popover.Content, { variant: "panel-popover", children: (0, import_jsx_runtime10.jsx)(
      ko2,
      {
        perLine: 7,
        onClickOutside: () => n(false),
        onEmojiSelect: (i2) => {
          e.onEmojiSelect(i2), n(false);
        },
        theme: r == null ? void 0 : r.colorSchemePreference
      }
    ) })
  ] });
};
function wo2(e, t) {
  return Ie3(e, [t]).get(t);
}
function Ie3(e, t) {
  const n = e.comments;
  if (!n)
    throw new Error("Comments plugin not found");
  const o = n.userStore, r = (0, import_react13.useCallback)(() => {
    const s2 = /* @__PURE__ */ new Map();
    for (const d of t) {
      const a2 = o.getUser(d);
      a2 && s2.set(d, a2);
    }
    return s2;
  }, [o, t]), i2 = (0, import_react13.useMemo)(() => ({
    current: r()
  }), [r]), c = (0, import_react13.useCallback)(
    (s2) => {
      const d = o.subscribe((a2) => {
        i2.current = r(), s2();
      });
      return o.loadUsers(t), d;
    },
    [o, r, t, i2]
  );
  return (0, import_react13.useSyncExternalStore)(c, () => i2.current);
}
var vo2 = (e) => {
  const t = p4(), n = y(), o = C2();
  if (!o.comments)
    throw new Error(
      "ReactionBadge must be used inside a BlockNote editor with comments enabled"
    );
  const r = e.comment.reactions.find(
    (d) => d.emoji === e.emoji
  );
  if (!r)
    throw new Error(
      "Trying to render reaction badge for non-existing reaction"
    );
  const [i2, c] = (0, import_react13.useState)([]), s2 = Ie3(o, i2);
  return (0, import_jsx_runtime10.jsx)(
    t.Generic.Badge.Root,
    {
      className: U("bn-badge", "bn-comment-reaction"),
      text: r.userIds.length.toString(),
      icon: r.emoji,
      isSelected: o.comments.threadStore.auth.canDeleteReaction(
        e.comment,
        r.emoji
      ),
      onClick: () => e.onReactionSelect(r.emoji),
      onMouseEnter: () => c(r.userIds),
      mainTooltip: n.comments.reactions.reacted_by,
      secondaryTooltip: `${Array.from(s2.values()).map((d) => d.username).join(`
`)}`
    },
    r.emoji
  );
};
var Ho = ({
  comment: e,
  thread: t,
  showResolveButton: n
}) => {
  const o = C2();
  if (!o.comments)
    throw new Error("Comments plugin not found");
  const r = y(), i2 = Te2(
    {
      initialContent: e.body,
      trailingBlock: false,
      dictionary: {
        ...r,
        placeholders: {
          emptyDocument: r.placeholders.edit_comment
        }
      },
      schema: o.comments.commentEditorSchema || _e2
    },
    [e.body]
  ), c = p4(), [s2, d] = (0, import_react13.useState)(false);
  if (!o.comments)
    throw new Error("Comments plugin not found");
  const a2 = o.comments.threadStore, u = (0, import_react13.useCallback)(() => {
    d(true);
  }, []), h4 = (0, import_react13.useCallback)(() => {
    i2.replaceBlocks(i2.document, e.body), d(false);
  }, [i2, e.body]), m = (0, import_react13.useCallback)(
    async (E2) => {
      await a2.updateComment({
        commentId: e.id,
        comment: {
          body: i2.document
        },
        threadId: t.id
      }), d(false);
    },
    [e, t.id, i2, a2]
  ), g = (0, import_react13.useCallback)(async () => {
    await a2.deleteComment({
      commentId: e.id,
      threadId: t.id
    });
  }, [e, t.id, a2]), f2 = (0, import_react13.useCallback)(
    async (E2) => {
      a2.auth.canAddReaction(e, E2) ? await a2.addReaction({
        threadId: t.id,
        commentId: e.id,
        emoji: E2
      }) : a2.auth.canDeleteReaction(e, E2) && await a2.deleteReaction({
        threadId: t.id,
        commentId: e.id,
        emoji: E2
      });
    },
    [a2, e, t.id]
  ), H2 = (0, import_react13.useCallback)(async () => {
    await a2.resolveThread({
      threadId: t.id
    });
  }, [t.id, a2]), B2 = (0, import_react13.useCallback)(async () => {
    await a2.unresolveThread({
      threadId: t.id
    });
  }, [t.id, a2]), V = wo2(o, e.userId);
  if (!e.body)
    return null;
  let S;
  const _ = a2.auth.canAddReaction(e), P2 = a2.auth.canDeleteComment(e), W = a2.auth.canUpdateComment(e), O2 = n && (t.resolved ? a2.auth.canUnresolveThread(t) : a2.auth.canResolveThread(t));
  s2 || (S = (0, import_jsx_runtime10.jsxs)(
    c.Generic.Toolbar.Root,
    {
      className: U("bn-action-toolbar", "bn-comment-actions"),
      variant: "action-toolbar",
      children: [
        _ && (0, import_jsx_runtime10.jsx)(
          je,
          {
            onEmojiSelect: (E2) => f2(E2.native),
            children: (0, import_jsx_runtime10.jsx)(
              c.Generic.Toolbar.Button,
              {
                mainTooltip: r.comments.actions.add_reaction,
                variant: "compact",
                children: (0, import_jsx_runtime10.jsx)(ze, { size: 16 })
              },
              "add-reaction"
            )
          }
        ),
        O2 && (t.resolved ? (0, import_jsx_runtime10.jsx)(
          c.Generic.Toolbar.Button,
          {
            mainTooltip: "Re-open",
            variant: "compact",
            onClick: B2,
            children: (0, import_jsx_runtime10.jsx)(Fn3, { size: 16 })
          },
          "reopen"
        ) : (0, import_jsx_runtime10.jsx)(
          c.Generic.Toolbar.Button,
          {
            mainTooltip: r.comments.actions.resolve,
            variant: "compact",
            onClick: H2,
            children: (0, import_jsx_runtime10.jsx)(so2, { size: 16 })
          },
          "resolve"
        )),
        (P2 || W) && (0, import_jsx_runtime10.jsxs)(c.Generic.Menu.Root, { position: "bottom-start", children: [
          (0, import_jsx_runtime10.jsx)(c.Generic.Menu.Trigger, { children: (0, import_jsx_runtime10.jsx)(
            c.Generic.Toolbar.Button,
            {
              mainTooltip: r.comments.actions.more_actions,
              variant: "compact",
              children: (0, import_jsx_runtime10.jsx)(fo2, { size: 16 })
            },
            "more-actions"
          ) }),
          (0, import_jsx_runtime10.jsxs)(c.Generic.Menu.Dropdown, { className: "bn-menu-dropdown", children: [
            W && (0, import_jsx_runtime10.jsx)(
              c.Generic.Menu.Item,
              {
                icon: (0, import_jsx_runtime10.jsx)(On3, {}),
                onClick: u,
                children: r.comments.actions.edit_comment
              },
              "edit-comment"
            ),
            P2 && (0, import_jsx_runtime10.jsx)(
              c.Generic.Menu.Item,
              {
                icon: (0, import_jsx_runtime10.jsx)(mo2, {}),
                onClick: g,
                children: r.comments.actions.delete_comment
              },
              "delete-comment"
            )
          ] })
        ] })
      ]
    }
  ));
  const $3 = e.createdAt.toLocaleDateString(void 0, {
    month: "short",
    day: "numeric"
  });
  if (!e.body)
    throw new Error("soft deletes are not yet supported");
  return (0, import_jsx_runtime10.jsx)(
    c.Comments.Comment,
    {
      authorInfo: V ?? "loading",
      timeString: $3,
      edited: e.updatedAt.getTime() !== e.createdAt.getTime(),
      showActions: "hover",
      actions: S,
      className: "bn-thread-comment",
      children: (0, import_jsx_runtime10.jsx)(
        Le3,
        {
          autoFocus: s2,
          editor: i2,
          editable: s2,
          actions: e.reactions.length > 0 || s2 ? ({ isEmpty: E2 }) => (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, { children: [
            e.reactions.length > 0 && !s2 && (0, import_jsx_runtime10.jsxs)(
              c.Generic.Badge.Group,
              {
                className: U(
                  "bn-badge-group",
                  "bn-comment-reactions"
                ),
                children: [
                  e.reactions.map((Z2) => (0, import_jsx_runtime10.jsx)(
                    vo2,
                    {
                      comment: e,
                      emoji: Z2.emoji,
                      onReactionSelect: f2
                    },
                    Z2.emoji
                  )),
                  _ && (0, import_jsx_runtime10.jsx)(
                    je,
                    {
                      onEmojiSelect: (Z2) => f2(Z2.native),
                      children: (0, import_jsx_runtime10.jsx)(
                        c.Generic.Badge.Root,
                        {
                          className: U(
                            "bn-badge",
                            "bn-comment-add-reaction"
                          ),
                          text: "+",
                          icon: (0, import_jsx_runtime10.jsx)(ze, { size: 16 }),
                          mainTooltip: r.comments.actions.add_reaction
                        }
                      )
                    }
                  )
                ]
              }
            ),
            s2 && (0, import_jsx_runtime10.jsxs)(
              c.Generic.Toolbar.Root,
              {
                variant: "action-toolbar",
                className: U(
                  "bn-action-toolbar",
                  "bn-comment-actions"
                ),
                children: [
                  (0, import_jsx_runtime10.jsx)(
                    c.Generic.Toolbar.Button,
                    {
                      mainTooltip: r.comments.save_button_text,
                      variant: "compact",
                      onClick: m,
                      isDisabled: E2,
                      children: r.comments.save_button_text
                    }
                  ),
                  (0, import_jsx_runtime10.jsx)(
                    c.Generic.Toolbar.Button,
                    {
                      className: "bn-button",
                      mainTooltip: r.comments.cancel_button_text,
                      variant: "compact",
                      onClick: h4,
                      children: r.comments.cancel_button_text
                    }
                  )
                ]
              }
            )
          ] }) : void 0
        }
      )
    }
  );
};
var Mo = ({
  thread: e,
  maxCommentsBeforeCollapse: t
}) => {
  const n = p4(), o = y(), r = C2(), i2 = Ie3(r, e.resolvedBy ? [e.resolvedBy] : []), c = e.comments.map((s2, d) => (0, import_jsx_runtime10.jsx)(
    Ho,
    {
      thread: e,
      comment: s2,
      showResolveButton: d === 0
    },
    s2.id
  ));
  if (e.resolved && e.resolvedUpdatedAt && e.resolvedBy) {
    if (!i2.get(e.resolvedBy))
      throw new Error(
        `User ${e.resolvedBy} resolved thread ${e.id}, but their data could not be found.`
      );
    const d = e.comments.findLastIndex(
      (a2) => e.resolvedUpdatedAt.getTime() > a2.createdAt.getTime()
    ) + 1;
    c.splice(
      d,
      0,
      (0, import_jsx_runtime10.jsx)(
        n.Comments.Comment,
        {
          className: "bn-thread-comment",
          authorInfo: e.resolvedBy && i2.get(e.resolvedBy) || "loading",
          timeString: e.resolvedUpdatedAt.toLocaleDateString(void 0, {
            month: "short",
            day: "numeric"
          }),
          edited: false,
          showActions: false,
          children: (0, import_jsx_runtime10.jsx)("div", { className: "bn-resolved-text", children: o.comments.sidebar.marked_as_resolved })
        },
        "resolved-comment"
      )
    );
  }
  return t && c.length > t && c.splice(
    1,
    c.length - 2,
    (0, import_jsx_runtime10.jsx)(
      n.Comments.ExpandSectionsPrompt,
      {
        className: "bn-thread-expand-prompt",
        children: o.comments.sidebar.more_replies(e.comments.length - 2)
      },
      "expand-prompt"
    )
  ), c;
};
var Mt2 = ({
  thread: e,
  selected: t,
  referenceText: n,
  maxCommentsBeforeCollapse: o,
  onFocus: r,
  onBlur: i2,
  tabIndex: c
}) => {
  const s2 = p4(), d = y(), a2 = C2(), u = a2.comments;
  if (!u)
    throw new Error("Comments plugin not found");
  const h4 = Te2({
    trailingBlock: false,
    dictionary: {
      ...d,
      placeholders: {
        emptyDocument: d.placeholders.comment_reply
      }
    },
    schema: a2.comments.commentEditorSchema || _e2
  }), m = (0, import_react13.useCallback)(async () => {
    await u.threadStore.addComment({
      comment: {
        body: h4.document
      },
      threadId: e.id
    }), h4.removeBlocks(h4.document);
  }, [u, h4, e.id]);
  return (0, import_jsx_runtime10.jsxs)(
    s2.Comments.Card,
    {
      className: "bn-thread",
      headerText: n,
      onFocus: r,
      onBlur: i2,
      selected: t,
      tabIndex: c,
      children: [
        (0, import_jsx_runtime10.jsx)(s2.Comments.CardSection, { className: "bn-thread-comments", children: (0, import_jsx_runtime10.jsx)(
          Mo,
          {
            thread: e,
            maxCommentsBeforeCollapse: t ? void 0 : o || 5
          }
        ) }),
        t && (0, import_jsx_runtime10.jsx)(s2.Comments.CardSection, { className: "bn-thread-composer", children: (0, import_jsx_runtime10.jsx)(
          Le3,
          {
            autoFocus: false,
            editable: true,
            editor: h4,
            actions: ({ isEmpty: g }) => g ? null : (0, import_jsx_runtime10.jsx)(
              s2.Generic.Toolbar.Root,
              {
                variant: "action-toolbar",
                className: U(
                  "bn-action-toolbar",
                  "bn-comment-actions"
                ),
                children: (0, import_jsx_runtime10.jsx)(
                  s2.Generic.Toolbar.Button,
                  {
                    mainTooltip: d.comments.save_button_text,
                    variant: "compact",
                    isDisabled: g,
                    onClick: m,
                    children: d.comments.save_button_text
                  }
                )
              }
            )
          }
        ) })
      ]
    }
  );
};
function yt2(e) {
  const t = e.comments;
  if (!t)
    throw new Error("Comments plugin not found");
  const n = t.threadStore, o = (0, import_react13.useRef)(void 0);
  o.current || (o.current = n.getThreads());
  const r = (0, import_react13.useCallback)(
    (i2) => n.subscribe((c) => {
      o.current = c, i2();
    }),
    [n]
  );
  return (0, import_react13.useSyncExternalStore)(r, () => o.current);
}
var yo2 = (e) => {
  const t = C2();
  if (!t.comments)
    throw new Error(
      "FloatingComposerController can only be used when BlockNote editor has enabled comments"
    );
  const n = D(
    t.comments.onUpdate.bind(t.comments)
  ), { isMounted: o, ref: r, style: i2, getFloatingProps: c, setReference: s2 } = z3(!!(n != null && n.selectedThreadId), null, 5e3, {
    placement: "bottom",
    middleware: [offset3(10), shift3(), flip3()],
    onOpenChange: (h4) => {
      var m;
      h4 || ((m = t.comments) == null || m.selectThread(void 0), t.focus());
    },
    ...e.floatingOptions
  }), d = (0, import_react13.useCallback)(() => {
    var m;
    if (!(n != null && n.selectedThreadId))
      return;
    const h4 = (m = t.domElement) == null ? void 0 : m.querySelector(
      `[data-bn-thread-id="${n == null ? void 0 : n.selectedThreadId}"]`
    );
    h4 && s2(h4);
  }, [s2, t, n == null ? void 0 : n.selectedThreadId]);
  (0, import_react13.useEffect)(() => {
    if (n != null && n.selectedThreadId)
      return t.onChange(() => {
        d();
      });
  }, [t, d, n == null ? void 0 : n.selectedThreadId]), (0, import_react13.useLayoutEffect)(d, [d]);
  const a2 = yt2(t);
  if (!o || !n || !n.selectedThreadId)
    return null;
  const u = e.floatingThread || Mt2;
  return (0, import_jsx_runtime10.jsx)("div", { ref: r, style: i2, ...c(), children: (0, import_jsx_runtime10.jsx)(
    u,
    {
      thread: a2.get(n.selectedThreadId),
      selected: true
    }
  ) });
};
var xo = (e) => {
  const t = p4(), n = y(), { block: o } = e, r = C2(), [i2, c] = (0, import_react13.useState)(""), s2 = (0, import_react13.useCallback)(
    (u) => {
      c(u.currentTarget.value);
    },
    []
  ), d = (0, import_react13.useCallback)(
    (u) => {
      u.key === "Enter" && (u.preventDefault(), r.updateBlock(o, {
        props: {
          name: Fo(i2),
          url: i2
        }
      }));
    },
    [r, o, i2]
  ), a2 = (0, import_react13.useCallback)(() => {
    r.updateBlock(o, {
      props: {
        name: Fo(i2),
        url: i2
      }
    });
  }, [r, o, i2]);
  return (0, import_jsx_runtime10.jsxs)(t.FilePanel.TabPanel, { className: "bn-tab-panel", children: [
    (0, import_jsx_runtime10.jsx)(
      t.FilePanel.TextInput,
      {
        className: "bn-text-input",
        placeholder: n.file_panel.embed.url_placeholder,
        value: i2,
        onChange: s2,
        onKeyDown: d,
        "data-test": "embed-input"
      }
    ),
    (0, import_jsx_runtime10.jsx)(
      t.FilePanel.Button,
      {
        className: "bn-button",
        onClick: a2,
        "data-test": "embed-input-button",
        children: n.file_panel.embed.embed_button[o.type] || n.file_panel.embed.embed_button.file
      }
    )
  ] });
};
var Vo2 = (e) => {
  var h4, m;
  const t = p4(), n = y(), { block: o, setLoading: r } = e, i2 = C2(), [c, s2] = (0, import_react13.useState)(false);
  (0, import_react13.useEffect)(() => {
    c && setTimeout(() => {
      s2(false);
    }, 3e3);
  }, [c]);
  const d = (0, import_react13.useCallback)(
    (g) => {
      if (g === null)
        return;
      async function f2(H2) {
        if (r(true), i2.uploadFile !== void 0)
          try {
            let B2 = await i2.uploadFile(H2, o.id);
            typeof B2 == "string" && (B2 = {
              props: {
                name: H2.name,
                url: B2
              }
            }), i2.updateBlock(o, B2);
          } catch {
            s2(true);
          } finally {
            r(false);
          }
      }
      f2(g);
    },
    [o, i2, r]
  ), a2 = i2.schema.blockSpecs[o.type], u = (m = (h4 = a2.implementation.meta) == null ? void 0 : h4.fileBlockAccept) != null && m.length ? a2.implementation.meta.fileBlockAccept.join(",") : "*/*";
  return (0, import_jsx_runtime10.jsxs)(t.FilePanel.TabPanel, { className: "bn-tab-panel", children: [
    (0, import_jsx_runtime10.jsx)(
      t.FilePanel.FileInput,
      {
        className: "bn-file-input",
        "data-test": "upload-input",
        accept: u,
        placeholder: n.file_panel.upload.file_placeholder[o.type] || n.file_panel.upload.file_placeholder.file,
        value: null,
        onChange: d
      }
    ),
    c && (0, import_jsx_runtime10.jsx)("div", { className: "bn-error-text", children: n.file_panel.upload.upload_error })
  ] });
};
var xt2 = (e) => {
  const t = p4(), n = y(), o = C2(), [r, i2] = (0, import_react13.useState)(false), c = e.tabs ?? [
    ...o.uploadFile !== void 0 ? [
      {
        name: n.file_panel.upload.title,
        tabPanel: (0, import_jsx_runtime10.jsx)(Vo2, { block: e.block, setLoading: i2 })
      }
    ] : [],
    {
      name: n.file_panel.embed.title,
      tabPanel: (0, import_jsx_runtime10.jsx)(xo, { block: e.block })
    }
  ], [s2, d] = (0, import_react13.useState)(
    e.defaultOpenTab || c[0].name
  );
  return (0, import_jsx_runtime10.jsx)(
    t.FilePanel.Root,
    {
      className: "bn-panel",
      defaultOpenTab: s2,
      openTab: s2,
      setOpenTab: d,
      tabs: c,
      loading: r
    }
  );
};
var Bo = (e) => {
  const t = C2();
  if (!t.filePanel)
    throw new Error(
      "FileToolbarController can only be used when BlockNote editor schema contains file block"
    );
  const n = D(
    t.filePanel.onUpdate.bind(t.filePanel)
  ), { isMounted: o, ref: r, style: i2, getFloatingProps: c } = z3(
    (n == null ? void 0 : n.show) || false,
    (n == null ? void 0 : n.referencePos) || null,
    5e3,
    {
      placement: "bottom",
      middleware: [offset3(10), flip3()],
      onOpenChange: (h4) => {
        h4 || (t.filePanel.closeMenu(), t.focus());
      },
      ...e.floatingOptions
    }
  );
  if (!o || !n)
    return null;
  const { show: s2, referencePos: d, ...a2 } = n, u = e.filePanel || xt2;
  return (0, import_jsx_runtime10.jsx)("div", { ref: r, style: i2, ...c(), children: (0, import_jsx_runtime10.jsx)(u, { ...a2 }) });
};
function So(e, t) {
  if (t == null)
    return false;
  if ("composedPath" in e)
    return e.composedPath().includes(t);
  const n = e;
  return n.target != null && t.contains(n.target);
}
function j4(e, t) {
  J2(e, t), he3(e, t);
}
function To2(e) {
  return (t) => {
    e.forEach((n) => {
      typeof n == "function" ? n(t) : n != null && (n.current = t);
    });
  };
}
function R2(e) {
  const t = F2();
  if (e || (e = t == null ? void 0 : t.editor), !e)
    throw new Error(
      "'editor' is required, either from BlockNoteContext or as a function argument"
    );
  const n = e, [o, r] = (0, import_react13.useState)(() => {
    var c;
    return ((c = n.getSelection()) == null ? void 0 : c.blocks) || [n.getTextCursorPosition().block];
  }), i2 = (0, import_react13.useCallback)(
    () => {
      var c;
      return r(
        ((c = n.getSelection()) == null ? void 0 : c.blocks) || [n.getTextCursorPosition().block]
      );
    },
    [n]
  );
  return j4(i2, n), o;
}
var Lo = {
  bold: qn3,
  italic: Yn3,
  underline: oo2,
  strike: to2,
  code: Gn3
};
function _o(e, t) {
  return e in t.schema.styleSchema && t.schema.styleSchema[e].type === e && t.schema.styleSchema[e].propSchema === "boolean";
}
var oe2 = (e) => {
  const t = y(), n = p4(), o = C2(), r = _o(
    e.basicTextStyle,
    o
  ), i2 = R2(o), [c, s2] = (0, import_react13.useState)(
    e.basicTextStyle in o.getActiveStyles()
  );
  j4(() => {
    r && s2(e.basicTextStyle in o.getActiveStyles());
  }, o);
  const d = (h4) => {
    if (o.focus(), !!r) {
      if (o.schema.styleSchema[h4].propSchema !== "boolean")
        throw new Error("can only toggle boolean styles");
      o.toggleStyles({ [h4]: true });
    }
  };
  if (!(0, import_react13.useMemo)(() => r ? !!i2.find((h4) => h4.content !== void 0) : false, [r, i2]) || !o.isEditable)
    return null;
  const u = Lo[e.basicTextStyle];
  return (0, import_jsx_runtime10.jsx)(
    n.FormattingToolbar.Button,
    {
      className: "bn-button",
      "data-test": e.basicTextStyle,
      onClick: () => d(e.basicTextStyle),
      isSelected: c,
      label: t.formatting_toolbar[e.basicTextStyle].tooltip,
      mainTooltip: t.formatting_toolbar[e.basicTextStyle].tooltip,
      secondaryTooltip: T(
        t.formatting_toolbar[e.basicTextStyle].secondary_tooltip,
        t.generic.ctrl_shortcut
      ),
      icon: (0, import_jsx_runtime10.jsx)(u, {})
    }
  );
};
var He3 = (e) => {
  const t = e.textColor || "default", n = e.backgroundColor || "default", o = e.size || 16, r = (0, import_react13.useMemo)(
    () => ({
      pointerEvents: "none",
      fontSize: (o * 0.75).toString() + "px",
      height: o.toString() + "px",
      lineHeight: o.toString() + "px",
      textAlign: "center",
      width: o.toString() + "px"
    }),
    [o]
  );
  return (0, import_jsx_runtime10.jsx)(
    "div",
    {
      className: "bn-color-icon",
      "data-background-color": n,
      "data-text-color": t,
      style: r,
      children: "A"
    }
  );
};
var We2 = [
  "default",
  "gray",
  "brown",
  "red",
  "orange",
  "yellow",
  "green",
  "blue",
  "purple",
  "pink"
];
var ge3 = (e) => {
  const t = p4(), n = y();
  return (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, { children: [
    (0, import_jsx_runtime10.jsx)(() => e.text ? (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, { children: [
      (0, import_jsx_runtime10.jsx)(t.Generic.Menu.Label, { children: n.color_picker.text_title }),
      We2.map((i2) => (0, import_jsx_runtime10.jsx)(
        t.Generic.Menu.Item,
        {
          onClick: () => {
            e.onClick && e.onClick(), e.text.setColor(i2);
          },
          "data-test": "text-color-" + i2,
          icon: (0, import_jsx_runtime10.jsx)(He3, { textColor: i2, size: e.iconSize }),
          checked: e.text.color === i2,
          children: n.color_picker.colors[i2]
        },
        "text-color-" + i2
      ))
    ] }) : null, {}),
    (0, import_jsx_runtime10.jsx)(() => e.background ? (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, { children: [
      (0, import_jsx_runtime10.jsx)(t.Generic.Menu.Label, { children: n.color_picker.background_title }),
      We2.map((i2) => (0, import_jsx_runtime10.jsx)(
        t.Generic.Menu.Item,
        {
          onClick: () => {
            e.onClick && e.onClick(), e.background.setColor(i2);
          },
          "data-test": "background-color-" + i2,
          icon: (0, import_jsx_runtime10.jsx)(He3, { backgroundColor: i2, size: e.iconSize }),
          checked: e.background.color === i2,
          children: n.color_picker.colors[i2]
        },
        "background-color-" + i2
      ))
    ] }) : null, {})
  ] });
};
function qe2(e, t) {
  return `${e}Color` in t.schema.styleSchema && t.schema.styleSchema[`${e}Color`].type === `${e}Color` && t.schema.styleSchema[`${e}Color`].propSchema === "string";
}
var Eo = () => {
  const e = p4(), t = y(), n = C2(), o = qe2("text", n), r = qe2("background", n), i2 = R2(n), [c, s2] = (0, import_react13.useState)(
    o && n.getActiveStyles().textColor || "default"
  ), [d, a2] = (0, import_react13.useState)(
    r && n.getActiveStyles().backgroundColor || "default"
  );
  j4(() => {
    o && s2(n.getActiveStyles().textColor || "default"), r && a2(
      n.getActiveStyles().backgroundColor || "default"
    );
  }, n);
  const u = (0, import_react13.useCallback)(
    (g) => {
      if (!o)
        throw Error(
          "Tried to set text color, but style does not exist in editor schema."
        );
      g === "default" ? n.removeStyles({ textColor: g }) : n.addStyles({ textColor: g }), setTimeout(() => {
        n.focus();
      });
    },
    [n, o]
  ), h4 = (0, import_react13.useCallback)(
    (g) => {
      if (!r)
        throw Error(
          "Tried to set background color, but style does not exist in editor schema."
        );
      g === "default" ? n.removeStyles({ backgroundColor: g }) : n.addStyles({ backgroundColor: g }), setTimeout(() => {
        n.focus();
      });
    },
    [r, n]
  );
  return !(0, import_react13.useMemo)(() => {
    if (!o && !r)
      return false;
    for (const g of i2)
      if (g.content !== void 0)
        return true;
    return false;
  }, [r, i2, o]) || !n.isEditable ? null : (0, import_jsx_runtime10.jsxs)(e.Generic.Menu.Root, { children: [
    (0, import_jsx_runtime10.jsx)(e.Generic.Menu.Trigger, { children: (0, import_jsx_runtime10.jsx)(
      e.FormattingToolbar.Button,
      {
        className: "bn-button",
        "data-test": "colors",
        label: t.formatting_toolbar.colors.tooltip,
        mainTooltip: t.formatting_toolbar.colors.tooltip,
        icon: (0, import_jsx_runtime10.jsx)(
          He3,
          {
            textColor: c,
            backgroundColor: d,
            size: 20
          }
        )
      }
    ) }),
    (0, import_jsx_runtime10.jsx)(
      e.Generic.Menu.Dropdown,
      {
        className: "bn-menu-dropdown bn-color-picker-dropdown",
        children: (0, import_jsx_runtime10.jsx)(
          ge3,
          {
            text: o ? {
              color: c,
              setColor: u
            } : void 0,
            background: r ? {
              color: d,
              setColor: h4
            } : void 0
          }
        )
      }
    )
  ] });
};
var $e = (e) => {
  for (const t of gr2)
    if (e.startsWith(t))
      return e;
  return `${br4}://${e}`;
};
var Vt3 = (e) => {
  const t = p4(), n = y(), { url: o, text: r, editLink: i2, showTextField: c } = e, [s2, d] = (0, import_react13.useState)(o), [a2, u] = (0, import_react13.useState)(r);
  (0, import_react13.useEffect)(() => {
    d(o), u(r);
  }, [r, o]);
  const h4 = (0, import_react13.useCallback)(
    (H2) => {
      H2.key === "Enter" && (H2.preventDefault(), i2($e(s2), a2));
    },
    [i2, s2, a2]
  ), m = (0, import_react13.useCallback)(
    (H2) => d(H2.currentTarget.value),
    []
  ), g = (0, import_react13.useCallback)(
    (H2) => u(H2.currentTarget.value),
    []
  ), f2 = (0, import_react13.useCallback)(
    () => i2($e(s2), a2),
    [i2, s2, a2]
  );
  return (0, import_jsx_runtime10.jsxs)(t.Generic.Form.Root, { children: [
    (0, import_jsx_runtime10.jsx)(
      t.Generic.Form.TextInput,
      {
        className: "bn-text-input",
        name: "url",
        icon: (0, import_jsx_runtime10.jsx)(ft2, {}),
        autoFocus: true,
        placeholder: n.link_toolbar.form.url_placeholder,
        value: s2,
        onKeyDown: h4,
        onChange: m,
        onSubmit: f2
      }
    ),
    c !== false && (0, import_jsx_runtime10.jsx)(
      t.Generic.Form.TextInput,
      {
        className: "bn-text-input",
        name: "title",
        icon: (0, import_jsx_runtime10.jsx)(Re2, {}),
        placeholder: n.link_toolbar.form.title_placeholder,
        value: a2,
        onKeyDown: h4,
        onChange: g,
        onSubmit: f2
      }
    )
  ] });
};
function Ro(e) {
  return "link" in e.schema.inlineContentSchema && e.schema.inlineContentSchema.link === "link";
}
var Io = () => {
  const e = C2(), t = p4(), n = y(), o = Ro(e), r = R2(e), [i2, c] = (0, import_react13.useState)(false), [s2, d] = (0, import_react13.useState)(e.getSelectedLinkUrl() || ""), [a2, u] = (0, import_react13.useState)(e.getSelectedText());
  j4(() => {
    u(e.getSelectedText() || ""), d(e.getSelectedLinkUrl() || "");
  }, e), (0, import_react13.useEffect)(() => {
    const f2 = (H2) => {
      (H2.ctrlKey || H2.metaKey) && H2.key === "k" && (c(true), H2.preventDefault());
    };
    if (!e.headless)
      return e.prosemirrorView.dom.addEventListener("keydown", f2), () => {
        e.prosemirrorView.dom.removeEventListener("keydown", f2);
      };
  }, [e.prosemirrorView, e.headless]);
  const h4 = (0, import_react13.useCallback)(
    (f2) => {
      e.createLink(f2), c(false), e.focus();
    },
    [e]
  ), m = e.transact(
    (f2) => fr(f2.selection)
  );
  return !(0, import_react13.useMemo)(() => {
    if (!o)
      return false;
    for (const f2 of r)
      if (f2.content === void 0)
        return false;
    return !m;
  }, [o, r, m]) || !("link" in e.schema.inlineContentSchema) || !e.isEditable ? null : (0, import_jsx_runtime10.jsxs)(t.Generic.Popover.Root, { opened: i2, children: [
    (0, import_jsx_runtime10.jsx)(t.Generic.Popover.Trigger, { children: (0, import_jsx_runtime10.jsx)(
      t.FormattingToolbar.Button,
      {
        className: "bn-button",
        "data-test": "createLink",
        label: n.formatting_toolbar.link.tooltip,
        mainTooltip: n.formatting_toolbar.link.tooltip,
        secondaryTooltip: T(
          n.formatting_toolbar.link.secondary_tooltip,
          n.generic.ctrl_shortcut
        ),
        icon: (0, import_jsx_runtime10.jsx)(ft2, {}),
        onClick: () => c(true)
      }
    ) }),
    (0, import_jsx_runtime10.jsx)(
      t.Generic.Popover.Content,
      {
        className: "bn-popover-content bn-form-popover",
        variant: "form-popover",
        children: (0, import_jsx_runtime10.jsx)(
          Vt3,
          {
            url: s2,
            text: a2,
            editLink: h4,
            showTextField: false
          }
        )
      }
    )
  ] });
};
var No = () => {
  const e = y(), t = p4(), n = C2(), [o, r] = (0, import_react13.useState)(), i2 = R2(n), c = (0, import_react13.useMemo)(() => {
    if (i2.length !== 1)
      return;
    const a2 = i2[0];
    if (pr(a2, n, a2.type, {
      url: "string",
      caption: "string"
    }))
      return r(a2.props.caption), a2;
  }, [n, i2]), s2 = (0, import_react13.useCallback)(
    (a2) => {
      c && E(n, c.type, {
        caption: "string"
      }) && a2.key === "Enter" && (a2.preventDefault(), n.updateBlock(c, {
        props: {
          caption: o
        }
      }));
    },
    [o, n, c]
  ), d = (0, import_react13.useCallback)(
    (a2) => r(a2.currentTarget.value),
    []
  );
  return !c || c.props.url === "" || !n.isEditable ? null : (0, import_jsx_runtime10.jsxs)(t.Generic.Popover.Root, { children: [
    (0, import_jsx_runtime10.jsx)(t.Generic.Popover.Trigger, { children: (0, import_jsx_runtime10.jsx)(
      t.FormattingToolbar.Button,
      {
        className: "bn-button",
        label: e.formatting_toolbar.file_caption.tooltip,
        mainTooltip: e.formatting_toolbar.file_caption.tooltip,
        icon: (0, import_jsx_runtime10.jsx)(Ue, {}),
        isSelected: c.props.caption !== ""
      }
    ) }),
    (0, import_jsx_runtime10.jsx)(
      t.Generic.Popover.Content,
      {
        className: "bn-popover-content bn-form-popover",
        variant: "form-popover",
        children: (0, import_jsx_runtime10.jsx)(t.Generic.Form.Root, { children: (0, import_jsx_runtime10.jsx)(
          t.Generic.Form.TextInput,
          {
            name: "file-caption",
            icon: (0, import_jsx_runtime10.jsx)(Ue, {}),
            value: o || "",
            autoFocus: true,
            placeholder: e.formatting_toolbar.file_caption.input_placeholder,
            onKeyDown: s2,
            onChange: d
          }
        ) })
      }
    )
  ] });
};
var Po = () => {
  const e = y(), t = p4(), n = C2(), o = R2(n), r = (0, import_react13.useMemo)(() => {
    if (o.length !== 1)
      return;
    const c = o[0];
    if (pr(c, n, c.type, { url: "string" }))
      return c;
  }, [n, o]), i2 = (0, import_react13.useCallback)(() => {
    n.focus(), n.removeBlocks([r]);
  }, [n, r]);
  return !r || r.props.url === "" || !n.isEditable ? null : (0, import_jsx_runtime10.jsx)(
    t.FormattingToolbar.Button,
    {
      className: "bn-button",
      label: e.formatting_toolbar.file_delete.tooltip[r.type] || e.formatting_toolbar.file_delete.tooltip.file,
      mainTooltip: e.formatting_toolbar.file_delete.tooltip[r.type] || e.formatting_toolbar.file_delete.tooltip.file,
      icon: (0, import_jsx_runtime10.jsx)(uo2, {}),
      onClick: i2
    }
  );
};
var Zo2 = () => {
  const e = y(), t = p4(), n = C2(), [o, r] = (0, import_react13.useState)(), i2 = R2(n), c = (0, import_react13.useMemo)(() => {
    if (i2.length !== 1)
      return;
    const a2 = i2[0];
    if (pr(a2, n, a2.type, {
      url: "string",
      name: "string"
    }))
      return r(a2.props.name), a2;
  }, [n, i2]), s2 = (0, import_react13.useCallback)(
    (a2) => {
      c && E(n, c.type, {
        name: "string"
      }) && a2.key === "Enter" && (a2.preventDefault(), n.updateBlock(c, {
        props: {
          name: o
        }
      }));
    },
    [o, n, c]
  ), d = (0, import_react13.useCallback)(
    (a2) => r(a2.currentTarget.value),
    []
  );
  return !c || c.props.name === "" || !n.isEditable ? null : (0, import_jsx_runtime10.jsxs)(t.Generic.Popover.Root, { children: [
    (0, import_jsx_runtime10.jsx)(t.Generic.Popover.Trigger, { children: (0, import_jsx_runtime10.jsx)(
      t.FormattingToolbar.Button,
      {
        className: "bn-button",
        label: e.formatting_toolbar.file_rename.tooltip[c.type] || e.formatting_toolbar.file_rename.tooltip.file,
        mainTooltip: e.formatting_toolbar.file_rename.tooltip[c.type] || e.formatting_toolbar.file_rename.tooltip.file,
        icon: (0, import_jsx_runtime10.jsx)(Ge2, {})
      }
    ) }),
    (0, import_jsx_runtime10.jsx)(
      t.Generic.Popover.Content,
      {
        className: "bn-popover-content bn-form-popover",
        variant: "form-popover",
        children: (0, import_jsx_runtime10.jsx)(t.Generic.Form.Root, { children: (0, import_jsx_runtime10.jsx)(
          t.Generic.Form.TextInput,
          {
            name: "file-name",
            icon: (0, import_jsx_runtime10.jsx)(Ge2, {}),
            value: o || "",
            autoFocus: true,
            placeholder: e.formatting_toolbar.file_rename.input_placeholder[c.type] || e.formatting_toolbar.file_rename.input_placeholder.file,
            onKeyDown: s2,
            onChange: d
          }
        ) })
      }
    )
  ] });
};
var Ao = () => {
  const e = y(), t = p4(), n = C2(), o = R2(n), [r, i2] = (0, import_react13.useState)(false);
  (0, import_react13.useEffect)(() => {
    i2(false);
  }, [o]);
  const c = o.length === 1 ? o[0] : void 0;
  return c === void 0 || !pr(c, n, c.type, {
    url: "string"
  }) || !n.isEditable ? null : (0, import_jsx_runtime10.jsxs)(t.Generic.Popover.Root, { opened: r, position: "bottom", children: [
    (0, import_jsx_runtime10.jsx)(t.Generic.Popover.Trigger, { children: (0, import_jsx_runtime10.jsx)(
      t.FormattingToolbar.Button,
      {
        className: "bn-button",
        onClick: () => i2(!r),
        isSelected: r,
        mainTooltip: e.formatting_toolbar.file_replace.tooltip[c.type] || e.formatting_toolbar.file_replace.tooltip.file,
        label: e.formatting_toolbar.file_replace.tooltip[c.type] || e.formatting_toolbar.file_replace.tooltip.file,
        icon: (0, import_jsx_runtime10.jsx)(io2, {})
      }
    ) }),
    (0, import_jsx_runtime10.jsx)(
      t.Generic.Popover.Content,
      {
        className: "bn-popover-content bn-panel-popover",
        variant: "panel-popover",
        children: (0, import_jsx_runtime10.jsx)(xt2, { block: c })
      }
    )
  ] });
};
var Do = () => {
  const e = y(), t = p4(), n = C2(), o = R2(n), [r, i2] = (0, import_react13.useState)(
    () => n.canNestBlock()
  );
  j4(() => {
    i2(n.canNestBlock());
  }, n);
  const c = (0, import_react13.useCallback)(() => {
    n.focus(), n.nestBlock();
  }, [n]);
  return !(0, import_react13.useMemo)(() => !o.find(
    (d) => n.schema.blockSchema[d.type].content !== "inline"
  ), [n.schema.blockSchema, o]) || !n.isEditable ? null : (0, import_jsx_runtime10.jsx)(
    t.FormattingToolbar.Button,
    {
      className: "bn-button",
      "data-test": "nestBlock",
      onClick: c,
      isDisabled: !r,
      label: e.formatting_toolbar.nest.tooltip,
      mainTooltip: e.formatting_toolbar.nest.tooltip,
      secondaryTooltip: T(
        e.formatting_toolbar.nest.secondary_tooltip,
        e.generic.ctrl_shortcut
      ),
      icon: (0, import_jsx_runtime10.jsx)(Kn3, {})
    }
  );
};
var Fo2 = () => {
  const e = y(), t = p4(), n = C2(), o = R2(n), [r, i2] = (0, import_react13.useState)(
    () => n.canUnnestBlock()
  );
  j4(() => {
    i2(n.canUnnestBlock());
  }, n);
  const c = (0, import_react13.useCallback)(() => {
    n.focus(), n.unnestBlock();
  }, [n]);
  return !(0, import_react13.useMemo)(() => !o.find(
    (d) => n.schema.blockSchema[d.type].content !== "inline"
  ), [n.schema.blockSchema, o]) || !n.isEditable ? null : (0, import_jsx_runtime10.jsx)(
    t.FormattingToolbar.Button,
    {
      className: "bn-button",
      "data-test": "unnestBlock",
      onClick: c,
      isDisabled: !r,
      label: e.formatting_toolbar.unnest.tooltip,
      mainTooltip: e.formatting_toolbar.unnest.tooltip,
      secondaryTooltip: T(
        e.formatting_toolbar.unnest.secondary_tooltip,
        e.generic.ctrl_shortcut
      ),
      icon: (0, import_jsx_runtime10.jsx)(Xn3, {})
    }
  );
};
var Oo = (e) => [
  {
    name: e.slash_menu.paragraph.title,
    type: "paragraph",
    icon: Re2,
    isSelected: (t) => t.type === "paragraph"
  },
  {
    name: e.slash_menu.heading.title,
    type: "heading",
    props: { level: 1 },
    icon: ie2,
    isSelected: (t) => t.type === "heading" && "level" in t.props && t.props.level === 1
  },
  {
    name: e.slash_menu.heading_2.title,
    type: "heading",
    props: { level: 2 },
    icon: ce3,
    isSelected: (t) => t.type === "heading" && "level" in t.props && t.props.level === 2
  },
  {
    name: e.slash_menu.heading_3.title,
    type: "heading",
    props: { level: 3 },
    icon: ae2,
    isSelected: (t) => t.type === "heading" && "level" in t.props && t.props.level === 3
  },
  {
    name: e.slash_menu.heading_4.title,
    type: "heading",
    props: { level: 4 },
    icon: mt2,
    isSelected: (t) => t.type === "heading" && "level" in t.props && t.props.level === 4
  },
  {
    name: e.slash_menu.heading_5.title,
    type: "heading",
    props: { level: 5 },
    icon: ht2,
    isSelected: (t) => t.type === "heading" && "level" in t.props && t.props.level === 5
  },
  {
    name: e.slash_menu.heading_6.title,
    type: "heading",
    props: { level: 6 },
    icon: gt2,
    isSelected: (t) => t.type === "heading" && "level" in t.props && t.props.level === 6
  },
  {
    name: e.slash_menu.toggle_heading.title,
    type: "heading",
    props: { level: 1, isToggleable: true },
    icon: ie2,
    isSelected: (t) => t.type === "heading" && "level" in t.props && t.props.level === 1 && "isToggleable" in t.props && t.props.isToggleable
  },
  {
    name: e.slash_menu.toggle_heading_2.title,
    type: "heading",
    props: { level: 2, isToggleable: true },
    icon: ce3,
    isSelected: (t) => t.type === "heading" && "level" in t.props && t.props.level === 2 && "isToggleable" in t.props && t.props.isToggleable
  },
  {
    name: e.slash_menu.toggle_heading_3.title,
    type: "heading",
    props: { level: 3, isToggleable: true },
    icon: ae2,
    isSelected: (t) => t.type === "heading" && "level" in t.props && t.props.level === 3 && "isToggleable" in t.props && t.props.isToggleable
  },
  {
    name: e.slash_menu.quote.title,
    type: "quote",
    icon: kt,
    isSelected: (t) => t.type === "quote"
  },
  {
    name: e.slash_menu.toggle_list.title,
    type: "toggleListItem",
    icon: vt2,
    isSelected: (t) => t.type === "toggleListItem"
  },
  {
    name: e.slash_menu.bullet_list.title,
    type: "bulletListItem",
    icon: pt2,
    isSelected: (t) => t.type === "bulletListItem"
  },
  {
    name: e.slash_menu.numbered_list.title,
    type: "numberedListItem",
    icon: Ct2,
    isSelected: (t) => t.type === "numberedListItem"
  },
  {
    name: e.slash_menu.check_list.title,
    type: "checkListItem",
    icon: bt,
    isSelected: (t) => t.type === "checkListItem"
  }
];
var Go2 = (e) => {
  const t = p4(), n = y(), o = C2(), r = R2(o), [i2, c] = (0, import_react13.useState)(o.getTextCursorPosition().block), s2 = (0, import_react13.useMemo)(() => (e.items || Oo(n)).filter(
    (u) => u.type in o.schema.blockSchema
  ), [o, n, e.items]), d = (0, import_react13.useMemo)(
    () => s2.find((u) => u.type === i2.type) !== void 0,
    [i2.type, s2]
  ), a2 = (0, import_react13.useMemo)(() => {
    const u = (h4) => {
      o.focus(), o.transact(() => {
        for (const m of r)
          o.updateBlock(m, {
            type: h4.type,
            props: h4.props
          });
      });
    };
    return s2.map((h4) => {
      const m = h4.icon;
      return {
        text: h4.name,
        icon: (0, import_jsx_runtime10.jsx)(m, { size: 16 }),
        onClick: () => u(h4),
        isSelected: h4.isSelected(i2)
      };
    });
  }, [i2, s2, o, r]);
  return j4(() => {
    c(o.getTextCursorPosition().block);
  }, o), !d || !o.isEditable ? null : (0, import_jsx_runtime10.jsx)(
    t.FormattingToolbar.Select,
    {
      className: "bn-select",
      items: a2
    }
  );
};
var Uo2 = () => {
  const e = y(), t = p4(), n = C2(), o = (0, import_react13.useCallback)(() => {
    var r;
    (r = n.comments) == null || r.startPendingComment(), n.formattingToolbar.closeMenu();
  }, [n]);
  return n.comments ? (0, import_jsx_runtime10.jsx)(
    t.FormattingToolbar.Button,
    {
      className: "bn-button",
      label: e.formatting_toolbar.comment.tooltip,
      mainTooltip: e.formatting_toolbar.comment.tooltip,
      icon: (0, import_jsx_runtime10.jsx)(ut2, {}),
      onClick: o
    }
  ) : null;
};
var zo2 = () => {
  const e = y(), t = p4(), n = C2(), o = (0, import_react13.useCallback)(() => {
    n._tiptapEditor.chain().focus().addPendingComment().run();
  }, [n]);
  return (
    // We manually check if a comment extension (like liveblocks) is installed
    // By adding default support for this, the user doesn't need to customize the formatting toolbar
    !n._tiptapEditor.commands.addPendingComment || !n.isEditable ? null : (0, import_jsx_runtime10.jsx)(
      t.FormattingToolbar.Button,
      {
        className: "bn-button",
        label: e.formatting_toolbar.comment.tooltip,
        mainTooltip: e.formatting_toolbar.comment.tooltip,
        icon: (0, import_jsx_runtime10.jsx)(ut2, {}),
        onClick: o
      }
    )
  );
};
function Me2(e, t) {
  try {
    const n = new URL(e, t);
    if (n.protocol !== "javascript:")
      return n.href;
  } catch {
  }
  return "#";
}
var jo2 = () => {
  const e = y(), t = p4(), n = C2(), o = R2(n), r = (0, import_react13.useMemo)(() => {
    if (o.length !== 1)
      return;
    const c = o[0];
    if (pr(c, n, c.type, { url: "string" }))
      return c;
  }, [n, o]), i2 = (0, import_react13.useCallback)(() => {
    r && r.props.url && (n.focus(), n.resolveFileUrl ? n.resolveFileUrl(r.props.url).then(
      (c) => window.open(Me2(c, window.location.href))
    ) : window.open(Me2(r.props.url, window.location.href)));
  }, [n, r]);
  return !r || r.props.url === "" ? null : (0, import_jsx_runtime10.jsx)(
    t.FormattingToolbar.Button,
    {
      className: "bn-button",
      label: e.formatting_toolbar.file_download.tooltip[r.type] || e.formatting_toolbar.file_download.tooltip.file,
      mainTooltip: e.formatting_toolbar.file_download.tooltip[r.type] || e.formatting_toolbar.file_download.tooltip.file,
      icon: (0, import_jsx_runtime10.jsx)(ho2, {}),
      onClick: i2
    }
  );
};
var Wo2 = () => {
  const e = y(), t = p4(), n = C2(), o = R2(n), r = (0, import_react13.useMemo)(() => {
    if (o.length !== 1)
      return;
    const c = o[0];
    if (pr(c, n, c.type, {
      url: "string",
      showPreview: "boolean"
    }))
      return c;
  }, [n, o]), i2 = (0, import_react13.useCallback)(() => {
    r && E(n, r.type, {
      showPreview: "boolean"
    }) && n.updateBlock(r, {
      props: {
        showPreview: !r.props.showPreview
      }
    });
  }, [n, r]);
  return !r || r.props.url === "" || !n.isEditable ? null : (0, import_jsx_runtime10.jsx)(
    t.FormattingToolbar.Button,
    {
      className: "bn-button",
      label: "Toggle preview",
      mainTooltip: e.formatting_toolbar.file_preview_toggle.tooltip,
      icon: (0, import_jsx_runtime10.jsx)(lo2, {}),
      isSelected: r.props.showPreview,
      onClick: i2
    }
  );
};
var qo2 = () => {
  const e = y(), t = p4(), n = C2(), o = R2(n), r = (0, import_react13.useMemo)(() => {
    var s2;
    if (o.length !== 1)
      return;
    const c = o[0];
    if (c.type === "table")
      return (s2 = n.tableHandles) == null ? void 0 : s2.getMergeDirection(c);
  }, [n, o]), i2 = (0, import_react13.useCallback)(() => {
    var c;
    (c = n.tableHandles) == null || c.mergeCells();
  }, [n]);
  return !n.isEditable || r === void 0 || !n.settings.tables.splitCells ? null : (0, import_jsx_runtime10.jsx)(
    t.FormattingToolbar.Button,
    {
      className: "bn-button",
      label: e.formatting_toolbar.table_cell_merge.tooltip,
      mainTooltip: e.formatting_toolbar.table_cell_merge.tooltip,
      icon: r === "horizontal" ? (0, import_jsx_runtime10.jsx)(Qn3, {}) : (0, import_jsx_runtime10.jsx)(eo2, {}),
      onClick: i2
    }
  );
};
var $o2 = {
  left: jn3,
  center: Un3,
  right: Wn3,
  justify: zn3
};
var pe3 = (e) => {
  const t = p4(), n = y(), o = C2(), r = R2(o), i2 = (0, import_react13.useMemo)(() => {
    var u;
    const a2 = r[0];
    if (pr(a2, o, a2.type, {
      textAlignment: C.textAlignment
    }))
      return a2.props.textAlignment;
    if (a2.type === "table") {
      const h4 = (u = o.tableHandles) == null ? void 0 : u.getCellSelection();
      if (!h4)
        return;
      const m = h4.cells.map(
        ({ row: f2, col: H2 }) => se(
          a2.content.rows[f2].cells[H2]
        ).props.textAlignment
      ), g = m[0];
      if (m.every((f2) => f2 === g))
        return g;
    }
  }, [o, r]), c = (0, import_react13.useCallback)(
    (a2) => {
      var u;
      o.focus();
      for (const h4 of r)
        if (pr(h4, o, h4.type, {
          textAlignment: C.textAlignment
        }) && E(o, h4.type, {
          textAlignment: C.textAlignment
        }))
          o.updateBlock(h4, {
            props: { textAlignment: a2 }
          });
        else if (h4.type === "table") {
          const m = (u = o.tableHandles) == null ? void 0 : u.getCellSelection();
          if (!m)
            continue;
          const g = h4.content.rows.map(
            (f2) => ({
              ...f2,
              cells: f2.cells.map((H2) => se(H2))
            })
          );
          m.cells.forEach(({ row: f2, col: H2 }) => {
            g[f2].cells[H2].props.textAlignment = a2;
          }), o.updateBlock(h4, {
            type: "table",
            content: {
              ...h4.content,
              type: "tableContent",
              rows: g
            }
          }), o.setTextCursorPosition(h4);
        }
    },
    [o, r]
  );
  if (!(0, import_react13.useMemo)(() => !!r.find(
    (a2) => pr(a2, o, a2.type, {
      textAlignment: C.textAlignment
    }) || a2.type === "table" && a2.children
  ), [o, r]) || !o.isEditable)
    return null;
  const d = $o2[e.textAlignment];
  return (0, import_jsx_runtime10.jsx)(
    t.FormattingToolbar.Button,
    {
      className: "bn-button",
      "data-test": `alignText${e.textAlignment.slice(0, 1).toUpperCase() + e.textAlignment.slice(1)}`,
      onClick: () => c(e.textAlignment),
      isSelected: i2 === e.textAlignment,
      label: n.formatting_toolbar[`align_${e.textAlignment}`].tooltip,
      mainTooltip: n.formatting_toolbar[`align_${e.textAlignment}`].tooltip,
      icon: (0, import_jsx_runtime10.jsx)(d, {})
    }
  );
};
var Xo2 = (e) => [
  (0, import_jsx_runtime10.jsx)(Go2, { items: e }, "blockTypeSelect"),
  (0, import_jsx_runtime10.jsx)(qo2, {}, "tableCellMergeButton"),
  (0, import_jsx_runtime10.jsx)(No, {}, "fileCaptionButton"),
  (0, import_jsx_runtime10.jsx)(Ao, {}, "replaceFileButton"),
  (0, import_jsx_runtime10.jsx)(Zo2, {}, "fileRenameButton"),
  (0, import_jsx_runtime10.jsx)(Po, {}, "fileDeleteButton"),
  (0, import_jsx_runtime10.jsx)(jo2, {}, "fileDownloadButton"),
  (0, import_jsx_runtime10.jsx)(Wo2, {}, "filePreviewButton"),
  (0, import_jsx_runtime10.jsx)(oe2, { basicTextStyle: "bold" }, "boldStyleButton"),
  (0, import_jsx_runtime10.jsx)(oe2, { basicTextStyle: "italic" }, "italicStyleButton"),
  (0, import_jsx_runtime10.jsx)(
    oe2,
    {
      basicTextStyle: "underline"
    },
    "underlineStyleButton"
  ),
  (0, import_jsx_runtime10.jsx)(oe2, { basicTextStyle: "strike" }, "strikeStyleButton"),
  (0, import_jsx_runtime10.jsx)(pe3, { textAlignment: "left" }, "textAlignLeftButton"),
  (0, import_jsx_runtime10.jsx)(pe3, { textAlignment: "center" }, "textAlignCenterButton"),
  (0, import_jsx_runtime10.jsx)(pe3, { textAlignment: "right" }, "textAlignRightButton"),
  (0, import_jsx_runtime10.jsx)(Eo, {}, "colorStyleButton"),
  (0, import_jsx_runtime10.jsx)(Do, {}, "nestBlockButton"),
  (0, import_jsx_runtime10.jsx)(Fo2, {}, "unnestBlockButton"),
  (0, import_jsx_runtime10.jsx)(Io, {}, "createLinkButton"),
  (0, import_jsx_runtime10.jsx)(Uo2, {}, "addCommentButton"),
  (0, import_jsx_runtime10.jsx)(zo2, {}, "addTiptapCommentButton")
];
var Bt2 = (e) => {
  const t = p4();
  return (0, import_jsx_runtime10.jsx)(
    t.FormattingToolbar.Root,
    {
      className: "bn-toolbar bn-formatting-toolbar",
      children: e.children || Xo2(e.blockTypeSelectItems)
    }
  );
};
var Xe3 = (e) => {
  switch (e) {
    case "left":
      return "top-start";
    case "center":
      return "top";
    case "right":
      return "top-end";
    default:
      return "top-start";
  }
};
var Ko2 = (e) => {
  const t = (0, import_react13.useRef)(null), n = C2(), [o, r] = (0, import_react13.useState)(
    () => {
      const m = n.getTextCursorPosition().block;
      return "textAlignment" in m.props ? Xe3(
        m.props.textAlignment
      ) : "top-start";
    }
  );
  j4(() => {
    const m = n.getTextCursorPosition().block;
    "textAlignment" in m.props ? r(
      Xe3(
        m.props.textAlignment
      )
    ) : r("top-start");
  }, n);
  const i2 = D(
    n.formattingToolbar.onUpdate.bind(n.formattingToolbar)
  ), { isMounted: c, ref: s2, style: d, getFloatingProps: a2 } = z3(
    (i2 == null ? void 0 : i2.show) || false,
    (i2 == null ? void 0 : i2.referencePos) || null,
    3e3,
    {
      placement: o,
      middleware: [offset3(10), shift3(), flip3()],
      onOpenChange: (m, g) => {
        m || (n.formattingToolbar.closeMenu(), n.focus());
      },
      canDismiss: {
        enabled: true,
        escapeKey: true,
        outsidePress: (m) => {
          var H2;
          const g = (H2 = n._tiptapEditor) == null ? void 0 : H2.view;
          return !g || !m.target ? false : !So(m, g.dom.parentElement);
        }
      },
      ...e.floatingOptions
    }
  ), u = (0, import_react13.useMemo)(() => To2([t, s2]), [t, s2]);
  if (!c || !i2)
    return null;
  if (!i2.show && t.current)
    return (0, import_jsx_runtime10.jsx)(
      "div",
      {
        ref: u,
        style: d,
        dangerouslySetInnerHTML: { __html: t.current.innerHTML }
      }
    );
  const h4 = e.formattingToolbar || Bt2;
  return (0, import_jsx_runtime10.jsx)("div", { ref: u, style: d, ...a2(), children: (0, import_jsx_runtime10.jsx)(h4, {}) });
};
var Yo2 = (e) => {
  const t = p4(), n = y();
  return (0, import_jsx_runtime10.jsx)(
    t.LinkToolbar.Button,
    {
      className: "bn-button",
      label: n.link_toolbar.delete.tooltip,
      mainTooltip: n.link_toolbar.delete.tooltip,
      isSelected: false,
      onClick: e.deleteLink,
      icon: (0, import_jsx_runtime10.jsx)(Jn3, {})
    }
  );
};
var Jo2 = (e) => {
  const t = p4(), n = y();
  return (0, import_jsx_runtime10.jsxs)(t.Generic.Popover.Root, { children: [
    (0, import_jsx_runtime10.jsx)(t.Generic.Popover.Trigger, { children: (0, import_jsx_runtime10.jsx)(
      t.LinkToolbar.Button,
      {
        className: "bn-button",
        mainTooltip: n.link_toolbar.edit.tooltip,
        isSelected: false,
        children: n.link_toolbar.edit.text
      }
    ) }),
    (0, import_jsx_runtime10.jsx)(
      t.Generic.Popover.Content,
      {
        className: "bn-popover-content bn-form-popover",
        variant: "form-popover",
        children: (0, import_jsx_runtime10.jsx)(Vt3, { ...e })
      }
    )
  ] });
};
var Qo2 = (e) => {
  const t = p4(), n = y();
  return (0, import_jsx_runtime10.jsx)(
    t.LinkToolbar.Button,
    {
      className: "bn-button",
      mainTooltip: n.link_toolbar.open.tooltip,
      label: n.link_toolbar.open.tooltip,
      isSelected: false,
      onClick: () => {
        window.open(Me2(e.url, window.location.href), "_blank");
      },
      icon: (0, import_jsx_runtime10.jsx)(go2, {})
    }
  );
};
var er3 = (e) => {
  const t = p4();
  return (0, import_jsx_runtime10.jsx)(
    t.LinkToolbar.Root,
    {
      className: "bn-toolbar bn-link-toolbar",
      onMouseEnter: e.stopHideTimer,
      onMouseLeave: e.startHideTimer,
      children: e.children || (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, { children: [
        (0, import_jsx_runtime10.jsx)(
          Jo2,
          {
            url: e.url,
            text: e.text,
            editLink: e.editLink
          }
        ),
        (0, import_jsx_runtime10.jsx)(Qo2, { url: e.url }),
        (0, import_jsx_runtime10.jsx)(Yo2, { deleteLink: e.deleteLink })
      ] })
    }
  );
};
var tr4 = (e) => {
  const t = C2(), n = {
    deleteLink: t.linkToolbar.deleteLink,
    editLink: t.linkToolbar.editLink,
    startHideTimer: t.linkToolbar.startHideTimer,
    stopHideTimer: t.linkToolbar.stopHideTimer
  }, o = D(
    t.linkToolbar.onUpdate.bind(t.linkToolbar)
  ), { isMounted: r, ref: i2, style: c, getFloatingProps: s2 } = z3(
    (o == null ? void 0 : o.show) || false,
    (o == null ? void 0 : o.referencePos) || null,
    4e3,
    {
      placement: "top-start",
      middleware: [offset3(10), flip3()],
      onOpenChange: (m) => {
        m || (t.linkToolbar.closeMenu(), t.focus());
      },
      ...e.floatingOptions
    }
  );
  if (!r || !o)
    return null;
  const { show: d, referencePos: a2, ...u } = o, h4 = e.linkToolbar || er3;
  return (0, import_jsx_runtime10.jsx)("div", { ref: i2, style: c, ...s2(), children: (0, import_jsx_runtime10.jsx)(h4, { ...u, ...n }) });
};
function nr3(e) {
  return k({ attr: { viewBox: "0 0 1024 1024" }, child: [{ tag: "path", attr: { d: "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8Z" }, child: [] }, { tag: "path", attr: { d: "M192 474h672q8 0 8 8v60q0 8-8 8H160q-8 0-8-8v-60q0-8 8-8Z" }, child: [] }] })(e);
}
var or3 = (e) => {
  const t = p4(), n = y(), o = C2(), r = (0, import_react13.useCallback)(() => {
    const i2 = e.block.content;
    if (i2 !== void 0 && Array.isArray(i2) && i2.length === 0)
      o.setTextCursorPosition(e.block), o.openSuggestionMenu("/");
    else {
      const s2 = o.insertBlocks(
        [{ type: "paragraph" }],
        e.block,
        "after"
      )[0];
      o.setTextCursorPosition(s2), o.openSuggestionMenu("/");
    }
  }, [o, e.block]);
  return (0, import_jsx_runtime10.jsx)(
    t.SideMenu.Button,
    {
      className: "bn-button",
      label: n.side_menu.add_block_label,
      icon: (0, import_jsx_runtime10.jsx)(nr3, { size: 24, onClick: r, "data-test": "dragHandleAdd" })
    }
  );
};
function St2(e) {
  return k({ attr: { viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { fill: "none", d: "M0 0h24v24H0V0z" }, child: [] }, { tag: "path", attr: { d: "M11 18c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zm-2-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z" }, child: [] }] })(e);
}
function rr3(e) {
  return k({ attr: { viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { fill: "none", d: "M0 0h24v24H0z" }, child: [] }, { tag: "path", attr: { d: "m7 10 5 5 5-5z" }, child: [] }] })(e);
}
var lr3 = (e) => {
  const t = p4(), n = C2(), o = e.block;
  return !pr(o, n, o.type, {
    textColor: "string"
  }) && !pr(o, n, o.type, {
    backgroundColor: "string"
  }) ? null : (0, import_jsx_runtime10.jsxs)(t.Generic.Menu.Root, { position: "right", sub: true, children: [
    (0, import_jsx_runtime10.jsx)(t.Generic.Menu.Trigger, { sub: true, children: (0, import_jsx_runtime10.jsx)(
      t.Generic.Menu.Item,
      {
        className: "bn-menu-item",
        subTrigger: true,
        children: e.children
      }
    ) }),
    (0, import_jsx_runtime10.jsx)(
      t.Generic.Menu.Dropdown,
      {
        sub: true,
        className: "bn-menu-dropdown bn-color-picker-dropdown",
        children: (0, import_jsx_runtime10.jsx)(
          ge3,
          {
            iconSize: 18,
            text: pr(o, n, o.type, {
              textColor: "string"
            }) && E(n, o.type, {
              textColor: "string"
            }) ? {
              color: o.props.textColor,
              setColor: (r) => n.updateBlock(o, {
                type: o.type,
                props: { textColor: r }
              })
            } : void 0,
            background: pr(o, n, o.type, {
              backgroundColor: "string"
            }) && E(n, o.type, {
              backgroundColor: "string"
            }) ? {
              color: o.props.backgroundColor,
              setColor: (r) => n.updateBlock(o, {
                props: { backgroundColor: r }
              })
            } : void 0
          }
        )
      }
    )
  ] });
};
var ir3 = (e) => {
  const t = p4(), n = C2();
  return (0, import_jsx_runtime10.jsx)(
    t.Generic.Menu.Item,
    {
      className: "bn-menu-item",
      onClick: () => n.removeBlocks([e.block]),
      children: e.children
    }
  );
};
var cr3 = (e) => {
  const t = p4(), n = C2();
  if (e.block.type !== "table" || !n.settings.tables.headers)
    return null;
  const o = !!e.block.content.headerRows;
  return (0, import_jsx_runtime10.jsx)(
    t.Generic.Menu.Item,
    {
      className: "bn-menu-item",
      checked: o,
      onClick: () => {
        const r = n.getBlock(e.block.id);
        r && n.updateBlock(r, {
          ...r,
          content: {
            ...r.content,
            headerRows: o ? void 0 : 1
          }
        });
      },
      children: e.children
    }
  );
};
var ar3 = (e) => {
  const t = p4(), n = C2();
  if (e.block.type !== "table" || !n.settings.tables.headers)
    return null;
  const o = !!e.block.content.headerCols;
  return (0, import_jsx_runtime10.jsx)(
    t.Generic.Menu.Item,
    {
      className: "bn-menu-item",
      checked: o,
      onClick: () => {
        n.updateBlock(e.block, {
          type: "table",
          content: {
            ...e.block.content,
            type: "tableContent",
            headerCols: o ? void 0 : 1
          }
        });
      },
      children: e.children
    }
  );
};
var sr3 = (e) => {
  const t = p4(), n = y();
  return (0, import_jsx_runtime10.jsx)(
    t.Generic.Menu.Dropdown,
    {
      className: "bn-menu-dropdown bn-drag-handle-menu",
      children: e.children || (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, { children: [
        (0, import_jsx_runtime10.jsx)(ir3, { ...e, children: n.drag_handle.delete_menuitem }),
        (0, import_jsx_runtime10.jsx)(lr3, { ...e, children: n.drag_handle.colors_menuitem }),
        (0, import_jsx_runtime10.jsx)(cr3, { ...e, children: n.drag_handle.header_row_menuitem }),
        (0, import_jsx_runtime10.jsx)(ar3, { ...e, children: n.drag_handle.header_column_menuitem })
      ] })
    }
  );
};
var dr3 = (e) => {
  const t = p4(), n = y(), o = e.dragHandleMenu || sr3;
  return (0, import_jsx_runtime10.jsxs)(
    t.Generic.Menu.Root,
    {
      onOpenChange: (r) => {
        r ? e.freezeMenu() : e.unfreezeMenu();
      },
      position: "left",
      children: [
        (0, import_jsx_runtime10.jsx)(t.Generic.Menu.Trigger, { children: (0, import_jsx_runtime10.jsx)(
          t.SideMenu.Button,
          {
            label: n.side_menu.drag_handle_label,
            draggable: true,
            onDragStart: (r) => e.blockDragStart(r, e.block),
            onDragEnd: e.blockDragEnd,
            className: "bn-button",
            icon: (0, import_jsx_runtime10.jsx)(St2, { size: 24, "data-test": "dragHandle" })
          }
        ) }),
        (0, import_jsx_runtime10.jsx)(o, { block: e.block, children: e.children })
      ]
    }
  );
};
var ur3 = (e) => {
  const t = p4(), n = (0, import_react13.useMemo)(() => {
    var r;
    const o = {
      "data-block-type": e.block.type
    };
    return e.block.type === "heading" && (o["data-level"] = e.block.props.level.toString()), (r = e.editor.schema.blockSpecs[e.block.type].implementation.meta) != null && r.fileBlockAccept && (e.block.props.url ? o["data-url"] = "true" : o["data-url"] = "false"), o;
  }, [e.block.props, e.block.type, e.editor.schema.blockSpecs]);
  return (0, import_jsx_runtime10.jsx)(t.SideMenu.Root, { className: "bn-side-menu", ...n, children: e.children || (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, { children: [
    (0, import_jsx_runtime10.jsx)(or3, { ...e }),
    (0, import_jsx_runtime10.jsx)(dr3, { ...e })
  ] }) });
};
var mr3 = (e) => {
  const t = C2(), n = {
    blockDragStart: t.sideMenu.blockDragStart,
    blockDragEnd: t.sideMenu.blockDragEnd,
    freezeMenu: t.sideMenu.freezeMenu,
    unfreezeMenu: t.sideMenu.unfreezeMenu
  }, o = D(
    t.sideMenu.onUpdate.bind(t.sideMenu)
  ), { isMounted: r, ref: i2, style: c, getFloatingProps: s2 } = z3(
    (o == null ? void 0 : o.show) || false,
    (o == null ? void 0 : o.referencePos) || null,
    1e3,
    {
      placement: "left-start",
      ...e.floatingOptions
    }
  );
  if (!r || !o)
    return null;
  const { show: d, referencePos: a2, ...u } = o, h4 = e.sideMenu || ur3;
  return (0, import_jsx_runtime10.jsx)("div", { ref: i2, style: c, ...s2(), children: (0, import_jsx_runtime10.jsx)(h4, { ...u, ...n, editor: t }) });
};
async function hr4(e, t) {
  return (await pi(e, t)).map(
    ({ id: n, onItemClick: o }) => ({
      id: n,
      onItemClick: o,
      icon: n
    })
  );
}
function gr3(e) {
  const t = p4(), n = y(), { items: o, loadingState: r, selectedIndex: i2, onItemClick: c, columns: s2 } = e, d = r === "loading-initial" || r === "loading" ? (0, import_jsx_runtime10.jsx)(
    t.GridSuggestionMenu.Loader,
    {
      className: "bn-grid-suggestion-menu-loader",
      columns: s2
    }
  ) : null, a2 = (0, import_react13.useMemo)(() => {
    const u = [];
    for (let h4 = 0; h4 < o.length; h4++) {
      const m = o[h4];
      u.push(
        (0, import_jsx_runtime10.jsx)(
          t.GridSuggestionMenu.Item,
          {
            className: "bn-grid-suggestion-menu-item",
            item: m,
            id: `bn-grid-suggestion-menu-item-${h4}`,
            isSelected: h4 === i2,
            onClick: () => c == null ? void 0 : c(m)
          },
          m.id
        )
      );
    }
    return u;
  }, [t, o, c, i2]);
  return (0, import_jsx_runtime10.jsxs)(
    t.GridSuggestionMenu.Root,
    {
      id: "bn-grid-suggestion-menu",
      columns: s2,
      className: "bn-grid-suggestion-menu",
      children: [
        d,
        a2,
        a2.length === 0 && e.loadingState === "loaded" && (0, import_jsx_runtime10.jsx)(
          t.GridSuggestionMenu.EmptyItem,
          {
            className: "bn-grid-suggestion-menu-empty-item",
            columns: s2,
            children: n.suggestion_menu.no_items_title
          }
        )
      ]
    }
  );
}
function Tt2(e, t, n, o = 3) {
  const r = (0, import_react13.useRef)(0);
  (0, import_react13.useEffect)(() => {
    t !== void 0 && (e.length > 0 ? r.current = t.length : t.length - r.current > o && n());
  }, [n, o, e.length, t]);
}
function Lt2(e, t) {
  const [n, o] = (0, import_react13.useState)([]), [r, i2] = (0, import_react13.useState)(false), c = (0, import_react13.useRef)(void 0), s2 = (0, import_react13.useRef)(void 0);
  return (0, import_react13.useEffect)(() => {
    const d = e;
    c.current = e, i2(true), t(e).then((a2) => {
      c.current === d && (o(a2), i2(false), s2.current = d);
    });
  }, [e, t]), {
    items: n || [],
    // The query that was used to retrieve the last set of items may not be the
    // same as the current query as the items from the current query may not
    // have been retrieved yet. This is useful when using the returns of this
    // hook in other hooks.
    usedQuery: s2.current,
    loadingState: s2.current === void 0 ? "loading-initial" : r ? "loading" : "loaded"
  };
}
function fr3(e, t, n, o, r) {
  const [i2, c] = (0, import_react13.useState)(0), s2 = o !== void 0 && o > 1;
  return (0, import_react13.useEffect)(() => {
    var a2;
    const d = (u) => (u.key === "ArrowLeft" && (u.preventDefault(), n.length && c((i2 - 1 + n.length) % n.length)), u.key === "ArrowRight" && (u.preventDefault(), n.length && c((i2 + 1 + n.length) % n.length)), u.key === "ArrowUp" ? (u.preventDefault(), n.length && c(
      (i2 - o + n.length) % n.length
    ), true) : u.key === "ArrowDown" ? (u.preventDefault(), n.length && c((i2 + o) % n.length), true) : u.key === "Enter" && !u.isComposing ? (u.stopPropagation(), u.preventDefault(), n.length && (r == null || r(n[i2])), true) : false);
    return (a2 = e.domElement) == null || a2.addEventListener(
      "keydown",
      d,
      true
    ), () => {
      var u;
      (u = e.domElement) == null || u.removeEventListener(
        "keydown",
        d,
        true
      );
    };
  }, [e.domElement, n, i2, r, o, s2]), (0, import_react13.useEffect)(() => {
    c(0);
  }, [t]), {
    selectedIndex: n.length === 0 ? void 0 : i2
  };
}
function br5(e) {
  const n = F2().setContentEditableProps, o = C2(), {
    getItems: r,
    gridSuggestionMenuComponent: i2,
    query: c,
    clearQuery: s2,
    closeMenu: d,
    onItemClick: a2,
    columns: u
  } = e, h4 = (0, import_react13.useCallback)(
    (V) => {
      d(), s2(), a2 == null || a2(V);
    },
    [a2, d, s2]
  ), { items: m, usedQuery: g, loadingState: f2 } = Lt2(
    c,
    r
  );
  Tt2(m, g, d);
  const { selectedIndex: H2 } = fr3(
    o,
    c,
    m,
    u,
    h4
  );
  return (0, import_react13.useEffect)(() => (n((V) => ({
    ...V,
    "aria-expanded": true,
    "aria-controls": "bn-suggestion-menu"
  })), () => {
    n((V) => ({
      ...V,
      "aria-expanded": false,
      "aria-controls": void 0
    }));
  }), [n]), (0, import_react13.useEffect)(() => (n((V) => ({
    ...V,
    "aria-activedescendant": H2 ? "bn-suggestion-menu-item-" + H2 : void 0
  })), () => {
    n((V) => ({
      ...V,
      "aria-activedescendant": void 0
    }));
  }), [n, H2]), (0, import_jsx_runtime10.jsx)(
    i2,
    {
      items: m,
      onItemClick: h4,
      loadingState: f2,
      selectedIndex: H2,
      columns: u
    }
  );
}
function Cr2(e) {
  const t = C2(), {
    triggerCharacter: n,
    gridSuggestionMenuComponent: o,
    columns: r,
    minQueryLength: i2,
    onItemClick: c,
    getItems: s2,
    floatingOptions: d
  } = e, a2 = (0, import_react13.useMemo)(() => c || ((S) => {
    S.onItemClick(t);
  }), [t, c]), u = (0, import_react13.useMemo)(() => s2 || (async (S) => await hr4(
    t,
    S
  )), [t, s2]), h4 = {
    closeMenu: t.suggestionMenus.closeMenu,
    clearQuery: t.suggestionMenus.clearQuery
  }, m = (0, import_react13.useCallback)(
    (S) => t.suggestionMenus.onUpdate(n, S),
    [t.suggestionMenus, n]
  ), g = D(m), { isMounted: f2, ref: H2, style: B2, getFloatingProps: V } = z3(
    (g == null ? void 0 : g.show) || false,
    (g == null ? void 0 : g.referencePos) || null,
    2e3,
    {
      placement: "bottom-start",
      middleware: [
        offset3(10),
        // Flips the menu placement to maximize the space available, and prevents
        // the menu from being cut off by the confines of the screen.
        flip3(),
        size3({
          apply({ availableHeight: S, elements: _ }) {
            Object.assign(_.floating.style, {
              maxHeight: `${S - 10}px`
            });
          }
        })
      ],
      onOpenChange(S) {
        S || t.suggestionMenus.closeMenu();
      },
      ...d
    }
  );
  return !f2 || !g || !(g != null && g.ignoreQueryLength) && i2 && (g.query.startsWith(" ") || g.query.length < i2) ? null : (0, import_jsx_runtime10.jsx)("div", { ref: H2, style: B2, ...V(), children: (0, import_jsx_runtime10.jsx)(
    br5,
    {
      query: g.query,
      closeMenu: h4.closeMenu,
      clearQuery: h4.clearQuery,
      getItems: u,
      columns: r,
      gridSuggestionMenuComponent: o || gr3,
      onItemClick: a2
    }
  ) });
}
function pr3(e) {
  const t = p4(), n = y(), { items: o, loadingState: r, selectedIndex: i2, onItemClick: c } = e, s2 = r === "loading-initial" || r === "loading" ? (0, import_jsx_runtime10.jsx)(
    t.SuggestionMenu.Loader,
    {
      className: "bn-suggestion-menu-loader"
    }
  ) : null, d = (0, import_react13.useMemo)(() => {
    let a2;
    const u = [];
    for (let h4 = 0; h4 < o.length; h4++) {
      const m = o[h4];
      m.group !== a2 && (a2 = m.group, u.push(
        (0, import_jsx_runtime10.jsx)(
          t.SuggestionMenu.Label,
          {
            className: "bn-suggestion-menu-label",
            children: a2
          },
          a2
        )
      )), u.push(
        (0, import_jsx_runtime10.jsx)(
          t.SuggestionMenu.Item,
          {
            className: U(
              "bn-suggestion-menu-item",
              m.size === "small" ? "bn-suggestion-menu-item-small" : ""
            ),
            item: m,
            id: `bn-suggestion-menu-item-${h4}`,
            isSelected: h4 === i2,
            onClick: () => c == null ? void 0 : c(m)
          },
          m.title
        )
      );
    }
    return u;
  }, [t, o, c, i2]);
  return (0, import_jsx_runtime10.jsxs)(
    t.SuggestionMenu.Root,
    {
      id: "bn-suggestion-menu",
      className: "bn-suggestion-menu",
      children: [
        d,
        d.length === 0 && (e.loadingState === "loading" || e.loadingState === "loaded") && (0, import_jsx_runtime10.jsx)(
          t.SuggestionMenu.EmptyItem,
          {
            className: "bn-suggestion-menu-item",
            children: n.suggestion_menu.no_items_title
          }
        ),
        s2
      ]
    }
  );
}
function kr3(e, t) {
  const [n, o] = (0, import_react13.useState)(0);
  return {
    selectedIndex: n,
    setSelectedIndex: o,
    handler: (r) => {
      if (r.key === "ArrowUp")
        return r.preventDefault(), e.length && o((n - 1 + e.length) % e.length), true;
      if (r.key === "ArrowDown")
        return r.preventDefault(), e.length && o((n + 1) % e.length), true;
      const i2 = wr2(r) ? r.nativeEvent.isComposing : r.isComposing;
      return r.key === "Enter" && !i2 ? (r.preventDefault(), r.stopPropagation(), e.length && (t == null || t(e[n])), true) : false;
    }
  };
}
function wr2(e) {
  return e.nativeEvent !== void 0;
}
function vr2(e, t, n, o, r) {
  const { selectedIndex: i2, setSelectedIndex: c, handler: s2 } = kr3(n, o);
  return (0, import_react13.useEffect)(() => {
    var d;
    return (d = r || e.domElement) == null || d.addEventListener("keydown", s2, true), () => {
      var a2;
      (a2 = r || e.domElement) == null || a2.removeEventListener(
        "keydown",
        s2,
        true
      );
    };
  }, [e.domElement, n, i2, o, r, s2]), (0, import_react13.useEffect)(() => {
    c(0);
  }, [t, c]), {
    selectedIndex: n.length === 0 ? void 0 : i2
  };
}
function Hr2(e) {
  const n = F2().setContentEditableProps, o = C2(), {
    getItems: r,
    suggestionMenuComponent: i2,
    query: c,
    clearQuery: s2,
    closeMenu: d,
    onItemClick: a2
  } = e, u = (0, import_react13.useCallback)(
    (B2) => {
      d(), s2(), a2 == null || a2(B2);
    },
    [a2, d, s2]
  ), { items: h4, usedQuery: m, loadingState: g } = Lt2(
    c,
    r
  );
  Tt2(h4, m, d);
  const { selectedIndex: f2 } = vr2(
    o,
    c,
    h4,
    u
  );
  return (0, import_react13.useEffect)(() => (n((B2) => ({
    ...B2,
    "aria-expanded": true,
    "aria-controls": "bn-suggestion-menu"
  })), () => {
    n((B2) => ({
      ...B2,
      "aria-expanded": false,
      "aria-controls": void 0
    }));
  }), [n]), (0, import_react13.useEffect)(() => (n((B2) => ({
    ...B2,
    "aria-activedescendant": f2 ? "bn-suggestion-menu-item-" + f2 : void 0
  })), () => {
    n((B2) => ({
      ...B2,
      "aria-activedescendant": void 0
    }));
  }), [n, f2]), (0, import_jsx_runtime10.jsx)(
    i2,
    {
      items: h4,
      onItemClick: u,
      loadingState: g,
      selectedIndex: f2
    }
  );
}
var Mr2 = {
  heading: ie2,
  heading_2: ce3,
  heading_3: ae2,
  heading_4: mt2,
  heading_5: ht2,
  heading_6: gt2,
  toggle_heading: ie2,
  toggle_heading_2: ce3,
  toggle_heading_3: ae2,
  quote: kt,
  toggle_list: vt2,
  numbered_list: Ct2,
  bullet_list: pt2,
  check_list: bt,
  paragraph: Re2,
  table: no2,
  image: wt,
  video: ro2,
  audio: Ht2,
  file: Ee2,
  emoji: Co2,
  code_block: $n3,
  divider: bo2
};
function yr2(e) {
  return hr(e).map((t) => {
    const n = Mr2[t.key];
    return {
      ...t,
      icon: (0, import_jsx_runtime10.jsx)(n, { size: 18 })
    };
  });
}
function xr2(e) {
  const t = C2(), {
    triggerCharacter: n,
    suggestionMenuComponent: o,
    minQueryLength: r,
    onItemClick: i2,
    getItems: c,
    floatingOptions: s2
  } = e, d = (0, import_react13.useMemo)(() => i2 || ((V) => {
    V.onItemClick(t);
  }), [t, i2]), a2 = (0, import_react13.useMemo)(() => c || (async (V) => mr(
    yr2(t),
    V
  )), [t, c]), u = {
    closeMenu: t.suggestionMenus.closeMenu,
    clearQuery: t.suggestionMenus.clearQuery
  }, h4 = (0, import_react13.useCallback)(
    (V) => t.suggestionMenus.onUpdate(n, V),
    [t.suggestionMenus, n]
  ), m = D(h4), { isMounted: g, ref: f2, style: H2, getFloatingProps: B2 } = z3(
    (m == null ? void 0 : m.show) || false,
    (m == null ? void 0 : m.referencePos) || null,
    2e3,
    {
      placement: "bottom-start",
      middleware: [
        offset3(10),
        // Flips the menu placement to maximize the space available, and prevents
        // the menu from being cut off by the confines of the screen.
        flip3({
          mainAxis: true,
          crossAxis: false
        }),
        shift3(),
        size3({
          apply({ availableHeight: V, elements: S }) {
            Object.assign(S.floating.style, {
              maxHeight: `${V - 10}px`,
              minHeight: "300px"
            });
          }
        })
      ],
      onOpenChange(V) {
        V || t.suggestionMenus.closeMenu();
      },
      ...s2
    }
  );
  return !g || !m || !(m != null && m.ignoreQueryLength) && r && (m.query.startsWith(" ") || m.query.length < r) ? null : (0, import_jsx_runtime10.jsx)(
    "div",
    {
      ref: f2,
      style: H2,
      ...B2(),
      onMouseDown: (V) => V.preventDefault(),
      children: (0, import_jsx_runtime10.jsx)(
        Hr2,
        {
          query: m.query,
          closeMenu: u.closeMenu,
          clearQuery: u.clearQuery,
          getItems: a2,
          suggestionMenuComponent: o || pr3,
          onItemClick: d
        }
      )
    }
  );
}
var Vr2 = (e, t = 0.3) => {
  const n = Math.floor(e) + t, o = Math.ceil(e) - t;
  return e >= n && e <= o ? Math.round(e) : e < n ? Math.floor(e) : Math.ceil(e);
};
var Br2 = (e) => {
  const t = p4(), n = (0, import_react13.useRef)(false), [o, r] = (0, import_react13.useState)(), i2 = (0, import_react13.useCallback)(
    (s2) => {
      e.onMouseDown(), r({
        originalContent: e.block.content,
        originalCroppedContent: {
          rows: e.editor.tableHandles.cropEmptyRowsOrColumns(
            e.block,
            e.orientation === "addOrRemoveColumns" ? "columns" : "rows"
          )
        },
        startPos: e.orientation === "addOrRemoveColumns" ? s2.clientX : s2.clientY
      }), n.current = false, s2.preventDefault();
    },
    [e]
  ), c = (0, import_react13.useCallback)(() => {
    n.current || e.editor.updateBlock(e.block, {
      type: "table",
      content: {
        ...e.block.content,
        rows: e.orientation === "addOrRemoveColumns" ? e.editor.tableHandles.addRowsOrColumns(
          e.block,
          "columns",
          1
        ) : e.editor.tableHandles.addRowsOrColumns(
          e.block,
          "rows",
          1
        )
      }
    });
  }, [e.block, e.orientation, e.editor]);
  return (0, import_react13.useEffect)(() => {
    const s2 = (d) => {
      var f2, H2;
      if (!o)
        throw new Error("editingState is undefined");
      n.current = true;
      const a2 = (e.orientation === "addOrRemoveColumns" ? d.clientX : d.clientY) - o.startPos, u = e.orientation === "addOrRemoveColumns" ? ((f2 = o.originalCroppedContent.rows[0]) == null ? void 0 : f2.cells.length) ?? 0 : o.originalCroppedContent.rows.length, h4 = e.orientation === "addOrRemoveColumns" ? ((H2 = o.originalContent.rows[0]) == null ? void 0 : H2.cells.length) ?? 0 : o.originalContent.rows.length, m = e.orientation === "addOrRemoveColumns" ? e.block.content.rows[0].cells.length : e.block.content.rows.length, g = h4 + Vr2(
        a2 / (e.orientation === "addOrRemoveColumns" ? ut : ur),
        0.3
      );
      g >= u && g > 0 && g !== m && (e.editor.updateBlock(e.block, {
        type: "table",
        content: {
          ...e.block.content,
          rows: e.orientation === "addOrRemoveColumns" ? e.editor.tableHandles.addRowsOrColumns(
            {
              type: "table",
              content: o.originalCroppedContent
            },
            "columns",
            g - u
          ) : e.editor.tableHandles.addRowsOrColumns(
            {
              type: "table",
              content: o.originalCroppedContent
            },
            "rows",
            g - u
          )
        }
      }), e.block.content && e.editor.setTextCursorPosition(e.block));
    };
    return o && window.addEventListener("mousemove", s2), () => {
      window.removeEventListener("mousemove", s2);
    };
  }, [o, e.block, e.editor, e.orientation]), (0, import_react13.useEffect)(() => {
    const s2 = e.onMouseUp, d = () => {
      r(void 0), s2();
    };
    return o && window.addEventListener("mouseup", d), () => {
      window.removeEventListener("mouseup", d);
    };
  }, [o, e.onMouseUp]), e.editor.isEditable ? (0, import_jsx_runtime10.jsx)(
    t.TableHandle.ExtendButton,
    {
      className: U(
        "bn-extend-button",
        e.orientation === "addOrRemoveColumns" ? "bn-extend-button-add-remove-columns" : "bn-extend-button-add-remove-rows",
        o !== null ? "bn-extend-button-editing" : ""
      ),
      onClick: c,
      onMouseDown: i2,
      children: e.children || (0, import_jsx_runtime10.jsx)(ao2, { size: 18, "data-test": "extendButton" })
    }
  ) : null;
};
var Ke2 = (e) => {
  const t = p4(), n = y(), r = C2().tableHandles;
  return r ? (0, import_jsx_runtime10.jsx)(
    t.Generic.Menu.Item,
    {
      onClick: () => {
        r.addRowOrColumn(
          e.index,
          e.orientation === "row" ? { orientation: "row", side: e.side } : { orientation: "column", side: e.side }
        );
      },
      children: n.table_handle[`add_${e.side}_menuitem`]
    }
  ) : null;
};
var Sr2 = (e) => {
  const t = p4(), n = y(), r = C2().tableHandles;
  return r ? (0, import_jsx_runtime10.jsx)(
    t.Generic.Menu.Item,
    {
      onClick: () => {
        r.removeRowOrColumn(e.index, e.orientation);
      },
      children: e.orientation === "row" ? n.table_handle.delete_row_menuitem : n.table_handle.delete_column_menuitem
    }
  ) : null;
};
var Tr2 = (e) => {
  const t = p4(), n = y(), o = C2(), r = o.tableHandles, i2 = (0, import_react13.useMemo)(() => !r || !e.block ? [] : e.orientation === "row" ? r.getCellsAtRowHandle(e.block, e.index) : r.getCellsAtColumnHandle(e.block, e.index), [e.block, e.index, e.orientation, r]), c = (d, a2) => {
    const u = e.block.content.rows.map((h4) => ({
      ...h4,
      cells: h4.cells.map((m) => se(m))
    }));
    i2.forEach(({ row: h4, col: m }) => {
      a2 === "text" ? u[h4].cells[m].props.textColor = d : u[h4].cells[m].props.backgroundColor = d;
    }), o.updateBlock(e.block, {
      type: "table",
      content: {
        ...e.block.content,
        rows: u
      }
    }), o.setTextCursorPosition(e.block);
  };
  if (!i2 || !i2[0] || !r || o.settings.tables.cellTextColor === false && o.settings.tables.cellBackgroundColor === false)
    return null;
  const s2 = se(i2[0].cell);
  return (0, import_jsx_runtime10.jsxs)(t.Generic.Menu.Root, { position: "right", sub: true, children: [
    (0, import_jsx_runtime10.jsx)(t.Generic.Menu.Trigger, { sub: true, children: (0, import_jsx_runtime10.jsx)(
      t.Generic.Menu.Item,
      {
        className: "bn-menu-item",
        subTrigger: true,
        children: e.children || n.drag_handle.colors_menuitem
      }
    ) }),
    (0, import_jsx_runtime10.jsx)(
      t.Generic.Menu.Dropdown,
      {
        sub: true,
        className: "bn-menu-dropdown bn-color-picker-dropdown",
        children: (0, import_jsx_runtime10.jsx)(
          ge3,
          {
            iconSize: 18,
            text: o.settings.tables.cellTextColor ? {
              // All cells have the same text color
              color: i2.every(
                ({ cell: d }) => pe(d) && d.props.textColor === s2.props.textColor
              ) ? s2.props.textColor : "default",
              setColor: (d) => {
                c(d, "text");
              }
            } : void 0,
            background: o.settings.tables.cellBackgroundColor ? {
              color: i2.every(
                ({ cell: d }) => pe(d) && d.props.backgroundColor === s2.props.backgroundColor
              ) ? s2.props.backgroundColor : "default",
              setColor: (d) => c(d, "background")
            } : void 0
          }
        )
      }
    )
  ] });
};
var Lr2 = (e) => {
  const t = p4(), n = y(), o = C2();
  if (!o.tableHandles || e.index !== 0 || e.orientation !== "row" || !o.settings.tables.headers)
    return null;
  const i2 = !!e.block.content.headerRows;
  return (0, import_jsx_runtime10.jsx)(
    t.Generic.Menu.Item,
    {
      className: "bn-menu-item",
      checked: i2,
      onClick: () => {
        const c = o.getBlock(e.block.id);
        c && o.updateBlock(c, {
          ...c,
          content: {
            ...c.content,
            headerRows: i2 ? void 0 : 1
          }
        });
      },
      children: n.drag_handle.header_row_menuitem
    }
  );
};
var _r2 = (e) => {
  const t = p4(), n = y(), o = C2();
  if (!o.tableHandles || e.index !== 0 || e.orientation !== "column" || !o.settings.tables.headers)
    return null;
  const i2 = !!e.block.content.headerCols;
  return (0, import_jsx_runtime10.jsx)(
    t.Generic.Menu.Item,
    {
      className: "bn-menu-item",
      checked: i2,
      onClick: () => {
        const c = o.getBlock(e.block.id);
        c && o.updateBlock(c, {
          ...c,
          content: {
            ...c.content,
            headerCols: i2 ? void 0 : 1
          }
        });
      },
      children: n.drag_handle.header_column_menuitem
    }
  );
};
var Er2 = (e) => {
  const t = p4();
  return (0, import_jsx_runtime10.jsx)(t.Generic.Menu.Dropdown, { className: "bn-table-handle-menu", children: e.children || (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, { children: [
    (0, import_jsx_runtime10.jsx)(
      Sr2,
      {
        orientation: e.orientation,
        block: e.block,
        index: e.index
      }
    ),
    (0, import_jsx_runtime10.jsx)(
      Ke2,
      {
        orientation: e.orientation,
        block: e.block,
        index: e.index,
        side: e.orientation === "row" ? "above" : "left"
      }
    ),
    (0, import_jsx_runtime10.jsx)(
      Ke2,
      {
        orientation: e.orientation,
        block: e.block,
        index: e.index,
        side: e.orientation === "row" ? "below" : "right"
      }
    ),
    (0, import_jsx_runtime10.jsx)(
      Lr2,
      {
        orientation: e.orientation,
        block: e.block,
        index: e.index
      }
    ),
    (0, import_jsx_runtime10.jsx)(
      _r2,
      {
        orientation: e.orientation,
        block: e.block,
        index: e.index
      }
    ),
    (0, import_jsx_runtime10.jsx)(
      Tr2,
      {
        orientation: e.orientation,
        block: e.block,
        index: e.index
      }
    )
  ] }) });
};
var Rr2 = (e) => {
  const t = p4(), [n, o] = (0, import_react13.useState)(false), r = e.tableHandleMenu || Er2, i2 = (0, import_react13.useMemo)(() => {
    const c = e.editor.tableHandles;
    return !c || !e.block || e.block.type !== "table" ? false : e.orientation === "column" ? c.getCellsAtColumnHandle(e.block, e.index).every(({ cell: s2 }) => j(s2) === 1) : c.getCellsAtRowHandle(e.block, e.index).every(({ cell: s2 }) => ae(s2) === 1);
  }, [e.block, e.editor.tableHandles, e.index, e.orientation]);
  return (0, import_jsx_runtime10.jsxs)(
    t.Generic.Menu.Root,
    {
      onOpenChange: (c) => {
        c ? (e.freezeHandles(), e.hideOtherSide()) : (e.unfreezeHandles(), e.showOtherSide(), e.editor.focus());
      },
      position: "right",
      children: [
        (0, import_jsx_runtime10.jsx)(t.Generic.Menu.Trigger, { children: (0, import_jsx_runtime10.jsx)(
          t.TableHandle.Root,
          {
            className: U(
              "bn-table-handle",
              n ? "bn-table-handle-dragging" : "",
              i2 ? "" : "bn-table-handle-not-draggable"
            ),
            draggable: i2,
            onDragStart: (c) => {
              o(true), e.dragStart(c);
            },
            onDragEnd: () => {
              e.dragEnd(), o(false);
            },
            style: e.orientation === "column" ? { transform: "rotate(0.25turn)" } : void 0,
            children: e.children || (0, import_jsx_runtime10.jsx)(St2, { size: 24, "data-test": "tableHandle" })
          }
        ) }),
        (0, import_react_dom5.createPortal)(
          (0, import_jsx_runtime10.jsx)(
            r,
            {
              orientation: e.orientation,
              block: e.block,
              index: e.index
            }
          ),
          e.menuContainer
        )
      ]
    }
  );
};
function Ye2(e, t, n) {
  const { refs: o, update: r, context: i2, floatingStyles: c } = useFloating2({
    open: t,
    placement: e === "addOrRemoveColumns" ? "right" : "bottom",
    middleware: [
      size3({
        apply({ rects: a2, elements: u }) {
          Object.assign(
            u.floating.style,
            e === "addOrRemoveColumns" ? {
              height: `${a2.reference.height}px`
            } : {
              width: `${a2.reference.width}px`
            }
          );
        }
      })
    ]
  }), { isMounted: s2, styles: d } = useTransitionStyles(i2);
  return (0, import_react13.useEffect)(() => {
    r();
  }, [n, r]), (0, import_react13.useEffect)(() => {
    n !== null && o.setReference({
      getBoundingClientRect: () => n
    });
  }, [e, n, o]), (0, import_react13.useMemo)(
    () => ({
      isMounted: s2,
      ref: o.setFloating,
      style: {
        display: "flex",
        ...d,
        ...c
      }
    }),
    [c, s2, o.setFloating, d]
  );
}
function Ir2(e, t, n) {
  const o = Ye2(
    "addOrRemoveRows",
    t,
    n
  ), r = Ye2(
    "addOrRemoveColumns",
    e,
    n
  );
  return (0, import_react13.useMemo)(
    () => ({
      addOrRemoveRowsButton: o,
      addOrRemoveColumnsButton: r
    }),
    [r, o]
  );
}
function Nr2(e, t, n) {
  return n && n.draggedCellOrientation === "row" ? new DOMRect(
    t.x,
    n.mousePos,
    t.width,
    0
  ) : new DOMRect(
    t.x,
    e.y,
    t.width,
    e.height
  );
}
function Pr2(e, t, n) {
  return n && n.draggedCellOrientation === "col" ? new DOMRect(
    n.mousePos,
    t.y,
    0,
    t.height
  ) : new DOMRect(
    e.x,
    t.y,
    e.width,
    t.height
  );
}
function Zr2(e) {
  return new DOMRect(
    e.x,
    e.y,
    e.width,
    0
  );
}
function ke3(e, t, n, o, r) {
  const { refs: i2, update: c, context: s2, floatingStyles: d } = useFloating2({
    open: t,
    placement: e === "row" ? "left" : e === "col" ? "top" : "bottom-end",
    middleware: [
      offset3(
        e === "row" ? -10 : e === "col" ? -12 : { mainAxis: 1, crossAxis: -1 }
      )
    ]
  }), { isMounted: a2, styles: u } = useTransitionStyles(s2);
  return (0, import_react13.useEffect)(() => {
    c();
  }, [n, o, c]), (0, import_react13.useEffect)(() => {
    n === null || o === null || // Ignore cell handle when dragging
    r && e === "cell" || i2.setReference({
      getBoundingClientRect: () => (e === "row" ? Nr2 : e === "col" ? Pr2 : Zr2)(n, o, r)
    });
  }, [r, e, n, o, i2]), (0, import_react13.useMemo)(
    () => ({
      isMounted: a2,
      ref: i2.setFloating,
      style: {
        display: "flex",
        ...u,
        ...d
      }
    }),
    [d, a2, i2.setFloating, u]
  );
}
function Ar2(e, t, n, o) {
  const r = ke3(
    "row",
    e,
    t,
    n,
    o
  ), i2 = ke3(
    "col",
    e,
    t,
    n,
    o
  ), c = ke3(
    "cell",
    e,
    t,
    n,
    o
  );
  return (0, import_react13.useMemo)(
    () => ({
      rowHandle: r,
      colHandle: i2,
      cellHandle: c
    }),
    [i2, r, c]
  );
}
var Dr2 = (e) => {
  var c, s2;
  const t = p4(), n = y(), o = C2(), r = (d, a2) => {
    const u = e.block.content.rows.map((h4) => ({
      ...h4,
      cells: h4.cells.map((m) => se(m))
    }));
    a2 === "text" ? u[e.rowIndex].cells[e.colIndex].props.textColor = d : u[e.rowIndex].cells[e.colIndex].props.backgroundColor = d, o.updateBlock(e.block, {
      type: "table",
      content: {
        ...e.block.content,
        rows: u
      }
    }), o.setTextCursorPosition(e.block);
  }, i2 = (s2 = (c = e.block.content.rows[e.rowIndex]) == null ? void 0 : c.cells) == null ? void 0 : s2[e.colIndex];
  return !i2 || o.settings.tables.cellTextColor === false && o.settings.tables.cellBackgroundColor === false ? null : (0, import_jsx_runtime10.jsxs)(t.Generic.Menu.Root, { position: "right", sub: true, children: [
    (0, import_jsx_runtime10.jsx)(t.Generic.Menu.Trigger, { sub: true, children: (0, import_jsx_runtime10.jsx)(
      t.Generic.Menu.Item,
      {
        className: "bn-menu-item",
        subTrigger: true,
        children: e.children || n.drag_handle.colors_menuitem
      }
    ) }),
    (0, import_jsx_runtime10.jsx)(
      t.Generic.Menu.Dropdown,
      {
        sub: true,
        className: "bn-menu-dropdown bn-color-picker-dropdown",
        children: (0, import_jsx_runtime10.jsx)(
          ge3,
          {
            iconSize: 18,
            text: o.settings.tables.cellTextColor ? {
              color: pe(i2) ? i2.props.textColor : "default",
              setColor: (d) => r(d, "text")
            } : void 0,
            background: o.settings.tables.cellBackgroundColor ? {
              color: pe(i2) ? i2.props.backgroundColor : "default",
              setColor: (d) => r(d, "background")
            } : void 0
          }
        )
      }
    )
  ] });
};
var Fr2 = (e) => {
  var i2, c;
  const t = p4(), n = y(), o = C2(), r = (c = (i2 = e.block.content.rows[e.rowIndex]) == null ? void 0 : i2.cells) == null ? void 0 : c[e.colIndex];
  return !r || !pe(r) || ae(r) === 1 && j(r) === 1 || !o.settings.tables.splitCells ? null : (0, import_jsx_runtime10.jsx)(
    t.Generic.Menu.Item,
    {
      onClick: () => {
        var s2;
        (s2 = o.tableHandles) == null || s2.splitCell({
          row: e.rowIndex,
          col: e.colIndex
        });
      },
      children: n.table_handle.split_cell_menuitem
    }
  );
};
var Or2 = (e) => {
  const t = p4();
  return (0, import_jsx_runtime10.jsx)(
    t.Generic.Menu.Dropdown,
    {
      className: "bn-menu-dropdown bn-table-handle-menu",
      children: e.children || (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, { children: [
        (0, import_jsx_runtime10.jsx)(
          Fr2,
          {
            block: e.block,
            rowIndex: e.rowIndex,
            colIndex: e.colIndex
          }
        ),
        (0, import_jsx_runtime10.jsx)(
          Dr2,
          {
            block: e.block,
            rowIndex: e.rowIndex,
            colIndex: e.colIndex
          }
        )
      ] })
    }
  );
};
var Gr2 = (e) => {
  const t = p4(), n = e.tableCellMenu || Or2;
  return !e.editor.settings.tables.splitCells && !e.editor.settings.tables.cellBackgroundColor && !e.editor.settings.tables.cellTextColor ? null : (0, import_jsx_runtime10.jsxs)(
    t.Generic.Menu.Root,
    {
      onOpenChange: (o) => {
        o ? e.freezeHandles() : (e.unfreezeHandles(), e.editor.focus());
      },
      position: "right",
      children: [
        (0, import_jsx_runtime10.jsx)(t.Generic.Menu.Trigger, { children: (0, import_jsx_runtime10.jsx)(t.Generic.Menu.Button, { className: "bn-table-cell-handle", children: e.children || (0, import_jsx_runtime10.jsx)(rr3, { size: 12, "data-test": "tableCellHandle" }) }) }),
        (0, import_react_dom5.createPortal)(
          (0, import_jsx_runtime10.jsx)(
            n,
            {
              block: e.block,
              rowIndex: e.rowIndex,
              colIndex: e.colIndex
            }
          ),
          e.menuContainer
        )
      ]
    }
  );
};
var Ur2 = (e) => {
  var $3, E2;
  const t = C2(), [n, o] = (0, import_react13.useState)(null);
  if (!t.tableHandles)
    throw new Error(
      "TableHandlesController can only be used when BlockNote editor schema contains table block"
    );
  const r = {
    rowDragStart: t.tableHandles.rowDragStart,
    colDragStart: t.tableHandles.colDragStart,
    dragEnd: t.tableHandles.dragEnd,
    freezeHandles: t.tableHandles.freezeHandles,
    unfreezeHandles: t.tableHandles.unfreezeHandles
  }, { freezeHandles: i2, unfreezeHandles: c } = r, s2 = (0, import_react13.useCallback)(() => {
    i2(), _(true), V(true);
  }, [i2]), d = (0, import_react13.useCallback)(() => {
    c(), _(false), V(false);
  }, [c]), a2 = D(
    t.tableHandles.onUpdate.bind(t.tableHandles)
  ), u = (0, import_react13.useMemo)(() => {
    var Z2, Q;
    return a2 != null && a2.draggingState ? {
      draggedCellOrientation: (Z2 = a2 == null ? void 0 : a2.draggingState) == null ? void 0 : Z2.draggedCellOrientation,
      mousePos: (Q = a2 == null ? void 0 : a2.draggingState) == null ? void 0 : Q.mousePos
    } : void 0;
  }, [
    a2 == null ? void 0 : a2.draggingState,
    ($3 = a2 == null ? void 0 : a2.draggingState) == null ? void 0 : $3.draggedCellOrientation,
    (E2 = a2 == null ? void 0 : a2.draggingState) == null ? void 0 : E2.mousePos
  ]), { rowHandle: h4, colHandle: m, cellHandle: g } = Ar2(
    (a2 == null ? void 0 : a2.show) || false,
    (a2 == null ? void 0 : a2.referencePosCell) || null,
    (a2 == null ? void 0 : a2.referencePosTable) || null,
    u
  ), { addOrRemoveColumnsButton: f2, addOrRemoveRowsButton: H2 } = Ir2(
    (a2 == null ? void 0 : a2.showAddOrRemoveColumnsButton) || false,
    (a2 == null ? void 0 : a2.showAddOrRemoveRowsButton) || false,
    (a2 == null ? void 0 : a2.referencePosTable) || null
  ), [B2, V] = (0, import_react13.useState)(false), [S, _] = (0, import_react13.useState)(false);
  if (!a2)
    return null;
  const P2 = e.tableHandle || Rr2, W = e.extendButton || Br2, O2 = e.tableCellHandle || Gr2;
  return (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, { children: [
    (0, import_jsx_runtime10.jsx)("div", { ref: o }),
    (0, import_jsx_runtime10.jsxs)(FloatingPortal, { root: a2.widgetContainer, children: [
      !B2 && n && h4.isMounted && a2.rowIndex !== void 0 && (0, import_jsx_runtime10.jsx)("div", { ref: h4.ref, style: h4.style, children: (0, import_jsx_runtime10.jsx)(
        P2,
        {
          editor: t,
          orientation: "row",
          showOtherSide: () => _(false),
          hideOtherSide: () => _(true),
          index: a2.rowIndex,
          block: a2.block,
          dragStart: r.rowDragStart,
          dragEnd: r.dragEnd,
          freezeHandles: r.freezeHandles,
          unfreezeHandles: r.unfreezeHandles,
          menuContainer: n
        }
      ) }),
      !S && n && m.isMounted && a2.colIndex !== void 0 && (0, import_jsx_runtime10.jsx)("div", { ref: m.ref, style: m.style, children: (0, import_jsx_runtime10.jsx)(
        P2,
        {
          editor: t,
          orientation: "column",
          showOtherSide: () => V(false),
          hideOtherSide: () => V(true),
          index: a2.colIndex,
          block: a2.block,
          dragStart: r.colDragStart,
          dragEnd: r.dragEnd,
          freezeHandles: r.freezeHandles,
          unfreezeHandles: r.unfreezeHandles,
          menuContainer: n
        }
      ) }),
      n && g.isMounted && a2.colIndex !== void 0 && a2.rowIndex !== void 0 && (0, import_jsx_runtime10.jsx)("div", { ref: g.ref, style: g.style, children: (0, import_jsx_runtime10.jsx)(
        O2,
        {
          editor: t,
          block: a2.block,
          rowIndex: a2.rowIndex,
          colIndex: a2.colIndex,
          menuContainer: n,
          freezeHandles: r.freezeHandles,
          unfreezeHandles: r.unfreezeHandles
        }
      ) }),
      (0, import_jsx_runtime10.jsx)(
        "div",
        {
          ref: H2.ref,
          style: H2.style,
          children: (0, import_jsx_runtime10.jsx)(
            W,
            {
              editor: t,
              orientation: "addOrRemoveRows",
              block: a2.block,
              onMouseDown: s2,
              onMouseUp: d
            }
          )
        }
      ),
      (0, import_jsx_runtime10.jsx)(
        "div",
        {
          ref: f2.ref,
          style: f2.style,
          children: (0, import_jsx_runtime10.jsx)(
            W,
            {
              editor: t,
              orientation: "addOrRemoveColumns",
              block: a2.block,
              onMouseDown: s2,
              onMouseUp: d
            }
          )
        }
      )
    ] })
  ] });
};
function zr2(e) {
  const t = C2();
  if (!t)
    throw new Error(
      "BlockNoteDefaultUI must be used within a BlockNoteContext.Provider"
    );
  return (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, { children: [
    e.formattingToolbar !== false && (0, import_jsx_runtime10.jsx)(Ko2, {}),
    e.linkToolbar !== false && (0, import_jsx_runtime10.jsx)(tr4, {}),
    e.slashMenu !== false && (0, import_jsx_runtime10.jsx)(xr2, { triggerCharacter: "/" }),
    e.emojiPicker !== false && (0, import_jsx_runtime10.jsx)(
      Cr2,
      {
        triggerCharacter: ":",
        columns: 10,
        minQueryLength: 2
      }
    ),
    e.sideMenu !== false && (0, import_jsx_runtime10.jsx)(mr3, {}),
    t.filePanel && e.filePanel !== false && (0, import_jsx_runtime10.jsx)(Bo, {}),
    t.tableHandles && e.tableHandles !== false && (0, import_jsx_runtime10.jsx)(Ur2, {}),
    t.comments && e.comments !== false && (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, { children: [
      (0, import_jsx_runtime10.jsx)(En3, {}),
      (0, import_jsx_runtime10.jsx)(yo2, {})
    ] })
  ] });
}
var jr2 = () => {
  const e = (0, import_react13.useMemo)(
    () => {
      var c;
      return (c = window.matchMedia) == null ? void 0 : c.call(window, "(prefers-color-scheme: dark)");
    },
    []
  ), t = (0, import_react13.useMemo)(
    () => {
      var c;
      return (c = window.matchMedia) == null ? void 0 : c.call(window, "(prefers-color-scheme: light)");
    },
    []
  ), n = e == null ? void 0 : e.matches, o = t == null ? void 0 : t.matches, [r, i2] = (0, import_react13.useState)(n ? "dark" : o ? "light" : "no-preference");
  return (0, import_react13.useEffect)(() => {
    i2(n ? "dark" : o ? "light" : "no-preference");
  }, [n, o]), (0, import_react13.useEffect)(() => {
    if (typeof (e == null ? void 0 : e.addEventListener) == "function") {
      const c = ({ matches: d }) => d && i2("dark"), s2 = ({ matches: d }) => d && i2("light");
      return e == null || e.addEventListener("change", c), t == null || t.addEventListener("change", s2), () => {
        e == null || e.removeEventListener("change", c), t == null || t.removeEventListener("change", s2);
      };
    } else {
      const c = () => i2(
        e.matches ? "dark" : t.matches ? "light" : "no-preference"
      );
      return e == null || e.addEventListener("change", c), t == null || t.addEventListener("change", c), () => {
        e == null || e.removeEventListener("change", c), t == null || t.removeEventListener("change", c);
      };
    }
  }, [e, t]), typeof window.matchMedia != "function", r;
};
var _t3 = (0, import_react13.createContext)(void 0);
function Wr2() {
  return (0, import_react13.useContext)(_t3);
}
function qr2() {
  const e = /* @__PURE__ */ new Set();
  let t = {};
  return {
    /**
     * Subscribe to the editor instance's changes.
     */
    subscribe(n) {
      return e.add(n), () => {
        e.delete(n);
      };
    },
    getSnapshot() {
      return t;
    },
    getServerSnapshot() {
      return t;
    },
    /**
     * Adds a new NodeView Renderer to the editor.
     */
    setRenderer(n, o) {
      t = {
        ...t,
        [n]: (0, import_react_dom5.createPortal)(o.reactElement, o.element, n)
      }, e.forEach((r) => r());
    },
    /**
     * Removes a NodeView Renderer from the editor.
     */
    removeRenderer(n) {
      const o = { ...t };
      delete o[n], t = o, e.forEach((r) => r());
    }
  };
}
var $r2 = ({
  contentComponent: e
}) => {
  const t = (0, import_react13.useSyncExternalStore)(
    e.subscribe,
    e.getSnapshot,
    e.getServerSnapshot
  );
  return (0, import_jsx_runtime10.jsx)(import_jsx_runtime10.Fragment, { children: Object.values(t) });
};
var Xr2 = (0, import_react13.forwardRef)((e, t) => {
  const [n, o] = (0, import_react13.useState)();
  return (0, import_react13.useImperativeHandle)(t, () => (r, i2) => {
    (0, import_react_dom5.flushSync)(() => {
      o({ node: r, container: i2 });
    }), o(void 0);
  }, []), (0, import_jsx_runtime10.jsx)(import_jsx_runtime10.Fragment, { children: n && (0, import_react_dom5.createPortal)(n.node, n.container) });
});
var Je3 = () => {
};
function Kr2(e, t) {
  const {
    editor: n,
    className: o,
    theme: r,
    children: i2,
    editable: c,
    onSelectionChange: s2,
    onChange: d,
    formattingToolbar: a2,
    linkToolbar: u,
    slashMenu: h4,
    emojiPicker: m,
    sideMenu: g,
    filePanel: f2,
    tableHandles: H2,
    comments: B2,
    autoFocus: V,
    renderEditor: S = true,
    ..._
  } = e, [P2, W] = (0, import_react13.useState)(), O2 = F2(), $3 = jr2(), E2 = (O2 == null ? void 0 : O2.colorSchemePreference) || $3, Z2 = r || (E2 === "dark" ? "dark" : "light");
  J2(d || Je3, n), he3(s2 || Je3, n), (0, import_react13.useEffect)(() => {
    n.isEditable = c !== false;
  }, [c, n]);
  const Q = (0, import_react13.useCallback)(
    (Pt2) => {
      n.elementRenderer = Pt2;
    },
    [n]
  ), It2 = (0, import_react13.useMemo)(() => ({
    ...O2,
    editor: n,
    setContentEditableProps: W,
    colorSchemePreference: Z2
  }), [O2, n, Z2]), Nt2 = (0, import_react13.useMemo)(() => ({
    editorProps: {
      autoFocus: V,
      contentEditableProps: P2
    },
    defaultUIProps: {
      formattingToolbar: a2,
      linkToolbar: u,
      slashMenu: h4,
      emojiPicker: m,
      sideMenu: g,
      filePanel: f2,
      tableHandles: H2,
      comments: B2
    }
  }), [
    V,
    P2,
    a2,
    u,
    h4,
    m,
    g,
    f2,
    H2,
    B2
  ]);
  return (0, import_jsx_runtime10.jsx)(at3.Provider, { value: It2, children: (0, import_jsx_runtime10.jsxs)(_t3.Provider, { value: Nt2, children: [
    (0, import_jsx_runtime10.jsx)(Xr2, { ref: Q }),
    (0, import_jsx_runtime10.jsx)(
      Yr2,
      {
        className: o,
        renderEditor: S,
        editable: c,
        editorColorScheme: Z2,
        ref: t,
        ..._,
        children: i2
      }
    )
  ] }) });
}
var Yr2 = import_react13.default.forwardRef(
  ({ className: e, renderEditor: t, editable: n, editorColorScheme: o, children: r, ...i2 }, c) => (0, import_jsx_runtime10.jsx)(
    "div",
    {
      className: U("bn-container", o, e),
      "data-color-scheme": o,
      ...i2,
      ref: c,
      children: t ? (0, import_jsx_runtime10.jsx)(Jr2, { editable: n, children: r }) : r
    }
  )
);
var Ll = import_react13.default.forwardRef(Kr2);
var Jr2 = (e) => {
  const t = Wr2(), n = C2(), o = (0, import_react13.useMemo)(() => qr2(), []), r = (0, import_react13.useCallback)(
    (i2) => {
      e.editable !== void 0 && e.editable !== n.isEditable && (n.isEditable = e.editable), n._tiptapEditor.contentComponent = o, i2 ? n.mount(i2) : n.unmount();
    },
    [n, o, e.editable]
  );
  return (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, { children: [
    (0, import_jsx_runtime10.jsx)($r2, { contentComponent: o }),
    (0, import_jsx_runtime10.jsx)(Qr2, { ...t.editorProps, ...e, mount: r }),
    (0, import_jsx_runtime10.jsx)(zr2, { ...t.defaultUIProps }),
    e.children
  ] });
};
var Qr2 = (e) => {
  const { autoFocus: t, mount: n, contentEditableProps: o } = e;
  return (0, import_jsx_runtime10.jsx)(
    "div",
    {
      "aria-autocomplete": "list",
      "aria-haspopup": "listbox",
      "data-bn-autofocus": t,
      ref: n,
      ...o
    }
  );
};
function G2(e, t) {
  let n;
  const o = document.createElement("div");
  let r;
  if (t != null && t.elementRenderer)
    t.elementRenderer(
      e((d) => n = d || void 0),
      o
    );
  else {
    if (!(t != null && t.headless))
      throw new Error(
        "elementRenderer not available, expected headless editor"
      );
    r = (0, import_client.createRoot)(o), (0, import_react_dom5.flushSync)(() => {
      r.render(e((d) => n = d || void 0));
    });
  }
  if (!o.childElementCount)
    return console.warn("ReactInlineContentSpec: renderHTML() failed"), {
      dom: document.createElement("span")
    };
  n == null || n.setAttribute("data-tmp-find", "true");
  const i2 = o.cloneNode(true), c = i2.firstElementChild, s2 = i2.querySelector(
    "[data-tmp-find]"
  );
  return s2 == null || s2.removeAttribute("data-tmp-find"), r == null || r.unmount(), {
    dom: c,
    contentDOM: s2 || void 0
  };
}
function we2(e) {
  var t;
  return (
    // Creates `blockContent` element
    (0, import_jsx_runtime10.jsx)(
      NodeViewWrapper,
      {
        onDragOver: (n) => n.preventDefault(),
        ...Object.fromEntries(
          Object.entries(e.domAttributes || {}).filter(
            ([n]) => n !== "class"
          )
        ),
        className: U(
          "bn-block-content",
          ((t = e.domAttributes) == null ? void 0 : t.class) || ""
        ),
        "data-content-type": e.blockType,
        ...Object.fromEntries(
          Object.entries(e.blockProps).filter(([n, o]) => {
            const r = e.propSchema[n];
            return o !== r.default;
          }).map(([n, o]) => [K(n), o])
        ),
        "data-file-block": e.isFileBlock === true || void 0,
        children: e.children
      }
    )
  );
}
function fe2(e, t, n) {
  return (o = {}) => {
    const r = typeof e == "function" ? e(o) : e, i2 = typeof t == "function" ? t(o) : t, c = n ? typeof n == "function" ? n(o) : n : void 0;
    return {
      config: r,
      implementation: {
        ...i2,
        toExternalHTML(s2, d) {
          const a2 = i2.toExternalHTML || i2.render;
          return G2((h4) => (0, import_jsx_runtime10.jsx)(
            we2,
            {
              blockType: s2.type,
              blockProps: s2.props,
              propSchema: r.propSchema,
              domAttributes: this.blockContentDOMAttributes,
              children: (0, import_jsx_runtime10.jsx)(
                a2,
                {
                  block: s2,
                  editor: d,
                  contentRef: (m) => {
                    h4(m), m && (m.className = U(
                      "bn-inline-content",
                      m.className
                    ));
                  }
                }
              )
            }
          ), d);
        },
        render(s2, d) {
          if (this.renderType === "nodeView")
            return ReactNodeViewRenderer(
              (a2) => {
                var g;
                const u = $t(
                  a2.getPos,
                  d,
                  a2.editor,
                  r.type
                ), h4 = useReactNodeView().nodeViewContentRef;
                if (!h4)
                  throw new Error("nodeViewContentRef is not set");
                const m = i2.render;
                return (0, import_jsx_runtime10.jsx)(
                  we2,
                  {
                    blockType: u.type,
                    blockProps: u.props,
                    propSchema: r.propSchema,
                    isFileBlock: !!((g = i2.meta) != null && g.fileBlockAccept),
                    domAttributes: this.blockContentDOMAttributes,
                    children: (0, import_jsx_runtime10.jsx)(
                      m,
                      {
                        block: u,
                        editor: d,
                        contentRef: (f2) => {
                          h4(f2), f2 && (f2.className = U(
                            "bn-inline-content",
                            f2.className
                          ), f2.dataset.nodeViewContent = "");
                        }
                      }
                    )
                  }
                );
              },
              {
                className: "bn-react-node-view-renderer"
              }
            )(this.props);
          {
            const a2 = i2.render;
            return G2((h4) => (0, import_jsx_runtime10.jsx)(
              we2,
              {
                blockType: s2.type,
                blockProps: s2.props,
                propSchema: r.propSchema,
                domAttributes: this.blockContentDOMAttributes,
                children: (0, import_jsx_runtime10.jsx)(
                  a2,
                  {
                    block: s2,
                    editor: d,
                    contentRef: (m) => {
                      h4(m), m && (m.className = U(
                        "bn-inline-content",
                        m.className
                      ));
                    }
                  }
                )
              }
            ), d);
          }
        }
      },
      extensions: c
    };
  };
}
function Ne3(e) {
  const t = C2(), [n, o] = (0, import_react13.useState)("loading"), [r, i2] = (0, import_react13.useState)();
  if ((0, import_react13.useEffect)(() => {
    let c = true;
    return (async () => {
      let s2 = "";
      o("loading");
      try {
        s2 = t.resolveFileUrl ? await t.resolveFileUrl(e) : e;
      } catch {
        o("error");
        return;
      }
      c && (o("loaded"), i2(s2));
    })(), () => {
      c = false;
    };
  }, [t, e]), n !== "loaded")
    return {
      loadingState: n
    };
  if (!r)
    throw new Error("Finished fetching file but did not get download URL.");
  return {
    loadingState: n,
    downloadUrl: r
  };
}
var Pe2 = (e) => (0, import_jsx_runtime10.jsxs)("figure", { children: [
  e.children,
  (0, import_jsx_runtime10.jsx)("figcaption", { children: e.caption })
] });
function el(e) {
  const t = C2();
  (0, import_react13.useEffect)(() => t.onUploadEnd(e), [e, t]);
}
function tl(e) {
  const t = C2();
  (0, import_react13.useEffect)(() => t.onUploadStart(e), [e, t]);
}
function Et2(e) {
  const [t, n] = (0, import_react13.useState)(false);
  return tl((o) => {
    o === e && n(true);
  }), el((o) => {
    o === e && n(false);
  }), t;
}
var nl = (e) => {
  const t = y(), n = (0, import_react13.useCallback)(
    (r) => {
      r.preventDefault();
    },
    []
  ), o = (0, import_react13.useCallback)(() => {
    e.editor.transact(
      (r) => r.setMeta(e.editor.filePanel.plugins[0], {
        block: e.block
      })
    );
  }, [e.block, e.editor]);
  return (0, import_jsx_runtime10.jsxs)(
    "div",
    {
      className: "bn-add-file-button",
      onMouseDown: n,
      onClick: o,
      children: [
        (0, import_jsx_runtime10.jsx)("div", { className: "bn-add-file-button-icon", children: e.buttonIcon || (0, import_jsx_runtime10.jsx)(Ee2, { size: 24 }) }),
        (0, import_jsx_runtime10.jsx)("div", { className: "bn-add-file-button-text", children: e.block.type in t.file_blocks.add_button_text ? t.file_blocks.add_button_text[e.block.type] : t.file_blocks.add_button_text.file })
      ]
    }
  );
};
var ol = (e) => (0, import_jsx_runtime10.jsxs)(
  "div",
  {
    className: "bn-file-name-with-icon",
    contentEditable: false,
    draggable: false,
    children: [
      (0, import_jsx_runtime10.jsx)("div", { className: "bn-file-icon", children: (0, import_jsx_runtime10.jsx)(Ee2, { size: 24 }) }),
      (0, import_jsx_runtime10.jsx)("p", { className: "bn-file-name", children: e.block.props.name })
    ]
  }
);
var Ze3 = (e) => {
  const t = Et2(e.block.id);
  return (0, import_jsx_runtime10.jsx)(
    "div",
    {
      className: "bn-file-block-content-wrapper",
      onMouseEnter: e.onMouseEnter,
      onMouseLeave: e.onMouseLeave,
      style: e.style,
      children: t ? (
        // Show loader while a file is being uploaded.
        (0, import_jsx_runtime10.jsx)("div", { className: "bn-file-loading-preview", children: "Loading..." })
      ) : e.block.props.url === "" ? (
        // Show the add file button if the file has not been uploaded yet.
        (0, import_jsx_runtime10.jsx)(nl, { ...e })
      ) : (
        // Show the file preview, or the file name and icon.
        (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, { children: [
          e.block.props.showPreview === false || !e.children ? (
            // Show file name and icon.
            (0, import_jsx_runtime10.jsx)(ol, { ...e })
          ) : (
            // Show preview.
            e.children
          ),
          e.block.props.caption && // Show the caption if there is one.
          (0, import_jsx_runtime10.jsx)("p", { className: "bn-file-caption", children: e.block.props.caption })
        ] })
      )
    }
  );
};
var be3 = (e) => (0, import_jsx_runtime10.jsxs)("div", { children: [
  e.children,
  (0, import_jsx_runtime10.jsx)("p", { children: e.caption })
] });
var rl = (e) => {
  const t = Ne3(e.block.props.url);
  return (0, import_jsx_runtime10.jsx)(
    "audio",
    {
      className: "bn-audio",
      src: t.loadingState === "loading" ? e.block.props.url : t.downloadUrl,
      controls: true,
      contentEditable: false,
      draggable: false
    }
  );
};
var ll = (e) => {
  if (!e.block.props.url)
    return (0, import_jsx_runtime10.jsx)("p", { children: "Add audio" });
  const t = e.block.props.showPreview ? (0, import_jsx_runtime10.jsx)("audio", { src: e.block.props.url }) : (0, import_jsx_runtime10.jsx)("a", { href: e.block.props.url, children: e.block.props.name || e.block.props.url });
  return e.block.props.caption ? e.block.props.showPreview ? (0, import_jsx_runtime10.jsx)(Pe2, { caption: e.block.props.caption, children: t }) : (0, import_jsx_runtime10.jsx)(be3, { caption: e.block.props.caption, children: t }) : t;
};
var il = (e) => (0, import_jsx_runtime10.jsx)(
  Ze3,
  {
    ...e,
    buttonIcon: (0, import_jsx_runtime10.jsx)(Ht2, { size: 24 }),
    children: (0, import_jsx_runtime10.jsx)(rl, { ...e })
  }
);
var _l = fe2(
  Cn,
  (e) => ({
    render: il,
    parse: yn(e),
    toExternalHTML: ll,
    runsBefore: ["file"]
  })
);
var El = fe2(Nn, {
  render: (e) => (0, import_jsx_runtime10.jsx)(Ze3, { ...e }),
  parse: In(),
  toExternalHTML: (e) => {
    if (!e.block.props.url)
      return (0, import_jsx_runtime10.jsx)("p", { children: "Add file" });
    const t = (0, import_jsx_runtime10.jsx)("a", { href: e.block.props.url, children: e.block.props.name || e.block.props.url });
    return e.block.props.caption ? (0, import_jsx_runtime10.jsx)(be3, { caption: e.block.props.caption, children: t }) : t;
  }
});
var Rt3 = (e) => {
  const [t, n] = (0, import_react13.useState)(void 0), [o, r] = (0, import_react13.useState)(
    e.block.props.previewWidth
  ), [i2, c] = (0, import_react13.useState)(false), s2 = (0, import_react13.useRef)(null);
  (0, import_react13.useEffect)(() => {
    const g = (H2) => {
      var _, P2;
      let B2;
      const V = "touches" in H2 ? H2.touches[0].clientX : H2.clientX;
      e.block.props.textAlignment === "center" ? t.handleUsed === "left" ? B2 = t.initialWidth + (t.initialClientX - V) * 2 : B2 = t.initialWidth + (V - t.initialClientX) * 2 : t.handleUsed === "left" ? B2 = t.initialWidth + t.initialClientX - V : B2 = t.initialWidth + V - t.initialClientX, r(
        Math.min(
          Math.max(B2, 64),
          ((P2 = (_ = e.editor.domElement) == null ? void 0 : _.firstElementChild) == null ? void 0 : P2.clientWidth) || Number.MAX_VALUE
        )
      );
    }, f2 = () => {
      n(void 0), e.editor.updateBlock(e.block, {
        props: {
          previewWidth: o
        }
      });
    };
    return t && (window.addEventListener("mousemove", g), window.addEventListener("touchmove", g), window.addEventListener("mouseup", f2), window.addEventListener("touchend", f2)), () => {
      window.removeEventListener("mousemove", g), window.removeEventListener("touchmove", g), window.removeEventListener("mouseup", f2), window.removeEventListener("touchend", f2);
    };
  }, [e, t, o]);
  const d = (0, import_react13.useCallback)(() => {
    e.editor.isEditable && c(true);
  }, [e.editor.isEditable]), a2 = (0, import_react13.useCallback)(() => {
    c(false);
  }, []), u = (0, import_react13.useCallback)(
    (g) => {
      g.preventDefault();
      const f2 = "touches" in g ? g.touches[0].clientX : g.clientX;
      n({
        handleUsed: "left",
        initialWidth: s2.current.clientWidth,
        initialClientX: f2
      });
    },
    []
  ), h4 = (0, import_react13.useCallback)(
    (g) => {
      g.preventDefault();
      const f2 = "touches" in g ? g.touches[0].clientX : g.clientX;
      n({
        handleUsed: "right",
        initialWidth: s2.current.clientWidth,
        initialClientX: f2
      });
    },
    []
  ), m = Et2(e.block.id);
  return (0, import_jsx_runtime10.jsx)(
    Ze3,
    {
      ...e,
      onMouseEnter: d,
      onMouseLeave: a2,
      style: e.block.props.url && !m && e.block.props.showPreview ? {
        width: o ? `${o}px` : "fit-content"
      } : void 0,
      children: (0, import_jsx_runtime10.jsxs)(
        "div",
        {
          className: "bn-visual-media-wrapper",
          style: { position: "relative" },
          ref: s2,
          children: [
            e.children,
            (i2 || t) && (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, { children: [
              (0, import_jsx_runtime10.jsx)(
                "div",
                {
                  className: "bn-resize-handle",
                  style: { left: "4px" },
                  onMouseDown: u,
                  onTouchStart: u
                }
              ),
              (0, import_jsx_runtime10.jsx)(
                "div",
                {
                  className: "bn-resize-handle",
                  style: { right: "4px" },
                  onMouseDown: h4,
                  onTouchStart: h4
                }
              )
            ] }),
            t && (0, import_jsx_runtime10.jsx)(
              "div",
              {
                style: {
                  position: "absolute",
                  height: "100%",
                  width: "100%"
                }
              }
            )
          ]
        }
      )
    }
  );
};
var cl = (e) => {
  const t = Ne3(e.block.props.url);
  return (0, import_jsx_runtime10.jsx)(
    "img",
    {
      className: "bn-visual-media",
      src: t.loadingState === "loading" ? e.block.props.url : t.downloadUrl,
      alt: e.block.props.caption || "BlockNote image",
      contentEditable: false,
      draggable: false
    }
  );
};
var al = (e) => {
  if (!e.block.props.url)
    return (0, import_jsx_runtime10.jsx)("p", { children: "Add image" });
  const t = e.block.props.showPreview ? (0, import_jsx_runtime10.jsx)(
    "img",
    {
      src: e.block.props.url,
      alt: e.block.props.name || e.block.props.caption || "BlockNote image",
      width: e.block.props.previewWidth
    }
  ) : (0, import_jsx_runtime10.jsx)("a", { href: e.block.props.url, children: e.block.props.name || e.block.props.url });
  return e.block.props.caption ? e.block.props.showPreview ? (0, import_jsx_runtime10.jsx)(Pe2, { caption: e.block.props.caption, children: t }) : (0, import_jsx_runtime10.jsx)(be3, { caption: e.block.props.caption, children: t }) : t;
};
var sl = (e) => (0, import_jsx_runtime10.jsx)(
  Rt3,
  {
    ...e,
    buttonIcon: (0, import_jsx_runtime10.jsx)(wt, { size: 24 }),
    children: (0, import_jsx_runtime10.jsx)(cl, { ...e })
  }
);
var Rl = fe2(
  Rn,
  (e) => ({
    render: sl,
    parse: Vn(e),
    toExternalHTML: al
  })
);
function dl2(e) {
  return k({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { d: "M14 3v4a1 1 0 0 0 1 1h4" }, child: [] }, { tag: "path", attr: { d: "M19 18v1a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2v-1" }, child: [] }, { tag: "path", attr: { d: "M3 14h3m4.5 0h3m4.5 0h3" }, child: [] }, { tag: "path", attr: { d: "M5 10v-5a2 2 0 0 1 2 -2h7l5 5v2" }, child: [] }] })(e);
}
var ul = {
  page_break: dl2
};
function Il(e) {
  return gr(e).map((t) => {
    const n = ul[t.key];
    return {
      ...t,
      icon: (0, import_jsx_runtime10.jsx)(n, { size: 18 })
    };
  });
}
var ml = (e) => {
  const t = Ne3(e.block.props.url);
  return (0, import_jsx_runtime10.jsx)(
    "video",
    {
      className: "bn-visual-media",
      src: t.loadingState === "loading" ? e.block.props.url : t.downloadUrl,
      controls: true,
      contentEditable: false,
      draggable: false
    }
  );
};
var hl = (e) => {
  if (!e.block.props.url)
    return (0, import_jsx_runtime10.jsx)("p", { children: "Add video" });
  const t = e.block.props.showPreview ? (0, import_jsx_runtime10.jsx)("video", { src: e.block.props.url }) : (0, import_jsx_runtime10.jsx)("a", { href: e.block.props.url, children: e.block.props.name || e.block.props.url });
  return e.block.props.caption ? e.block.props.showPreview ? (0, import_jsx_runtime10.jsx)(Pe2, { caption: e.block.props.caption, children: t }) : (0, import_jsx_runtime10.jsx)(be3, { caption: e.block.props.caption, children: t }) : t;
};
var gl = (e) => (0, import_jsx_runtime10.jsx)(
  Rt3,
  {
    ...e,
    buttonIcon: (0, import_jsx_runtime10.jsx)(co2, { size: 24 }),
    children: (0, import_jsx_runtime10.jsx)(ml, { ...e })
  }
);
var Nl = fe2(
  mo,
  (e) => ({
    render: gl,
    parse: go(e),
    toExternalHTML: hl
  })
);
var fl = (e, t) => {
  if (t.type === "toggled")
    return !e;
  if (t.type === "childAdded")
    return true;
  if (t.type === "lastChildRemoved")
    return false;
  throw new Z(t);
};
var Pl = (e) => {
  const { block: t, editor: n, children: o, toggledState: r } = e, [i2, c] = (0, import_react13.useReducer)(
    fl,
    (r || Hn).get(t)
  ), [s2, d] = (0, import_react13.useState)(t.children.length), a2 = (m) => {
    (r || Hn).set(
      n.getBlock(m),
      !i2
    ), c({
      type: "toggled"
    });
  }, u = (m) => {
    (r || Hn).set(m, true), c({
      type: "childAdded"
    });
  }, h4 = (m) => {
    (r || Hn).set(m, false), c({
      type: "lastChildRemoved"
    });
  };
  return J2(() => {
    if ("isToggleable" in t.props && !t.props.isToggleable)
      return;
    const m = n.getBlock(t), g = m.children.length ?? 0;
    g > s2 ? i2 || u(m) : g === 0 && g < s2 && i2 && h4(m), d(g);
  }), "isToggleable" in t.props && !t.props.isToggleable ? o : (0, import_jsx_runtime10.jsxs)("div", { children: [
    (0, import_jsx_runtime10.jsxs)("div", { className: "bn-toggle-wrapper", "data-show-children": i2, children: [
      (0, import_jsx_runtime10.jsx)(
        "button",
        {
          className: "bn-toggle-button",
          type: "button",
          onMouseDown: (m) => m.preventDefault(),
          onClick: () => a2(n.getBlock(t)),
          children: (0, import_jsx_runtime10.jsx)(
            "svg",
            {
              xmlns: "http://www.w3.org/2000/svg",
              height: "1em",
              viewBox: "0 -960 960 960",
              width: "1em",
              fill: "currentcolor",
              children: (0, import_jsx_runtime10.jsx)("path", { d: "M472-480 332-620q-18-18-18-44t18-44q18-18 44-18t44 18l183 183q9 9 14 21t5 24q0 12-5 24t-14 21L420-252q-18 18-44 18t-44-18q-18-18-18-44t18-44l140-140Z" })
            }
          )
        }
      ),
      o
    ] }),
    i2 && s2 === 0 && (0, import_jsx_runtime10.jsx)(
      "button",
      {
        className: "bn-toggle-add-block-button",
        type: "button",
        onClick: () => {
          const m = n.updateBlock(t, {
            // Single empty block with default type.
            children: [{}]
          });
          n.setTextCursorPosition(m.children[0].id, "end"), n.focus();
        },
        children: n.dictionary.toggle_blocks.add_block_button
      }
    )
  ] });
};
var Zl = (e) => {
  const [t, n] = (0, import_react13.useState)("none"), o = (0, import_react13.useRef)(null), r = C2(), i2 = D(
    r.formattingToolbar.onUpdate.bind(r.formattingToolbar)
  ), c = (0, import_react13.useMemo)(() => ({
    display: "flex",
    position: "fixed",
    bottom: 0,
    zIndex: 3e3,
    transform: t
  }), [t]);
  if ((0, import_react13.useEffect)(() => {
    const d = window.visualViewport;
    function a2() {
      const u = document.body, h4 = d.offsetLeft, m = d.height - u.getBoundingClientRect().height + d.offsetTop;
      n(
        `translate(${h4}px, ${m}px) scale(${1 / d.scale})`
      );
    }
    return window.visualViewport.addEventListener("scroll", a2), window.visualViewport.addEventListener("resize", a2), a2(), () => {
      window.visualViewport.removeEventListener("scroll", a2), window.visualViewport.removeEventListener("resize", a2);
    };
  }, []), !i2)
    return null;
  if (!i2.show && o.current)
    return (0, import_jsx_runtime10.jsx)(
      "div",
      {
        ref: o,
        style: c,
        dangerouslySetInnerHTML: { __html: o.current.innerHTML }
      }
    );
  const s2 = e.formattingToolbar || Bt2;
  return (0, import_jsx_runtime10.jsx)("div", { ref: o, style: c, children: (0, import_jsx_runtime10.jsx)(s2, {}) });
};
var bl = import_react13.default.memo(
  ({
    thread: e,
    selectedThreadId: t,
    editor: n,
    maxCommentsBeforeCollapse: o,
    referenceText: r
  }) => {
    const i2 = (0, import_react13.useCallback)(
      (s2) => {
        var d;
        s2.target.closest(".bn-action-toolbar") || (d = n.comments) == null || d.selectThread(e.id);
      },
      [n.comments, e.id]
    ), c = (0, import_react13.useCallback)(
      (s2) => {
        var u;
        if (!s2.relatedTarget || s2.relatedTarget.closest(".bn-action-toolbar"))
          return;
        const d = s2.target instanceof Node ? s2.target : null, a2 = s2.relatedTarget instanceof Node ? s2.relatedTarget.closest(".bn-thread") : null;
        (!d || !a2 || !a2.contains(d)) && ((u = n.comments) == null || u.selectThread(void 0));
      },
      [n.comments]
    );
    return (0, import_jsx_runtime10.jsx)(
      Mt2,
      {
        thread: e,
        selected: e.id === t,
        referenceText: r,
        maxCommentsBeforeCollapse: o,
        onFocus: i2,
        onBlur: c,
        tabIndex: 0
      }
    );
  }
);
function Cl(e, t, n) {
  if (t === "recent-activity")
    return e.sort(
      (o, r) => r.comments[r.comments.length - 1].createdAt.getTime() - o.comments[o.comments.length - 1].createdAt.getTime()
    );
  if (t === "oldest")
    return e.sort(
      (o, r) => o.createdAt.getTime() - r.createdAt.getTime()
    );
  if (t === "position")
    return e.sort((o, r) => {
      var s2, d;
      const i2 = ((s2 = n == null ? void 0 : n.get(o.id)) == null ? void 0 : s2.from) || Number.MAX_VALUE, c = ((d = n == null ? void 0 : n.get(r.id)) == null ? void 0 : d.from) || Number.MAX_VALUE;
      return i2 - c;
    });
  throw new Z(t);
}
function Qe3(e, t) {
  return e.transact((n) => {
    if (!t)
      return "Original content deleted";
    if (n.doc.nodeSize < t.to)
      return "";
    const o = n.doc.textBetween(
      t.from,
      t.to
    );
    return o.length > 15 ? `${o.slice(0, 15)}` : o;
  });
}
function Al(e) {
  const t = C2();
  if (!t.comments)
    throw new Error("Comments plugin not found");
  const n = D(
    t.comments.onUpdate.bind(t.comments)
  ), o = n == null ? void 0 : n.selectedThreadId, r = yt2(t), i2 = (0, import_react13.useMemo)(() => {
    const c = Array.from(r.values()), s2 = Cl(
      c,
      e.sort || "position",
      n == null ? void 0 : n.threadPositions
    ), d = [];
    for (const a2 of s2)
      a2.resolved ? (e.filter === "resolved" || e.filter === "all") && d.push({
        thread: a2,
        referenceText: Qe3(
          t,
          n == null ? void 0 : n.threadPositions.get(a2.id)
        )
      }) : (e.filter === "open" || e.filter === "all") && d.push({
        thread: a2,
        referenceText: Qe3(
          t,
          n == null ? void 0 : n.threadPositions.get(a2.id)
        )
      });
    return d;
  }, [r, n == null ? void 0 : n.threadPositions, e.filter, e.sort, t]);
  return (0, import_jsx_runtime10.jsx)("div", { className: "bn-threads-sidebar", children: i2.map((c) => (0, import_jsx_runtime10.jsx)(
    bl,
    {
      thread: c.thread,
      selectedThreadId: o,
      editor: t,
      referenceText: c.referenceText,
      maxCommentsBeforeCollapse: e.maxCommentsBeforeCollapse
    },
    c.thread.id
  )) });
}
function Dl(e) {
  const t = F2();
  if (e || (e = t == null ? void 0 : t.editor), !e)
    throw new Error(
      "'editor' is required, either from BlockNoteContext or as a function argument"
    );
  const n = e, [o, r] = (0, import_react13.useState)(() => n.getActiveStyles()), i2 = (0, import_react13.useCallback)(() => {
    r(n.getActiveStyles());
  }, [n]);
  return J2(i2, n), he3(i2, n), o;
}
function pl() {
  const [, e] = (0, import_react13.useState)(0);
  return () => e((t) => t + 1);
}
var Fl = (e) => {
  const t = pl();
  (0, import_react13.useEffect)(() => {
    const n = () => {
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          t();
        });
      });
    };
    return e.on("transaction", n), () => {
      e.off("transaction", n);
    };
  }, [e]);
};
function kl(e) {
  return e.currentTarget instanceof HTMLElement && e.relatedTarget instanceof HTMLElement ? e.currentTarget.contains(e.relatedTarget) : false;
}
function Ol({
  onBlur: e,
  onFocus: t
} = {}) {
  const n = (0, import_react13.useRef)(null), [o, r] = (0, import_react13.useState)(false), i2 = (0, import_react13.useRef)(false), c = (a2) => {
    r(a2), i2.current = a2;
  }, s2 = (a2) => {
    i2.current || (c(true), t == null || t(a2));
  }, d = (a2) => {
    i2.current && !kl(a2) && (c(false), e == null || e(a2));
  };
  return (0, import_react13.useEffect)(() => {
    const a2 = n.current;
    if (a2)
      return a2.addEventListener("focusin", s2), a2.addEventListener("focusout", d), () => {
        a2 == null || a2.removeEventListener("focusin", s2), a2 == null || a2.removeEventListener("focusout", d);
      };
  }, [s2, d]), { ref: n, focused: o };
}
function ve2(e) {
  return (
    // Creates inline content section element
    (0, import_jsx_runtime10.jsx)(
      NodeViewWrapper,
      {
        as: "span",
        className: "bn-inline-content-section",
        "data-inline-content-type": e.inlineContentType,
        ...Object.fromEntries(
          Object.entries(e.inlineContentProps).filter(([t, n]) => {
            const o = e.propSchema[t];
            return n !== o.default;
          }).map(([t, n]) => [K(t), n])
        ),
        children: e.children
      }
    )
  );
}
function Gl(e, t) {
  var o;
  const n = Node3.create({
    name: e.type,
    inline: true,
    group: "inline",
    selectable: e.content === "styled",
    atom: e.content === "none",
    draggable: (o = t.meta) == null ? void 0 : o.draggable,
    content: e.content === "styled" ? "inline*" : "",
    addAttributes() {
      return Ft(e.propSchema);
    },
    addKeyboardShortcuts() {
      return Zo(e);
    },
    parseHTML() {
      return hn2(
        e,
        t.parse
      );
    },
    renderHTML({ node: r }) {
      const i2 = this.options.editor, c = Jt(
        r,
        i2.schema.inlineContentSchema,
        i2.schema.styleSchema
      ), s2 = t.toExternalHTML || t.render, d = G2(
        (a2) => (0, import_jsx_runtime10.jsx)(
          s2,
          {
            contentRef: (u) => {
              a2(u), u && (u.dataset.editable = "");
            },
            inlineContent: c,
            updateInlineContent: () => {
            },
            editor: i2
          }
        ),
        i2
      );
      return qo(
        d,
        e.type,
        r.attrs,
        e.propSchema
      );
    },
    addNodeView() {
      const r = this.options.editor;
      return (i2) => ReactNodeViewRenderer(
        (c) => {
          const s2 = useReactNodeView().nodeViewContentRef;
          if (!s2)
            throw new Error("nodeViewContentRef is not set");
          const d = t.render;
          return (0, import_jsx_runtime10.jsx)(
            ve2,
            {
              inlineContentProps: c.node.attrs,
              inlineContentType: e.type,
              propSchema: e.propSchema,
              children: (0, import_jsx_runtime10.jsx)(
                d,
                {
                  contentRef: (a2) => {
                    s2(a2), a2 && (a2.dataset.editable = "");
                  },
                  editor: r,
                  inlineContent: Jt(
                    c.node,
                    r.schema.inlineContentSchema,
                    r.schema.styleSchema
                  ),
                  updateInlineContent: (a2) => {
                    const u = O(
                      [a2],
                      r.pmSchema
                    ), h4 = c.getPos();
                    h4 !== void 0 && r.transact(
                      (m) => m.replaceWith(h4, h4 + c.node.nodeSize, u)
                    );
                  }
                }
              )
            }
          );
        },
        {
          className: "bn-ic-react-node-view-renderer",
          as: "span"
          // contentDOMElementTag: "span", (requires tt upgrade)
        }
      )(i2);
    }
  });
  return Kt(
    e,
    {
      node: n,
      render(r, i2, c) {
        const s2 = t.render;
        return G2((a2) => (0, import_jsx_runtime10.jsx)(
          ve2,
          {
            inlineContentProps: r.props,
            inlineContentType: e.type,
            propSchema: e.propSchema,
            children: (0, import_jsx_runtime10.jsx)(
              s2,
              {
                contentRef: (u) => {
                  a2(u), u && (u.dataset.editable = "");
                },
                editor: c,
                inlineContent: r,
                updateInlineContent: i2
              }
            )
          }
        ), c);
      },
      toExternalHTML(r, i2) {
        const c = t.toExternalHTML || t.render;
        return G2((d) => (0, import_jsx_runtime10.jsx)(
          ve2,
          {
            inlineContentProps: r.props,
            inlineContentType: e.type,
            propSchema: e.propSchema,
            children: (0, import_jsx_runtime10.jsx)(
              c,
              {
                contentRef: (a2) => {
                  d(a2), a2 && (a2.dataset.editable = "");
                },
                editor: i2,
                inlineContent: r,
                updateInlineContent: () => {
                }
              }
            )
          }
        ), i2);
      }
    }
  );
}
function Ul(e, t) {
  const n = Mark.create({
    name: e.type,
    addAttributes() {
      return Qt(e.propSchema);
    },
    parseHTML() {
      return Yt(e);
    },
    renderHTML({ mark: o }) {
      const r = t.render, i2 = G2(
        (c) => (0, import_jsx_runtime10.jsx)(
          r,
          {
            editor: this.options.editor,
            value: e.propSchema === "boolean" ? void 0 : o.attrs.stringValue,
            contentRef: (s2) => {
              c(s2), s2 && (s2.dataset.editable = "");
            }
          }
        ),
        this.options.editor
      );
      return J(
        i2,
        e.type,
        o.attrs.stringValue,
        e.propSchema
      );
    },
    addMarkView() {
      const o = this.options.editor;
      return (r) => {
        const i2 = ReactMarkViewRenderer((c) => {
          const s2 = (0, import_react13.useContext)(ReactMarkViewContext).markViewContentRef;
          if (!s2)
            throw new Error("markViewContentRef is not set");
          const d = t.render;
          return (0, import_jsx_runtime10.jsx)(
            d,
            {
              editor: o,
              contentRef: (a2) => {
                s2(a2), a2 && (a2.dataset.markViewContent = "");
              },
              value: e.propSchema === "boolean" ? void 0 : c.mark.attrs.stringValue
            }
          );
        })(r);
        return i2.didMountContentDomElement = true, i2;
      };
    }
  });
  return Ke(e, {
    mark: n,
    render(o, r) {
      const i2 = t.render, c = G2(
        (s2) => (0, import_jsx_runtime10.jsx)(
          i2,
          {
            editor: r,
            value: o,
            contentRef: (d) => {
              s2(d), d && (d.dataset.editable = "");
            }
          }
        ),
        r
      );
      return J(
        c,
        e.type,
        o,
        e.propSchema
      );
    },
    toExternalHTML(o, r) {
      const i2 = t.render, c = G2(
        (s2) => (0, import_jsx_runtime10.jsx)(
          i2,
          {
            editor: r,
            value: o,
            contentRef: (d) => {
              s2(d), d && (d.dataset.editable = "");
            }
          }
        ),
        r
      );
      return J(
        c,
        e.type,
        o,
        e.propSchema
      );
    }
  });
}
function zl(e, t) {
  const n = e.getBoundingClientRect(), o = t.getBoundingClientRect(), r = n.top < o.top, i2 = n.bottom > o.bottom;
  return r && i2 ? "both" : r ? "top" : i2 ? "bottom" : "none";
}

export {
  getOverflowAncestors,
  autoUpdate,
  offset3 as offset,
  shift3 as shift,
  limitShift3 as limitShift,
  flip3 as flip,
  size3 as size,
  hide3 as hide,
  inline3 as inline,
  arrow3 as arrow,
  useMergeRefs,
  useHover,
  FloatingDelayGroup,
  useDelayGroup,
  useDismiss,
  useFloating2 as useFloating,
  useFocus,
  useInteractions,
  useRole,
  Vo,
  U,
  Wo,
  A,
  rr,
  at3 as at,
  F2 as F,
  C2 as C,
  he3 as he,
  Bn3 as Bn,
  z3 as z,
  D,
  Tn3 as Tn,
  p4 as p,
  Te2 as Te,
  y,
  J2 as J,
  _n3 as _n,
  En3 as En,
  wo2 as wo,
  Ie3 as Ie,
  Ho,
  Mo,
  Mt2 as Mt,
  yt2 as yt,
  yo2 as yo,
  xo,
  Vo2,
  xt2 as xt,
  Bo,
  j4 as j,
  To2 as To,
  R2 as R,
  oe2 as oe,
  Eo,
  Vt3 as Vt,
  Io,
  No,
  Po,
  Zo2 as Zo,
  Ao,
  Do,
  Fo2 as Fo,
  Oo,
  Go2 as Go,
  Uo2 as Uo,
  zo2 as zo,
  jo2 as jo,
  Wo2,
  qo2 as qo,
  pe3 as pe,
  Xo2 as Xo,
  Bt2 as Bt,
  Ko2 as Ko,
  Yo2 as Yo,
  Jo2 as Jo,
  Qo2 as Qo,
  er3 as er,
  tr4 as tr,
  or3 as or,
  lr3 as lr,
  ir3 as ir,
  cr3 as cr,
  ar3 as ar,
  sr3 as sr,
  dr3 as dr,
  ur3 as ur,
  mr3 as mr,
  hr4 as hr,
  Tt2 as Tt,
  Lt2 as Lt,
  fr3 as fr,
  br5 as br,
  Cr2 as Cr,
  kr3 as kr,
  vr2 as vr,
  Hr2 as Hr,
  yr2 as yr,
  xr2 as xr,
  Br2 as Br,
  Ke2 as Ke,
  Sr2 as Sr,
  Er2 as Er,
  Rr2 as Rr,
  Ir2 as Ir,
  Ar2 as Ar,
  Dr2 as Dr,
  Fr2 as Fr,
  Or2 as Or,
  Gr2 as Gr,
  Ur2 as Ur,
  zr2 as zr,
  jr2 as jr,
  Ll,
  Jr2 as Jr,
  we2 as we,
  fe2 as fe,
  Ne3 as Ne,
  Pe2 as Pe,
  el,
  tl,
  Et2 as Et,
  nl,
  ol,
  Ze3 as Ze,
  be3 as be,
  rl,
  ll,
  il,
  _l,
  El,
  Rt3 as Rt,
  cl,
  al,
  sl,
  Rl,
  Il,
  ml,
  hl,
  gl,
  Nl,
  Pl,
  Zl,
  Qe3 as Qe,
  Al,
  Dl,
  Fl,
  Ol,
  ve2 as ve,
  Gl,
  Ul,
  zl
};
/*! Bundled license information:

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.3.0
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)
*/
//# sourceMappingURL=chunk-PUFYXQCE.js.map
